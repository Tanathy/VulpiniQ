<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #1d1d1d;
            color: #a3a3a3;
            line-height: 1.6;
            font-size: 12px;
        }

        .collection {
            margin: 5px;
            background-color: #ffffff0a;
            border-radius: 10px;
        }

        .collection_title {
            font-size: 24px;
            font-weight: bold;
            color: #949494;
            padding: 0px 10px;
        }

        .collection_content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        }

        .card {
            user-select: none;
            cursor: default;
            background-color: rgba(255, 255, 255, 0.04);
            color: #7e7e7e;
            border-radius: 10px;
            width: 300px;
            padding: 5px;
            margin: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        }

        .card_header {
            font-size: 20px;
            font-weight: bold;
            color: #949494;
        }

        .card_description {
            font-size: 14px;
            margin-bottom: 10px;
        }

        .card_active,
        .card:hover {
            background-color: rgba(197, 146, 231, 0.178);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
            color: #b9b9b9;
        }


        .card_example {
            color: #a4eec5;
            margin-top: 10px;
        }

        .card_dependencies {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .dependency_tag {
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.4);
            padding: 0 10px;
            border-radius: 20px;
            margin: 1px;
        }

        .dependent {
            background-color: rgb(181 160 160 / 18%);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
            color: #b9b9b9;
        }


        .bracket {
            color: #e7e192;
        }

        .bracket_inner {
            color: #96a8f5;
        }

        .class,
        .object {
            color: #bb6485;
            font-weight: bold;
        }

        .keyword {
            color: #f78c6c;
        }

        .operator {
            color: #ff5370;
        }

        .method {
            color: #82aaff;
        }

        .string {
            color: #d8a378;
            font-weight: bold;
        }

        .number {
            color: #f78c6c;
        }

        .generated {
            margin-top: 30px;
        }

        .gen_code {
            font-size: 12px;
            color: #a3a3a3;
            padding: 10px;
            background-color: #1d1d1d;
            border-radius: 10px;
            margin: 10px;
            overflow: auto;
            width: calc(100% - 20px);
            height: 150px;
        }
    </style>

    <script>

        var source = "const Q = (() => {\n    'use strict';\n\n    var GLOBAL = {};\n\n\n    function Q(identifier, attributes, props) {\n        if (!(this instanceof Q)) {\n            return new Q(identifier, attributes, props);\n        }\n        else if (identifier instanceof HTMLElement || identifier instanceof Node) {\n            this.nodes = [identifier];\n            return;\n        }\n        else if (identifier instanceof Q) {\n            this.nodes = identifier.nodes;\n            return;\n        }\n        else if (identifier instanceof NodeList) {\n            this.nodes = Array.from(identifier);\n            return;\n        }\n        else if (typeof identifier === 'string') {\n            let isCreating = !!attributes || identifier.includes('<');\n\n            if (isCreating) {\n                const fragment = document.createDocumentFragment();\n                const pseudo = document.createElement('div');\n                pseudo.innerHTML = identifier;\n                while (pseudo.firstChild) {\n                    fragment.appendChild(pseudo.firstChild);\n                }\n                this.nodes = Array.from(fragment.childNodes);\n\n                if (attributes) {\n                    this.nodes.forEach(el => {\n                        for (const [attr, value] of Object.entries(attributes)) {\n                            if (attr === 'class') {\n\n                                if (Array.isArray(value)) {\n                                    el.classList.add(...value);\n                                }\n                                else {\n\n                                    el.classList.add(...value.split(/\\s+/));\n                                }\n                            }\n\n                            else if (attr === 'style') {\n                                if (typeof value === 'object') {\n                                    for (const [key, val] of Object.entries(value)) {\n                                        el.style[key] = val;\n                                    }\n                                }\n                                else {\n                                    el.style.cssText = value;\n                                }\n                            }\n                            else if (attr === 'text') {\n                                el.textContent = value;\n                            }\n\n                            else if (attr === 'html') {\n                                el.innerHTML = value;\n                            }\n\n                            else {\n                                el.setAttribute(attr, value);\n                            }\n                        }\n                    });\n                }\n                if (props) {\n                    this.nodes.forEach(el => {\n                        for (const prop of props) {\n                            el[prop] = true;\n                        }\n                    });\n                }\n            } else {\n                let elem = document.querySelectorAll(identifier);\n                this.nodes = Array.from(elem);\n            }\n        }\n    }\n    //METHODS//\n    //EXTENSIONS//\n    return Q;\n})();";
var methods = {
    "addClass": {
        "Name": "addClass",
        "Method": "Prototype",
        "Desc": "Adds one or more classes to each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Class Manipulation",
        "Example": "Q(selector).addClass(\"class1 class2\");",
        "Script": "Q.prototype.addClass = function (classes) {\n    const classList = classes.split(' ');\n    return this.each(el => this.nodes[el].classList.add(...classList));\n};"
    },
    "animate": {
        "Name": "animate",
        "Method": "Prototype",
        "Desc": "Animates each node with specific CSS properties.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Animation",
        "Example": "Q(selector).animate(duration, { opacity: 0, left: \"50px\" }, callback);",
        "Script": "Q.prototype.animate = function (duration, properties, callback) {\n    return this.each(el => {\n        const element = this.nodes[el];\n        const transitionProperties = Object.keys(properties).map(prop => `${prop} ${duration}ms`).join(', ');\n        element.style.transition = transitionProperties;\n        for (const prop in properties) {\n            element.style[prop] = properties[prop];\n        }\n        if (typeof callback === 'function') {\n            setTimeout(() => {\n                if (callback) callback.call(element);\n            }, duration);\n        }\n    }), this;\n};"
    },
    "append": {
        "Name": "append",
        "Method": "Prototype",
        "Desc": "Appends child nodes or HTML to each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).append(\"<div>Appended</div>\");",
        "Script": "Q.prototype.append = function (...nodes) {\n    return this.each(el => {\n        const parent = this.nodes[el];\n\n        nodes.forEach(child => {\n\n            if (typeof child === 'string') {\n                parent.insertAdjacentHTML('beforeend', child);\n            } else if (child instanceof HTMLElement || child instanceof Q) {\n                parent.appendChild(child.nodes[0]);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                Array.from(child).forEach(subchild => parent.appendChild(subchild));\n            }\n        });\n    });\n};"
    },
    "attr": {
        "Name": "attr",
        "Method": "Prototype",
        "Desc": "Gets or sets attributes on the nodes. Can handle multiple attributes if provided as an object.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Attribute Manipulation",
        "Example": "Q(selector).attr(attribute, value);",
        "Script": "Q.prototype.attr = function (attribute, value) {\n    if (typeof attribute === 'object') {\n        return this.each(el => {\n            for (let key in attribute) {\n                if (attribute.hasOwnProperty(key)) {\n                    this.nodes[el].setAttribute(key, attribute[key]);\n                }\n            }\n        });\n    } else {\n        if (value === undefined) {\n            return this.nodes[0]?.getAttribute(attribute) || null;\n        }\n        return this.each(el => this.nodes[el].setAttribute(attribute, value));\n    }\n};"
    },
    "bind": {
        "Name": "bind",
        "Method": "Prototype",
        "Desc": "Adds an event listener to each node with the ability to use event delegation.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q(selector).bind(\"click\", () => console.log(\"Clicked\"));",
        "Script": "Q.prototype.bind = function (event, handler) {\n    if (!this._eventDelegation) {\n        this._eventDelegation = {};\n    }\n\n    if (!this._eventDelegation[event]) {\n        document.addEventListener(event, (e) => {\n            this.each(el => {\n                if (this.nodes[el].contains(e.target)) {\n                    handler.call(e.target, e);\n                }\n            });\n        });\n        this._eventDelegation[event] = true;\n    }\n    return this;\n};"
    },
    "blur": {
        "Name": "blur",
        "Method": "Prototype",
        "Desc": "Blurs the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Form Manipulation",
        "Example": "Q(selector).blur();",
        "Script": "Q.prototype.blur = function () {\n    return this.each(el => this.nodes[el].blur());\n};"
    },
    "children": {
        "Name": "children",
        "Method": "Prototype",
        "Desc": "Returns the children of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).children();",
        "Script": "Q.prototype.children = function () {\n    return new Q(this.nodes[0].children);\n};"
    },
    "click": {
        "Name": "click",
        "Method": "Prototype",
        "Desc": "Triggers a click event on each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q(selector).click();",
        "Script": "Q.prototype.click = function () {\n    return this.each(el => this.nodes[el].click());\n};"
    },
    "clone": {
        "Name": "clone",
        "Method": "Prototype",
        "Desc": "Clones the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).clone();",
        "Script": "Q.prototype.clone = function () {\n    return new Q(this.nodes[0].cloneNode(true));\n};"
    },
    "closest": {
        "Name": "closest",
        "Method": "Prototype",
        "Desc": "Returns the closest parent node of the first node that matches a specific selector.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).closest(\".parent\");",
        "Script": "Q.prototype.closest = function (selector) {\n    let el = this.nodes[0];\n    while (el) {\n        if (el.matches && el.matches(selector)) {\n            return new Q(el);\n        }\n        el = el.parentElement;\n    }\n    return null;\n};"
    },
    "css": {
        "Name": "css",
        "Method": "Prototype",
        "Desc": "Gets or sets CSS styles on the nodes. Can handle multiple styles if provided as an object.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Style Manipulation",
        "Example": "Q(selector).css(property, value);",
        "Script": "Q.prototype.css = function (property, value) {\n    if (typeof property === 'object') {\n        return this.each(el => {\n            for (let key in property) {\n                if (property.hasOwnProperty(key)) {\n                    this.nodes[el].style[key] = property[key];\n                }\n            }\n        });\n    } else {\n        if (value === undefined) {\n            return getComputedStyle(this.nodes[0])[property];\n        }\n        return this.each(el => this.nodes[el].style[property] = value);\n    }\n};"
    },
    "data": {
        "Name": "data",
        "Method": "Prototype",
        "Desc": "Gets or sets data-* attributes on the nodes.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Data Manipulation",
        "Example": "Q(selector).data(key, value);",
        "Script": "Q.prototype.data = function (key, value) {\n    if (value === undefined) {\n        return this.nodes[0]?.dataset[key] || null;\n    }\n    return this.each(el => this.nodes[el].dataset[key] = value);\n};"
    },
    "each": {
        "Name": "each",
        "Method": "Prototype",
        "Desc": "Iterates over all nodes in the Q object and executes a callback on each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Iteration",
        "Example": "Q(selector).each((index, element) => console.log(index, element));",
        "Script": "Q.prototype.each = function (callback) {\n    this.nodes.forEach((el, index) => callback.call(el, index, el));\n    return this;\n};"
    },
    "empty": {
        "Name": "empty",
        "Method": "Prototype",
        "Desc": "Empties the innerHTML of each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Content Manipulation",
        "Example": "Q(selector).empty();",
        "Script": "Q.prototype.empty = function () {\n    return this.each(el => this.nodes[el].innerHTML = '');\n};"
    },
    "eq": {
        "Name": "eq",
        "Method": "Prototype",
        "Desc": "Returns a specific node by index.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).eq(1);",
        "Script": "Q.prototype.eq = function (index) {\n    return new Q(this.nodes[index]);\n};"
    },
    "fadeIn": {
        "Name": "fadeIn",
        "Method": "Prototype",
        "Desc": "Fades in each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).fadeIn(duration, callback);",
        "Script": "Q.prototype.fadeIn = function (duration = 400, callback) {\n    return this.each(el => {\n        this.nodes[el].style.display = '';\n        this.nodes[el].style.transition = `opacity ${duration}ms`;\n        this.nodes[el].offsetHeight;\n        this.nodes[el].style.opacity = 1;\n        setTimeout(() => {\n            this.nodes[el].style.transition = '';\n            if (callback) callback();\n        }, duration);\n    });\n};"
    },
    "fadeOut": {
        "Name": "fadeOut",
        "Method": "Prototype",
        "Desc": "Fades out each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).fadeOut(duration, callback);",
        "Script": "Q.prototype.fadeOut = function (duration = 400, callback) {\n    return this.each(el => {\n        this.nodes[el].style.transition = `opacity ${duration}ms`;\n        this.nodes[el].style.opacity = 0;\n        setTimeout(() => {\n            this.nodes[el].style.transition = '';\n            this.nodes[el].style.display = 'none';\n            if (callback) callback();\n        }, duration);\n    });\n};"
    },
    "fadeTo": {
        "Name": "fadeTo",
        "Method": "Prototype",
        "Desc": "Fades each node to a specific opacity.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).fadeTo(opacity, duration, callback);",
        "Script": "Q.prototype.fadeTo = function (opacity, duration = 400, callback) {\n    return this.each(el => {\n        this.nodes[el].style.transition = `opacity ${duration}ms`;\n        this.nodes[el].offsetHeight;\n        this.nodes[el].style.opacity = opacity;\n        setTimeout(() => {\n            this.nodes[el].style.transition = '';\n            if (callback) callback();\n        }, duration);\n    });\n};"
    },
    "fadeToggle": {
        "Name": "fadeToggle",
        "Method": "Prototype",
        "Desc": "Toggles the fade state of each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).fadeToggle(duration, callback);",
        "Script": "Q.prototype.fadeToggle = function (duration = 400, callback) {\n    return this.each(el => {\n        if (window.getComputedStyle(this.nodes[el]).opacity === '0') {\n            this.fadeIn(duration, callback);\n        } else {\n            this.fadeOut(duration, callback);\n        }\n    });\n};"
    },
    "find": {
        "Name": "find",
        "Method": "Prototype",
        "Desc": "Finds child nodes of the first node that match a specific selector.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).find(\".child\");",
        "Script": "Q.prototype.find = function (selector) {\n    const foundNodes = this.nodes[0].querySelectorAll(selector);\n    return foundNodes.length ? Q(foundNodes) : null;\n};"
    },
    "first": {
        "Name": "first",
        "Method": "Prototype",
        "Desc": "Returns the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).first();",
        "Script": "Q.prototype.first = function () {\n    return new Q(this.nodes[0]);\n};"
    },
    "focus": {
        "Name": "focus",
        "Method": "Prototype",
        "Desc": "Focuses on the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Form Manipulation",
        "Example": "Q(selector).focus();",
        "Script": "Q.prototype.focus = function () {\n    return this.each(el => this.nodes[el].focus());\n};"
    },
    "hasClass": {
        "Name": "hasClass",
        "Method": "Prototype",
        "Desc": "Checks if the first node has a specific class.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Class Manipulation",
        "Example": "Q(selector).hasClass(className);",
        "Script": "Q.prototype.hasClass = function (className) {\n    return this.nodes[0]?.classList.contains(className) || false;\n};"
    },
    "height": {
        "Name": "height",
        "Method": "Prototype",
        "Desc": "Gets or sets the height of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Dimensions",
        "Example": "Q(selector).height(value);",
        "Script": "Q.prototype.height = function (value) {\n    if (value === undefined) {\n        return this.nodes[0].offsetHeight;\n    }\n    return this.each(el => this.nodes[el].style.height = value);\n};"
    },
    "hide": {
        "Name": "hide",
        "Method": "Prototype",
        "Desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).hide(duration, callback);",
        "Script": "Q.prototype.hide = function (duration = 0, callback) {\n    return this.each(el => {\n        const element = this.nodes[el];\n        if (duration === 0) {\n            element.style.display = 'none';\n            if (callback) callback();\n        } else {\n            element.style.transition = `opacity ${duration}ms`;\n            element.style.opacity = 1;\n            setTimeout(() => {\n                element.style.opacity = 0;\n                element.addEventListener('transitionend', function handler() {\n                    element.style.display = 'none';\n                    element.style.transition = '';\n                    element.removeEventListener('transitionend', handler);\n                    if (callback) callback();\n                });\n            }, 0);\n        }\n    });\n};"
    },
    "html": {
        "Name": "html",
        "Method": "Prototype",
        "Desc": "Gets or sets the innerHTML of the nodes.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Content Manipulation",
        "Example": "Q(selector).html(string);",
        "Script": "Q.prototype.html = function (...content) {\n    if (content.length === 0) {\n        return this.nodes[0]?.innerHTML || null;\n    }\n    return this.each(el => {\n        el = this.nodes[el];\n        el.innerHTML = '';\n        content.forEach(child => {\n            if (typeof child === 'string') {\n                el.insertAdjacentHTML('beforeend', child);\n            } else if (child instanceof Q) {\n                child.nodes.forEach(node => el.appendChild(node));\n            } else if (child instanceof HTMLElement) {\n                el.appendChild(child);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                Array.from(child).forEach(subchild => el.appendChild(subchild));\n            }\n        });\n    });\n};"
    },
    "id": {
        "Name": "id",
        "Method": "Prototype",
        "Desc": "Gets or sets the id attribute of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Attributes",
        "Example": "Q(selector).id(); or Q(selector).id('new-id');",
        "Script": "Q.prototype.id = function (id) {\n    if (id === undefined) {\n        return this.nodes[0].id;\n    }\n\n    return this.nodes[0].id = id;\n};"
    },
    "index": {
        "Name": "index",
        "Method": "Prototype",
        "Desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).index(index);",
        "Script": "Q.prototype.index = function (index) {\n    if (index === undefined) {\n        return Array.from(this.nodes[0].parentNode.children).indexOf(this.nodes[0]);\n    }\n    return this.each(el => {\n        const parent = this.nodes[el].parentNode;\n        const siblings = Array.from(parent.children);\n        const position = siblings.indexOf(el);\n        const target = siblings.splice(index, 1)[0];\n        if (position < index) {\n            parent.insertBefore(target, el);\n        } else {\n            parent.insertBefore(target, this.nodes[el].nextSibling);\n        }\n    });\n};"
    },
    "inside": {
        "Name": "inside",
        "Method": "Prototype",
        "Desc": "Checks if the first node is inside another node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).inside(\".parent\");",
        "Script": "Q.prototype.inside = function (selector) {\n    return this.nodes[0]?.closest(selector) !== null;\n};"
    },
    "is": {
        "Name": "is",
        "Method": "Prototype",
        "Desc": "Checks if the first node matches a specific selector.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Utilities",
        "Example": "Q(selector).is(\":visible\");",
        "Script": "Q.prototype.is = function (selector) {\n    const node = this.nodes[0];\n\n    if (!node) return false; \n\n    if (typeof selector === 'function') {\n        return selector.call(node, 0, node);\n    }\n\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return node.offsetWidth > 0 && node.offsetHeight > 0;\n            case ':hidden':\n                return node.offsetWidth === 0 || node.offsetHeight === 0;\n            case ':hover':\n                return node === document.querySelector(':hover');\n            case ':focus':\n                return node === document.activeElement;\n            case ':blur':\n                return node !== document.activeElement;\n            case ':checked':\n                return node.checked;\n            case ':selected':\n                return node.selected;\n            case ':disabled':\n                return node.disabled;\n            case ':enabled':\n                return !node.disabled;\n            default:\n                return node.matches(selector);\n        }\n    }\n\n    if (selector instanceof HTMLElement || selector instanceof Node) {\n        return node === selector;\n    }\n\n    if (selector instanceof Q) {\n        return node === selector.nodes[0];\n    }\n\n    return false;\n};"
    },
    "isExists": {
        "Name": "isExists",
        "Method": "Prototype and Static",
        "Desc": "Checks if the first node exists in the DOM.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Utilities",
        "Example": "Q(selector).isExists(); or Q.isExists('.ok')",
        "Script": "Q.prototype.isExists = function () {\n    return document.body.contains(this.nodes[0]);\n};\n\n\nQ.isExists = function (selector) {\n    return document.querySelector(selector) !== null;\n};"
    },
    "last": {
        "Name": "last",
        "Method": "Prototype",
        "Desc": "Returns the last node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).last();",
        "Script": "Q.prototype.last = function () {\n    return new Q(this.nodes[this.nodes.length - 1]);\n};"
    },
    "off": {
        "Name": "off",
        "Method": "Prototype",
        "Desc": "Removes an event listener from each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q(selector).off(\"click\", handler);",
        "Script": "Q.prototype.off = function (events, handler, options = {}) {\n    const defaultOptions = {\n        capture: false,\n        once: false,\n        passive: false\n    };\n    options = { ...defaultOptions, ...options };\n\n    return this.each(el => {\n        events.split(' ').forEach(event => this.nodes[el].removeEventListener(event, handler, options));\n    });\n};"
    },
    "offset": {
        "Name": "offset",
        "Method": "Prototype",
        "Desc": "Returns the top and left offset of the first node relative to the document.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Dimensions",
        "Example": "Q(selector).offset();",
        "Script": "Q.prototype.offset = function () {\n    const rect = this.nodes[0].getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX\n    };\n};"
    },
    "on": {
        "Name": "on",
        "Method": "Prototype",
        "Desc": "Adds an event listener to each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
        "Script": "Q.prototype.on = function (events, handler, options = {}) {\n    const defaultOptions = {\n        capture: false,\n        once: false,\n        passive: false\n    };\n\n    options = { ...defaultOptions, ...options };\n\n    return this.each(el => {\n        events.split(' ').forEach(event => this.nodes[el].addEventListener(event, handler, options));\n    });\n};"
    },
    "parent": {
        "Name": "parent",
        "Method": "Prototype",
        "Desc": "Returns the parent node of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Traversal",
        "Example": "Q(selector).parent();",
        "Script": "Q.prototype.parent = function () {\n    return new Q(this.nodes[0].parentNode);\n};"
    },
    "position": {
        "Name": "position",
        "Method": "Prototype",
        "Desc": "Returns the top and left position of the first node relative to its offset parent.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Dimension/Position",
        "Example": "Q(selector).position();",
        "Script": "Q.prototype.position = function () {\n    return {\n        top: this.nodes[0].offsetTop,\n        left: this.nodes[0].offsetLeft\n    };\n};"
    },
    "prepend": {
        "Name": "prepend",
        "Method": "Prototype",
        "Desc": "Prepends child nodes or HTML to each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).prepend(\"<div>Prepended</div>\");",
        "Script": "Q.prototype.prepend = function (...nodes) {\n    return this.each(el => {\n        const parent = this.nodes[el];\n\n        nodes.forEach(child => {\n            if (typeof child === 'string') {\n                parent.insertAdjacentHTML('afterbegin', child);\n            } else if (child instanceof HTMLElement || child instanceof Q) {\n                parent.insertBefore(child.nodes[0], parent.firstChild);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                Array.from(child).forEach(subchild => parent.insertBefore(subchild, parent.firstChild));\n            }\n        });\n    });\n};"
    },
    "prop": {
        "Name": "prop",
        "Method": "Prototype",
        "Desc": "Gets or sets a property on the nodes.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Property Manipulation",
        "Example": "Q(selector).prop(property, value);",
        "Script": "Q.prototype.prop = function (property, value) {\n    if (value === undefined) {\n        return this.nodes[0]?.[property] || null;\n    }\n    return this.each(function (index, el) {\n        el[property] = value;\n    });\n};"
    },
    "remove": {
        "Name": "remove",
        "Method": "Prototype",
        "Desc": "Removes each node from the DOM.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).remove();",
        "Script": "Q.prototype.remove = function () {\n    return this.each(el => this.nodes[el].remove());\n};"
    },
    "removeAttr": {
        "Name": "removeAttr",
        "Method": "Prototype",
        "Desc": "Removes an attribute from each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Attribute Manipulation",
        "Example": "Q(selector).removeAttr(attribute);",
        "Script": "Q.prototype.removeAttr = function (attribute) {\n    return this.each(el => this.nodes[el].removeAttribute(attribute));\n};"
    },
    "removeClass": {
        "Name": "removeClass",
        "Method": "Prototype",
        "Desc": "Removes one or more classes from each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Class Manipulation",
        "Example": "Q(selector).removeClass(\"class1 class2\");",
        "Script": "Q.prototype.removeClass = function (classes) {\n    const classList = classes.split(' ');\n    return this.each(el => this.nodes[el].classList.remove(...classList));\n};"
    },
    "removeData": {
        "Name": "removeData",
        "Method": "Prototype",
        "Desc": "Removes a data-* attribute from each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Data Manipulation",
        "Example": "Q(selector).removeData(key);",
        "Script": "Q.prototype.removeData = function (key) {\n    return this.each(el => delete this.nodes[el].dataset[key]);\n};"
    },
    "removeProp": {
        "Name": "removeProp",
        "Method": "Prototype",
        "Desc": "Removes a property from each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Property Manipulation",
        "Example": "Q(selector).removeProp(property);",
        "Script": "Q.prototype.removeProp = function (property) {\n    return this.each(el => delete this.nodes[el][property]);\n};"
    },
    "removeTransition": {
        "Name": "removeTransition",
        "Method": "Prototype",
        "Desc": "Removes the transition from each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).removeTransition();",
        "Script": "Q.prototype.removeTransition = function () {\n    return this.each(el => this.nodes[el].style.transition = '');\n};"
    },
    "scrollHeight": {
        "Name": "scrollHeight",
        "Method": "Prototype",
        "Desc": "Returns the scroll height of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Scroll Manipulation",
        "Example": "Q(selector).scrollHeight();",
        "Script": "Q.prototype.scrollHeight = function () {\n    return this.nodes[0].scrollHeight;\n};"
    },
    "scrollLeft": {
        "Name": "scrollLeft",
        "Method": "Prototype",
        "Desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Scroll Manipulation",
        "Example": "Q(selector).scrollLeft(value, increment);",
        "Script": "Q.prototype.scrollLeft = function (value, increment = false) {\n    if (value === undefined) {\n        return this.nodes[0].scrollLeft;\n    }\n    return this.each(el => {\n        const maxScrollLeft = this.nodes[el].scrollWidth - this.nodes[el].clientWidth;\n        if (increment) {\n            this.nodes[el].scrollLeft = Math.min(this.nodes[el].scrollLeft + value, maxScrollLeft);\n        } else {\n            this.nodes[el].scrollLeft = Math.min(value, maxScrollLeft);\n        }\n    });\n};"
    },
    "scrollTop": {
        "Name": "scrollTop",
        "Method": "Prototype",
        "Desc": "Gets or sets the vertical scroll position of the first node, with an option to increment.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Scroll Manipulation",
        "Example": "Q(selector).scrollTop(value, increment);",
        "Script": "Q.prototype.scrollTop = function (value, increment = false) {\n    if (value === undefined) {\n        return this.nodes[0].scrollTop;\n    }\n    return this.each(el => {\n        const maxScrollTop = this.nodes[el].scrollHeight - this.nodes[el].clientHeight;\n        if (increment) {\n            this.nodes[el].scrollTop = Math.min(this.nodes[el].scrollTop + value, maxScrollTop);\n        } else {\n            this.nodes[el].scrollTop = Math.min(value, maxScrollTop);\n        }\n    });\n};"
    },
    "scrollWidth": {
        "Name": "scrollWidth",
        "Method": "Prototype",
        "Desc": "Returns the scroll width of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Dimensions",
        "Example": "Q(selector).scrollWidth();",
        "Script": "Q.prototype.scrollWidth = function () {\n    return this.nodes[0].scrollWidth;\n};"
    },
    "show": {
        "Name": "show",
        "Method": "Prototype",
        "Desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).show(duration, callback);",
        "Script": "Q.prototype.show = function (duration = 0, callback) {\n    return this.each(el => {\n        const element = this.nodes[el];\n        if (duration === 0) {\n            element.style.display = '';\n            if (callback) callback();\n        } else {\n            element.style.transition = `opacity ${duration}ms`;\n            element.style.opacity = 0;\n            element.style.display = '';\n            setTimeout(() => {\n                element.style.opacity = 1;\n                element.addEventListener('transitionend', function handler() {\n                    element.style.transition = '';\n                    element.removeEventListener('transitionend', handler);\n                    if (callback) callback();\n                });\n            }, 0);\n        }\n    });\n};"
    },
    "size": {
        "Name": "size",
        "Method": "Prototype",
        "Desc": "Returns the width and height of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Dimensions",
        "Example": "Q(selector).size();",
        "Script": "Q.prototype.size = function () {\n    return {\n        width: this.nodes[0].offsetWidth,\n        height: this.nodes[0].offsetHeight\n    };\n};"
    },
    "text": {
        "Name": "text",
        "Method": "Prototype",
        "Desc": "Gets or sets the text content of the nodes.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Content Manipulation",
        "Example": "Q(selector).text(string);",
        "Script": "Q.prototype.text = function (content) {\n    if (content === undefined) {\n        return this.nodes[0]?.textContent || null;\n    }\n    return this.each(el => this.nodes[el].textContent = content);\n};"
    },
    "toggle": {
        "Name": "toggle",
        "Method": "Prototype",
        "Desc": "Toggles the display of each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Utilities",
        "Example": "Q(selector).toggle();",
        "Script": "Q.prototype.toggle = function () {\n    return this.each(el => this.nodes[el].style.display = this.nodes[el].style.display === 'none' ? '' : 'none');\n};"
    },
    "toggleClass": {
        "Name": "toggleClass",
        "Method": "Prototype",
        "Desc": "Toggles a class on each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Class Manipulation",
        "Example": "Q(selector).toggleClass(className);",
        "Script": "Q.prototype.toggleClass = function (className) {\n    return this.each(el => this.nodes[el].classList.toggle(className));\n};"
    },
    "trigger": {
        "Name": "trigger",
        "Method": "Prototype",
        "Desc": "Triggers a specific event on each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q(selector).trigger(\"click\");",
        "Script": "Q.prototype.trigger = function (event) {\n    return this.each(function (index, el) {\n        el.dispatchEvent(new Event(event));\n    });\n};"
    },
    "unwrap": {
        "Name": "unwrap",
        "Method": "Prototype",
        "Desc": "Removes the parent wrapper of each node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).unwrap();",
        "Script": "Q.prototype.unwrap = function () {\n    return this.each(el => {\n        const parent = this.nodes[el].parentNode;\n        if (parent !== document.body) {\n            parent.replaceWith(...this.nodes);\n        }\n    });\n};"
    },
    "val": {
        "Name": "val",
        "Method": "Prototype",
        "Desc": "Gets or sets the value of form elements in the nodes.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Form Manipulation",
        "Example": "Q(selector).val(value);",
        "Script": "Q.prototype.val = function (value) {\n    if (value === undefined) {\n        return this.nodes[0]?.value || null;\n    }\n    return this.each(el => this.nodes[el].value = value);\n};"
    },
    "Wait": {
        "Name": "Wait",
        "Method": "Prototype",
        "Desc": "Returns a promise that resolves after a given time. Useful for delaying actions.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Utility",
        "Example": "Q('.text').wait(1000).text('Hello, World!');",
        "Script": "Q.prototype.wait = function (ms) {\n    \n    const qInstance = this;\n\n    \n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(qInstance); \n        }, ms);\n    });\n};"
    },
    "walk": {
        "Name": "walk",
        "Method": "Prototype",
        "Desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Iteration",
        "Example": "Q(selector).walk((node) => console.log(node), true); // Passes Q object",
        "Script": "Q.prototype.walk = function (callback, useQObject = true) {\n    this.nodes.forEach((el, index) => {\n        const node = useQObject ? Q(el) : el;\n        callback.call(el, node, index);\n    });\n    return this;\n};"
    },
    "width": {
        "Name": "width",
        "Method": "Prototype",
        "Desc": "Gets or sets the width of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Dimensions",
        "Example": "Q(selector).width(value);",
        "Script": "Q.prototype.width = function (value) {\n    if (value === undefined) {\n        return this.nodes[0].offsetWidth;\n    }\n    return this.each(el => this.nodes[el].style.width = value);\n};"
    },
    "wrap": {
        "Name": "wrap",
        "Method": "Prototype",
        "Desc": "Wraps each node with the specified wrapper element.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).wrap(\"<div class='wrapper'></div>\");",
        "Script": "Q.prototype.wrap = function (wrapper) {\n    return this.each(el => {\n        const parent = this.nodes[el].parentNode;\n        const newParent = typeof wrapper === 'string' ? document.createElement(wrapper) : wrapper;\n        parent.insertBefore(newParent, this.nodes[el]);\n        newParent.appendChild(this.nodes[el]);\n    });\n};"
    },
    "wrapAll": {
        "Name": "wrapAll",
        "Method": "Prototype",
        "Desc": "Wraps all nodes together in a single wrapper element.",
        "variant": "method",
        "Dependencies": [],
        "Type": "DOM Manipulation",
        "Example": "Q(selector).wrapAll(\"<div class='wrapper'></div>\");",
        "Script": "Q.prototype.wrapAll = function (wrapper) {\n    return this.each(el => {\n        const parent = this.nodes[el].parentNode;\n        const newParent = typeof wrapper === 'string' ? document.createElement(wrapper) : wrapper;\n        parent.insertBefore(newParent, this.nodes[0]);\n        this.nodes.forEach(child => newParent.appendChild(child));\n    });\n};"
    },
    "zIndex": {
        "Name": "zIndex",
        "Method": "Prototype",
        "Desc": "Gets or sets the z-index of the first node.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Display",
        "Example": "Q(selector).zIndex(value);",
        "Script": "Q.prototype.zIndex = function (value) {\n    if (value === undefined) {\n        let zIndex = this.nodes[0].style.zIndex;\n        if (!zIndex) {\n            zIndex = window.getComputedStyle(this.nodes[0]).zIndex;\n        }\n        return zIndex;\n    }\n    return this.each(el => this.nodes[el].style.zIndex = value);\n};"
    },
    "ColorBrightness": {
        "Name": "ColorBrightness",
        "Method": "Static",
        "Desc": "Adjusts the brightness of a color by a percentage.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Color",
        "Example": "Q.ColorBrightness('#000000', 50); // #7f7f7f (black +50%)",
        "Script": "Q.ColorBrightness = function (color, percent) {\n    let r, g, b, a = 1;\n    let hex = false;\n\n    \n    if (!color.startsWith('#') && !color.startsWith('rgb')) {\n        throw new Error('Unsupported color format');\n    }\n\n    \n    if (color.startsWith('#')) {\n        color = color.replace(/^#/, '');\n        if (color.length === 3) {\n            r = parseInt(color[0] + color[0], 16);\n            g = parseInt(color[1] + color[1], 16);\n            b = parseInt(color[2] + color[2], 16);\n        }\n        if (color.length === 6) {\n            r = parseInt(color.substring(0, 2), 16);\n            g = parseInt(color.substring(2, 4), 16);\n            b = parseInt(color.substring(4, 6), 16);\n        }\n        hex = true;\n    }\n\n    \n    if (color.startsWith('rgb')) {\n        const rgba = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(\\.\\d+)?))?\\)/);\n        if (rgba) {\n            r = parseInt(rgba[1]);\n            g = parseInt(rgba[2]);\n            b = parseInt(rgba[3]);\n            if (rgba[4]) {\n                a = parseFloat(rgba[4]);\n            }\n        }\n    }\n\n    \n    r = Math.min(255, Math.max(0, r + (r * percent / 100)));\n    g = Math.min(255, Math.max(0, g + (g * percent / 100)));\n    b = Math.min(255, Math.max(0, b + (b * percent / 100)));\n\n    \n    if (hex) {\n        return '#' +\n            ('0' + Math.round(r).toString(16)).slice(-2) +\n            ('0' + Math.round(g).toString(16)).slice(-2) +\n            ('0' + Math.round(b).toString(16)).slice(-2);\n    } else if (color.startsWith('rgb')) {\n        if (a === 1) {\n            return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n        } else {\n            return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;\n        }\n    }\n}"
    },
    "Debounce": {
        "Name": "Debounce",
        "Method": "Static",
        "Desc": "Debounces a function to only be called after a certain amount of time has passed since the last call avoiding multiple calls in a short period of time.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q.Debounce('myFunction', 500, myFunction);",
        "Script": "Q.Debounce = function (id, time, callback) {\n    GLOBAL = GLOBAL || {};\n    GLOBAL.Flood = GLOBAL.Flood || {};\n    if (GLOBAL.Flood[id]) {\n        clearTimeout(GLOBAL.Flood[id]);\n    }\n    GLOBAL.Flood[id] = time ? setTimeout(callback, time) : callback();\n};"
    },
    "Done": {
        "Name": "Done",
        "Method": "Static",
        "Desc": "Registers callbacks to be executed when the window has fully loaded.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q.Done(() => { console.log('Window has fully loaded'); });",
        "Script": "Q.Done = (function () {\n    const callbacks = [];\n    window.addEventListener('load', () => {\n        callbacks.forEach(callback => callback());\n    });\n    return function (callback) {\n        callbacks.push(callback);\n    };\n})();"
    },
    "HSL2RGB": {
        "Name": "HSL2RGB",
        "Method": "Static",
        "Desc": "Converts HSL to RGB.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Color",
        "Example": "Q.HSL2RGB(0, 0, 1); // [255, 255, 255]",
        "Script": "Q.HSL2RGB = function (h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; \n    } else {\n        let hue2rgb = function (p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        let p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return [r * 255, g * 255, b * 255];\n};"
    },
    "ID": {
        "Name": "ID",
        "Method": "Static",
        "Desc": "Generates a random hexadecimal ID with a specified length and optional prefix.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Utility",
        "Example": "Q.ID(8, 'user-'); // user-1a2b3c4d",
        "Script": "Q.ID = function (length = 8, prefix = '') {\n    return prefix + [...Array(length)]\n        .map(() => Math.floor(Math.random() * 16).toString(16))\n        .join('');\n};"
    },
    "isDarkColor": {
        "Name": "isDarkColor",
        "Method": "Static",
        "Desc": "Determines if a color is dark or light based on HSP.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Color",
        "Example": "Q.isDarkColor('#000000'); or Q.isDarkColor('#000000', 20, 100); // 20 is margin, 100 is threshold",
        "Script": "Q.isDarkColor = (color, margin = 20, threshold = 100) => {\n    let r, g, b;\n\n    \n    const parseHex = (hex) => {\n        if (hex.length === 3) {\n            return [\n                parseInt(hex[0] + hex[0], 16),\n                parseInt(hex[1] + hex[1], 16),\n                parseInt(hex[2] + hex[2], 16),\n            ];\n        } else if (hex.length === 6) {\n            return [\n                parseInt(hex.slice(0, 2), 16),\n                parseInt(hex.slice(2, 4), 16),\n                parseInt(hex.slice(4, 6), 16),\n            ];\n        }\n        throw new Error('Invalid hex color format');\n    };\n\n    \n    if (color[0] === '#') {\n        [r, g, b] = parseHex(color.slice(1));\n    } else if (color.startsWith('rgb')) {\n        const rgba = color.match(/\\d+/g);\n        if (rgba && rgba.length >= 3) {\n            [r, g, b] = rgba.map(Number);\n        } else {\n            throw new Error('Invalid rgb/rgba color format');\n        }\n    } else {\n        throw new Error('Unsupported color format');\n    }\n\n    \n    const hsp = Math.sqrt(\n        0.299 * (r ** 2) +\n        0.587 * (g ** 2) +\n        0.114 * (b ** 2)\n    ) + margin;\n\n    \n    return hsp < threshold;\n};"
    },
    "Leaving": {
        "Name": "Leaving",
        "Method": "Static",
        "Desc": "Registers callbacks to be executed when the window is about to be unloaded.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q.Leaving((event) => { console.log('Window is about to be unloaded'); });",
        "Script": "Q.Leaving = (function () {\n    const callbacks = [];\n    window.addEventListener('beforeunload', (event) => {\n        callbacks.forEach(callback => callback(event));\n    });\n    return function (callback) {\n        callbacks.push(callback);\n    };\n})();"
    },
    "Ready": {
        "Name": "Ready",
        "Method": "Static",
        "Desc": "Registers callbacks to be executed when the DOM is fully loaded.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q.Ready(() => { console.log('DOM is ready'); });",
        "Script": "Q.Ready = (function () {\n    const callbacks = [];\n    document.addEventListener('DOMContentLoaded', () => {\n        callbacks.forEach(callback => callback());\n    }, { once: true });\n\n    return function (callback) {\n        if (document.readyState === 'loading') {\n            callbacks.push(callback);\n        } else {\n            callback();\n        }\n    };\n})();"
    },
    "Resize": {
        "Name": "Resize",
        "Method": "Static",
        "Desc": "Registers callbacks to be executed on window resize, providing the new width and height.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Event Handling",
        "Example": "Q.Resize((width, height) => { console.log(`Width: ${width}, Height: ${height}`); });",
        "Script": "Q.Resize = (function () {\n    const callbacks = [];\n    window.addEventListener('resize', () => {\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        callbacks.forEach(callback => callback(width, height));\n    });\n    return function (callback) {\n        callbacks.push(callback);\n    };\n})();"
    },
    "RGB2HSL": {
        "Name": "RGB2HSL",
        "Method": "Static",
        "Desc": "Converts RGB to HSL.",
        "variant": "method",
        "Dependencies": [],
        "Type": "Color",
        "Example": "Q.RGB2HSL(255, 255, 255); // [0, 0, 1]",
        "Script": "Q.RGB2HSL = function (r, g, b) {\n    r /= 255, g /= 255, b /= 255;\n    let max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2;\n\n    if (max === min) {\n        h = s = 0; \n    } else {\n        let d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n    }\n\n    return [h, s, l];\n};"
    },
    "Container": {
        "Name": "Container",
        "Method": "Plugin",
        "Desc": "Useful to create tabbed containers.",
        "variant": "plugin",
        "Dependencies": [
            "Style",
            "addClass",
            "removeClass",
            "on",
            "append",
            "each",
            "find",
            "scrollTop",
            "scrollLeft",
            "Icons"
        ],
        "Type": "Plugin",
        "Example": "var containers = Q.Container();",
        "Script": "Q.Container = function (options = {}) {\n\n    let Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' container_icon');\n        return iconElement;\n    };\n\n    Q.Icons();\n    let classes = Q.style(` \n         .container_icon {\n             width: 100%;\n             height: 100%;\n             color: #777; /* Default color */\n             pointer-events: none;\n             z-index: 1;\n         }\n\n          .tab_navigation_buttons {\n         box-sizing: border-box;\n            width: 20px;\n            background-color: #333;\n            display: flex;\n            justify-content: center;\n            padding: 4px;\n        }\n        \n        .tab_navigation_buttons_vertical {\n            width: auto;\n            height: 20px;\n        }\n        \n        .tab_navigation_buttons:hover {\n            background-color: #555;\n        }\n        \n        .tab_container {\n            width: 100%;\n            height: 300px;\n        }\n        \n        .tab_container_vertical {\n        display: flex;\n                }\n        \n        .tab_navigation_header {\n        \n            background-color: #333;\n            display: flex;\n        }\n        \n        .tab_navigation_header_vertical {\n            flex-direction: column;\n                width: auto;\n        }\n        \n        .tab_navigation_tabs {\n        user-select: none;\n            display: flex;\n            flex-direction: row;\n            width: 100%;\n            overflow: hidden;\n        }\n        \n        .tab_navigation_tabs_vertical {\n            flex-direction: column;\n        }\n        \n        .tab_active {\n            background-color: #555;\n            color: #fff;\n        }\n        \n        .tab {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            cursor: default;\n            padding: 5px 25px;\n        }\n        \n        .tab_disabled {\n            background-color: #333;\n            color: #555;\n        }\n `,\n        {\n            'tab_navigation_buttons': 'tab_navigation_buttons',\n            'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n            'tab_container': 'tab_container',\n            'tab_container_vertical': 'tab_container_vertical',\n            'tab_navigation_header': 'tab_navigation_header',\n            'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n            'tab_navigation_tabs': 'tab_navigation_tabs',\n            'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n            'tab_active': 'tab_active',\n            'tab': 'tab',\n            'tab_disabled': 'tab_disabled'\n        });\n\n    return {\n        Tab: function (data, horizontal = true) {\n            let wrapper = Q('<div>', { class: classes.tab_container });\n            let tabs_wrapper = Q('<div>', { class: classes.tab_navigation_header });\n            let tabs_nav_left = Q('<div>', { class: classes.tab_navigation_buttons });\n            let tabs_nav_right = Q('<div>', { class: classes.tab_navigation_buttons });\n            let tabs = Q('<div>', { class: classes.tab_navigation_tabs });\n\n            tabs_wrapper.append(tabs_nav_left, tabs, tabs_nav_right);\n\n            let content = Q('<div>');\n            wrapper.append(tabs_wrapper, content);\n            if (!horizontal) {\n                wrapper.addClass(classes.tab_container_vertical);\n                tabs.addClass(classes.tab_navigation_tabs_vertical);\n                tabs_wrapper.addClass(classes.tab_navigation_header_vertical);\n                tabs_nav_left.addClass(classes.tab_navigation_buttons_vertical);\n                tabs_nav_right.addClass(classes.tab_navigation_buttons_vertical);\n                tabs_nav_left.append(Icon('arrow-up'));\n                tabs_nav_right.append(Icon('arrow-down'));\n            }\n            else {\n                tabs_nav_left.append(Icon('arrow-left'));\n                tabs_nav_right.append(Icon('arrow-right'));\n            }\n\n            let data_tabs = {};\n            let data_contents = {};\n\n            data.forEach((item) => {\n                const tab = Q('<div>', { class: classes.tab, 'data-value': item.value }).text(item.title);\n                if (item.disabled) {\n                    tab.addClass(classes.tab_disabled);\n                }\n\n                data_tabs[item.value] = tab;\n                data_contents[item.value] = item.content;\n\n                tab.on('click', function () {\n\n                    if (item.disabled) {\n                        return;\n                    }\n\n                    let foundTabs = tabs.find('.' + classes.tab_active);\n\n                    if (foundTabs) {\n                        foundTabs.removeClass(classes.tab_active);\n                    }\n\n                    tab.addClass(classes.tab_active);\n                    content.html(data_contents[item.value]);\n                });\n                tabs.append(tab);\n            });\n\n            tabs_nav_left.on('click', function () {\n\n                if (!horizontal) {\n                    tabs.scrollTop(-tabs.height(), true);\n                } else {\n                    tabs.scrollLeft(-tabs.width(), true);\n                }\n            });\n\n            tabs_nav_right.on('click', function () {\n\n                if (!horizontal) {\n                    tabs.scrollTop(tabs.height(), true);\n                } else {\n                    tabs.scrollLeft(tabs.width(), true);\n                }\n            });\n\n            wrapper.select = function (value) {\n                data_tabs.forEach(tab => {\n                    if (tab.data('value') === value) {\n                        tab.click();\n                    }\n                });\n            };\n\n            wrapper.disabled = function (value, state) {\n                if (data_tabs[value]) {\n                    if (state) {\n                        data_tabs[value].addClass(classes.tab_disabled);\n                    } else {\n                        data_tabs[value].removeClass(classes.tab_disabled);\n                    }\n                }\n            };\n\n            return wrapper;\n        }\n    };\n\n\n\n\n};"
    },
    "Cookie": {
        "Name": "Cookie",
        "Method": "Plugin",
        "Desc": "Provides methods to store and retrieve data from the browser cookies.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "Q.Cookie('key', 'value to store'); Q.Cookie('key'); // returns 'value to store'",
        "Script": "Q.Cookie = function (key, value, options = {}) {\n    function _serialize(options) {\n        const { days, path, domain, secure } = options;\n        let cookieString = '';\n\n        if (days) {\n            const date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            cookieString += `expires=${date.toUTCString()}; `;\n        }\n        if (path) {\n            cookieString += `path=${path}; `;\n        }\n        if (domain) {\n            cookieString += `domain=${domain}; `;\n        }\n        if (secure) {\n            cookieString += 'secure; ';\n        }\n        return cookieString;\n    }\n\n    function _parse(cookieString) {\n        return cookieString.split(';').reduce((cookies, cookie) => {\n            const [name, value] = cookie.split('=').map(c => c.trim());\n            cookies[name] = value;\n            return cookies;\n        }, {});\n    }\n\n    if (arguments.length === 2) { \n        if (value === null || value === '') { \n            value = ''; \n            options = { ...options, days: -1 }; \n        }\n        return document.cookie = `${key}=${value}; ${_serialize(options)}`; \n    } else if (arguments.length === 1) { \n        return _parse(document.cookie)[key]; \n    }\n};"
    },
    "Fetch": {
        "Name": "Fetch",
        "Method": "Plugin",
        "Desc": "Fetches data from a URL and returns it to a callback function. Supports retries, timeouts, and custom response validation.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "Q.fetch('https://api.example.com/data', (error, data) => console.log(error, data));",
        "Script": "Q.Fetch = function (url, callback, options = {}) {\n    const {\n        method = 'GET',\n        headers = {},\n        body,\n        contentType = 'application/json',\n        responseType = 'json',\n        credentials = 'same-origin',\n        retries = 3,\n        retryDelay = 1000, \n        timeout = 0, \n        validateResponse = (data) => data \n    } = options;\n\n    headers['Content-Type'] = headers['Content-Type'] || contentType;\n\n    \n    const controller = new AbortController();\n    const { signal } = controller;\n\n    \n    const fetchWithRetry = (attempt) => {\n        \n        const timeoutId = timeout ? setTimeout(() => controller.abort(), timeout) : null;\n\n        fetch(url, { method, headers, body, credentials, signal })\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(`Network response was not ok: ${response.statusText}`);\n                }\n                switch (responseType) {\n                    case 'json': return response.json();\n                    case 'text': return response.text();\n                    case 'blob': return response.blob();\n                    case 'arrayBuffer': return response.arrayBuffer();\n                    default: throw new Error('Unsupported response type');\n                }\n            })\n            .then(data => {\n                if (timeoutId) clearTimeout(timeoutId);\n                return validateResponse(data);\n            })\n            .then(data => callback(null, data))\n            .catch(error => {\n                if (timeoutId) clearTimeout(timeoutId);\n\n                if (error.name === 'AbortError') {\n                    callback(new Error('Fetch request was aborted'), null);\n                } else if (attempt < retries) {\n                    console.warn(`Retrying fetch (${attempt + 1}/${retries}):`, error);\n                    setTimeout(() => fetchWithRetry(attempt + 1), retryDelay);\n                } else {\n                    callback(error, null);\n                }\n            });\n    };\n\n    fetchWithRetry(0);\n\n    \n    return {\n        abort: () => controller.abort()\n    };\n};"
    },
    "Form": {
        "Name": "Form",
        "Method": "Plugin",
        "Desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
        "variant": "plugin",
        "Dependencies": [
            "Style",
            "addClass",
            "removeClass",
            "on",
            "append",
            "each",
            "find",
            "scrollTop",
            "scrollLeft",
            "hasClass",
            "text",
            "html",
            "val",
            "click",
            "closest",
            "empty",
            "show",
            "hide",
            "css",
            "attr",
            "prop",
            "remove",
            "add"
        ],
        "Type": "Plugin",
        "Example": "var containers = Q.Form()",
        "Script": "Q.Form = function (options = {}) {\n\n    let Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' form_icon');\n        return iconElement;\n    }\n\n    let classes = Q.style(`\n           .form_icon {\n               width: 100%;\n               height: 100%;\n               color: #fff;\n               /* Default color */\n               pointer-events: none;\n           }\n\n           .q_form {\n               box-sizing: border-box;\n               font-family: inherit;\n               font-size: inherit;\n               color: inherit;\n               margin: 1px;\n           }\n\n           .q_form_disabled {\n               opacity: 0.5;\n           }\n\n           .q_form_checkbox,\n           .q_form_radio {\n               display: flex;\n               width: fit-content;\n               align-items: center;\n           }\n\n           .q_form_checkbox .label:empty,\n           .q_form_radio .label:empty {\n               display: none;\n           }\n\n           .q_form_checkbox .label,\n           .q_form_radio .label {\n               padding-left: 5px;\n               user-select: none;\n           }\n\n           .q_form_cb {\n               position: relative;\n               width: 20px;\n               height: 20px;\n               background-color: #555555;\n           }\n\n           .q_form_cb input[type=\"checkbox\"] {\n               opacity: 0;\n               top: 0;\n               left: 0;\n               padding: 0;\n               margin: 0;\n               width: 100%;\n               height: 100%;\n               position: absolute;\n           }\n\n           .q_form_cb input[type=\"checkbox\"]:checked+label:before {\n               content: \"\";\n               position: absolute;\n               display: block;\n               top: 0;\n               left: 0;\n               width: 100%;\n               height: 100%;\n               background-color: #1DA1F2;\n           }\n\n           .q_form_r {\n               position: relative;\n               width: 20px;\n               height: 20px;\n               background-color: #555555;\n               border-radius: 50%;\n               overflow: hidden;\n           }\n\n           .q_form_r input[type=\"radio\"] {\n               opacity: 0;\n               top: 0;\n               left: 0;\n               padding: 0;\n               margin: 0;\n               width: 100%;\n               height: 100%;\n               position: absolute;\n               border-radius: 50%;\n           }\n\n           .q_form_r input[type=\"radio\"]:checked+label:before {\n               content: \"\";\n               position: absolute;\n               display: block;\n               top: 0;\n               left: 0;\n               width: 100%;\n               height: 100%;\n               background-color: #1DA1F2;\n               border-radius: 50%;\n           }\n\n           .q_form_input {\n               width: calc(100% - 2px);\n               padding: 5px;\n               outline: none;\n               border: 0;\n           }\n\n           .q_form_input:focus,\n           .q_form_textarea:focus {\n               outline: 1px solid #1DA1F2;\n           }\n\n           .q_form_textarea {\n               width: calc(100% - 2px);\n               padding: 5px;\n               outline: none;\n               border: 0;\n           }\n\n           .q_window {\n               position: fixed;\n               background-color: #333;\n               z-index: 1000;\n               box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);\n               border: 1px solid rgba(255, 255, 255, 0.01);\n               border-radius: 5px;\n               overflow: hidden;\n               display: flex;\n               flex-direction: column;\n           }\n\n           .q_window_titlebar {\n               user-select: none;\n               display: flex;\n               background-color: #222;\n               width: 100%;\n               flex-shrink: 0;\n           }\n\n           .q_window_buttons {\n               display: flex;\n           }\n\n           .q_window_button {\n               box-sizing: border-box;\n               display: flex;\n               justify-content: center;\n               align-items: center;\n               cursor: pointer;\n               width: 30px;\n               height: 30px;\n               padding: 10px;\n               background-color: rgba(255, 255, 255, 0.01);\n               margin-left: 1px;\n           }\n\n           .q_window_button:hover {\n               background-color: #424242;\n           }\n\n           .q_window_close:hover {\n               background-color: #e81123;\n           }\n\n           .q_window_titletext {\n               flex-grow: 1;\n               color: #fff;\n               align-content: center;\n               white-space: nowrap;\n               overflow: hidden;\n               text-overflow: ellipsis;\n               padding: 0 5px\n           }\n\n           .q_window_content {\n               width: 100%;\n               overflow-y: auto;\n               flex: 1;\n           }\n\n           .q_slider_wrapper {\n               position: relative;\n               height: 20px;\n               overflow: hidden;\n               background-color: #333;\n           }\n\n           .q_slider_pos {\n               position: absolute;\n               top: 0;\n               left: 0;\n               width: 0;\n               height: 100%;\n               background-color: #1473e6;\n           }\n\n           .q_form_slider {\n               width: 100%;\n               opacity: 0;\n               height: 100%;\n               position: absolute;\n           }\n\n\n           .q_form_dropdown {\n               user-select: none;\n               position: relative;\n               background-color: #333;\n           }\n\n           .q_form_dropdown_options {\n               position: absolute;\n               width: 100%;\n               background-color: #333;\n               z-index: 1;\n           }\n\n           .q_form_dropdown_option,\n           .q_form_dropdown_selected {\n               padding: 5px 0px;\n           }\n\n           .q_form_button {\n               user-select: none;\n               padding: 5px 10px;\n               cursor: pointer;\n           }\n\n           .q_form_button:hover {\n               background-color: #555;\n           }\n\n           .q_form_button:active {\n               background-color: #777;\n           }\n\n           .q_form_file {\n               user-select: none;\n               position: relative;\n               overflow: hidden;\n           }\n\n           .q_form_file input[type=\"file\"] {\n               position: absolute;\n               width: 100%;\n               height: 100%;\n               opacity: 0;\n           }\n\n           .datepicker_wrapper {\n               user-select: none;\n               width: 100%;\n               height: 100%;\n               display: flex;\n               flex-direction: column;\n           }\n\n           .datepicker_header {\n               display: flex;\n               align-items: center;\n               color: #fff;\n               justify-content: center;\n           }\n\n           .datepicker_header div {\n               padding: 15px 5px;\n           }\n\n           .datepicker_weekdays {\n               display: grid;\n               grid-template-columns: repeat(7, 1fr);\n           }\n\n           .datepicker_weekdays div {\n               display: flex;\n               align-items: center;\n               justify-content: center;\n           }\n\n           .datepicker_days {\n               display: grid;\n               grid-template-columns: repeat(7, 1fr);\n               flex: 1;\n           }\n\n           .prev_month,\n           .next_month {\n               opacity: 0.5;\n           }\n\n           .datepicker_body {\n               display: flex;\n               flex-direction: column;\n               flex: 1;\n           }\n\n           .days {\n               cursor: default;\n               display: flex;\n               align-items: center;\n               justify-content: center;\n           }\n\n           .day_selected {\n               background-color: #1473e6;\n               color: #fff;\n           }\n\n           .datepicker_footer {\n               display: flex;\n               justify-content: flex-end;\n           }\n\n\n           .tag_container {\n                display: flex;\n                flex-wrap: wrap;\n}\n\n\n.tag_tag {\n    display: flex;\n    align-items: center;\n    border: 1px solid #333;\n    color: #fff;\noverflow: hidden;\n    margin: 2px;\n    border-radius: 5px;\n}\n\n        .tag_rating {\n    display: flex;\n    background-color: #333;\n    padding: 2px 5px;\n    align-items: center;\n            }\n\n            .tag_icon {\n                width: 10px;\n                height: 10px;\n                \n}\n\n.tag_icon_small {\n    width: 5px;\n    height: 5px;\n}\n\n.tag_name {\n    padding: 2px 8px;\n}\n\n.tag_value {\n    padding: 0 5px;\n    user-select: none;   \n}\n\n.tag_close {\n    cursor: pointer;\n    background-color: #333;\n    height: auto;\n    width: 20px;\n}\n\n.tag_input {\nwidth: content;\n    border: 0;\n    margin:0;\n    background-color: transparent;\n    color: #fff;\n}\n\n.tag_name[contenteditable=\"true\"] {\n    cursor: text;\n}\n\n.tag_name[contenteditable=\"true\"]:focus {\n    outline: 0;\n}\n\n    `, {\n        'q_form': 'q_form',\n        'q_form_disabled': 'q_form_disabled',\n        'q_form_checkbox': 'q_form_checkbox',\n        'q_form_radio': 'q_form_radio',\n        'q_form_cb': 'q_form_cb',\n        'q_form_r': 'q_form_r',\n        'q_form_input': 'q_form_input',\n        'q_form_textarea': 'q_form_textarea',\n        'q_window': 'q_window',\n        'q_window_titlebar': 'q_window_titlebar',\n        'q_window_buttons': 'q_window_buttons',\n        'q_window_button': 'q_window_button',\n        'q_window_titletext': 'q_window_titletext',\n        'q_window_content': 'q_window_content',\n        'q_slider_wrapper': 'q_slider_wrapper',\n        'q_slider_pos': 'q_slider_pos',\n        'q_form_slider': 'q_form_slider',\n        'q_form_dropdown': 'q_form_dropdown',\n        'q_form_dropdown_options': 'q_form_dropdown_options',\n        'q_form_dropdown_option': 'q_form_dropdown_option',\n        'q_form_dropdown_selected': 'q_form_dropdown_selected',\n        'q_form_button': 'q_form_button',\n        'q_form_progress_bar': 'q_form_progress_bar',\n        'q_form_file': 'q_form_file',\n        'q_form_progress': 'q_form_progress',\n        'q_form_dropdown_active': 'q_form_dropdown_active',\n        'q_window_close': 'q_window_close',\n        'q_window_minimize': 'q_window_minimize',\n        'q_window_maximize': 'q_window_maximize',\n\n        'tag_name': 'tag_name',\n        'tag_input': 'tag_input',\n        'tag_close': 'tag_close',\n        'tag_value': 'tag_value',\n        'tag_icon_small': 'tag_icon_small',\n        'tag_rating': 'tag_rating',\n        'tag_container': 'tag_container',\n        'tag_tag': 'tag_tag',\n        'tag_icon': 'tag_icon',\n        'tag_up': 'tag_up',\n        'tag_down': 'tag_down',\n    });\n\n    return {\n\n\n        Tag: function (options = {}) {\n            const defaultOptions = {\n                min: 0,\n                max: 10,\n                step: 1,\n                value: 0,\n                digit: 3,\n                flood: 500,\n                disabled: false,\n                removable: true,\n                votes: true,\n                readonly: false,\n                placeholder: ''\n            };\n        \n            \n            let { min, max, step, digit, votes, removable, flood } = { ...defaultOptions, ...options };\n        \n            if (step.toString().includes('.')) {\n                digit = step.toString().split('.')[1].length;\n            }\n        \n            let data = [];\n            let changeCallback = null; \n            const tagContainer = Q('<div>', { class: classes.tag_container });\n            const input = Q('<input>', { class: classes.tag_input });\n            const malformFix = Q('<input>', { class: classes.tag_input });\n            let ID = Q.ID(5, '_');\n        \n            \n        \n            \n            const changeTagValue = (tag, delta, currentValue) => {\n                let newValue = tag.value + delta;\n                newValue = Math.min(Math.max(newValue, min), max);\n                tag.value = parseFloat(newValue.toFixed(digit));\n                currentValue.text(tag.value);\n                data = data.map(t => (t.tag === tag.tag ? { ...t, value: tag.value } : t));\n        \n                \n                if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n            };\n        \n            const appendTags = tags => {\n                tags.forEach(tag => {\n                    const tagElement = Q('<div>', { class: classes.tag_tag });\n                    let tagValue = Q('<div>', { class: classes.tag_name }).text(tag.tag);\n        \n                    if (votes) {\n                        const tagRate = Q('<div>', { class: classes.tag_rating });\n                        const upvote = Q('<div>', { class: [classes.tag_icon, classes.tag_up] }).html(Icon('arrow-up'));\n                        const currentValue = Q('<div>', { class: classes.tag_value }).text(tag.value);\n                        const downvote = Q('<div>', { class: [classes.tag_icon, classes.tag_down] }).html(Icon('arrow-down'));\n        \n                        tagRate.append(downvote, currentValue, upvote);\n                        tagElement.append(tagRate);\n        \n                        upvote.on('click', () => changeTagValue(tag, step, currentValue));\n                        downvote.on('click', () => changeTagValue(tag, -step, currentValue));\n                    }\n        \n                    if (!defaultOptions.readonly) {\n                        tagValue.attr('contenteditable', true);\n        \n                        tagValue.on('input', function () {\n                            malformFix.val(tagValue.text());\n                            tagValue.text(malformFix.val());\n                            tag.tag = malformFix.val();\n        \n                            \n                            if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n                        });\n                    }\n        \n                    tagElement.append(tagValue);\n        \n                    if (removable) {\n                        const close = Q('<div>', { class: [classes.tag_icon_small, classes.tag_close] }).html(Icon('window-close'));\n                        close.on('click', () => {\n                            data = data.filter(t => t.tag !== tag.tag);\n                            tagElement.remove();\n        \n                            \n                            if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n                        });\n                        tagElement.append(close);\n                    }\n        \n                    tagContainer.append(tagElement);\n                });\n            };\n        \n            tagContainer.add = function (taglist) {\n                tagContainer.empty();\n        \n                if (!Array.isArray(taglist)) {\n                    taglist = [taglist];\n                }\n        \n                taglist = taglist.map(tag => (typeof tag === 'string' ? { tag, value: 0 } : tag));\n                data = [...data, ...taglist];\n        \n                appendTags(data);\n            };\n        \n            tagContainer.get = function () {\n                return data;\n            };\n        \n            \n            tagContainer.change = function (callback) {\n                changeCallback = callback;\n            };\n        \n            return tagContainer;\n        },\n\n\n\n        \n        DatePicker: function (value = '', locale = window.navigator.language, range = false) {\n\n            let getFirstDayOfWeek = () => {\n                \n                let startDate = new Date();\n                let dayOfWeek = startDate.getDay();\n                startDate.setDate(startDate.getDate() - dayOfWeek);\n\n                \n                return startDate.toLocaleDateString(locale, { weekday: 'short' });\n            };\n\n            let daysLocale = (short = true) => {\n                let days = [];\n                let baseDate = new Date(2021, 0, 4); \n                const options = { weekday: short ? 'short' : 'long' };\n\n                let firstDayOfWeek = getFirstDayOfWeek(); \n\n                \n                while (baseDate.toLocaleDateString(locale, options) !== firstDayOfWeek) {\n                    baseDate.setDate(baseDate.getDate() - 1);\n                }\n\n                for (let i = 0; i < 7; i++) {\n                    let date = new Date(baseDate);\n                    date.setDate(date.getDate() + i);\n                    days.push(date.toLocaleDateString(locale, options));\n                }\n                return days;\n            };\n\n            let monthsLocale = (short = true) => {\n                let months = [];\n                for (let i = 0; i < 12; i++) {\n                    let date = new Date(2021, i, 1);\n                    months.push(date.toLocaleDateString(locale, { month: short ? 'short' : 'long' }));\n                }\n                return months;\n            };\n\n            let date = value ? new Date(value) : new Date();\n            let day = date.getDate();\n            let month = date.getMonth() + 1;\n            let year = date.getFullYear();\n            let daysInMonth = new Date(year, month, 0).getDate();\n            let firstDay = new Date(year, month - 1, 1).getDay();\n            let lastDay = new Date(year, month - 1, daysInMonth).getDay();\n\n            \n            let days = daysLocale(true);\n            let dayNames = days.map((dayName, i) => {\n                let dayElement = Q('<div>');\n                dayElement.text(dayName);\n                return dayElement;\n            });\n\n            let wrapper = Q('<div class=\"datepicker_wrapper\">');\n            let header = Q('<div class=\"datepicker_header\">');\n            let body = Q('<div class=\"datepicker_body\">');\n            let footer = Q('<div class=\"datepicker_footer\">');\n            let weekdays = Q('<div class=\"datepicker_weekdays\">');\n            let days_wrapper = Q('<div class=\"datepicker_days\">');\n            let dateInput = Q('<input type=\"date\">');\n            let button_ok = this.Button('OK');\n            let button_today = this.Button('Today');\n            footer.append(button_today, button_ok);\n            body.append(weekdays, days_wrapper);\n            wrapper.append(header, body, footer);\n\n            \n            \n            let container_months = Q('<div>');\n            let container_years = Q('<div>');\n\n            header.append(container_months, container_years);\n\n            if (wrapper.inside(classes.q_window)) {\n                let button_cancel = this.Button('Cancel');\n                footer.append(button_cancel);\n                button_cancel.click(function () {\n                    wrapper.closest('.' + classes.q_window).hide(200);\n                });\n            }\n\n            container_months.on('click', function () {\n\n\n\n            });\n\n            button_today.click(function () {\n                date = new Date();\n                day = date.getDate();\n                month = date.getMonth() + 1;\n                year = date.getFullYear();\n                daysInMonth = new Date(year, month, 0).getDate();\n                firstDay = new Date(year, month - 1, 1).getDay();\n                lastDay = new Date(year, month - 1, daysInMonth).getDay();\n                populateDays(month, year, day);\n                populateHeader(month, year, day);\n            });\n\n            const populateHeader = function (month, year, day) {\n                \n                \n                let months = monthsLocale(false);\n\n                \n                \n                container_months.text(months[month - 1]);\n                container_years.text(year);\n            }\n\n            let populateDays = function (month, year, day) {\n                days_wrapper.empty();\n\n                \n                let daysInPrevMonth = new Date(year, month - 1, 0).getDate();\n                let prevMonthDays = [];\n                for (let i = daysInPrevMonth - firstDay + 1; i <= daysInPrevMonth; i++) {\n                    let dayElement = Q('<div>');\n                    dayElement.text(i);\n                    dayElement.addClass('days prev_month');\n                    prevMonthDays.push(dayElement);\n                }\n\n                let currentMonthDays = [];\n                for (let i = 1; i <= daysInMonth; i++) {\n                    let dayElement = Q('<div>');\n                    dayElement.text(i);\n                    dayElement.addClass('days current_month');\n                    if (i === day) {\n                        dayElement.addClass('day_selected');\n                    }\n                    currentMonthDays.push(dayElement);\n                }\n\n                let nextMonthDays = [];\n                for (let i = 1; i <= 7 - lastDay; i++) {\n                    let dayElement = Q('<div>');\n                    dayElement.text(i);\n                    dayElement.addClass('days next_month');\n                    nextMonthDays.push(dayElement);\n                }\n\n                days_wrapper.append(...prevMonthDays, ...currentMonthDays, ...nextMonthDays);\n            };\n\n            weekdays.append(...dayNames);\n\n            populateDays(month, year, day);\n\n            populateHeader(month, year, day);\n\n            days_wrapper.on('click', function (e) {\n                let target = Q(e.target);\n                if (target.hasClass('days')) {\n                    let day = parseInt(target.text());\n\n                    if (target.hasClass('prev_month')) {\n                        if (month === 1) {\n                            month = 12;\n                            year--;\n                        } else {\n                            month--;\n                        }\n                    } else if (target.hasClass('next_month')) {\n                        if (month === 12) {\n                            month = 1;\n                            year++;\n                        } else {\n                            month++;\n                        }\n                    }\n\n                    date = new Date(year, month - 1, day);\n                    populateDays(month, year, day);\n                    populateHeader(month, year, day);\n                }\n            });\n\n            return wrapper;\n        },\n\n        \n        ProgressBar: function (value = 0, min = 0, max = 100, autoKill = 0) {\n            let timer = null;\n            const progress = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_progress + '\">');\n            const bar = Q('<div class=\"' + classes.q_form_progress_bar + '\">');\n            progress.append(bar);\n\n            function clearAutoKillTimer() {\n                if (timer) {\n                    clearTimeout(timer);\n                    timer = null;\n                }\n            }\n\n            function setAutoKillTimer() {\n                if (autoKill > 0) {\n                    clearAutoKillTimer();\n                    timer = setTimeout(() => {\n                        progress.hide();\n                    }, autoKill);\n                }\n            }\n\n            progress.value = function (value) {\n                const range = max - min;\n                const newWidth = ((value - min) / range) * 100 + '%';\n                if (bar.css('width') !== newWidth) {\n                    bar.css({ width: newWidth });\n                }\n                progress.show();\n                clearAutoKillTimer();\n                setAutoKillTimer();\n            };\n\n            progress.min = function (value) {\n                min = value;\n                progress.value(value);\n            };\n\n            progress.max = function (value) {\n                max = value;\n                progress.value(value);\n            };\n\n            progress.autoKill = function (delay) {\n                autoKill = delay;\n                setAutoKillTimer();\n            };\n\n            progress.value(value);\n\n            return progress;\n        },\n\n        \n        Button: function (text = '') {\n            const button = Q(`<div class=\"${classes.q_form} ${classes.q_form_button}\">${text}</div>`);\n\n            button.click = function (callback) {\n                button.on('click', callback);\n            };\n\n            button.disabled = function (state) {\n                if (state) {\n                    button.addClass(classes.q_form_disabled);\n                }\n                else {\n                    button.removeClass(classes.q_form_disabled);\n                }\n            };\n\n            button.text = function (text) {\n                button.text(text);\n            };\n\n            button.remove = function () {\n                button.remove();\n            };\n\n            return button;\n        },\n\n        \n        File: function (text = '', accept = '*', multiple = false) {\n            const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_file + ' ' + classes.q_form_button + '\">');\n            const input = Q(`<input type=\"file\" accept=\"${accept}\" ${multiple ? 'multiple' : ''}>`);\n            const label = Q(`<div>${text}</div>`);\n            container.append(input, label);\n\n            input.disabled = function (state) {\n                input.prop('disabled', state);\n                if (state) {\n                    container.addClass(classes.q_form_disabled);\n                } else {\n                    container.removeClass(classes.q_form_disabled);\n                }\n            };\n\n            container.change = function (callback) {\n                input.on('change', function () {\n                    callback(this.files);\n                });\n            };\n\n            container.image = function (processText = '', size, callback) {\n                input.on('change', function () {\n                    label.text(processText);\n                    let files = this.files;\n                    let fileReaders = [];\n                    let images = [];\n\n                    for (let i = 0; i < files.length; i++) {\n                        if (!files[i].type.startsWith('image/')) {\n                            continue;\n                        }\n\n                        fileReaders[i] = new FileReader();\n                        fileReaders[i].onload = function (e) {\n                            let img = new Image();\n                            img.onload = function () {\n                                if (size !== 'original') {\n                                    let canvas = document.createElement('canvas');\n                                    let ctx = canvas.getContext('2d');\n                                    let width = size;\n                                    let height = (img.height / img.width) * width;\n                                    canvas.width = width;\n                                    canvas.height = height;\n                                    ctx.drawImage(img, 0, 0, width, height);\n                                    images.push(canvas.toDataURL('image/png'));\n                                } else {\n                                    images.push(e.target.result);\n                                }\n                                if (images.length === files.length) {\n                                    label.text(text);\n                                    callback(images);\n                                }\n                            };\n                            img.src = e.target.result;\n                        };\n                        fileReaders[i].readAsDataURL(files[i]);\n                    }\n                });\n            };\n\n            return container;\n        },\n\n\n        DropDown: function (data) {\n            let wrapper = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_dropdown + '\">');\n            let selected = Q('<div class=\"' + classes.q_form_dropdown_selected + '\">');\n            let options = Q('<div class=\"' + classes.q_form_dropdown_options + '\">');\n\n            options.hide();\n            wrapper.append(selected, options);\n\n\n            let valueMap = new Map();\n\n            data.forEach((item, index) => {\n                let option = Q('<div class=\"' + classes.q_form_dropdown_option + '\">');\n                option.html(item.content);\n                if (item.disabled) {\n                    option.addClass(classes.q_form_disabled);\n                }\n                options.append(option);\n                valueMap.set(option, item.value);\n            });\n\n\n            selected.html(data[0].content);\n            let selectedValue = data[0].value;\n\n            function deselect() {\n                options.hide();\n                document.removeEventListener('click', deselect);\n            }\n            options.find('.' + classes.q_form_dropdown_option).first().addClass(classes.q_form_dropdown_active);\n\n            options.on('click', function (e) {\n                let target = Q(e.target);\n                if (target.hasClass(classes.q_form_dropdown_option) && !target.hasClass(classes.q_form_disabled)) {\n                    selected.html(target.html());\n                    selectedValue = valueMap.get(target);\n                    deselect();\n                    options.find('.' + classes.q_form_dropdown_option).removeClass(classes.q_form_dropdown_active);\n                    target.addClass(classes.q_form_dropdown_active);\n                }\n            });\n\n            selected.on('click', function (e) {\n                e.stopPropagation();\n                options.toggle();\n                if (options.is(':visible')) {\n                    document.addEventListener('click', deselect);\n                } else {\n                    document.removeEventListener('click', deselect);\n                }\n            });\n\n            wrapper.change = function (callback) {\n                options.on('click', function (e) {\n                    let target = Q(e.target);\n                    if (target.hasClass(classes.q_form_dropdown_option) && !target.hasClass(classes.q_form_disabled)) {\n                        callback(valueMap.get(target));\n                    }\n                });\n            };\n\n            wrapper.select = function (value) {\n                options.find('.' + classes.q_form_dropdown_option).each(function () {\n                    let option = Q(this);\n                    if (valueMap.get(option) === value) {\n                        selected.html(option.html());\n                        selectedValue = value;\n                        deselect();\n                        options.find('.' + classes.q_form_dropdown_option).removeClass(classes.q_form_dropdown_active);\n                        option.addClass(classes.q_form_dropdown_active);\n                    }\n                });\n            };\n\n            wrapper.disabled = function (value, state) {\n                options.find('.' + classes.q_form_dropdown_option).each(function () {\n                    let option = Q(this);\n                    if (valueMap.get(option) === value) {\n                        option.prop('disabled', state);\n                        if (state) {\n                            option.addClass(classes.q_form_disabled);\n                        } else {\n                            option.removeClass(classes.q_form_disabled);\n                        }\n                    }\n                });\n            };\n\n            wrapper.remove = function (value) {\n                options.find('.' + classes.q_form_dropdown_option).each(function () {\n                    let option = Q(this);\n                    if (valueMap.get(option) === value) {\n                        option.remove();\n                        valueMap.delete(option);\n                    }\n                });\n            };\n\n            wrapper.value = function () {\n                return selectedValue;\n            };\n\n            return wrapper;\n        },\n\n\n        Slider: function (min = 0, max = 100, value = 50) {\n            const slider = Q('<input type=\"range\" class=\"' + classes.q_form_slider + '\">');\n            slider.attr('min', min);\n            slider.attr('max', max);\n            slider.attr('value', value);\n\n            let slider_wrapper = Q('<div class=\"' + classes.q_form + ' ' + classes.q_slider_wrapper + '\">');\n            let slider_value = Q('<div class=\"' + classes.q_slider_pos + '\">');\n            slider_wrapper.append(slider_value, slider);\n\n            const slider_width = () => {\n                let percent = (slider.val() - slider.attr('min')) / (slider.attr('max') - slider.attr('min')) * 100;\n                slider_value.css({\n                    width: percent + '%'\n                });\n            };\n\n            slider.on('input', function () {\n                slider_width();\n            });\n\n            slider_width();\n\n            slider_wrapper.change = function (callback) {\n                slider.on('input', function () {\n                    callback(this.value);\n                });\n            };\n\n            slider_wrapper.value = function (value) {\n                if (value !== undefined) {\n                    slider.val(value);\n                    slider.trigger('input');\n                }\n                return slider.val();\n            };\n\n            slider_wrapper.disabled = function (state) {\n                slider.prop('disabled', state);\n                if (state) {\n                    slider_wrapper.addClass(classes.q_form_disabled);\n                } else {\n                    slider_wrapper.removeClass(classes.q_form_disabled);\n                }\n\n            };\n            slider_wrapper.min = function (value) {\n                if (value !== undefined) {\n                    slider.attr('min', value);\n                    slider.trigger('input');\n                }\n                return slider.attr('min');\n            };\n            slider_wrapper.max = function (value) {\n                if (value !== undefined) {\n                    slider.attr('max', value);\n                    slider.trigger('input');\n                }\n                return slider.attr('max');\n            };\n            slider_wrapper.remove = function () {\n                slider_wrapper.remove();\n            };\n            return slider_wrapper;\n        },\n\n        \n        Window: function (title = '', data, width = 300, height = 300, x = 100, y = 10) {\n\n            let dimensions = { width, height, x, y };\n            let minimized = false;\n            let maximized = false;\n            let animation_speed = 200;\n\n            let window_wrapper = Q('<div class=\"' + classes.q_window + '\">');\n            let titlebar = Q('<div class=\"' + classes.q_window_titlebar + '\">');\n            let titletext = Q('<div class=\"' + classes.q_window_titletext + '\">');\n            let uniqueButtons = Q('<div class=\"' + classes.q_window_unique_buttons + '\">');\n            let default_buttons = Q('<div class=\"' + classes.q_window_buttons + '\">');\n            let content = Q('<div class=\"' + classes.q_window_content + '\">');\n            let close = Q('<div class=\"' + classes.q_window_button + ' ' + classes.q_window_close + '\">');\n            let minimize = Q('<div class=\"' + classes.q_window_button + ' ' + classes.q_window_minimize + '\">');\n            let maximize = Q('<div class=\"' + classes.q_window_button + ' ' + classes.q_window_maximize + '\">');\n\n            close.append(Icon('window-close'));\n            minimize.html(Icon('window-minimize'));\n            maximize.html(Icon('window-full'));\n\n            content.append(data);\n            titletext.text(title);\n            titletext.attr('title', title);\n\n            titlebar.append(titletext, uniqueButtons, default_buttons);\n            default_buttons.append(minimize, maximize, close);\n            window_wrapper.append(titlebar, content);\n\n\n\n            dimensions.width = dimensions.width > window_wrapper.parent().width() ? window_wrapper.parent().width() : dimensions.width;\n            dimensions.height = dimensions.height > window_wrapper.parent().height() ? window_wrapper.parent().height() : dimensions.height;\n            dimensions.x = dimensions.x + dimensions.width > window_wrapper.parent().width() ? window_wrapper.parent().width() - dimensions.width : dimensions.x;\n            dimensions.y = dimensions.y + dimensions.height > window_wrapper.parent().height() ? window_wrapper.parent().height() - dimensions.height : dimensions.y;\n\n            window_wrapper.css({\n                width: dimensions.width + 'px',\n                height: dimensions.height + 'px',\n                left: dimensions.x + 'px',\n                top: dimensions.y + 'px'\n            });\n\n            function debounce(func, wait) {\n                let timeout;\n                return function (...args) {\n                    clearTimeout(timeout);\n                    timeout = setTimeout(() => func.apply(this, args), wait);\n                };\n            }\n\n            function handleResize() {\n                const browserWidth = window.innerWidth;\n                const browserHeight = window.innerHeight;\n\n                const { left: currentX, top: currentY } = window_wrapper.position();\n                let { width: currentWidth, height: currentHeight } = window_wrapper.size();\n\n                currentWidth = Math.min(currentWidth, browserWidth);\n                currentHeight = Math.min(currentHeight, browserHeight);\n                const newX = Math.min(currentX, browserWidth - currentWidth);\n                const newY = Math.min(currentY, browserHeight - currentHeight);\n\n                window_wrapper.css({\n                    width: `${currentWidth}px`,\n                    height: `${currentHeight}px`,\n                    left: `${newX}px`,\n                    top: `${newY}px`\n                });\n            }\n\n            window.addEventListener('resize', debounce(handleResize, 300));\n\n            close.on('click', function () {\n\n                window_wrapper.animate(200, {\n                    opacity: 0,\n                    transform: 'scale(0.8)'\n                }, function () {\n                    window_wrapper.hide();\n                });\n\n            });\n\n            minimize.on('click', function () {\n                content.toggle();\n\n                if (maximized) {\n                    maximized = false;\n                    maximize.html(Icon('window-full'));\n                    window_wrapper.animate(animation_speed, {\n                        width: dimensions.width + 'px',\n                        height: dimensions.height + 'px',\n                        left: dimensions.x + 'px',\n                        top: dimensions.y + 'px'\n                    }, function () {\n                        window_wrapper.removeTransition();\n                    });\n                }\n\n                if (minimized) {\n                    minimize.html(Icon('window-minimize'));\n                    window_wrapper.css({\n                        height: dimensions.height + 'px'\n                    });\n                    minimized = false;\n                    handleResize();\n\n                } else {\n                    minimize.html(Icon('window-windowed'));\n                    window_wrapper.css({\n                        height: titlebar.height() + 'px'\n                    });\n                    minimized = true;\n                }\n            });\n\n            maximize.on('click', function () {\n\n                if (minimized) {\n                    minimize.html(Icon('window-minimize'));\n                    minimized = false;\n                    if (!content.is(':visible')) {\n                        content.toggle();\n                    }\n                }\n\n                if (maximized) {\n                    maximized = false;\n                    maximize.html(Icon('window-full'));\n                    window_wrapper.animate(animation_speed, {\n                        width: dimensions.width + 'px',\n                        height: dimensions.height + 'px',\n                        left: dimensions.x + 'px',\n                        top: dimensions.y + 'px'\n                    }, function () {\n                        window_wrapper.removeTransition();\n                        handleResize();\n                    });\n\n                } else {\n                    maximized = true;\n                    maximize.html(Icon('window-windowed'));\n                    window_wrapper.animate(animation_speed, {\n                        width: '100%',\n                        height: '100%',\n                        left: 0,\n                        top: 0,\n                        borderRadius: 0\n                    }, function () {\n                        window_wrapper.removeTransition();\n                    });\n                }\n            });\n\n            const zindex = () => {\n                let highestZIndex = 0;\n                Q('.q_window').each(function () {\n                    let zIndex = parseInt(Q(this).css('z-index'));\n                    if (zIndex > highestZIndex) {\n                        highestZIndex = zIndex;\n                    }\n                });\n                return highestZIndex + 1;\n\n            };\n\n\n            titlebar.on('pointerdown', function (e) {\n                let offset = window_wrapper.position();\n                let x = e.clientX - offset.left;\n                let y = e.clientY - offset.top;\n\n                window_wrapper.css({\n                    'z-index': zindex()\n                });\n\n\n                const pointerMoveHandler = function (e) {\n\n                    let left = e.clientX - x;\n                    let top = e.clientY - y;\n\n\n                    left = Math.max(0, left);\n                    top = Math.max(0, top);\n\n                    let currentWidth = window_wrapper.width();\n                    let currentHeight = window_wrapper.height();\n\n\n                    left = Math.min(window.innerWidth - currentWidth, left);\n                    top = Math.min(window.innerHeight - currentHeight, top);\n\n                    dimensions.x = left;\n                    dimensions.y = top;\n\n                    window_wrapper.css({\n                        left: dimensions.x + 'px',\n                        top: dimensions.y + 'px'\n                    });\n\n                };\n\n                const pointerUpHandler = function () {\n                    Q(document).off('pointermove', pointerMoveHandler);\n                    Q(document).off('pointerup', pointerUpHandler);\n                };\n\n                Q(document).on('pointermove', pointerMoveHandler);\n                Q(document).on('pointerup', pointerUpHandler);\n            });\n\n            window_wrapper.show = function () {\n                if (window_wrapper.isExists()) {\n                    window_wrapper.fadeIn(200);\n                }\n                else {\n                    Q('body').append(window_wrapper);\n                }\n            };\n\n            window_wrapper.hide = function () {\n                window_wrapper.fadeOut(200);\n            };\n\n            window_wrapper.title = function (newTitle) {\n                if (newTitle !== undefined) {\n                    titletext.text(newTitle);\n                }\n                return titletext.text();\n            };\n\n            window_wrapper.content = function (newContent) {\n                if (newContent !== undefined) {\n                    content.html(newContent);\n                }\n            };\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            window_wrapper.close = function () {\n                close.click();\n            };\n\n            window_wrapper.minimize = function () {\n                minimize.click();\n            };\n\n            window_wrapper.maximize = function () {\n                maximize.click();\n            };\n\n            window_wrapper.remove = function () {\n                window_wrapper.remove();\n            };\n\n            return window_wrapper;\n        },\n\n        CheckBox: function (checked = false, text = '') {\n            let ID = '_' + Q.ID();\n            const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_checkbox + '\">');\n            const checkbox_container = Q('<div class=\"' + classes.q_form_cb + '\">');\n            const input = Q(`<input type=\"checkbox\" id=\"${ID}\">`);\n            const label = Q(`<label for=\"${ID}\">${text}</label>`);\n            const labeltext = Q(`<div class=\"label\">${text}</div>`);\n            checkbox_container.append(input, label);\n            container.append(checkbox_container, labeltext);\n\n            container.checked = function (state) {\n                input.prop('checked', state);\n                if (state) {\n                    input.trigger('change');\n                }\n            };\n\n            container.change = function (callback) {\n                input.on('change', function () {\n                    callback(this.checked);\n                });\n            };\n\n            container.disabled = function (state) {\n                input.prop('disabled', state);\n                if (state) {\n                    container.addClass(classes.q_form_disabled);\n                } else {\n                    container.removeClass(classes.q_form_disabled);\n                }\n            };\n\n            container.text = function (text) {\n                labeltext.text(text);\n            };\n\n            return container;\n\n        },\n\n        TextBox: function (type = 'text', value = '', placeholder = '') {\n            const input = Q(`<input class=\"${classes.q_form} ${classes.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n\n            input.placeholder = function (text) {\n                input.attr('placeholder', text);\n            };\n            input.disabled = function (state) {\n                input.prop('disabled', state);\n\n                if (state) {\n                    input.addClass(classes.q_form_disabled);\n                } else {\n                    input.removeClass(classes.q_form_disabled);\n                }\n            };\n            input.reset = function () {\n                input.val('');\n            };\n            input.change = function (callback) {\n                input.on('change', function () {\n                    callback(this.value);\n                });\n            };\n\n            return input;\n        },\n\n        TextArea: function (value = '', placeholder = '') {\n            const textarea = Q(`<textarea class=\"${classes.q_form} ${classes.q_form_textarea}\" placeholder=\"${placeholder}\">${value}</textarea>`);\n\n            textarea.placeholder = function (text) {\n                textarea.attr('placeholder', text);\n            };\n            textarea.disabled = function (state) {\n                textarea.prop('disabled', state);\n                if (state) {\n                    textarea.addClass(classes.q_form_disabled);\n                } else {\n                    textarea.removeClass(classes.q_form_disabled);\n                }\n            };\n            textarea.reset = function () {\n                textarea.val('');\n            };\n            textarea.change = function (callback) {\n                textarea.on('change', function () {\n                    callback(this.value);\n                });\n            };\n            return textarea;\n        },\n        Radio: function (data) {\n            let wrapper = Q('<div class=\"q_form q_form_radio_wrapper\">');\n            let radios = [];\n\n            data.forEach((item, index) => {\n                let ID = '_' + Q.ID();\n                const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_radio + '\">');\n                const radio_container = Q('<div class=\"' + classes.q_form_r + '\">');\n                const input = Q(`<input type=\"radio\" id=\"${ID}\" name=\"${item.name}\" value=\"${item.value}\">`);\n                const label = Q(`<label for=\"${ID}\"></label>`);\n                const labeltext = Q(`<div class=\"label\">${item.text}</div>`);\n\n                if (item.disabled) {\n                    input.prop('disabled', true);\n                    container.addClass(classes.q_form_disabled);\n                }\n\n                radios.push({ container, input, labeltext });\n\n                radio_container.append(input, label);\n                container.append(radio_container, labeltext);\n                wrapper.append(container);\n            });\n\n            wrapper.change = function (callback) {\n                radios.forEach(radio => {\n                    radio.input.on('change', function () {\n                        if (this.checked) {\n                            callback(this.value);\n                        }\n                    });\n                });\n            };\n            wrapper.select = function (value) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.input.prop('checked', true).trigger('click');\n                    }\n                });\n            };\n            wrapper.disabled = function (value, state) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.input.prop('disabled', state);\n\n                        if (state) {\n                            radio.container.addClass(classes.q_form_disabled);\n                        } else {\n                            radio.container.removeClass(classes.q_form_disabled);\n                        }\n                    }\n                });\n            };\n            wrapper.text = function (value, text) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.labeltext.text(text);\n                    }\n                });\n            };\n            wrapper.remove = function (value) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.container.remove();\n                    }\n                });\n            };\n            wrapper.reset = function () {\n                radios.forEach(radio => radio.input.prop('checked', false));\n            };\n            wrapper.checked = function (value, state) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.input.prop('checked', state);\n                    }\n                });\n            };\n            return wrapper;\n        }\n    };\n\n};"
    },
    "Icons": {
        "Name": "Icons",
        "Method": "Plugin",
        "Desc": "Additional icons for the VulpiniQ library.",
        "variant": "plugin",
        "Dependencies": [
            "Style"
        ],
        "Type": "Plugin",
        "Example": "Q.Icons();",
        "Script": "Q.Icons = function (data, classes) {\n    let classes = Q.style(`\n:root {\n    --svg_arrow-down: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_arrow-left: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_arrow-right: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_arrow-up: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_window-close: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_window-full: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_window-minimize: url('data:image/svg+xml,<svg xmlns=\"http:\n    --svg_window-windowed: url('data:image/svg+xml,<svg xmlns=\"http:\n}\n.svg_window-close {\n    -webkit-mask: var(--svg_window-close) no-repeat center;\n    mask: var(--svg_window-close) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_window-full {\n    -webkit-mask: var(--svg_window-full) no-repeat center;\n    mask: var(--svg_window-full) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_window-minimize {\n    -webkit-mask: var(--svg_window-minimize) no-repeat center;\n    mask: var(--svg_window-minimize) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_window-windowed {\n    -webkit-mask: var(--svg_window-windowed) no-repeat center;\n    mask: var(--svg_window-windowed) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_arrow-down {\n    -webkit-mask: var(--svg_arrow-down) no-repeat center;\n    mask: var(--svg_arrow-down) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_arrow-left {\n    -webkit-mask: var(--svg_arrow-left) no-repeat center;\n    mask: var(--svg_arrow-left) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_arrow-right {\n    -webkit-mask: var(--svg_arrow-right) no-repeat center;\n    mask: var(--svg_arrow-right) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n.svg_arrow-up {\n    -webkit-mask: var(--svg_arrow-up) no-repeat center;\n    mask: var(--svg_arrow-up) no-repeat center;\n    background-color: currentColor;\n    -webkit-mask-size: contain;\n    mask-size: contain;\n}\n     `, {});\n};"
    },
    "Image": {
        "Name": "Image",
        "Method": "Plugin",
        "Desc": "Useful to manipulate images.",
        "variant": "plugin",
        "Dependencies": [
            "RGB2HSL",
            "HSL2RGB"
        ],
        "Type": "Plugin",
        "Example": "var image = Q.Image();",
        "Script": "Q.Image = function (options) {\n    let Canvas = Q('<canvas>')\n    let canvas_node = Canvas.nodes[0];\n\n    let defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        size: 'auto',\n        quality: 1\n    }\n\n    options = Object.assign(defaultOptions, options);\n\n\n    Canvas.Load = function (src, callback) {\n        \n        let img = new Image();\n        img.src = src;\n        img.onload = function () {\n            canvas_node.width = img.width;\n            canvas_node.height = img.height;\n            canvas_node.getContext('2d').drawImage(img, 0, 0);\n            if (callback) callback();\n        };\n    }\n\n    Canvas.Get = function (format = options.format, quality = options.quality) {\n        if (format === 'jpeg' || format === 'webp') {\n            return canvas_node.toDataURL('image/' + format, quality);\n        } else {\n            return canvas_node.toDataURL('image/' + format);\n        }\n    }\n\n    Canvas.Save = function (filename, format = options.format, quality = options.quality) {\n        let href = Canvas.Get(format, quality);\n        let a = Q('<a>', { download: filename, href: href });\n        a.click();\n    }\n\n    Canvas.Clear = function (fill = options.fill) {\n        let ctx = canvas_node.getContext('2d');\n        ctx.fillStyle = fill;\n        ctx.fillRect(0, 0, canvas_node.width, canvas_node.height);\n    }\n\n    Canvas.Resize = function (width, height, size = options.size, keepDimensions = false) {\n        options.width = width;\n        options.height = height;\n        options.size = size;\n\n        console.log(keepDimensions);\n\n        let temp = Q('<canvas>', { width: width, height: height }).nodes[0];\n        let ctx = temp.getContext('2d');\n        let ratio = 1;\n\n        let canvasWidth = canvas_node.width;\n        let canvasHeight = canvas_node.height;\n\n        if (size === 'contain') {\n            if (keepDimensions) {\n                \n                let widthRatio = width / canvasWidth;\n                let heightRatio = height / canvasHeight;\n                ratio = Math.min(widthRatio, heightRatio);\n\n                \n                let newWidth = canvasWidth * ratio;\n                let newHeight = canvasHeight * ratio;\n                let xOffset = (width - newWidth) / 2;\n                let yOffset = (height - newHeight) / 2;\n\n                \n                ctx.fillStyle = options.fill;\n                ctx.fillRect(0, 0, width, height);\n                ctx.drawImage(canvas_node, xOffset, yOffset, newWidth, newHeight);\n            } else {\n                \n                let widthRatio = width / canvasWidth;\n                let heightRatio = height / canvasHeight;\n                ratio = Math.min(widthRatio, heightRatio);\n                let newWidth = canvasWidth * ratio;\n                let newHeight = canvasHeight * ratio;\n                ctx.imageSmoothingEnabled = true;\n                ctx.imageSmoothingQuality = 'high';\n                ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n            }\n        } else if (size === 'cover') {\n            \n            let widthRatio = width / canvasWidth;\n            let heightRatio = height / canvasHeight;\n            ratio = Math.max(widthRatio, heightRatio);\n\n            let newWidth = canvasWidth * ratio;\n            let newHeight = canvasHeight * ratio;\n\n            let xOffset = (newWidth - width) / 2;\n            let yOffset = (newHeight - height) / 2;\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = 'high';\n            ctx.drawImage(canvas_node, -xOffset, -yOffset, newWidth, newHeight);\n        } else if (size === 'auto') {\n            ratio = Math.min(width / canvasWidth, height / canvasHeight);\n            let newWidth = canvasWidth * ratio;\n            let newHeight = canvasHeight * ratio;\n\n            ctx.fillStyle = options.fill;\n            ctx.fillRect(0, 0, width, height);\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = 'high';\n            ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n        }\n\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n\n    \n    \n    \n    \n\n    \n\n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n    Canvas.Crop = function (x, y, width, height) {\n        let temp = Q('<canvas>', { width: width, height: height });\n        temp.getContext('2d').drawImage(canvas_node, x, y, width, height, 0, 0, width, height);\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n\n    Canvas.Rotate = function (degrees) {\n        let temp = Q('<canvas>', { width: canvas_node.height, height: canvas_node.width });\n        let ctx = temp.getContext('2d');\n        ctx.translate(canvas_node.height / 2, canvas_node.width / 2);\n        ctx.rotate(degrees * Math.PI / 180);\n        ctx.drawImage(canvas_node, -canvas_node.width / 2, -canvas_node.height / 2);\n        canvas_node.width = temp.width;\n        canvas_node.height = temp.height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n\n    Canvas.Flip = function (direction = 'horizontal') \n    {\n        let temp = Q('<canvas>', { width: canvas_node.width, height: canvas_node.height });\n        let ctx = temp.getContext('2d');\n        ctx.translate(canvas_node.width, 0);\n        ctx.scale(direction == 'horizontal' ? -1 : 1, direction == 'vertical' ? -1 : 1);\n        ctx.drawImage(canvas_node, 0, 0);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n\n    Canvas.Grayscale = function () {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;\n            pixels[i] = avg;\n            pixels[i + 1] = avg;\n            pixels[i + 2] = avg;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n\n    Canvas.Brightness = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] += value;\n            pixels[i + 1] += value;\n            pixels[i + 2] += value;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n\n    Canvas.Contrast = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let factor = (259 * (value + 255)) / (255 * (259 - value));\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = factor * (pixels[i] - 128) + 128;\n            pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n            pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n\n    Canvas.Vivid = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = Math.min(255, pixels[i] * value);\n            pixels[i + 1] = Math.min(255, pixels[i + 1] * value);\n            pixels[i + 2] = Math.min(255, pixels[i + 2] * value);\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n\n    Canvas.Hue = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let r = pixels[i];\n            let g = pixels[i + 1];\n            let b = pixels[i + 2];\n            let hsl = Q.RGB2HSL(r, g, b);\n            hsl[0] += value;\n            let rgb = Q.HSL2RGB(hsl[0], hsl[1], hsl[2]);\n            pixels[i] = rgb[0];\n            pixels[i + 1] = rgb[1];\n            pixels[i + 2] = rgb[2];\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n\n    Canvas.Sharpen = function (options) {\n        let defaults = {\n            amount: 1,\n            threshold: 0,\n            radius: 1,\n            quality: 1\n        };\n\n        options = Object.assign(defaults, options);\n\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n\n        let weights = [-1, -1, -1, -1, 9, -1, -1, -1, -1];\n        let katet = Math.round(Math.sqrt(weights.length));\n        let half = Math.floor(katet / 2);\n\n        let divisor = weights.reduce((sum, weight) => sum + weight, 0) || 1;\n        let offset = 0;\n        let dataCopy = new Uint8ClampedArray(pixels);\n\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n\n        let iterations = Math.round(options.quality);\n        let iteration = 0;\n\n        while (iteration < iterations) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n\n                    let dstOff = (y * width + x) * 4;\n\n                    for (let cy = 0; cy < katet; cy++) {\n                        for (let cx = 0; cx < katet; cx++) {\n                            let scy = y + cy - half;\n                            let scx = x + cx - half;\n\n                            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                                let srcOff = (scy * width + scx) * 4;\n                                let wt = weights[cy * katet + cx];\n\n                                r += dataCopy[srcOff] * wt;\n                                g += dataCopy[srcOff + 1] * wt;\n                                b += dataCopy[srcOff + 2] * wt;\n                            }\n                        }\n                    }\n\n                    r = Math.min(Math.max((r / divisor) + offset, 0), 255);\n                    g = Math.min(Math.max((g / divisor) + offset, 0), 255);\n                    b = Math.min(Math.max((b / divisor) + offset, 0), 255);\n                    if (Math.abs(dataCopy[dstOff] - r) > options.threshold) {\n                        pixels[dstOff] = r;\n                        pixels[dstOff + 1] = g;\n                        pixels[dstOff + 2] = b;\n                    }\n                }\n            }\n            iteration++;\n        }\n        ctx.putImageData(data, 0, 0);\n    }\n\n    Canvas.Emboss = function (options) {\n        let defaults = {\n            strength: 1,       \n            direction: 'top-left',  \n            blend: true,       \n            grayscale: true    \n        };\n\n        \n        options = Object.assign(defaults, options);\n\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n\n        \n        let dataCopy = new Uint8ClampedArray(pixels);\n\n        \n        let kernels = {\n            'top-left': [-2, -1, 0, -1, 1, 1, 0, 1, 2],\n            'top-right': [0, -1, -2, 1, 1, -1, 2, 1, 0],\n            'bottom-left': [0, 1, 2, -1, 1, 1, -2, -1, 0],\n            'bottom-right': [2, 1, 0, 1, 1, -1, 0, -1, -2]\n        };\n\n        \n        let kernel = kernels[options.direction] || kernels['top-left'];\n        let katet = Math.sqrt(kernel.length);  \n        let half = Math.floor(katet / 2);\n\n        let strength = options.strength;\n        let divisor = 1;  \n        let offset = 128; \n\n        \n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0;\n                let dstOff = (y * width + x) * 4;  \n\n                \n                for (let cy = 0; cy < katet; cy++) {\n                    for (let cx = 0; cx < katet; cx++) {\n                        let scy = y + cy - half;\n                        let scx = x + cx - half;\n\n                        \n                        if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                            let srcOff = (scy * width + scx) * 4;  \n                            let wt = kernel[cy * katet + cx];  \n\n                            r += dataCopy[srcOff] * wt;\n                            g += dataCopy[srcOff + 1] * wt;\n                            b += dataCopy[srcOff + 2] * wt;\n                        }\n                    }\n                }\n\n                \n                r = (r / divisor) * strength + offset;\n                g = (g / divisor) * strength + offset;\n                b = (b / divisor) * strength + offset;\n\n                \n                if (options.grayscale) {\n                    let avg = (r + g + b) / 3;\n                    r = g = b = avg;\n                }\n\n                \n                r = Math.min(Math.max(r, 0), 255);\n                g = Math.min(Math.max(g, 0), 255);\n                b = Math.min(Math.max(b, 0), 255);\n\n                \n                if (options.blend) {\n                    pixels[dstOff] = (pixels[dstOff] + r) / 2;\n                    pixels[dstOff + 1] = (pixels[dstOff + 1] + g) / 2;\n                    pixels[dstOff + 2] = (pixels[dstOff + 2] + b) / 2;\n                } else {\n                    pixels[dstOff] = r;\n                    pixels[dstOff + 1] = g;\n                    pixels[dstOff + 2] = b;\n                }\n            }\n        }\n\n        \n        ctx.putImageData(data, 0, 0);\n    }\n\n    Canvas.Blur = function (options) {\n        let defaults = {\n            radius: 5,  \n            quality: 1  \n        };\n\n        options = Object.assign(defaults, options);\n\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n\n        \n        function gaussianKernel(radius) {\n            let size = 2 * radius + 1;\n            let kernel = new Float32Array(size * size);\n            let sigma = radius / 3;  \n            let sum = 0;\n            let center = radius;\n\n            for (let y = 0; y < size; y++) {\n                for (let x = 0; x < size; x++) {\n                    let dx = x - center;\n                    let dy = y - center;\n                    let weight = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));\n                    kernel[y * size + x] = weight;\n                    sum += weight;\n                }\n            }\n\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= sum;\n            }\n\n            return {\n                kernel: kernel,\n                size: size\n            };\n        }\n\n        let { kernel, size } = gaussianKernel(options.radius);\n        let half = Math.floor(size / 2);\n        let iterations = Math.round(options.quality);\n\n        function applyBlur() {\n            let output = new Uint8ClampedArray(pixels);\n\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n                    let dstOff = (y * width + x) * 4;\n\n                    for (let ky = 0; ky < size; ky++) {\n                        for (let kx = 0; kx < size; kx++) {\n                            let ny = y + ky - half;\n                            let nx = x + kx - half;\n\n                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                                let srcOff = (ny * width + nx) * 4;\n                                let weight = kernel[ky * size + kx];\n\n                                r += pixels[srcOff] * weight;\n                                g += pixels[srcOff + 1] * weight;\n                                b += pixels[srcOff + 2] * weight;\n                            }\n                        }\n                    }\n\n                    output[dstOff] = r;\n                    output[dstOff + 1] = g;\n                    output[dstOff + 2] = b;\n                }\n            }\n\n            return output;\n        }\n\n        \n        for (let i = 0; i < iterations; i++) {\n            pixels = applyBlur();\n        }\n\n        ctx.putImageData(new ImageData(pixels, width, height), 0, 0);\n    }\n    return Canvas;\n}"
    },
    "ImageViewer": {
        "Name": "ImageViewer",
        "Method": "Plugin",
        "Desc": "A simple image viewer plugin",
        "variant": "plugin",
        "Dependencies": [
            "Style",
            "Icons"
        ],
        "Type": "Plugin",
        "Example": "// Dependencies: Style, Icons",
        "Script": "Q.ImageViewer = function () {\n    console.log('ImageViewer Plugin Loaded');\n    let classes = Q.style(`\n.image_viewer_wrapper {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0,0,0,0.8);\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n}\n\nimage_viewer_wrapper .image_wrapper {\n    position: relative;\n    width: 80%;\n    height: 80%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.left_button, .right_button, .close_button {\n    position: absolute;\n    background: rgba(255,255,255,0.5);\n    border: none;\n    cursor: pointer;\n    padding: 10px;\n}\n\n.left_button {\n    left: 10px;\n}\n\n.right_button {\n    right: 10px;\n}\n\n.close_button {\n    top: 10px;\n    right: 10px;\n}\n    `, {\n        'image_viewer_wrapper': 'image_viewer_wrapper'\n    });\n\n    class Viewer {\n        constructor() {\n            this.selector = null;\n            this.images = []; \n            this.currentIndex = 0; \n            this.construct();\n            this.eventHandler = this.handleClick.bind(this);\n            this.eventListenerActive = false;\n            this.addEventListener(); \n        }\n\n        construct() {\n            this.wrapper = Q('<div>', { class: classes.image_viewer_wrapper });\n            this.image_wrapper = Q('<div>', { class: 'image_wrapper' });\n            this.left_button = Q('<button>', { class: 'left_button', text: 'Prev' });\n            this.right_button = Q('<button>', { class: 'right_button', text: 'Next' });\n            this.close_button = Q('<button>', { class: 'close_button', text: 'Close' });\n\n            this.wrapper.append(this.left_button, this.image_wrapper, this.right_button, this.close_button);\n\n            \n            this.left_button.on('click', () => this.prev());\n            this.right_button.on('click', () => this.next());\n            this.close_button.on('click', () => this.close());\n\n            \n            this.left_button.hide();\n            this.right_button.hide();\n        }\n\n        handleClick(e) {\n            if (e.target.closest(this.selector)) {\n                const src = e.target.src;\n                if (src) {\n                    this.open([src]); \n                }\n            }\n        }\n\n        addEventListener() {\n            if (!this.eventListenerActive) {\n                document.addEventListener('click', this.eventHandler);\n                this.eventListenerActive = true;\n            }\n        }\n\n        removeEventListener() {\n            if (this.eventListenerActive) {\n                document.removeEventListener('click', this.eventHandler);\n                this.eventListenerActive = false;\n            }\n        }\n\n        open(images) {\n            this.construct(); \n            this.images = images; \n            this.currentIndex = 0; \n\n            this.updateImage(); \n            this.updateNavigation(); \n            Q('body').append(this.wrapper); \n        }\n\n        close() {\n            this.wrapper.remove();\n        }\n\n        prev() {\n            if (this.currentIndex > 0) {\n                this.currentIndex--;\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n\n        next() {\n            if (this.currentIndex < this.images.length - 1) {\n                this.currentIndex++;\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n\n        updateImage() {\n            const src = this.images[this.currentIndex];\n            this.image_wrapper.empty();\n            const img = Q('<img>', { src: src, style: 'max-width: 100%; max-height: 100%;' });\n            this.image_wrapper.append(img);\n        }\n\n        updateNavigation() {\n            \n            if (this.images.length > 1) {\n                if (this.currentIndex > 0) {\n                    this.left_button.show();\n                } else {\n                    this.left_button.hide();\n                }\n\n                if (this.currentIndex < this.images.length - 1) {\n                    this.right_button.show();\n                } else {\n                    this.right_button.hide();\n                }\n            } else {\n                this.left_button.hide();\n                this.right_button.hide();\n            }\n        }\n\n        setSelector(selector) {\n            this.selector = selector;\n            this.addEventListener(); \n        }\n\n        remove() {\n            this.removeEventListener(); \n            this.wrapper.remove(); \n        }\n    }\n\n    let viewer = new Viewer();\n\n    return {\n        selector: function (selector) {\n            viewer.setSelector(selector);\n            return this;\n        },\n        open: function (images) {\n            viewer.open(images);\n            return this;\n        },\n        close: function () {\n            viewer.close();\n            return this;\n        },\n        remove: function () {\n            viewer.remove();\n            return this;\n        }\n    };\n}"
    },
    "JSON": {
        "Name": "JSON",
        "Method": "Plugin",
        "Desc": "Provides methods to parse, deflate, and inflate, modify JSON objects.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "var json = Q.JSON({ key: 'value' }); json.Parse({ modify: true, recursive: true }, (key, value) => value + ' modified');",
        "Script": "Q.JSON = function (json) {\n    if (!(this instanceof Q.JSON)) {\n        return new Q.JSON(json);\n    }\n    this.json = json;\n};\n\nQ.JSON.prototype.Parse = function (options = { modify: false, recursive: false }, callback) {\n    const process = (data) => {\n        if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n            for (const key in data) {\n                if (data.hasOwnProperty(key)) {\n                    const newValue = callback(key, data[key]);\n                    if (modify) {\n                        data[key] = newValue;\n                    }\n                    if (recursive && typeof data[key] === 'object' && data[key] !== null) {\n                        process(data[key]);\n                    }\n                }\n            }\n        }\n    };\n\n    process(this.json);\n    return this.json;\n};\n\nQ.JSON.prototype.deflate = function (level) {\n    const map = {};\n    let counter = 1;\n\n    function replaceRecursive(obj) {\n        if (typeof obj === 'object' && obj !== null) {\n            for (let key in obj) {\n                if (typeof obj[key] === 'object') {\n                    replaceRecursive(obj[key]);\n                }\n\n                if (key.length >= level) {\n                    if (!map[key]) {\n                        map[key] = `[${counter}]`;\n                        counter++;\n                    }\n                    const newKey = map[key];\n                    obj[newKey] = obj[key];\n                    delete obj[key];\n                }\n\n                if (typeof obj[key] === 'string' && obj[key].length >= level) {\n                    if (!map[obj[key]]) {\n                        map[obj[key]] = `[${counter}]`;\n                        counter++;\n                    }\n                    obj[key] = map[obj[key]];\n                }\n            }\n        }\n    }\n\n    const compressedData = JSON.parse(JSON.stringify(this.json));\n    replaceRecursive(compressedData);\n\n    return { data: compressedData, map: map };\n};\n\nQ.JSON.prototype.inflate = function (deflatedJson) {\n    const { data, map } = deflatedJson;\n    const reverseMap = Object.fromEntries(Object.entries(map).map(([k, v]) => [v, k]));\n\n    function restoreRecursive(obj) {\n        if (typeof obj === 'object' && obj !== null) {\n            for (let key in obj) {\n                const originalKey = reverseMap[key] || key;\n                const value = obj[key];\n\n                delete obj[key];\n                obj[originalKey] = value;\n\n                if (typeof obj[originalKey] === 'object') {\n                    restoreRecursive(obj[originalKey]);\n                } else if (reverseMap[obj[originalKey]]) {\n                    obj[originalKey] = reverseMap[obj[originalKey]];\n                }\n            }\n        }\n    }\n\n    const inflatedData = JSON.parse(JSON.stringify(data));\n    restoreRecursive(inflatedData);\n    return inflatedData;\n};"
    },
    "NodeBlock": {
        "Name": "NodeBlock",
        "Method": "Plugin",
        "Desc": "A plugin for creating UML blocks and connections.",
        "variant": "plugin",
        "Dependencies": [
            "ColorBrightness",
            "isDarkColor",
            "Style"
        ],
        "Type": "Plugin",
        "Example": "var uml = Q.NodeBlock('#canvas', 800, 600); // Create a new UML canvas",
        "Script": "Q.NodeBlock = function (selector, width, height, options) {\n\n    let classes = Q.style(`\n\n.node_preferences {\n    position: absolute;\n    width: 350px;\n    max-height: 300px;\n    background: #181818;\n    overflow: hidden;\n    overflow-y: scroll;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n}\n\n.pref_content h1, .pref_content h2, .pref_content h3, .pref_content h4, .pref_content h5, .pref_content h6 {\nline-break: anywhere;\nmargin: 0 0 2px 0;\npadding: 0;\n}\n\n.pref_content h1 { font-size: 150%; }\n.pref_content h2 { font-size: 140%; }\n.pref_content h3 { font-size: 130%; }\n.pref_content h4 { font-size: 120%; }\n.pref_content h5 { font-size: 110%; }\n.pref_content h6 { font-size: 100%; }\n\n.pref_content p { margin: 0; padding: 0; color: #7a7a7a; }\n.pref_content ul { margin: 5px 5px; padding-left: 15px; color: #7a7a7a; }\n.pref_content li { padding: 0px; margin: 0px; }\n.pref_content table { border-collapse: collapse; width: 100%; }\n.pref_content table, th, td { padding: 0; margin: 0; font-size: 90%; line-break: anywhere; border: 1px solid #222; }\n.pref_content th, td { padding: 1px; text-align: left; }\n.pref_content th { background-color: #222; }\n.pref_content tfoot { background-color: #222; }\n\n\n\n\n.pref_title {\n    font-size: 12px;\n    margin: 5px;\n    color: #7a7a7a;\n    text-align: center;\n}\n\n.node_preferences::-webkit-scrollbar {\n    width: 10px;\n}\n\n.node_preferences::-webkit-scrollbar-track {\n    background: #3a3a3a;\n}\n\n.node_preferences::-webkit-scrollbar-thumb {\n    background: #242424;\n}\n\n.node_preferences::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n\n\n.pref_content {\n\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n    padding: 5px 5px;\n}\n\n.pref_content img {\n    width: 100%;\n    height: auto;\n}\n\n\n.connection_content {\n    display: flex;\n    justify-content: space-between;\n}\n\n.left,\n.right {\n    width: 50%;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin: 5px;\n}\n\n.connection_wrapper {\n    display: flex;\n    justify-content: space-between;\n    margin: 1px;\n}\n\n.color_wrapper {\n    position: relative;\n    width: 20px;\n    height: 20px;\n    overflow: hidden;\n    flex-shrink: 0;\n}\n\n.color {\n    position: absolute;\n    width: 100px;\n    top: -20px;\n    left: -20px;\n    height: 100px;\n}\n\n.connection {\n    font-size: 12px;\npadding: 0 5px;\n    width: 100%;\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n}\n\n.button_nodes {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 8px;\n    width: 15px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.button_nodes_big {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 12px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.button_add\n{\n    margin:1px;\n    width: 20px;\n    height: 20px;\n}\n\n        `, {\n        \"node_preferences\": \"node_preferences\",\n        \"pref_title\": \"pref_title\",\n        \"pref_content\": \"pref_content\",\n        \"connection_content\": \"connection_content\",\n        \"left\": \"left\",\n        \"right\": \"right\",\n        \"connection_wrapper\": \"connection_wrapper\",\n        \"color_wrapper\": \"color_wrapper\",\n        \"connection\": \"connection\",\n        \"button_nodes\": \"button_nodes\",\n        \"button_nodes_big\": \"button_nodes_big\",\n        \"button_add\": \"button_add\",\n        \"name\": \"_name\",\n        \"content\": \"_content\",\n        \"manipulation\": \"manipulation\",\n        \"color\": \"color\",\n        \"pref_section\": \"pref_section\",\n    }, false);\n\n    class UMLBlock {\n        constructor(custom_style, appearance, id, name, text, x, y, width, connLeft = [], connRight = [], connections = []) {\n            this.name = name;\n            this.text = text;\n            this.t_text = \"\";\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.connections = connections;\n            this.connLeft = connLeft;\n            this.connRight = connRight;\n            this.height = 0; \n            this.isDragging = false;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            this.img = null;\n            this.content = null;\n            this.contentHeight = 0;\n            this.unescapedBase64Data = null;\n            this.appearance = appearance;\n            this.custom_style = custom_style;\n            this.appearance = Object.assign({}, this.appearance, custom_style);\n            this.darkText = '#ffffff';\n            this.lightText = '#000000';\n            this._processColors();\n        }\n\n        _restyle(object) {\n            this.custom_style = object;\n            this.appearance = Object.assign({}, this.appearance, object);\n            this._processColors();\n            this.t_text = '';\n        }\n\n        _processColors() {\n            this.appearance.titleBackground = Q.ColorBrightness(this.appearance.background, this.appearance.factorTitleBackground);\n            const isDark = Q.isDarkColor(this.appearance.background, this.appearance.factorDarkColorMargin, this.appearance.factorDarkColorThreshold);\n            const textColor = isDark ? this.appearance.darkTextColor : this.appearance.lightTextColor;\n            const borderColor = isDark ? Q.ColorBrightness(this.appearance.background, this.appearance.factorLightColors) : Q.ColorBrightness(this.appearance.background, this.appearance.factorDarkColors);\n            this.appearance.titleColor = textColor;\n            this.appearance.connectionTextColor = textColor;\n            this.appearance.textColor = textColor;\n            this.appearance.node_table_color = borderColor;\n        }\n\n\n        _drawContainer(ctx, x, y, width, height) {\n            const { shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, background, radius } = this.appearance;\n\n            \n            ctx.shadowColor = shadowColor;\n            ctx.shadowBlur = shadowBlur;\n            ctx.shadowOffsetX = shadowOffsetX;\n            ctx.shadowOffsetY = shadowOffsetY;\n\n            \n            ctx.fillStyle = background;\n            ctx.beginPath();\n\n            \n            ctx.moveTo(x + radius, y);\n            ctx.arcTo(x + width, y, x + width, y + radius, radius);        \n            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius); \n            ctx.arcTo(x, y + height, x, y + height - radius, radius);      \n            ctx.arcTo(x, y, x + radius, y, radius);                       \n\n            ctx.fill();\n\n            \n            ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n            ctx.shadowBlur = 0;\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n        }\n\n        _drawTitle(ctx, x, y, width, height, title) {\n            ctx.fillStyle = this.appearance.titleBackground;\n            ctx.beginPath();\n            ctx.moveTo(x + this.appearance.radius, y);\n            ctx.arcTo(x + width, y, x + width, y + height, this.appearance.radius);\n            ctx.arcTo(x + width, y + height, x, y + height, 0);\n            ctx.arcTo(x, y + height, x, y, 0);\n            ctx.arcTo(x, y, x + width, y, this.appearance.radius);\n            ctx.closePath();\n            ctx.fill();\n\n\n            ctx.fillStyle = this.appearance.titleColor;\n            ctx.font = 'bold ' + this.appearance.fontSizeTitle + 'px ' + this.appearance.font;\n            const titleX = x + (width - ctx.measureText(title).width) / 2;\n            const titleY = y + (height + this.appearance.fontSizeTitle) / 2;\n            ctx.fillText(title, titleX, titleY);\n        }\n\n        parseHTML2Canvas(html, callback) {\n\n            \n            html = html.replace(/style=\"[^\"]*\"/g, '');\n            \n            \n            html = html.replace(/<br>/g, '');\n\n            if (this.t_text == html) {\n                callback(this.content, this.contentHeight);\n                return;\n            }\n            this.t_text = html;\n\n            \n            let tempContainer = document.createElement('div');\n            tempContainer.style.position = 'absolute';\n            tempContainer.style.visibility = 'hidden';\n            tempContainer.style.width = (this.width - this.appearance.fontSize) + 'px';\n            document.body.appendChild(tempContainer);\n\n            \n            let style = document.createElement('style');\n\n            let st = `\n            table {border-collapse: collapse; width: 100%;}\n            table, th, td {padding: 0; margin: 0; font-size: ${(this.appearance.fontSize * 0.9)}px; line-break: anywhere;border: 1px solid ${this.appearance.node_table_color};}\n            th, td {padding: 1px; text-align: left;}\n            th {background-color: ${this.appearance.node_table_color};}\n            tfoot {background-color: ${this.appearance.node_table_color};}\n        \n            h1, h2, h3, h4, h5, h6 {line-break: anywhere; margin: 0 0 2px 0; padding: 0;}\n            h1 {font-size: ${(this.appearance.fontSize * 1.5)}px;}\n            h2 {font-size: ${(this.appearance.fontSize * 1.4)}px;}\n            h3 {font-size: ${(this.appearance.fontSize * 1.3)}px;}\n            h4 {font-size: ${(this.appearance.fontSize * 1.2)}px;}\n            h5 {font-size: ${(this.appearance.fontSize * 1.1)}px;}\n            h6 {font-size: ${(this.appearance.fontSize * 1.0)}px;}\n                            p { margin: 0; padding: 0; color: ${this.appearance.textColor}; }\n                            ul { margin: 5px 5px; padding-left: 15px; color: ${this.appearance.textColor}; }\n                            li { padding: 0px; margin: 0px; }\n                            div {font-family: ${this.appearance.font}, sans-serif; font-size: ${this.appearance.fontSize}px; color: ${this.appearance.textColor}; }\n                        `;\n\n            style.innerHTML = st;\n            document.head.appendChild(style);\n\n            \n            tempContainer.innerHTML = html;\n\n            \n            this.contentHeight = tempContainer.offsetHeight + this.appearance.padding;\n\n            \n            document.body.removeChild(tempContainer);\n            document.head.removeChild(style);\n\n            \n            this.content = document.createElement('canvas');\n            this.content.width = this.width;\n            this.content.height = this.contentHeight; \n            let ctx = this.content.getContext('2d');\n\n            let data = '<svg xmlns=\"http:\n                '<foreignObject width=\"100%\" height=\"100%\">' +\n                '<style>' +\n                st +\n                '</style>' +\n                '<div xmlns=\"http:\n                html +\n                '</div>' +\n                '</foreignObject>' +\n                '</svg>';\n\n            let DOMURL = window.URL || window.webkitURL || window;\n            let img = new Image();\n            let svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });\n            let url = DOMURL.createObjectURL(svg);\n\n            img.onload = () => {\n                ctx.drawImage(img, 0, 0);\n                DOMURL.revokeObjectURL(url);\n                callback(this.content, this.contentHeight);\n            };\n\n            img.src = url;\n        }\n\n        draw(ctx) {\n            const TITLE_HEIGHT = this.appearance.fontSizeTitle + (this.appearance.padding * 2);\n            const CONNECTION_HEIGHT = this.appearance.padding + TITLE_HEIGHT;\n            const CONNECTION_PADDING = (this.appearance.connectionPointSize * 2) + this.appearance.connectionPointPadding;\n            const maxConnectionsHeight = Math.max(this.connLeft.length, this.connRight.length) * CONNECTION_PADDING;\n\n            \n            const updateContainerHeight = (contentHeight) => {\n                this.height = TITLE_HEIGHT + (this.appearance.padding * 2) + maxConnectionsHeight + contentHeight + this.appearance.padding;\n            };\n\n            const drawImageContent = (img, drawX, drawY, drawWidth, drawHeight) => {\n                const contentHeight = drawHeight + this.appearance.padding;\n                updateContainerHeight(contentHeight);\n                this._drawContainer(ctx, this.x, this.y, this.width, this.height, this.appearance.radius);\n                this._drawTitle(ctx, this.x, this.y, this.width, TITLE_HEIGHT, this.name);\n                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n                this.drawConnectionPoints(ctx, CONNECTION_HEIGHT, CONNECTION_PADDING);\n            };\n\n            \n            const isBase64Image = this.text.includes('base64');\n\n            \n            const extractBase64Data = () => {\n                const base64Match = this.text.match(/base64,([^\"]*)/);\n                return base64Match && base64Match[1] ? base64Match[1] : null;\n            };\n\n            \n            if (isBase64Image) {\n                const base64Data = extractBase64Data();\n                if (!base64Data) return;\n\n                \n                if (this.base64Data === base64Data.length) {\n                    const imgWidth = this.img.width;\n                    const imgHeight = this.img.height;\n                    const aspectRatio = imgHeight / imgWidth;\n                    const drawWidth = this.width - (this.appearance.padding*2);\n                    const drawHeight = drawWidth * aspectRatio;\n                    const drawX = this.x + this.appearance.padding;\n                    const drawY = this.y + TITLE_HEIGHT + (this.appearance.padding) + maxConnectionsHeight;\n\n                    drawImageContent(this.img, drawX, drawY, drawWidth, drawHeight);\n                    return;\n                }\n\n                \n                const unescapedBase64Data = 'data:image/png;base64,' + decodeURIComponent(base64Data);\n                this.img = new Image();\n                this.img.src = unescapedBase64Data;\n                this.base64Data = base64Data.length;\n\n                this.img.onload = () => {\n                    const imgMatch = this.text.match(/<img[^>]+src=\"([^\">]+)\"/);\n                    if (imgMatch && imgMatch[1]) {\n                        this.text = `<img src=\"${imgMatch[1]}\"/>`;\n                    }\n\n                    const imgWidth = this.img.width;\n                    const imgHeight = this.img.height;\n                    const aspectRatio = imgHeight / imgWidth;\n                    const drawWidth = this.width - (this.appearance.padding*2);\n                    const drawHeight = drawWidth * aspectRatio;\n                    const drawX = this.x + this.appearance.padding;\n                    const drawY = this.y + TITLE_HEIGHT + (this.appearance.padding) + maxConnectionsHeight;\n\n                    drawImageContent(this.img, drawX, drawY, drawWidth, drawHeight);\n                };\n\n                return;\n            } else {\n                \n                this.parseHTML2Canvas(this.text, (canvas, contentHeight) => {\n                    updateContainerHeight(contentHeight);\n                    this._drawContainer(ctx, this.x, this.y, this.width, this.height, this.appearance.radius);\n                    this._drawTitle(ctx, this.x, this.y, this.width, TITLE_HEIGHT, this.name);\n                    ctx.drawImage(canvas, this.x + this.appearance.padding, this.y + TITLE_HEIGHT + this.appearance.padding + maxConnectionsHeight);\n                    this.drawConnectionPoints(ctx, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                });\n            }\n        }\n\n\n        drawConnectionPoints(ctx, paddingTop, height) {\n            const connectionY = this.y + paddingTop;\n            const font = `bold ${this.appearance.fontSizeConnection}px ${this.appearance.font}`;\n            const pointSize = this.appearance.connectionPointSize;\n            const connectionPaddingX = this.appearance.connectionTextPaddingX;\n            const middleYOffset = ((pointSize / 2) + (this.appearance.fontSizeConnection / 2)) - this.appearance.connectionTextPaddingY;\n\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n\n            ctx.font = font;\n\n            const drawConnectionPoints = (connList, coordsArray, baseX, getTextX) => {\n                connList.forEach((conn, index) => {\n                    const connY = connectionY + index * height;\n                    coordsArray.push({ x: baseX, y: connY });\n\n                    ctx.fillStyle = conn.color || this.appearance.connectionColor;\n                    ctx.beginPath();\n                    ctx.arc(baseX, connY, pointSize, 0, 2 * Math.PI);\n                    ctx.fill();\n\n                    ctx.fillStyle = this.appearance.connectionTextColor;\n                    ctx.fillText(conn.title, getTextX(conn.title, baseX), connY + middleYOffset);\n                });\n            };\n\n            if (Array.isArray(this.connLeft)) {\n                drawConnectionPoints(this.connLeft, this.leftConnCoords, this.x, (title, baseX) => baseX + connectionPaddingX * 2);\n            }\n\n            if (Array.isArray(this.connRight)) {\n                drawConnectionPoints(this.connRight, this.rightConnCoords, this.x + this.width, (title, baseX) => baseX - ctx.measureText(title).width - connectionPaddingX * 2);\n            }\n        }\n\n\n        addConnection(conn) {\n            this.connections.push(conn);\n        }\n\n        removeConnection(conn) {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n        }\n\n        isMouseOver(mouseX, mouseY) {\n            return mouseX >= this.x && mouseX <= this.x + this.width && mouseY >= this.y && mouseY <= this.y + this.height;\n        }\n\n        getAllConnectionCoords() {\n            return [...this.leftConnCoords, ...this.rightConnCoords];\n        }\n\n        getConnectionCoord(point, index) {\n            return point === 'left' ? this.leftConnCoords[index] : this.rightConnCoords[index];\n        }\n    }\n\n    class UMLCanvas {\n        constructor(selector, width, height, appearance, classes) {\n            this.element_parent = Q(selector);\n            this.canvas = Q('<canvas>', { width: width, height: height });\n            this.width = width;\n            this.height = height;\n            this.element_parent.append(this.canvas);\n            this.canvas_context = this.canvas.nodes[0].getContext('2d');\n            this.blocks = [];\n            this.connections = [];\n            this.draggingBlock = null;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.connection_start = null;\n            this.connection_end = null;\n            this.mouseX = 0;\n            this.mouseY = 0;\n            this.isMenuPreferences = false;\n            this.isDraggingBlock = false;\n            this.isOverConnection = false;\n            this.appearance = appearance;\n            this.classes = classes;\n\n            this.canvas.on('click', this._event_click.bind(this)); \n            this.canvas.on('mousedown', this._event_pointer_down.bind(this));\n            this.canvas.on('mousemove', this._event_pointer_move.bind(this));\n            this.canvas.on('mouseup', this._event_pointer_up.bind(this));\n            this.canvas.on('contextmenu', this._event_click_right.bind(this), false); \n        }\n\n        import(uml) {\n            \n            const blockCreationPromises = uml.blocks.map(async (block) => {\n                \n                const newBlock = new UMLBlock(\n                    block.custom_style,\n                    this.appearance,\n                    block.id, block.name, block.text, block.x, block.y, block.width,\n                    block.connLeft.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connRight.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connections\n                );\n                this.addBlock(newBlock);\n            });\n\n            \n            Promise.all(blockCreationPromises).then(() => {\n                \n                uml.connections.forEach(conn => {\n                    const startBlock = this.blocks.find(b => b.id === conn.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.target);\n\n                    const startCoords = this._point_coords(startBlock, conn.point);\n                    const endCoords = this._point_coords(endBlock, conn.targetPoint);\n\n                    if (startCoords && endCoords) {\n                        this._connection_create(\n                            { block: startBlock, point: conn.point, x: startCoords.x, y: startCoords.y },\n                            { block: endBlock, point: conn.targetPoint, x: endCoords.x, y: endCoords.y }\n                        );\n                    } else {\n                        console.error('Connection failed to initialize:', startBlock, endBlock);\n                    }\n                });\n            }).catch(err => {\n                console.error('Error during block initialization:', err);\n            });\n        }\n\n        export() {\n            return {\n                blocks: this.blocks.map(block => ({\n                    custom_style: block.custom_style,\n                    id: block.id,\n                    name: block.name,\n                    text: block.text,\n                    x: block.x,\n                    y: block.y,\n                    width: block.width,\n                    connLeft: block.connLeft,\n                    connRight: block.connRight,\n                    connections: block.connections\n                })),\n                connections: this.connections.map(conn => ({\n                    id: conn.start.block.id,\n                    point: conn.start.point,\n                    target: conn.end.block.id,\n                    targetPoint: conn.end.point\n                }))\n            };\n        }\n\n        async addBlock(block) {\n            this.blocks.push(block);\n            await this._connections_init(block);\n            this.render();\n        }\n\n        removeBlock(block) {\n            this.blocks = this.blocks.filter(b => b.id !== block.id);\n            this.connections = this.connections.filter(conn =>\n                conn.start.block.id !== block.id && conn.end.block.id !== block.id\n            );\n            this.render();\n        }\n\n\n        getJointContent() {\n            \n\n            let block = this.blocks[0];\n            let content = block.text;\n            let connections = block.connections;\n            let nextBlock = null;\n\n            while (connections.length > 0) {\n                let conn = connections[0];\n                nextBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                content += nextBlock.text;\n                connections = nextBlock.connections;\n            }\n\n            return content;\n        }\n\n\n        duplicateBlock(block) {\n            let id = this._id();\n            const newBlock = new UMLBlock(\n                block.custom_style,\n                this.appearance,\n                id, block.name, block.text, block.x + 50, block.y + 50, block.width,\n                block.connLeft, block.connRight, []\n            );\n            this.addBlock(newBlock);\n        }\n\n        render() {\n            this.canvas_context.clearRect(0, 0, this.width, this.height);\n\n            \n\n            \n            this.connections.forEach(conn => {\n                let startColor = this._getConnectionColor(conn.start.block, conn.start.point);\n                let endColor = this._getConnectionColor(conn.end.block, conn.end.point);\n\n                this.canvas_context.strokeStyle = 'rgb(150, 150, 150)';\n\n                this.canvas_context.beginPath();\n\n                \n                this.canvas_context.lineWidth = 2;\n\n                \n                let gradient = this.canvas_context.createLinearGradient(conn.start.x, conn.start.y, conn.end.x, conn.end.y);\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, endColor);\n                this.canvas_context.strokeStyle = gradient;\n\n                this.canvas_context.moveTo(conn.start.x, conn.start.y);\n                this.canvas_context.lineTo(conn.end.x, conn.end.y);\n                this.canvas_context.stroke();\n\n                \n                let dx = conn.end.x - conn.start.x;\n                let dy = conn.end.y - conn.start.y;\n                let length = Math.sqrt(dx * dx + dy * dy);\n                let unitDx = dx / length;\n                let unitDy = dy / length;\n\n                \n                let arrowLength = 10;\n                let arrowWidth = 5;\n                for (let i = 100; i < length; i += 200) {\n                    let x = conn.start.x + unitDx * i;\n                    let y = conn.start.y + unitDy * i;\n\n                    this.canvas_context.beginPath();\n                    this.canvas_context.moveTo(x, y);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx + arrowWidth * unitDy, y - arrowLength * unitDy - arrowWidth * unitDx);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx - arrowWidth * unitDy, y - arrowLength * unitDy + arrowWidth * unitDx);\n                    this.canvas_context.closePath();\n                    this.canvas_context.fillStyle = gradient;\n                    this.canvas_context.fill();\n                }\n            });\n\n            \n            if (this.connection_start && this.connection_end === null) {\n                let startColor = this._getConnectionColor(this.connection_start.block, this.connection_start.point);\n\n                let gradient = this.canvas_context.createLinearGradient(this.connection_start.x, this.connection_start.y, this.mouseX, this.mouseY);\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, \"rgb(150, 150, 150)\");  \n                this.canvas_context.strokeStyle = gradient;\n\n                this.canvas_context.beginPath();\n                this.canvas_context.moveTo(this.connection_start.x, this.connection_start.y);\n                this.canvas_context.lineTo(this.mouseX, this.mouseY);\n                this.canvas_context.stroke();\n            }\n\n            this.blocks.forEach(block => {\n                block.draw(this.canvas_context);\n            });\n        }\n\n        \n        _getConnectionColor(block, pointId) {\n            for (let i = 0; i < block.connLeft.length; i++) {\n                if (block.connLeft[i].id === pointId) {\n                    return block.connLeft[i].color;\n                }\n            }\n\n            for (let i = 0; i < block.connRight.length; i++) {\n                if (block.connRight[i].id === pointId) {\n                    return block.connRight[i].color;\n                }\n            }\n        }\n\n        updateConnections(block) {\n\n            let preferences = Q('.' + classes.node_preferences);\n\n            let left = preferences.find('.' + classes.left);\n            let right = preferences.find('.' + classes.right);\n\n            let leftConnections = block.connLeft;\n            let rightConnections = block.connRight;\n\n            \n\n\n            \n            let newLeftConnections = [];\n            left.find('.' + classes.connection_wrapper).walk((element) => {\n\n                \n                let id = element.id();\n                let title = element.find('.' + classes.connection).val();\n                let color = element.find('.' + classes.color).val();\n\n                newLeftConnections.push({ id: id, title: title, color: color });\n            }, true);\n\n            let newRightConnections = [];\n            right.find('.' + classes.connection_wrapper).walk((element) => {\n                let id = element.id();\n                let title = element.find('.' + classes.connection).val();\n                let color = element.find('.' + classes.color).val();\n                newRightConnections.push({ id: id, title: title, color: color });\n            }, true);\n\n            let newConnections = [...newLeftConnections, ...newRightConnections];\n            let existingConnections = [...leftConnections, ...rightConnections];\n\n            newConnections.forEach(newConn => {\n                let existingConn = existingConnections.find(conn => conn.id === newConn.id);\n                if (existingConn) {\n                    existingConn.title = (newConn.title && newConn.title !== null) ? newConn.title : '';\n                    existingConn.color = newConn.color;\n                } else {\n                    existingConnections.push(newConn);\n                }\n            });\n        }\n\n        updateBlock(selectedblock = null, callback) {\n            let preferences = Q('.' + classes.node_preferences);\n            let block;\n            if (selectedblock) {\n                block = selectedblock;\n            }\n            else {\n                block = this.blocks.find(b => b.id === preferences.id());\n            }\n            \n            let name = preferences.find('#' + classes.name).text();\n            let content = preferences.find('#' + classes.content).html();\n            block.name = name;\n            block.text = content;\n            if (callback) callback(block);\n        }\n\n        _event_pointer_down(event) {\n            if (event.button === 2) return; \n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                let block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this.isDraggingBlock = true;\n                    \n                    this.draggingBlock = block;\n                    this.offsetX = mouseX - block.x;\n                    this.offsetY = mouseY - block.y;\n                    block.isDragging = true;\n                    break;\n                }\n            }\n        }\n        _event_pointer_move(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n\n            if (this.draggingBlock) {\n                this.draggingBlock.x = mouseX - this.offsetX;\n                this.draggingBlock.y = mouseY - this.offsetY;\n                this._connection_update();\n                this.render();\n                return;\n            }\n\n            if (this.connection_start && this.connection_end === null) {\n                this.mouseX = mouseX;\n                this.mouseY = mouseY;\n                this.render();\n                return;\n            }\n\n            if (this.isOverConnection) {\n                this.isOverConnection = false;\n                this.render();\n            }\n\n            this.connections.forEach(conn => {\n\n                \n                if (this._point_line_segment(mouseX, mouseY, conn.start.x, conn.start.y, conn.end.x, conn.end.y)) {\n\n                    if (!this.isOverConnection) {\n\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.start.x, conn.start.y, this.appearance.connectionPointSize + 2, 0, 2 * Math.PI);\n                        let startColor = this._getConnectionColor(conn.start.block, conn.start.point);\n                        this.canvas_context.strokeStyle = startColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.end.x, conn.end.y, this.appearance.connectionPointSize + 2, 0, 2 * Math.PI);\n                        let endColor = this._getConnectionColor(conn.end.block, conn.end.point);\n                        this.canvas_context.strokeStyle = endColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n\n                        this.isOverConnection = true;\n                    }\n                }\n            });\n        }\n        _event_pointer_up(event) {\n            if (this.draggingBlock) {\n                this.isDraggingBlock = false;\n                this.draggingBlock.isDragging = false;\n                this.draggingBlock = null;\n                this._connection_update();\n                this.render();\n            }\n\n            if (this.connection_start && this.connection_end === null) {\n                \n                setTimeout(() => {\n                    this.connection_start = null;\n                    this.mouseX = 0;\n                    this.mouseY = 0;\n                    this.render();\n                }, 100);\n            }\n        }\n\n        _event_click(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n\n            for (let block of this.blocks) {\n                if (this._connection_over_point(block, mouseX, mouseY)) {\n                    if (this.connection_start === null) {\n                        this.connection_start = this._point_details(block, mouseX, mouseY);\n                    }\n                    else if (this.connection_end === null) {\n                        this.connection_end = this._point_details(block, mouseX, mouseY);\n\n                        \n                        if (this.connection_start.block !== this.connection_end.block &&\n                            !this._connection_exists(this.connection_start, this.connection_end)) {\n                            \n                            this._connection_create(this.connection_start, this.connection_end);\n                            block.addConnection({ id: this.connection_start.block.id, point: this.connection_start.point });\n                        } else {\n                            this.connection_start = null;\n                            this.connection_end = null;\n                            this.render();\n                        }\n\n                        \n                        this.connection_start = null;\n                        this.connection_end = null;\n                    }\n                    return;\n                }\n            }\n        }\n\n\n        _menu_context(x, y) {\n            let div = Q('<div>', { class: ['preferences'], style: { position: 'absolute', left: x + 'px', top: y + 'px' } });\n            this.isMenuPreferences = true;\n\n            let add = Q('<div>', { class: ['button_nodes_big'], text: 'Create Block' });\n            add.on('click', () => {\n\n                let id = this._id();\n                let block = new UMLBlock({}, this.appearance, id, 'Class', 'Content', x, y, 200, [{ id: this._id(), title: 'Left', color: '#333333' }], [{ id: this._id(), title: 'Right', color: '#333333' }]);\n                this.addBlock(block);\n                this._menu_remove();\n            });\n            div.append(add);\n            this.element_parent.append(div);\n        }\n\n\n        _event_click_right(event) {\n            event.preventDefault(); \n\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n\n\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n\n            \n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                let block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this._menu_remove();\n                    this._menu_preferences(block, mouseX, mouseY);\n                    return;\n                }\n            }\n\n\n\n            \n\n            for (let i = 0; i < this.connections.length; i++) {\n                let conn = this.connections[i];\n                if (this._point_line_segment(mouseX, mouseY, conn.start.x, conn.start.y, conn.end.x, conn.end.y)) {\n                    \n                    const startBlock = this.blocks.find(b => b.id === conn.start.block.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.end.block.id);\n\n                    if (startBlock && endBlock) {\n                        startBlock.removeConnection({ id: endBlock.id, point: conn.start.point });\n                    }\n\n                    \n                    this.connections.splice(i, 1);\n\n                    this.render();\n                    return;\n                }\n            }\n            this._menu_context(mouseX, mouseY);\n            this.render();\n        }\n\n        _id() {\n            return '_' + Math.random().toString(36).substr(2, 9);\n        }\n\n\n        _menu_remove() {\n            Q('.' + classes.node_preferences).remove();\n            this.isMenuPreferences = false;\n        }\n\n        \n        _menu_item_section(title, content) {\n            let div = Q('<div>', { class: [classes.pref_section] });\n            let titleDiv = Q('<div>', { class: [classes.pref_title], text: title });\n            div.append(titleDiv, content);\n            return div;\n        }\n\n        _menu_item_input(id, content, placeholder) {\n            let input = Q('<div>', { class: [classes.pref_content], id: id, contentEditable: true, html: content, placeholder: placeholder });\n            return input;\n        }\n\n        _menu_item_connections(block) {\n\n            let div = Q('<div>', { class: [classes.connection_content] });\n            let left = Q('<div>', { class: [classes.left] });\n            let right = Q('<div>', { class: [classes.right] });\n\n            const connItem = (pos, conn) => {\n\n                let connection_wrapper = Q('<div>', { class: [classes.connection_wrapper], id: conn.id });\n                let connection = Q('<input>', { class: [classes.connection], type: 'text', value: conn.title, placeholder: 'Point...', maxLength: 10 });\n                let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n                let color = Q('<input>', { class: [classes.color], type: 'color', value: conn.color });\n\n                color_wrapper.append(color);\n\n                color.on('change', () => {\n                    conn.color = color.val();\n                    this.render();\n                });\n\n                connection.on('input', () => {\n                    let contitle = connection.val();\n                    conn.title = (conn.title && contitle !== null) ? contitle : '';\n                    this.updateConnections(block);\n                    this.render();\n                });\n                connection_wrapper.append(color_wrapper, connection);\n\n                let remove = Q('<div>', { class: [classes.button_nodes], text: 'X' });\n                remove.on('click', () => {\n                    connection_wrapper.remove();\n                    this.connections = this.connections.filter(c => {\n                        if (c.start.block.id === block.id && c.start.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.end.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.end.point });\n                            return false;\n                        }\n                        if (c.end.block.id === block.id && c.end.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.start.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.start.point });\n                            return false;\n                        }\n                        return true;\n                    });\n                    if (pos === 'left') { block.connLeft = block.connLeft.filter(c => c.id !== conn.id); }\n                    if (pos === 'right') { block.connRight = block.connRight.filter(c => c.id !== conn.id); }\n                    this.render();\n                });\n                connection_wrapper.append(remove);\n                return connection_wrapper;\n            };\n\n            block.connLeft.forEach(conn => {\n                let connection_wrapper = connItem('left', conn);\n                left.append(connection_wrapper);\n            });\n\n            block.connRight.forEach(conn => {\n                let connection_wrapper = connItem('right', conn);\n                right.append(connection_wrapper);\n            });\n\n\n            let add = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            add.on('click', () => {\n\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connLeft.push(connection);\n                left.append(connItem('left', connection));\n                left.append(add);\n                this.render();\n            });\n            left.append(add);\n\n            let addRight = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            addRight.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connRight.push(connection);\n                right.append(connItem('right', connection));\n                right.append(addRight);\n                this.render();\n            });\n            right.append(addRight);\n\n            div.append(left, right);\n            return div;\n        }\n\n        _menu_manipulation(block) {\n            let div = Q('<div>', { class: [classes.manipulation] });\n            let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n            let color = Q('<input>', { class: [classes.color], type: 'color', value: block.appearance.background });\n            color_wrapper.append(color);\n\n            color.on('change', () => {\n                block._restyle({ background: color.val() });\n                this.render();\n            });\n\n            div.append(color_wrapper);\n\n            let delete_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Delete Block' });\n            delete_button.on('click', () => {\n                this.removeBlock(block);\n                this._menu_remove();\n            });\n\n            let duplicate_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Duplicate Block' });\n            duplicate_button.on('click', () => {\n                this.duplicateBlock(block);\n                this._menu_remove();\n            });\n\n            div.append(color_wrapper, delete_button, duplicate_button);\n\n            return div;\n        }\n\n        _menu_preferences(block, x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences], id: block.id });\n            div.css({ position: 'absolute', left: x + 'px', top: y + 'px' });\n            let title = this._menu_item_section('Class', this._menu_item_input(classes.name, block.name, 'Class name...'));\n            let content = this._menu_item_section('Content', this._menu_item_input(classes.content, block.text, 'Content...'));\n            let connections = this._menu_item_section('Connections', this._menu_item_connections(block));\n            let manipulation = this._menu_item_section('Manipulation', this._menu_manipulation(block));\n            div.append(title, content, connections, manipulation);\n            this.element_parent.append(div);\n            this.isMenuPreferences = true;\n        }\n\n        _connections_init(block) {\n            block.connections.forEach(conn => {\n                const targetBlock = this.blocks.find(b => b.id === conn.id);\n                if (targetBlock) {\n                    const startCoords = this._point_coords(block, 'right');\n                    const endCoords = this._point_coords(targetBlock, 'left');\n                    this._connection_create(\n                        { block: block, point: 'right', x: startCoords.x, y: startCoords.y },\n                        { block: targetBlock, point: conn.point, x: endCoords.x, y: endCoords.y }\n                    );\n                }\n            });\n        }\n\n        _blocks_connected(block1, block2) {\n            return this.connections.some(connection =>\n                (connection.start.block === block1 && connection.end.block === block2) ||\n                (connection.start.block === block2 && connection.end.block === block1)\n            );\n        }\n\n        _connection_exists(startConn, endConn) {\n            return this.connections.some(conn =>\n                (conn.start.block === startConn.block && conn.start.point === startConn.point &&\n                    conn.end.block === endConn.block && conn.end.point === endConn.point) ||\n                (conn.start.block === endConn.block && conn.start.point === endConn.point &&\n                    conn.end.block === startConn.block && conn.end.point === startConn.point)\n            );\n        }\n\n        _connection_create(startConn, endConn) {\n            this.connections.push({\n                start: { block: startConn.block, point: startConn.point, x: startConn.x, y: startConn.y },\n                end: { block: endConn.block, point: endConn.point, x: endConn.x, y: endConn.y }\n            });\n\n            \n            startConn.block.addConnection({ id: endConn.block.id, point: startConn.point });\n            endConn.block.addConnection({ id: startConn.block.id, point: endConn.point });\n\n            this.render();\n        }\n\n        _connection_update() {\n            this.connections.forEach(conn => {\n                const startCoords = this._point_coords(conn.start.block, conn.start.point);\n                const endCoords = this._point_coords(conn.end.block, conn.end.point);\n                conn.start.x = startCoords.x;\n                conn.start.y = startCoords.y;\n                conn.end.x = endCoords.x;\n                conn.end.y = endCoords.y;\n            });\n        }\n\n        _point_coords(block, pointId) {\n            const leftCoords = block.leftConnCoords;\n            const rightCoords = block.rightConnCoords;\n\n            \n            for (let i = 0; i < block.connLeft.length; i++) {\n                if (block.connLeft[i].id === pointId) {\n                    return { x: leftCoords[i].x, y: leftCoords[i].y };\n                }\n            }\n\n            for (let i = 0; i < block.connRight.length; i++) {\n                if (block.connRight[i].id === pointId) {\n                    return { x: rightCoords[i].x, y: rightCoords[i].y };\n                }\n            }\n\n            \n            return { x: block.x, y: block.y };\n        }\n\n        _connection_over_point(block, x, y) {\n            const radius = 5;\n            return block.getAllConnectionCoords().some(coord => Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius);\n        }\n\n        _point_details(block, x, y) {\n            const radius = 5;\n            let matchedPoint = null;\n\n            block.leftConnCoords.forEach((coord, index) => {\n                if (Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius) {\n                    matchedPoint = { block: block, point: block.connLeft[index].id, x: coord.x, y: coord.y, index: index };\n                }\n            });\n\n            if (!matchedPoint) {\n                block.rightConnCoords.forEach((coord, index) => {\n                    if (Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius) {\n                        matchedPoint = { block: block, point: block.connRight[index].id, x: coord.x, y: coord.y, index: index };\n                    }\n                });\n            }\n\n            return matchedPoint;\n        }\n\n        _point_line_segment(px, py, x1, y1, x2, y2) {\n            const distance = this._point_line_distance(px, py, x1, y1, x2, y2);\n            const buffer = 5; \n            return distance <= buffer;\n        }\n\n        _point_line_distance(px, py, x1, y1, x2, y2) {\n            const A = px - x1;\n            const B = py - y1;\n            const C = x2 - x1;\n            const D = y2 - y1;\n\n            const dot = (A * C) + (B * D);\n            const len_sq = (C * C) + (D * D);\n            let param = -1;\n            if (len_sq !== 0) {\n                param = dot / len_sq;\n            }\n\n            let xx, yy;\n            if (param < 0) {\n                xx = x1;\n                yy = y1;\n            } else if (param > 1) {\n                xx = x2;\n                yy = y2;\n            } else {\n                xx = x1 + param * C;\n                yy = y1 + param * D;\n            }\n\n            const dx = px - xx;\n            const dy = py - yy;\n            return Math.sqrt((dx * dx) + (dy * dy));\n        }\n    }\n\n    let appearance = {\n        darkTextColor: '#888',\n        lightTextColor: '#222',\n        background: '#181818',\n        factorTitleBackground: -20,\n        factorDarkColors: -30,\n        factorLightColors: 80,\n        factorDarkColorMargin: 20,\n        factorDarkColorThreshold: 127,\n        \n        \n        \n        connectionPointSize: 5,\n        connectionPointPadding: 5,\n        connectionTextPaddingX: 5,\n        connectionTextPaddingY: 5,\n        \n        shadowBlur: 10,\n        shadowColor: 'rgba(0, 0, 0, 0.2)',\n        shadowOffsetX: 0,\n        shadowOffsetY: 5,\n        font: 'Arial',\n        fontSize: 12,\n        fontSizeTitle: 12,\n        fontSizeConnection: 10,\n        padding: 5,\n        radius: 10\n        \n    };\n\n    appearance = Object.assign(appearance, options);\n    let uml = new UMLCanvas(selector, width, height, appearance, classes);\n\n    return {\n        import: function (data) {\n            uml.import(data);\n        },\n        export: function () {\n            return uml.export();\n        },\n        addBlock: function (block) {\n            uml.addBlock(block);\n        },\n        removeBlock: function (block) {\n            uml.removeBlock(block);\n        }\n    };\n\n}"
    },
    "Socket": {
        "Name": "Socket",
        "Method": "Plugin",
        "Desc": "Provides a WebSocket implementation with automatic reconnection and status callbacks.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "var socket = Q.Socket('ws://localhost:8080', console.log, console.log);",
        "Script": "Q.Socket = function (url, onMessage, onStatus, options = {}) {\n    const { retries = 5, delay = 1000, protocols = [] } = options;\n    let socket, attempts = 0;\n\n    const connect = () => {\n        socket = new WebSocket(url, protocols);\n        socket.onopen = () => { onStatus?.('connected'); attempts = 0; };\n        socket.onmessage = event => onMessage?.(event.data);\n        socket.onerror = error => onStatus?.('error', error);\n        socket.onclose = () => {\n            if (++attempts <= retries) {\n                onStatus?.('closed');\n                setTimeout(connect, delay);\n            } else {\n                onStatus?.('Max retries exceeded');\n            }\n        };\n    };\n    connect();\n\n    return {\n        send: msg => socket.readyState === WebSocket.OPEN && socket.send(msg),\n        reconnect: () => connect(),\n        close: () => socket.close()\n    };\n};"
    },
    "Storage": {
        "Name": "Storage",
        "Method": "Plugin",
        "Desc": "Provides methods to store and retrieve data from the local storage.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "Q.Storage('key', 'value to store'); Q.Storage('key'); // returns 'value to store'",
        "Script": "Q.Storage = function (key, value) {\n    if (arguments.length === 2) { \n        if (value === null || value === '') { \n            localStorage.removeItem(key); \n        } else {\n            localStorage.setItem(key, JSON.stringify(value)); \n        }\n    } else if (arguments.length === 1) { \n        let storedValue = localStorage.getItem(key); \n        try {\n            return JSON.parse(storedValue); \n        } catch (e) {\n            return storedValue; \n        }\n    }\n};"
    },
    "String": {
        "Name": "String",
        "Method": "Plugin",
        "Desc": "Provides methods to manipulate strings.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "Q.String('hello').capitalize(); // returns 'Hello'",
        "Script": "Q.String = function (string) {\n    if (!(this instanceof Q.String)) {\n        return new Q.String(string);\n    }\n    this.string = string;\n};\n\nQ.String.prototype.capitalize = function () {\n    return this.string.charAt(0).toUpperCase() + this.string.slice(1);\n};\n\nQ.String.prototype.levenshtein = function (string) {\n    const a = this.string, b = string;\n    const matrix = Array.from({ length: a.length + 1 }, (_, i) => Array.from({ length: b.length + 1 }, (_, j) => i || j));\n\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\n\nQ.String.prototype.find = function (stringOrRegex) {\n    return this.string.match(stringOrRegex);\n};\n\nQ.String.prototype.replaceAll = function (stringOrRegex, replacement) {\n    return this.string.replace(new RegExp(stringOrRegex, 'g'), replacement);\n};"
    },
    "Style": {
        "Name": "Style",
        "Method": "Plugin",
        "Desc": "Provides methods to apply global styles to the document. It's useful for applying CSS variables from JavaScript. Q.style will be removed after the styles are applied on the document ready event.",
        "variant": "plugin",
        "Dependencies": [
            "ID"
        ],
        "Type": "Plugin",
        "Example": "Q.style(':root { --color: red; } body { background-color: var(--color); }');",
        "Script": "Q.style = (function () {\n    let styleData = {\n        gen: \"\",\n        root: '',\n        element: null,\n        checked: false,\n    };\n\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib-root-styles') || createStyleElement();\n            styleData.init = true;\n        }\n\n        let finalStyles = '';\n\n        if (styleData.root) {\n            \n            finalStyles = `:root {${styleData.root}}\\n`;\n        }\n\n        finalStyles += styleData.gen;\n\n        styleData.element.textContent = finalStyles;\n    }\n\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib-root-styles';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n\n    window.addEventListener('load', () => {\n        console.log('Styles plugin loaded.');\n\n        \n        delete Q.style;\n\n    }, { once: true });\n\n    return function (styles, mapping = null, obfuscate = false) {\n        if (typeof styles === 'string') {\n            const rootContentMatch = styles.match(/:root\\s*{([^}]*)}/);\n            if (rootContentMatch) {\n                styles = styles.replace(rootContentMatch[0], '');\n                const rootContent = rootContentMatch[1].split(';').map(item => item.trim()).filter(item => item);\n                styleData.root += rootContent.join(';') + ';';\n            }\n\n            \n            \n            \n            \n            \n            \n            \n\n            \n            \n            \n            \n            \n            \n\n\n            \n            if (obfuscate && mapping) {\n                const keys = Object.keys(mapping);\n                keys.forEach((key) => {\n                    let newKey = Q.ID(5, '_');\n\n                    \n                    styles = styles.replace(new RegExp(`\\\\b${key}\\\\b`, 'gm'), newKey);\n                    \n                    mapping[key] = mapping[key].replace(key, newKey);\n\n\n\n                });\n            }\n\n\n\n            styleData.gen += styles;\n\n            applyStyles();\n                return mapping;\n        } else {\n            console.error('Invalid styles parameter. Expected a string.');\n        }\n    };\n})();"
    },
    "Task": {
        "Name": "Task",
        "Method": "Plugin",
        "Desc": "Provides methods to run tasks asynchronously and handle their completion or failure. Basically a Promise wrapper, but with more control.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "var task = Q.Task('task1', () => console.log('Task 1'), () => console.log('Task 2')); task.Run();",
        "Script": "Q.Task = (function () {\n    const tasks = {};\n    const runningTasks = {};\n\n    function createTask(id) {\n        if (!tasks[id]) {\n            tasks[id] = [];\n        }\n    }\n\n    function addTask(id, ...functions) {\n        if (!tasks[id]) {\n            createTask(id);\n        }\n        tasks[id].push(...functions);\n    }\n\n    async function runTask(id) {\n        if (!tasks[id] || tasks[id].length === 0) {\n            console.error(`No tasks found with ID: ${id}`);\n            return;\n        }\n\n        runningTasks[id] = {\n            doneCallback: null,\n            failCallback: null,\n            timeout: 20000, \n            timeoutCallback: null,\n        };\n\n        const { timeout, timeoutCallback } = runningTasks[id];\n        const timeoutPromise = new Promise((_, reject) => {\n            const timer = setTimeout(() => {\n                abortTask(id);\n                reject(new Error(`Task with ID: ${id} timed out after ${timeout / 1000} seconds`));\n            }, timeout);\n\n            runningTasks[id].timeoutClear = () => clearTimeout(timer);\n        });\n\n        try {\n            await Promise.race([\n                (async () => {\n                    for (const task of tasks[id]) {\n                        await new Promise((resolve, reject) => {\n                            try {\n                                const result = task();\n                                if (result instanceof Promise) {\n                                    result.then(resolve).catch(reject);\n                                } else {\n                                    resolve();\n                                }\n                            } catch (error) {\n                                reject(error);\n                            }\n                        });\n                    }\n                })(),\n                timeoutPromise\n            ]);\n\n            if (runningTasks[id]?.doneCallback) {\n                runningTasks[id].doneCallback();\n            }\n        } catch (error) {\n            console.error(`Task with ID: ${id} failed with error:`, error);\n            if (runningTasks[id]?.failCallback) {\n                runningTasks[id].failCallback(error);\n            }\n        } finally {\n            if (runningTasks[id]?.timeoutClear) {\n                runningTasks[id].timeoutClear();\n            }\n            delete runningTasks[id];\n        }\n    }\n\n    function abortTask(id) {\n        if (runningTasks[id]) {\n            delete runningTasks[id];\n            console.log(`Task with ID: ${id} has been aborted.`);\n        }\n    }\n\n    function taskDone(id, callback) {\n        if (runningTasks[id]) {\n            runningTasks[id].doneCallback = callback;\n        }\n    }\n\n    function taskFail(id, callback) {\n        if (runningTasks[id]) {\n            runningTasks[id].failCallback = callback;\n        }\n    }\n\n    function setTimeoutForTask(id, seconds) {\n        if (runningTasks[id]) {\n            runningTasks[id].timeout = seconds * 1000;\n        }\n    }\n\n    function setTimeoutCallback(id, callback) {\n        if (runningTasks[id]) {\n            runningTasks[id].timeoutCallback = callback;\n        }\n    }\n\n    return function (id, ...functions) {\n        if (functions.length > 0) {\n            addTask(id, ...functions);\n        }\n        return {\n            Run: () => runTask(id),\n            Abort: () => abortTask(id),\n            Done: callback => taskDone(id, callback),\n            Fail: callback => taskFail(id, callback),\n            Timeout: (seconds) => setTimeoutForTask(id, seconds),\n            TimeoutCallback: (callback) => setTimeoutCallback(id, callback),\n        };\n    };\n})();"
    },
    "Timer": {
        "Name": "Timer",
        "Method": "Plugin",
        "Desc": "Provides a timer implementation with automatic stop and interrupt. Useful for running tasks at intervals or for a specific duration.",
        "variant": "plugin",
        "Dependencies": [],
        "Type": "Plugin",
        "Example": "Q.Timer(() => console.log('Tick'), 'timer1', { tick: 5, delay: 1000, interrupt: true });",
        "Script": "Q.Timer = function (callback, id, options = {}) {\n    const defaultOptions = {\n        tick: 1,\n        delay: 1000,\n        interrupt: false\n    };\n\n    options = { ...defaultOptions, ...options };\n    let tickCount = 0;\n    let intervalId = null;\n\n    if (!Q.Timer.activeTimers) {\n        Q.Timer.activeTimers = new Map();\n    }\n\n    if (options.interrupt && Q.Timer.activeTimers.has(id)) {\n        clearInterval(Q.Timer.activeTimers.get(id));\n    }\n\n    intervalId = setInterval(() => {\n        callback();\n\n        tickCount++;\n        if (options.tick > 0 && tickCount >= options.tick) {\n            clearInterval(intervalId);\n            Q.Timer.activeTimers.delete(id);\n        }\n    }, options.delay);\n\n    Q.Timer.activeTimers.set(id, intervalId);\n\n    return intervalId;\n};\n\nQ.Timer.stop = function (id) {\n    if (Q.Timer.activeTimers && Q.Timer.activeTimers.has(id)) {\n        clearInterval(Q.Timer.activeTimers.get(id));\n        Q.Timer.activeTimers.delete(id);\n    }\n};\n\nQ.Timer.stopAll = function () {\n    if (Q.Timer.activeTimers) {\n        for (let intervalId of Q.Timer.activeTimers.values()) {\n            clearInterval(intervalId);\n        }\n        Q.Timer.activeTimers.clear();\n    }\n};"
    }
};

        function Highlight(code) {

            //get all texts between "" and safe escape all special html characters"
            code = code.replace(/\"(.*?)\"/g, (match, p1) => {
                return `"${p1.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}"`;
            });


            //first Q is the class name which should be colored
            code = code.replace(/Q\(/g, "<span class='class'>Q</span>(");

            // Q. is the object property which should be colored
            code = code.replace(/Q\./g, "<span class='object'>Q.</span>");


            // Replace text within parentheses
            code = code.replace(/\((.*?)\)/g, "(<span class='bracket_inner'>$1</span>)");

            // Replace text within curly braces
            code = code.replace(/\{(.*?)\}/g, "{<span class='bracket_inner'>$1</span>}");

            // Replace text within square brackets
            code = code.replace(/\[(.*?)\]/g, "[<span class='bracket_inner'>$1</span>]");

            // color the following characters: {}, (), []
            code = code.replace(/\{|\}|\(|\)|\[|\]/g, "<span class='bracket'>$&</span>");





            // color the following keywords: function, return, if, else, for, while, const, let, var
            code = code.replace(/\b(function|return|if|else|for|while|const|let|var)\b/g, "<span class='keyword'>$1</span>");

            // mark the strings.
            code = code.replace(/\"(.*?)\"/g, "<span class='string'>\"$1\"</span>");

            // mark the numbers.
            // code = code.replace(/\b(\d+)\b/g, "<span class='number'>$1</span>");

            return code;
        }


        function minify(code) {

            //remove all leading spaces
            code = code.replace(/^\s*/gm, "");


            //remove all new lines
            code = code.replace(/\n/g, "");

            return code;
        }

        function CalculateSizeKB(code) {
            return (new Blob([code]).size / 1024).toFixed(2) + " KB";
        }


        function BuildCode() {
            let depends = [];
            let code = [];
            //get the current year also separated date and time for build
            let date = new Date();
            let license = `
// VulpiniQ Utility Library
// (c) ${date.getFullYear()} VulpiniQ
// Build: ${date.toLocaleString()}
// License: MIT
`;

            const markDependencies = (deps) => {
                document.querySelectorAll(".dependent").forEach(dep => {
                    dep.classList.remove("dependent");
                });

                document.querySelectorAll(".card").forEach(card => {
                    let dataName = card.getAttribute("data-name");
                    if (deps.includes(dataName)) {
                        card.classList.add("dependent");

                        //add Script to the code
                        code.unshift(methods[dataName].Script);

                    }
                });
            }

            let genCode = document.querySelector(".gen_code");
            let minified = document.querySelector(".minified");

            let gen_size = document.querySelector(".gen_code_size");
            let minified_size = document.querySelector(".minified_size");

            //get all .card_active and collect all data-name into an array
            let activeCards = document.querySelectorAll(".card_active");
            
            activeCards.forEach(card => {
                code.push(methods[card.dataset.name].Script);
                if (methods[card.dataset.name].Dependencies) {
                    depends = depends.concat(methods[card.dataset.name].Dependencies);
                 }
            });

            markDependencies(depends);

            code = [...new Set(code)];
            
            let finalCode = source.replace("//METHODS//", code.join("\n\n")).replace("//EXTENSIONS//", "");
            finalCode = finalCode.replace(/^\s*[\r\n]/gm, "");
            let minifiedCode = minify(finalCode);

            gen_size.textContent = "Total size of this build: " + CalculateSizeKB(finalCode);
            minified_size.textContent = "Total size of this build: " + CalculateSizeKB(minifiedCode);

            

            genCode.value = license + finalCode;
            minified.value = license + minifiedCode;



        }


        document.addEventListener("DOMContentLoaded", function () {
            let container = document.querySelector(".container");
            container.innerHTML = "";

            const createCollection = (type) => {
                const collection = document.createElement("div");
                collection.classList.add("collection");
                collection.dataset.type = type;
                const title = document.createElement("div");
                title.classList.add("collection_title");
                title.textContent = type;
                collection.appendChild(title);
                const content = document.createElement("div");
                content.classList.add("collection_content");
                collection.appendChild(content);
                return collection;
            };

            const createCard = (name, desc, example, deps) => {
                const card = document.createElement("div");
                card.classList.add("card");
                card.dataset.name = name;

                const header = document.createElement("div");
                header.classList.add("card_header");
                header.textContent = name;
                card.appendChild(header);

                const description = document.createElement("div");
                description.classList.add("card_description");
                description.textContent = desc;
                card.appendChild(description);

                const cardExample = document.createElement("div");
                cardExample.classList.add("card_example");
                cardExample.innerHTML = Highlight(example);
                card.appendChild(cardExample);

                const Dependencies = document.createElement("div");
                Dependencies.classList.add("card_dependencies");

                deps.forEach(dep => {
                    const tag = document.createElement("div");
                    tag.classList.add("dependency_tag");
                    tag.textContent = dep;
                    Dependencies.appendChild(tag);
                });

                card.appendChild(Dependencies);

                card.onclick = () => {
                    card.classList.toggle("card_active");
                    BuildCode();
                };

                return card;
            };

            const addToCollection = (collection, card) => {
                //select collection with data-type attribute. if not exists, create it.
                let collectionElement = document.querySelector(`.collection[data-type="${collection}"]`);
                if (!collectionElement) {
                    collectionElement = createCollection(collection);
                    container.appendChild(collectionElement);
                }
                collectionElement.querySelector(".collection_content").appendChild(card);
            };

            Object.entries(methods).forEach(([key, value]) => {
                const card = createCard(value.Name, value.Desc, value.Example, value.Dependencies);
                addToCollection(value.Type, card);
            });



        });


    </script>


</head>

<body>

    <div class="container"></div>

    <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>

    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div>

</body>

</html>