<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>
    <link rel="stylesheet" href="builder.css">
<style>*{ margin: 0; padding: 0; box-sizing: border-box; /* outline: 1px solid rgba(255, 255, 255, 0.2); */}body{ font-family: 'Arial', sans-serif; background-color: #0e0e0e; color: #a3a3a3; line-height: 1.6; font-size: 12px;}::-webkit-scrollbar{ width: 8px; height: 8px;}::-webkit-scrollbar-track{ background: #2e2e2e;}::-webkit-scrollbar-thumb{ background: #555; border-radius: 4px;}::-webkit-scrollbar-thumb:hover{ background: #777;}.container{ display: flex;}.left_side{width: 50%;background-color: #0000003d;border-right: 1px solid #ffffff15;}.right_side{ flex-shrink: 0; width: 50%;padding-left:5px}.tab_header{display:flex;}.tab{padding: 5px 15px;cursor: pointer;}.tab.active{background: rgba(255, 255, 255, 0.2);color: #c4c4c4;}.tab_container{overflow-x: hidden;height: calc(100vh - 30px);padding: 0 5px;}.tags{display: flex;flex-wrap: wrap;}.tag{ padding: 0px 9px; margin: 3px; background: #333; border-radius: 5px; cursor: default;}.block{ cursor: default;padding:10px; background: #ffffff09; border-radius: 10px; /* outline: 1px solid #ffffff10; */ width: 100%;}.block.active{ background: #ffffff18;}.block_example{ padding: 8px; background: #00000033; border-radius: 12px; width: 100%; margin-top: 10px;}.code_content{ display: grid; grid-template-columns: repeat(2, 1fr); /* Create 3 equal columns */ gap: 10px; /* Add gap between grid items */}.block_dependencies{ margin-top: 10px;}.block_title{ font-size: 16px; font-weight: bold; margin-bottom: 20px;}.code_category_title{ font-size: 20px; font-weight: bold; margin: 15px 0}.code_category{margin-bottom: 40px;}.codeData{ padding: 10px; background: #00000033; border-radius: 12px; width: calc(100% - 10px); height: 200px; margin-top: 10px; color: #a3a3a3; text-align: justify; border: 1px solid #ffffff10; box-sizing: border-box; margin: 5px; resize: vertical; max-height: 400px;}.codeData:focus{ outline: none;}.footer{display:flex;}.sizedata{ margin: 0 20px; display: flex; align-items: center;}.btn{ padding: 5px 10px; background: #333; color: #a3a3a3; border: none; border-radius: 5px; cursor: pointer;}.tab_content{ display: none;}.tab_content.active{ display: block;}.bracket{ color: #e7e192;}.bracket_inner{ color: #96a8f5;}.class,.object{ color: #bb6485; font-weight: bold;}.keyword{ color: #f78c6c;}.operator{ color: #ff5370;}.method{ color: #82aaff;}.string{ color: #d8a378; font-weight: bold;}.number{ color: #f78c6c;}.comment{ color: #428f59 !important;}</style>
<script>
var DATA = {
    "frame": "const Q = (() => {\n    'use strict';\n    const _ob = Object, _ar = Array, _ma = Math, _da = Date, _re = RegExp, \n          _st = setTimeout, _un = undefined, _n = null, _nl = NodeList,\n          _el = Element, _si = setInterval, _c = console, _ct = clearTimeout,\n          _ci = clearInterval, _pr = Promise, _str = String, _nu = Number,\n          _bo = Boolean, _json = JSON, _map = Map, _set = Set, _sym = Symbol,\n          _win = window, _doc = document, _loc = location, _hist = history,\n          _ls = localStorage, _ss = sessionStorage, _f = fetch, _ev = Event,\n          _ac = AbortController, _as = AbortSignal, _err = Error;\n    let GLOBAL = {};\n    let styleData = {\n        root: '',\n        generic: \"\",\n        responsive: {},\n        element: _n,\n        init: false\n    };\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib-root-styles') || createStyleElement();\n            styleData.init = true;\n        }\n        let finalStyles = styleData.root ? `:root {${styleData.root}}\\n` : '';\n        finalStyles += styleData.generic;\n        const breakpoints = _ob.keys(styleData.responsive);\n        for (let i = 0; i < breakpoints.length; i++) {\n            const size = breakpoints[i];\n            const css = styleData.responsive[size];\n            if (css) {\n                finalStyles += `\\n@media (max-width: ${size}) {\\n${css}\\n}`;\n            }\n        }\n        styleData.element.textContent = finalStyles;\n    }\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib-root-styles';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n    window.addEventListener('load', applyStyles, { once: true });\n    function Q(identifier, attributes, props) {\n        if (!(this instanceof Q)) return new Q(identifier, attributes, props);\n        if (identifier && identifier.nodeType) { \n            this.nodes = [identifier];\n            return;\n        }\n        if (identifier instanceof Q) {\n            this.nodes = identifier.nodes;\n            return;\n        }\n        if (identifier?.constructor === _nl) {\n            this.nodes = _ar.from(identifier);\n            return;\n        }\n        if (typeof identifier === 'string') { \n            const isCreating = attributes || identifier.indexOf('<') > -1;\n            if (isCreating) {\n                const template = document.createElement('template');\n                template.innerHTML = identifier.trim();\n                this.nodes = _ar.from(template.content.childNodes);\n                if (attributes) {\n                    const attrEntries = _ob.entries(attributes);\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = attrEntries.length; j < m; j++) {\n                            const [attr, val] = attrEntries[j];\n                            if (attr === 'class') {\n                                element.classList.add(...(Array.isArray(val) ? val : val.split(/\\s+/)));\n                            } else if (attr === 'style') {\n                                if (typeof val === 'object') {\n                                    const styleEntries = _ob.entries(val);\n                                    for (let k = 0, p = styleEntries.length; k < p; k++) {\n                                        const [prop, propVal] = styleEntries[k];\n                                        element.style[prop] = propVal;\n                                    }\n                                } else {\n                                    element.style.cssText = val;\n                                }\n                            } else if (attr === 'text') {\n                                element.textContent = val;\n                            } else if (attr === 'html') {\n                                element.innerHTML = val;\n                            } else {\n                                element.setAttribute(attr, val);\n                            }\n                        }\n                    }\n                }\n                if (props) {\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = props.length; j < m; j++) {\n                            element[props[j]] = true;\n                        }\n                    }\n                }\n            } else {\n                this.nodes = _ar.from(document.querySelectorAll(identifier));\n            }\n        }\n    }\n    Q.Ext = (methodName, functionImplementation) =>\n        (Q.prototype[methodName] = functionImplementation, Q);\n    Q.getGLOBAL = key => GLOBAL[key];\n    Q.setGLOBAL = value => (GLOBAL = { ...GLOBAL, ...value });\n    Q.style = (root = _n, style = '', responsive = _n, mapping = _n) => {\n        if (mapping) {\n            const keys = _ob.keys(mapping);\n            keys.forEach((key) => {\n                let newKey = Q.ID ? Q.ID(5, '_') : `_${_ma.random().toString(36).substring(2, 7)}`;\n                if (style && typeof style === 'string') {\n                    style = style.replace(new _re(`\\\\.${key}\\\\b`, 'gm'), `.${newKey}`);\n                    style = style.replace(new _re(`^\\\\s*\\\\.${key}\\\\s*{`, 'gm'), `.${newKey} {`);\n                    style = style.replace(new _re(`(,\\\\s*)\\\\.${key}\\\\b`, 'gm'), `$1.${newKey}`);\n                    style = style.replace(new _re(`(\\\\s+)\\\\.${key}\\\\b`, 'gm'), `$1.${newKey}`);\n                }\n                mapping[key] = mapping[key].replace(key, newKey);\n            });\n        }\n        if (root && typeof root === 'string') {\n            styleData.root += root.trim() + ';';\n        }\n        if (style && typeof style === 'string') {\n            styleData.generic += style;\n        }\n        if (responsive && typeof responsive === 'object') {\n            const breakpoints = _ob.entries(responsive);\n            for (let i = 0; i < breakpoints.length; i++) {\n                const [size, css] = breakpoints[i];\n                if (css && typeof css === 'string') {\n                    if (!styleData.responsive[size]) {\n                        styleData.responsive[size] = '';\n                    }           \n                    styleData.responsive[size] += css + '\\n';\n                }\n            }\n        }\n        if (document.readyState === 'complete') {\n            applyStyles();\n        }  \n        return mapping;\n    };\n    Q._ = {\n        ob: _ob, ar: _ar, ma: _ma, da: _da, re: _re, st: _st, un: _un,\n        n: _n, nl: _nl, el: _el, si: _si, c: _c, ct: _ct, ci: _ci,\n        pr: _pr, str: _str, nu: _nu, bo: _bo, json: _json, map: _map,\n        set: _set, sym: _sym, win: _win, doc: _doc, loc: _loc, hist: _hist,\n        ls: _ls, ss: _ss, f: _f, ev: _ev, ac: _ac, as: _as, err: _err\n    };\n    return Q;\n})();",
    "basics": {
        "Done": {
            "uuid": "98cced47-e716-47c9-9c6b-a1591831bcac",
            "name": "Done",
            "method": "Static",
            "desc": "Registers one or more callback functions to be executed once the window has completely loaded.",
            "type": "Event Handling",
            "example": "// Basic usage - single callback\nQ.Done(() => {\n    console.log('Window has fully loaded');\n    document.body.style.opacity = '1';\n});\n\n// Multiple callbacks - executed in order\nQ.Done(() => {\n    // Initialize main application\n    initApp();\n});\n\nQ.Done(() => {\n    // Show UI elements\n    document.querySelector('#app').style.display = 'block';\n    document.querySelector('#loader').style.display = 'none';\n});",
            "dependencies": [],
            "script": "Q.Done=((c)=>{\n    window.addEventListener(\"load\",()=>{while(c.length)c.shift()();c=0});\n    return f=>c?c.push(f):f()\n})([])"
        },
        "Leaving": {
            "uuid": "d5c1b3eb-dfa8-4654-880c-7676aafa0e1f",
            "name": "Leaving",
            "method": "Static",
            "desc": "Registers callbacks to be executed when the window is about to be unloaded.",
            "type": "Event Handling",
            "example": "// Warn about unsaved changes\nQ.Leaving((event) => {\n    if (hasUnsavedChanges()) {\n        event.returnValue = 'You have unsaved changes. Are you sure you want to leave?';\n    }\n});\n\n// Save application state\nQ.Leaving((event) => {\n    localStorage.setItem('appState', JSON.stringify(getCurrentState()));\n    sessionStorage.setItem('lastVisited', new Date().toISOString());\n});",
            "dependencies": [],
            "script": "Q.Leaving=((c)=>{\n    let ev;\n    window.addEventListener(\"beforeunload\",e=>{\n      ev=e;while(c.length)c.shift()(e);c=0\n    });\n    return f=>c?c.push(f):f(ev)\n  })([])"
        },
        "Ready": {
            "uuid": "16913780-15b4-4c5e-96bb-fa51e04f7f07",
            "name": "Ready",
            "method": "Static",
            "desc": "Registers callbacks to be executed once the DOM is fully loaded and parsed.",
            "type": "Event Handling",
            "example": "// Basic initialization\nQ.Ready(() => {\n    const app = document.querySelector('#app');\n    app.classList.remove('loading');\n});\n\n// Set up event listeners\nQ.Ready(() => {\n    document.querySelectorAll('.nav-link').forEach(link => {\n        link.addEventListener('click', handleNavigation);\n    });\n});",
            "dependencies": [],
            "script": "Q.Ready=((c)=>{\n    document.readyState==='loading'?document.addEventListener(\"DOMContentLoaded\",()=>{while(c.length)c.shift()();c=0},{once:1}):c=0;\n    return f=>c?c.push(f):f();\n  })([])"
        },
        "Resize": {
            "uuid": "8cb431ec-12bf-407c-b1d6-78ab261a325c",
            "name": "Resize",
            "method": "Static",
            "desc": "Registers callbacks to be executed whenever the window is resized, providing the updated width and height.",
            "type": "Event Handling",
            "example": "Q.Resize((width, height) => {\n    const sidebar = document.querySelector('.sidebar');\n    sidebar.style.display = width < 768 ? 'none' : 'block';\n});\n\nQ.Resize((width, height) => {\n    const baseFontSize = Math.max(14, Math.min(18, width / 100));\n    document.documentElement.style.fontSize = `${baseFontSize}px`;\n});",
            "dependencies": [],
            "script": "Q.Resize=((c)=>{\n    addEventListener(\"resize\",()=>{\n      for(let i=0,l=c.length;i<l;) c[i++](innerWidth,innerHeight)\n    });\n    return f=>c.push(f)\n  })([])"
        }
    },
    "methods": {
        "addClass": {
            "uuid": "f83ba996-4b20-4baf-a624-22a7bbe91bfe",
            "name": "addClass",
            "method": "Prototype",
            "desc": "Adds one or more classes to each node, ignoring duplicates.",
            "type": "Class Manipulation",
            "example": "Q(selector).addClass(\"class1\"); // Adds a single class\nQ(selector).addClass(\"class1 class2\"); // Adds multiple classes",
            "dependencies": [],
            "script": "Q.Ext('addClass', function (classes) {\n    var b = classes.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].classList.add.apply(nodes[i].classList, b);\n    }\n    return this;\n});"
        },
        "after": {
            "uuid": "b6944194-8689-484c-95d5-dfd5de8e7da4",
            "name": "after",
            "method": "Prototype",
            "desc": "Inserts content after each element in the current set of matched elements.",
            "type": "DOM Manipulation",
            "example": "Q(selector).after(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML\nQ(selector).after(document.createElement(\"div\")); // Adds a div element\nQ(selector).after(Q(otherSelector)); // Inserts a Q object\nQ(selector).after([document.createElement(\"span\"), document.createElement(\"img\")]); // Inserts multiple elements",
            "dependencies": [],
            "script": "Q.Ext('after', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const target = nodes[i];\n    const parent = target.parentNode;\n    if (!parent) continue;\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const content = contents[j];\n      if (typeof content === \"string\") {\n        target.insertAdjacentHTML('afterend', content);\n      } else if (content?.nodeType === 1) {\n        if (target.nextSibling) {\n          parent.insertBefore(content, target.nextSibling);\n        } else {\n          parent.appendChild(content);\n        }\n      } else if (content instanceof Q) {\n        if (target.nextSibling) {\n          parent.insertBefore(content.nodes[0], target.nextSibling);\n        } else {\n          parent.appendChild(content.nodes[0]);\n        }\n      } else if (Array.isArray(content) || content?.constructor === NodeList) {\n        const subNodes = Array.from(content);\n        let nextSibling = target.nextSibling;\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          if (nextSibling) {\n            parent.insertBefore(subNodes[k], nextSibling);\n            nextSibling = subNodes[k].nextSibling;\n          } else {\n            parent.appendChild(subNodes[k]);\n          }\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "animate": {
            "uuid": "ef1efe04-ab53-4c53-9ee3-a9183ad1c5b2",
            "name": "animate",
            "method": "Prototype",
            "desc": "Animates each node using specified CSS properties over a given duration, with an optional callback when complete.",
            "type": "Animation",
            "example": "Q(selector).animate(500, { opacity: 0 }, () => { console.log('Fade out complete'); }); // Fades out over 500ms\nQ(selector).animate(1000, { left: \"100px\", top: \"50px\" }); // Moves to new position in 1 second\nQ(selector).animate(700, { opacity: 1, backgroundColor: \"#ff0000\" }, () => { alert('Animation finished!'); }); // Changes opacity and background color",
            "dependencies": [
                "each"
            ],
            "script": "Q.Ext('animate', function (duration, b, e) {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var f = nodes[i],\n        keys = Object.keys(b),\n        c = '';\n    for (var j = 0, klen = keys.length; j < klen; j++) {\n      c += keys[j] + ' ' + duration + 'ms' + (j < klen - 1 ? ', ' : '');\n    }\n    f.style.transition = c;\n    for (var j = 0; j < klen; j++) {\n      var d = keys[j];\n      f.style[d] = b[d];\n    }\n    if (typeof e === 'function') {\n      setTimeout((function(g){\n          return function(){ e.call(g); };\n      })(f), duration);\n    }\n  }\n  return this;\n});"
        },
        "append": {
            "uuid": "7a28c580-c71a-4e4d-b524-12fb04c90e66",
            "name": "append",
            "method": "Prototype",
            "desc": "Appends child nodes, HTML, or multiple elements to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).append(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML\nQ(selector).append(document.createElement(\"div\")); // Adds a div element\nQ(selector).append(Q(otherSelector)); // Appends a Q object\nQ(selector).append([document.createElement(\"span\"), document.createElement(\"img\")]); // Appends multiple elements\nQ(selector).append(document.querySelectorAll(\".items\")); // Appends a NodeList of elements",
            "dependencies": [],
            "script": "Q.Ext('append', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const child = contents[j];\n      if (typeof child === \"string\") {\n        parent.insertAdjacentHTML('beforeend', child);\n      } else if (child?.nodeType === 1 || child instanceof Q) {\n        parent.appendChild(child.nodes ? child.nodes[0] : child);\n      } else if (Array.isArray(child) || child?.constructor === NodeList) {\n        const subNodes = Array.from(child);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.appendChild(subNodes[k]);\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "attr": {
            "uuid": "ead1b924-88b6-4407-b3f9-e64421e57eb6",
            "name": "attr",
            "method": "Prototype",
            "desc": "Gets or sets attributes on the nodes, supporting multiple attributes at once.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).attr(\"id\", \"newId\"); // Sets the \"id\" attribute to \"newId\" <br> Q(selector).attr({ \"src\": \"image.jpg\", \"alt\": \"An image\" }); // Sets multiple attributes <br> Q(selector).attr(\"href\"); // Gets the \"href\" attribute value",
            "dependencies": [],
            "script": "Q.Ext('attr', function (attribute, value) {\n    var nodes = this.nodes;\n    if (typeof attribute === 'object') {\n        var keys = Object.keys(attribute);\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            var node = nodes[i];\n            for (var j = 0, klen = keys.length; j < klen; j++) {\n                node.setAttribute(keys[j], attribute[keys[j]]);\n            }\n        }\n        return this;\n    } else {\n        if (value === undefined) {\n            return nodes[0] && nodes[0].getAttribute(attribute) || null;\n        }\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            nodes[i].setAttribute(attribute, value);\n        }\n        return this;\n    }\n});"
        },
        "before": {
            "uuid": "99dd1c2f-1f24-4675-a2f9-523b3066b14d",
            "name": "before",
            "method": "Prototype",
            "desc": "Inserts content before each element in the current set of matched elements.",
            "type": "DOM Manipulation",
            "example": "Q(selector).before(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML\nQ(selector).before(document.createElement(\"div\")); // Adds a div element\nQ(selector).before(Q(otherSelector)); // Inserts a Q object\nQ(selector).before([document.createElement(\"span\"), document.createElement(\"img\")]); // Inserts multiple elements",
            "dependencies": [],
            "script": "Q.Ext('before', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const target = nodes[i];\n    const parent = target.parentNode;\n    if (!parent) continue;\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const content = contents[j];\n      if (typeof content === \"string\") {\n        target.insertAdjacentHTML('beforebegin', content);\n      } else if (content?.nodeType === 1) {\n        parent.insertBefore(content, target);\n      } else if (content instanceof Q) {\n        parent.insertBefore(content.nodes[0], target);\n      } else if (Array.isArray(content) || content?.constructor === NodeList) {\n        const subNodes = Array.from(content);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.insertBefore(subNodes[k], target);\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "bind": {
            "uuid": "63f71459-f5b4-4afe-980c-67d0dd640c86",
            "name": "bind",
            "method": "Prototype",
            "desc": "Adds an event listener to each node, allowing for event delegation to improve performance.",
            "type": "Event Handling",
            "example": "Q(selector).bind(\"click\", () => console.log(\"Clicked\")); // Logs \"Clicked\" when any matching node is clicked <br> Q('.btn').bind(\"mouseover\", (e) => { console.log(`Hovered over: ${e.target.tagName}`); }); // Logs the tag name of the hovered element",
            "dependencies": [],
            "script": "Q.Ext('bind', function (event, handler) {\n    if (!this._eventDelegation) {\n        this._eventDelegation = {};\n    }\n    if (!this._eventDelegation[event]) {\n        document.addEventListener(event, (e) => {\n            var nodes = this.nodes;\n            for (var i = 0, l = nodes.length; i < l; i++) {\n                if (nodes[i].contains(e.target)) {\n                    handler.call(e.target, e);\n                }\n            }\n        });\n        this._eventDelegation[event] = true;\n    }\n    return this;\n});"
        },
        "blur": {
            "uuid": "aa32e77f-0584-4a07-a826-541281936b5f",
            "name": "blur",
            "method": "Prototype",
            "desc": "Removes focus from the first node in the selection, effectively blurring it.",
            "type": "Form Manipulation",
            "example": "Q(selector).blur(); // Removes focus from the first matched input field <br> Q('.active').blur(); // Blurs the first active element <br> Q('textarea').blur(); // Blurs the first textarea in the selection",
            "dependencies": [],
            "script": "Q.Ext('blur', function () {\n    var nodes = this.nodes; // ...existing code...\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].blur();\n    }\n    return this;\n});"
        },
        "children": {
            "uuid": "25edb49b-f439-40fc-809a-8d4fe8325043",
            "name": "children",
            "method": "Prototype",
            "desc": "Gets the children of each element in the set of matched elements.",
            "type": "DOM Traversal",
            "example": "Q(selector).children(); // Returns all direct children\nQ(selector).children('.specific-class'); // Returns children with the specified class\nQ(selector).children('[data-attribute=\"value\"]'); // Returns children with the specified attribute",
            "dependencies": [],
            "script": "Q.Ext('children', function (selector) {\n  const result = [];\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    const children = parent.children; // Get HTMLCollection of children\n    if (children) {\n      const childrenArray = Array.from(children);\n      if (selector) {\n        for (let j = 0, clen = childrenArray.length; j < clen; j++) {\n          const child = childrenArray[j];\n          if (child.matches && child.matches(selector)) {\n            result.push(child);\n          }\n        }\n      } else {\n        for (let j = 0, clen = childrenArray.length; j < clen; j++) {\n          result.push(childrenArray[j]);\n        }\n      }\n    }\n  }\n  return new Q(result);\n});"
        },
        "click": {
            "uuid": "d2cc565e-91ba-410e-9456-f59b5a3620a1",
            "name": "click",
            "method": "Prototype",
            "desc": "Simulates a click event on each node in the selection.",
            "type": "Event Handling",
            "example": "Q(selector).click();",
            "dependencies": [],
            "script": "Q.Ext('click', function () {\n    var nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].click();\n    }\n    return this;\n});"
        },
        "clone": {
            "uuid": "65f93ff9-3231-4fb9-b25d-a608c019b68b",
            "name": "clone",
            "method": "Prototype",
            "desc": "Creates a deep copy of the first node in the selection, including its child nodes.",
            "type": "DOM Manipulation",
            "example": "Q(selector).clone();",
            "dependencies": [],
            "script": "Q.Ext('clone', function () {\n    return new Q(this.nodes[0].cloneNode(true));\n});"
        },
        "closest": {
            "uuid": "215cfda9-64e5-41b4-82b2-129eeede5e89",
            "name": "closest",
            "method": "Prototype",
            "desc": "Finds the nearest ancestor node of the first node that matches a given selector.",
            "type": "Traversal",
            "example": "Q(selector).closest(\".parent\");",
            "dependencies": [],
            "script": "Q.Ext('closest', function (selector) {\n    let node = this.nodes[0];\n    while (node) {\n        if (node.matches && node.matches(selector)) {\n            return new Q(node);\n        }\n        node = node.parentElement;\n    }\n    return null;\n});"
        },
        "css": {
            "uuid": "2700a830-0676-42d3-8fa5-01ef5e225ab8",
            "name": "css",
            "method": "Prototype",
            "desc": "Retrieves or sets CSS styles on the selected nodes. Supports setting multiple styles if provided as an object.",
            "type": "Style Manipulation",
            "example": "Q(selector).css('color', 'red');",
            "dependencies": [],
            "script": "Q.Ext('css', function(property, value) {\n  const nodes = this.nodes;\n  if (typeof property === 'object') {\n      for (let i = 0, len = nodes.length; i < len; i++) {\n          const style = nodes[i].style;\n          for (const key in property) {\n              style[key] = property[key];\n          }\n      }\n      return this;\n  }\n  if (value === Q._.un) return getComputedStyle(nodes[0])[property];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].style[property] = value;\n  }\n  return this;\n});"
        },
        "data": {
            "uuid": "61128515-bfab-4ca0-a67e-66fc35b436ef",
            "name": "data",
            "method": "Prototype",
            "desc": "Retrieves or sets data-* attributes on the selected nodes. Provides an easy way to store and access custom data associated with the elements.",
            "type": "Data Manipulation",
            "example": "Q(selector).data('userId', 123);",
            "dependencies": [],
            "script": "Q.Ext('data', function (key, value) {\n    const nodes = this.nodes;\n    if (value === Q._.un) {\n        return nodes[0] && nodes[0].dataset[key] || Q._.n;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].dataset[key] = value;\n    }\n    return this;\n});"
        },
        "each": {
            "uuid": "acf2cd61-6e52-4bed-ba59-0e44ab112eea",
            "name": "each",
            "method": "Prototype",
            "desc": "Iterates over all nodes in the Q object and executes a callback on each node, providing access to the index and element.",
            "type": "Iteration",
            "example": "Q(selector).each((index, element) => console.log(index, element));",
            "dependencies": [],
            "script": "Q.Ext('each', function (callback) {\n    if (!this.nodes) return this;\n    const nodes = this.nodes;\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        callback.call(nodes[i], i, nodes[i]);\n    }\n    return this;\n});"
        },
        "empty": {
            "uuid": "8e94168f-e84b-4414-9efa-b0f18f54d434",
            "name": "empty",
            "method": "Prototype",
            "desc": "Empties the innerHTML of each node.",
            "type": "Content Manipulation",
            "example": "Q(selector).empty();",
            "dependencies": [],
            "script": "Q.Ext('empty', function () {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].innerHTML = '';\n  }\n  return this;\n});"
        },
        "eq": {
            "uuid": "3c54e528-fba2-46da-9212-da1cd104ad29",
            "name": "eq",
            "method": "Prototype",
            "desc": "Returns a specific node by index.",
            "type": "Traversal",
            "example": "Q(selector).eq(1);",
            "dependencies": [],
            "script": "Q.Ext('eq', function (index) {\n  var node = this.nodes[index];\n  return node ? new Q(node) : null;\n});"
        },
        "fadeIn": {
            "uuid": "ad310171-aa44-4cc4-934f-973a20912e1f",
            "name": "fadeIn",
            "method": "Prototype",
            "desc": "Fades in each node.",
            "type": "Display",
            "example": "Q(selector).fadeIn(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeIn', function(duration, callback) {\n    duration = duration || 400;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.display = '';\n            style.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            style.opacity = 1;\n            setTimeout(function() {\n                style.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeOut": {
            "uuid": "6dda0dcc-e42f-474f-ab51-b071fec409a1",
            "name": "fadeOut",
            "method": "Prototype",
            "desc": "Fades out each node.",
            "type": "Display",
            "example": "Q(selector).fadeOut(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeOut', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.transition = 'opacity ' + duration + 'ms';\n            style.opacity = 0;\n            setTimeout(function() {\n                style.transition = '';\n                style.display = 'none';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeTo": {
            "uuid": "07432232-a617-4c27-a77c-d38987bfe773",
            "name": "fadeTo",
            "method": "Prototype",
            "desc": "Fades each node to a specific opacity.",
            "type": "Display",
            "example": "Q(selector).fadeTo(opacity, duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeTo', function(opacity, duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            style.opacity = opacity;\n            setTimeout(function() {\n                style.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeToggle": {
            "uuid": "b7fa0b3e-620b-4c1d-8ad2-820286648875",
            "name": "fadeToggle",
            "method": "Prototype",
            "desc": "Toggles the fade state of each node.",
            "type": "Display",
            "example": "Q(selector).fadeToggle(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeToggle', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var computed = window.getComputedStyle(nodes[i]);\n        if (computed.opacity === '0') {\n            this.fadeIn(duration, callback);\n        } else {\n            this.fadeOut(duration, callback);\n        }\n    }\n    return this;\n});"
        },
        "find": {
            "uuid": "c6dae30f-070b-4b3e-9bad-201d4a465df1",
            "name": "find",
            "method": "Prototype",
            "desc": "Finds child nodes of the first node that match a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).find(\".child\");",
            "dependencies": [],
            "script": "Q.Ext('find', function(selector) {\n    var parent = this.nodes[0];\n    if (!parent) return null;\n    var found = parent.querySelectorAll(selector);\n    return found.length ? Q(found) : null;\n});"
        },
        "first": {
            "uuid": "e9a4a8b7-50bd-453c-9ed9-b0156d064324",
            "name": "first",
            "method": "Prototype",
            "desc": "Returns the first node.",
            "type": "Traversal",
            "example": "Q(selector).first();",
            "dependencies": [],
            "script": "Q.Ext('first', function () {\n    return new Q(this.nodes[0]);\n});"
        },
        "focus": {
            "uuid": "03c6fde9-bab8-4bd0-bdb0-65661a1e3007",
            "name": "focus",
            "method": "Prototype",
            "desc": "Focuses on the first node.",
            "type": "Form Manipulation",
            "example": "Q(selector).focus();",
            "dependencies": [],
            "script": "Q.Ext('focus', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].focus();\n    }\n    return this;\n});"
        },
        "hasClass": {
            "uuid": "5684310d-4760-4c2f-9b79-e613653517cb",
            "name": "hasClass",
            "method": "Prototype",
            "desc": "Checks if the first node has a specific class.",
            "type": "Class Manipulation",
            "example": "Q(selector).hasClass(className);",
            "dependencies": [],
            "script": "Q.Ext('hasClass', function(className) {\n    var node = this.nodes[0];\n    return (node && node.classList.contains(className)) || false;\n});"
        },
        "height": {
            "uuid": "2906d79f-da85-48fb-a27c-b5f8269c125b",
            "name": "height",
            "method": "Prototype",
            "desc": "Gets or sets the height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).height(value);",
            "dependencies": [],
            "script": "Q.Ext('height', function (value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0].offsetHeight;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.height = value;\n    }\n    return this;\n});"
        },
        "hide": {
            "uuid": "b415545d-61c6-44cb-adc8-3733f559e14b",
            "name": "hide",
            "method": "Prototype",
            "desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).hide(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('hide', function (duration, callback) {\n    duration = duration || 0;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        if (duration === 0) {\n            node.style.display = 'none';\n            if (callback) callback();\n        } else {\n            node.style.transition = 'opacity ' + duration + 'ms';\n            node.style.opacity = 1;\n            setTimeout((function(n) {\n                return function() {\n                    n.style.opacity = 0;\n                    n.addEventListener('transitionend', function handler() {\n                        n.style.display = 'none';\n                        n.style.transition = '';\n                        n.removeEventListener('transitionend', handler);\n                        if (callback) callback();\n                    });\n                };\n            })(node), 0);\n        }\n    }\n    return this;\n});"
        },
        "html": {
            "uuid": "07196f69-f8c2-4119-8238-2781df12f0da",
            "name": "html",
            "method": "Prototype",
            "desc": "Gets or sets the innerHTML of the nodes. This method allows for easy manipulation of the content inside the selected elements.",
            "type": "Content Manipulation",
            "example": "const currentHtml = Q(selector).html(); // Retrieves the innerHTML of the first selected element <br> Q(selector).html('<div>New Content</div>'); // Sets the innerHTML of each selected element to '<div>New Content</div>' <br> Q(selector).html(['<span>First</span>', '<span>Second</span>']); // Sets the innerHTML with an array of strings <br> const newNode = Q('<p>Paragraph</p>'); Q(selector).html(newNode); // Sets the innerHTML with a Q object containing a new node <br> Q(selector).html(document.createElement('div')); // Sets the innerHTML with a new HTMLElement <br> const nodeList = document.querySelectorAll('.child'); Q(selector).html(nodeList); // Sets the innerHTML with a NodeList of child elements <br> Q(selector).html([]); // Sets the innerHTML to an empty string <br> Q(selector).html(null); // Sets the innerHTML to an empty string",
            "dependencies": [],
            "script": "Q.Ext('html', function (content) {\n    var nodes = this.nodes;\n    if (content === undefined) {\n        return nodes[0] ? nodes[0].innerHTML : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        node.innerHTML = '';\n        var appendContent = function(child) {\n            if (typeof child === 'string') {\n                node.insertAdjacentHTML('beforeend', child);\n            } else if (child instanceof Q) {\n                for (var j = 0, clen = child.nodes.length; j < clen; j++) {\n                    node.appendChild(child.nodes[j]);\n                }\n            } else if (child?.nodeType === 1 || child?.nodeType != null) {\n                node.appendChild(child);\n            } else if (Array.isArray(child) || child?.constructor === NodeList) {\n                var subs = Array.from(child);\n                for (var k = 0, slen = subs.length; k < slen; k++) {\n                    node.appendChild(subs[k]);\n                }\n            }\n        };\n        if (Array.isArray(content) || content?.constructor === NodeList) {\n            var contArr = Array.from(content);\n            for (var m = 0, mlen = contArr.length; m < mlen; m++) {\n                appendContent(contArr[m]);\n            }\n        } else {\n            appendContent(content);\n        }\n    }\n    return this;\n});"
        },
        "id": {
            "uuid": "6082da57-0db4-4a5c-9818-982550a57da8",
            "name": "id",
            "method": "Prototype",
            "desc": "Gets or sets the id attribute of the first node.",
            "type": "Attributes",
            "example": "Q(selector).id(); // Retrieves or Q(selector).id('new-id');",
            "dependencies": [],
            "script": "Q.Ext('id', function (ident) {\n    var node = this.nodes[0];\n    if (ident === undefined) return node.id;\n    node.id = ident;\n    return this;\n});"
        },
        "index": {
            "uuid": "75f6f5a7-dd7a-40fc-b86d-be00949d6e5e",
            "name": "index",
            "method": "Prototype",
            "desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
            "type": "Traversal",
            "example": "Q(selector).index(); // Retrieves the index or Q(selector).index(2);",
            "dependencies": [],
            "script": "Q.Ext('index', function (index) {\n    var first = this.nodes[0];\n    if (index === undefined) {\n        return Array.prototype.indexOf.call(first.parentNode.children, first);\n    }\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i],\n            parent = node.parentNode;\n        if (!parent) continue;\n        var children = Array.from(parent.children);\n        parent.removeChild(node);\n        if (index >= children.length) {\n            parent.appendChild(node);\n        } else {\n            parent.insertBefore(node, children[index]);\n        }\n    }\n    return this;\n});"
        },
        "inside": {
            "uuid": "208fa2b9-2ca7-411c-b934-d6088b0be2c0",
            "name": "inside",
            "method": "Prototype",
            "desc": "Checks if the first node is inside another node, determined by a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).inside(\".parent\");",
            "dependencies": [],
            "script": "Q.Ext('inside', function (selector) {\n    var node = this.nodes[0];\n    return node ? node.closest(selector) !== null : false;\n});"
        },
        "is": {
            "uuid": "c5f760f6-bfe2-4f30-a7e7-482df9450312",
            "name": "is",
            "method": "Prototype",
            "desc": "Checks if the first node matches a specific selector or condition, allowing for dynamic queries and element comparisons.",
            "type": "Utilities",
            "example": "Q(selector).is(\":visible\"); // Checks if the element is currently visible",
            "dependencies": [],
            "script": "Q.Ext('is', function (selector) {\n    var node = this.nodes[0];\n    if (!node) return false;\n    if (typeof selector === 'function') {\n        return selector.call(node, 0, node);\n    }\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return node.offsetWidth > 0 && node.offsetHeight > 0;\n            case ':hidden':\n                return node.offsetWidth === 0 || node.offsetHeight === 0;\n            case ':hover':\n                return node === document.querySelector(':hover');\n            case ':focus':\n                return node === document.activeElement;\n            case ':blur':\n                return node !== document.activeElement;\n            case ':checked':\n                return node.checked;\n            case ':selected':\n                return node.selected;\n            case ':disabled':\n                return node.disabled;\n            case ':enabled':\n                return !node.disabled;\n            default:\n                return node.matches(selector);\n        }\n    }\n    if (selector?.nodeType === 1 || selector?.nodeType != null) {\n        return node === selector;\n    }\n    if (selector instanceof Q) {\n        return node === selector.nodes[0];\n    }\n    return false;\n});"
        },
        "isExists": {
            "uuid": "9a76d84c-7ebc-4e26-b829-98bce6fcb92a",
            "name": "isExists",
            "method": "Prototype",
            "desc": "Checks if the first node exists in the DOM.",
            "type": "Utilities",
            "example": "Q(selector).isExists(); or Q.isExists('.ok')",
            "dependencies": [],
            "script": "Q.Ext('isExists', function () {\n    var node = this.nodes[0];\n    return node ? document.body.contains(node) : false;\n});\nQ.isExists = function (selector) {\n    return document.querySelector(selector) !== null;\n};"
        },
        "last": {
            "uuid": "43b86e59-80a3-46a5-967d-07f8f83bf497",
            "name": "last",
            "method": "Prototype",
            "desc": "Returns the last node.",
            "type": "Traversal",
            "example": "Q(selector).last();",
            "dependencies": [],
            "script": "Q.Ext('last', function () {\n    var nodes = this.nodes;\n    return new Q(nodes[nodes.length - 1]);\n});"
        },
        "map": {
            "uuid": "316b9375-a4b7-462e-bf48-8807b6c8dedc",
            "name": "map",
            "method": "Prototype",
            "desc": "Maps each node to a new array.",
            "type": "Array",
            "example": "Q(selector).map(el => el.innerHTML);",
            "dependencies": [],
            "script": "Q.Ext('map', function (callback) {\n    var result = [],\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        result.push(callback(new Q(nodes[i])));\n    }\n    return result;\n});"
        },
        "off": {
            "uuid": "de479953-f607-4d8f-bfbf-ecf5cd5f860d",
            "name": "off",
            "method": "Prototype",
            "desc": "Removes an event listener from each node.",
            "type": "Event Handling",
            "example": "Q(selector).off(\"click\", handler);",
            "dependencies": [],
            "script": "Q.Ext('off', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].removeEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
        },
        "offset": {
            "uuid": "2e4783b3-a10f-40e7-bf7f-e1d1d13e13ea",
            "name": "offset",
            "method": "Prototype",
            "desc": "Returns the top and left offset of the first node relative to the document.",
            "type": "Dimensions",
            "example": "Q(selector).offset();",
            "dependencies": [],
            "script": "Q.Ext('offset', function () {\n    var node = this.nodes[0],\n        rect = node.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX\n    };\n});"
        },
        "on": {
            "uuid": "c99cc2a8-1653-4660-83bb-fa1e38498954",
            "name": "on",
            "method": "Prototype",
            "desc": "Adds an event listener to each node.",
            "type": "Event Handling",
            "example": "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
            "dependencies": [],
            "script": "Q.Ext('on', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].addEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
        },
        "parent": {
            "uuid": "dd53773d-200e-4e24-9e25-664ba3849145",
            "name": "parent",
            "method": "Prototype",
            "desc": "Returns the parent node of the first node.",
            "type": "Traversal",
            "example": "Q(selector).parent();",
            "dependencies": [],
            "script": "Q.Ext('parent', function () {\n    var node = this.nodes[0];\n    return new Q(node ? node.parentNode : null);\n});"
        },
        "position": {
            "uuid": "9f257c25-06b1-48d7-858a-3501d817ca13",
            "name": "position",
            "method": "Prototype",
            "desc": "Returns the top and left position of the first node relative to its offset parent.",
            "type": "Dimension/Position",
            "example": "Q(selector).position();",
            "dependencies": [],
            "script": "Q.Ext('position', function () {\n    var node = this.nodes[0];\n    return {\n        top: node.offsetTop,\n        left: node.offsetLeft\n    };\n});"
        },
        "prepend": {
            "uuid": "acce611a-d644-47cd-ba66-2f0f9970e220",
            "name": "prepend",
            "method": "Prototype",
            "desc": "Prepends child nodes or HTML to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).prepend(\"<div>Prepended</div>\");",
            "dependencies": [],
            "script": "Q.Ext('prepend', function () {\n    var nodes = this.nodes,\n        contents = Array.prototype.slice.call(arguments),\n        i, j, k, parent, child, subNodes;\n    for (i = 0; i < nodes.length; i++) {\n        parent = nodes[i];\n        for (j = 0; j < contents.length; j++) {\n            child = contents[j];\n            if (typeof child === 'string') {\n                parent.insertAdjacentHTML('afterbegin', child);\n            } else if (child instanceof Q) {\n                parent.insertBefore(child.nodes[0], parent.firstChild);\n            } else if (child?.nodeType === 1 || child?.nodeType != null) {\n                parent.insertBefore(child, parent.firstChild);\n            } else if (Array.isArray(child) || child?.constructor === NodeList) {\n                subNodes = Array.from(child);\n                for (k = 0; k < subNodes.length; k++) {\n                    parent.insertBefore(subNodes[k], parent.firstChild);\n                }\n            }\n        }\n    }\n    return this;\n});"
        },
        "prop": {
            "uuid": "dc0ad149-ee5c-4fc7-ab19-f3526df4ca0f",
            "name": "prop",
            "method": "Prototype",
            "desc": "Gets or sets a property on the nodes.",
            "type": "Property Manipulation",
            "example": "Q(selector).prop(property, value);",
            "dependencies": "",
            "script": "Q.Ext('prop', function (property, value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0] ? nodes[0][property] : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i][property] = value;\n    }\n    return this;\n});"
        },
        "remove": {
            "uuid": "65d7bf91-380a-4682-9715-b50b708a5b77",
            "name": "remove",
            "method": "Prototype",
            "desc": "Removes each node from the DOM.",
            "type": "DOM Manipulation",
            "example": "Q(selector).remove();",
            "dependencies": "",
            "script": "Q.Ext('remove', function() {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].remove();\n    }\n    return this;\n});"
        },
        "removeAttr": {
            "uuid": "fe6c8198-0857-400c-b36b-93dfcf16abbd",
            "name": "removeAttr",
            "method": "Prototype",
            "desc": "Removes an attribute from each node.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).removeAttr(attribute);",
            "dependencies": "",
            "script": "Q.Ext('removeAttr', function (attribute) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].removeAttribute(attribute);\n    }\n    return this;\n});"
        },
        "removeClass": {
            "uuid": "f741e5cd-91a3-4c7e-a77c-a2dabcad0168",
            "name": "removeClass",
            "method": "Prototype",
            "desc": "Removes one or more classes from each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).removeClass(\"class1 class2\");",
            "dependencies": "",
            "script": "Q.Ext('removeClass', function (classes) {\n    var list = classes.split(' ');\n    for (var i = 0, len = this.nodes.length; i < len; i++) {\n        this.nodes[i].classList.remove.apply(this.nodes[i].classList, list);\n    }\n    return this;\n});"
        },
        "removeData": {
            "uuid": "4afa5d26-c159-424e-881a-70b752dbf1b3",
            "name": "removeData",
            "method": "Prototype",
            "desc": "Removes a data-* attribute from each node.",
            "type": "Data Manipulation",
            "example": "Q(selector).removeData(key);",
            "dependencies": "",
            "script": "Q.Ext('removeData', function (key) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i].dataset[key];\n    }\n    return this;\n});"
        },
        "removeProp": {
            "uuid": "e4a51721-6323-40f3-87d3-5f2c583d1428",
            "name": "removeProp",
            "method": "Prototype",
            "desc": "Removes a property from each node.",
            "type": "Property Manipulation",
            "example": "Q(selector).removeProp(property);",
            "dependencies": "",
            "script": "Q.Ext('removeProp', function (property) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i][property];\n    }\n    return this;\n});"
        },
        "removeTransition": {
            "uuid": "d4c98abc-96e0-42b3-9e1d-0fd945e3a0fa",
            "name": "removeTransition",
            "method": "Prototype",
            "desc": "Removes the transition from each node.",
            "type": "Display",
            "example": "Q(selector).removeTransition();",
            "dependencies": "",
            "script": "Q.Ext('removeTransition', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.transition = '';\n    }\n    return this;\n});"
        },
        "scrollHeight": {
            "uuid": "27654a9c-a5cc-4ee8-a1f9-7527e9c8ba7b",
            "name": "scrollHeight",
            "method": "Prototype",
            "desc": "Returns the scroll height of the first node.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollHeight();",
            "dependencies": "",
            "script": "Q.Ext('scrollHeight', function () {\n    var node = this.nodes[0];\n    return node.scrollHeight;\n});"
        },
        "scrollLeft": {
            "uuid": "beb0c421-2c9b-43b1-8318-ae6a7d1fa2e9",
            "name": "scrollLeft",
            "method": "Prototype",
            "desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollLeft(value, increment);",
            "dependencies": "",
            "script": "Q.Ext('scrollLeft', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollLeft;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollLeft = current.scrollWidth - current.clientWidth;\n        current.scrollLeft = increment \n            ? Math.min(current.scrollLeft + value, maxScrollLeft) \n            : Math.min(value, maxScrollLeft);\n    }\n    return this;\n});"
        },
        "scrollTop": {
            "uuid": "110a611d-c4af-4e63-b5c3-2f8ca72f58e9",
            "name": "scrollTop",
            "method": "Prototype",
            "desc": "Gets or sets the vertical scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollTop(value, increment);",
            "dependencies": "",
            "script": "Q.Ext('scrollTop', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollTop;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollTop = current.scrollHeight - current.clientHeight;\n        current.scrollTop = increment \n            ? Math.min(current.scrollTop + value, maxScrollTop) \n            : Math.min(value, maxScrollTop);\n    }\n    return this;\n});"
        },
        "scrollWidth": {
            "uuid": "09bdbf5d-7c8f-41b2-ba86-ff51b2d1a55e",
            "name": "scrollWidth",
            "method": "Prototype",
            "desc": "Returns the scroll width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).scrollWidth();",
            "dependencies": "",
            "script": "Q.Ext('scrollWidth', function () {\n    var node = this.nodes[0];\n    return node.scrollWidth;\n});"
        },
        "show": {
            "uuid": "bc4f8ddf-946f-415a-95ad-f45eb25a59bd",
            "name": "show",
            "method": "Prototype",
            "desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).show(duration, callback);",
            "dependencies": "",
            "script": "Q.Ext('show', function (duration = 0, callback) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const element = this.nodes[i];\n        if (duration === 0) {\n            element.style.display = '';\n            if (callback) callback();\n        } else {\n            element.style.transition = `opacity ${duration}ms`;\n            element.style.opacity = 0;\n            element.style.display = '';\n            setTimeout(() => {\n                element.style.opacity = 1;\n                element.addEventListener('transitionend', () => {\n                    element.style.transition = '';\n                    if (callback) callback();\n                }, { once: true });\n            }, 0);\n        }\n    }\n    return this;\n});"
        },
        "size": {
            "uuid": "d869cb8a-d65a-4061-b92e-b09dba27a7a3",
            "name": "size",
            "method": "Prototype",
            "desc": "Returns the width and height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).size();",
            "dependencies": "",
            "script": "Q.Ext('size', function () {\n    const node = this.nodes[0];\n\treturn {\n\t\twidth: node.offsetWidth,\n\t\theight: node.offsetHeight\n\t};\n});"
        },
        "text": {
            "uuid": "78f7da5c-9bb0-433f-a42b-203061f3ea8a",
            "name": "text",
            "method": "Prototype",
            "desc": "Gets or sets the text content of the nodes.",
            "type": "Content Manipulation",
            "example": "Q(selector).text(string);",
            "dependencies": "",
            "script": "Q.Ext('text', function (content) {\n    if (content === undefined) {\n        return this.nodes[0]?.textContent || null;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].textContent = content;\n    }\n    return this;\n});"
        },
        "toggle": {
            "uuid": "a79eff83-d976-4cf2-b755-b7969e64c65b",
            "name": "toggle",
            "method": "Prototype",
            "desc": "Toggles the display of each node.",
            "type": "Utilities",
            "example": "Q(selector).toggle();",
            "dependencies": "",
            "script": "Q.Ext('toggle', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.display = (nodes[i].style.display === 'none' ? '' : 'none');\n    }\n    return this;\n});"
        },
        "toggleClass": {
            "uuid": "066c8d13-cbf4-4aa6-bd97-59daab911ea7",
            "name": "toggleClass",
            "method": "Prototype",
            "desc": "Toggles a class on each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).toggleClass(className);",
            "dependencies": "",
            "script": "Q.Ext('toggleClass', function (className) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].classList.toggle(className);\n    }\n    return this;\n});"
        },
        "trigger": {
            "uuid": "f520b0f3-ba4f-4469-9209-020a85908aba",
            "name": "trigger",
            "method": "Prototype",
            "desc": "Triggers a specific event on each node.",
            "type": "Event Handling",
            "example": "Q(selector).trigger(\"click\");",
            "dependencies": [],
            "script": "Q.Ext('trigger', function (event) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].dispatchEvent(new Event(event));\n    }\n    return this;\n});"
        },
        "unwrap": {
            "uuid": "d16969b7-629b-424e-b35e-141d89ebbbe9",
            "name": "unwrap",
            "method": "Prototype",
            "desc": "Removes the parent wrapper of each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).unwrap();",
            "dependencies": [],
            "script": "Q.Ext('unwrap', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const el = this.nodes[i];\n        const parent = el.parentNode;\n        if (parent && parent !== document.body) {\n            parent.replaceWith(...parent.childNodes);\n        }\n    }\n    return this;\n});"
        },
        "val": {
            "uuid": "b4f90463-b556-4d4c-9a6e-8a1cfd1218af",
            "name": "val",
            "method": "Prototype",
            "desc": "Gets or sets the value of form elements in the nodes.",
            "type": "Form Manipulation",
            "example": "Q(selector).val(value);",
            "dependencies": [],
            "script": "Q.Ext('val', function(input) {\n    if (input === undefined) return this.nodes[0]?.value || null;\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].value = input;\n    }\n    return this;\n});"
        },
        "wait": {
            "uuid": "bf0267d4-8d77-4efe-92fe-eac0144d6e61",
            "name": "wait",
            "method": "Prototype",
            "desc": "Returns a promise that resolves after a given time. Useful for delaying actions.",
            "type": "Utility",
            "example": "Q('.text').wait(1000).text('Hello, World!');",
            "dependencies": [],
            "script": "Q.Ext('wait', function(ms) {\n\treturn new Promise(resolve => setTimeout(() => resolve(this), ms));\n});"
        },
        "walk": {
            "uuid": "53d4c3d7-2589-4aaa-bc8a-04fc7f551796",
            "name": "walk",
            "method": "Prototype",
            "desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter.",
            "type": "Iteration",
            "example": "Q(selector).walk((node) => console.log(node), true); // Passes Q object",
            "dependencies": [],
            "script": "Q.Ext('walk', function (callback, useQObject = false) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = useQObject ? Q(this.nodes[i]) : this.nodes[i];\n        callback.call(this.nodes[i], node, i);\n    }\n    return this;\n});"
        },
        "width": {
            "uuid": "66d5e1ba-93db-4467-beae-9e7d81624fed",
            "name": "width",
            "method": "Prototype",
            "desc": "Gets or sets the width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).width(value);",
            "dependencies": [],
            "script": "Q.Ext('width', function (value) {\n    if (typeof value === 'undefined') {\n        return this.nodes[0] ? this.nodes[0].offsetWidth : undefined;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.width = value;\n    }\n    return this;\n});"
        },
        "wrap": {
            "uuid": "08a58e7b-080e-48c2-ae8a-8d411f50f885",
            "name": "wrap",
            "method": "Prototype",
            "desc": "Wraps each node with the specified wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrap(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrap', function (wrapper) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        const parentNode = node.parentNode;\n        let newParentElement;\n        if (typeof wrapper === 'string') {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = wrapper.trim();\n            newParentElement = tempDiv.firstElementChild.cloneNode(true);\n        } else {\n            newParentElement = wrapper;\n        }\n        parentNode.insertBefore(newParentElement, node);\n        newParentElement.appendChild(node);\n    }\n    return this;\n});"
        },
        "wrapAll": {
            "uuid": "bf98670c-3952-400b-80b9-6c4d96626042",
            "name": "wrapAll",
            "method": "Prototype",
            "desc": "Wraps all nodes together in a single wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrapAll(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrapAll', function (wrapper) {\n    if (!this.nodes.length) return this;\n    const parent = this.nodes[0].parentNode;\n    let newParent = typeof wrapper === 'string'\n        ? ((tempDiv => (tempDiv.innerHTML = wrapper.trim(), tempDiv.firstElementChild))\n           (document.createElement('div')))\n        : wrapper;\n    parent.insertBefore(newParent, this.nodes[0]);\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        newParent.appendChild(this.nodes[i]);\n    }\n    return this;\n});"
        },
        "zIndex": {
            "uuid": "a02c9264-2e5a-445d-9fa4-e36ed97d7e11",
            "name": "zIndex",
            "method": "Prototype",
            "desc": "Gets or sets the z-index of the first node.",
            "type": "Display",
            "example": "Q(selector).zIndex(value);",
            "dependencies": [],
            "script": "Q.Ext('zIndex', function (value) {\n    const node = this.nodes[0];\n    if (!node) return;\n    if (value === undefined) {\n        let Index = node.style.zIndex || window.getComputedStyle(node).zIndex;\n        return Index;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.zIndex = value;\n    }\n    return this;\n});"
        }
    },
    "plugins": {
        "Container": {
            "uuid": "8b941309-4e9c-44a6-a5aa-a40bd8b4a440",
            "name": "Container",
            "method": "Plugin",
            "desc": "Useful to create containers for your elements, like tabs, accordions, etc.",
            "type": "Plugin",
            "example": "var containers = Q.Container();",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "Icons"
            ],
            "script": "Q.Container = function (options = {}) {\n    const Container = {};\n    Container.Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' container_icon');\n        return iconElement;\n    };\n    Q.Icons();\n    Container.classes = Q.style('', `\n        .container_icon {\n            width: 100%;\n            height: 100%;\n            color: #777; /* Default color */\n            pointer-events: none;\n            z-index: 1;\n        }\n    `, null, {\n        'container_icon': 'container_icon'\n    });\n    return Container;\n};"
        },
        "Container.Tab": {
            "uuid": "293b3e53-1a5b-4383-b762-515a98e4c931",
            "name": "Container.Tab",
            "method": "Component",
            "desc": "Tab component for Container plugin",
            "type": "Component",
            "example": "var tabs = Q.Container.Tab([{title: 'Tab 1', value: 'tab1', content: 'Content 1'}, {title: 'Tab 2', value: 'tab2', content: 'Content 2'}]);",
            "dependencies": [
                "Container",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "find",
                "scrollTop",
                "scrollLeft",
                "html",
                "text",
                "data",
                "click"
            ],
            "script": "Q.Container.Tab = function (options = {}) {\n    const Container = Q.Container();\n    const Icon = Container.Icon;\n    const sharedClasses = Container.classes;\n    const classes = Object.assign({}, sharedClasses, Q.style('', `\n        .tab_navigation_buttons {\n            box-sizing: border-box;\n            width: 20px;\n            background-color: #333;\n            display: flex;\n            justify-content: center;\n            padding: 4px;\n        }\n        .tab_navigation_buttons_vertical {\n            width: auto;\n            height: 20px;\n        }\n        .tab_navigation_buttons:hover {\n            background-color: #555;\n        }\n        .tab_container {\n            width: 100%;\n            height: 300px;\n        }\n        .tab_container_vertical {\n            display: flex;\n        }\n        .tab_navigation_header {\n            background-color: #333;\n            display: flex;\n        }\n        .tab_navigation_header_vertical {\n            flex-direction: column;\n            width: auto;\n        }\n        .tab_navigation_tabs {\n            user-select: none;\n            display: flex;\n            flex-direction: row;\n            width: 100%;\n            overflow: hidden;\n        }\n        .tab_navigation_tabs_vertical {\n            flex-direction: column;\n        }\n        .tab_active {\n            background-color: #555;\n            color: #fff;\n        }\n        .tab {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            cursor: default;\n            padding: 5px 25px;\n        }\n        .tab_disabled {\n            background-color: #333;\n            color: #555;\n        }\n    `, null, {\n        'tab_navigation_buttons': 'tab_navigation_buttons',\n        'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n        'tab_container': 'tab_container',\n        'tab_container_vertical': 'tab_container_vertical',\n        'tab_navigation_header': 'tab_navigation_header',\n        'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n        'tab_navigation_tabs': 'tab_navigation_tabs',\n        'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n        'tab_active': 'tab_active',\n        'tab': 'tab',\n        'tab_disabled': 'tab_disabled'\n    }));\n    return function (data, horizontal = true) {\n        let wrapper = Q('<div>', { class: classes.tab_container });\n        let tabs_wrapper = Q('<div>', { class: classes.tab_navigation_header });\n        let tabs_nav_left = Q('<div>', { class: classes.tab_navigation_buttons });\n        let tabs_nav_right = Q('<div>', { class: classes.tab_navigation_buttons });\n        let tabs = Q('<div>', { class: classes.tab_navigation_tabs });\n        tabs_wrapper.append(tabs_nav_left, tabs, tabs_nav_right);\n        let content = Q('<div>');\n        wrapper.append(tabs_wrapper, content);\n        if (!horizontal) {\n            wrapper.addClass(classes.tab_container_vertical);\n            tabs.addClass(classes.tab_navigation_tabs_vertical);\n            tabs_wrapper.addClass(classes.tab_navigation_header_vertical);\n            tabs_nav_left.addClass(classes.tab_navigation_buttons_vertical);\n            tabs_nav_right.addClass(classes.tab_navigation_buttons_vertical);\n            tabs_nav_left.append(Icon('arrow-up'));\n            tabs_nav_right.append(Icon('arrow-down'));\n        }\n        else {\n            tabs_nav_left.append(Icon('arrow-left'));\n            tabs_nav_right.append(Icon('arrow-right'));\n        }\n        let data_tabs = {};\n        let data_contents = {};\n        data.forEach((item) => {\n            const tab = Q('<div>', { class: classes.tab, 'data-value': item.value }).text(item.title);\n            if (item.disabled) {\n                tab.addClass(classes.tab_disabled);\n            }\n            data_tabs[item.value] = tab;\n            data_contents[item.value] = item.content;\n            tab.on('click', function () {\n                if (item.disabled) {\n                    return;\n                }\n                let foundTabs = tabs.find('.' + classes.tab_active);\n                if (foundTabs) {\n                    foundTabs.removeClass(classes.tab_active);\n                }\n                tab.addClass(classes.tab_active);\n                content.html(data_contents[item.value]);\n            });\n            tabs.append(tab);\n        });\n        tabs_nav_left.on('click', function () {\n            if (!horizontal) {\n                tabs.scrollTop(-tabs.height(), true);\n            } else {\n                tabs.scrollLeft(-tabs.width(), true);\n            }\n        });\n        tabs_nav_right.on('click', function () {\n            if (!horizontal) {\n                tabs.scrollTop(tabs.height(), true);\n            } else {\n                tabs.scrollLeft(tabs.width(), true);\n            }\n        });\n        wrapper.select = function (value) {\n            Object.keys(data_tabs).forEach(key => {\n                if (data_tabs[key].data('value') === value) {\n                    data_tabs[key].click();\n                }\n            });\n        };\n        wrapper.disabled = function (value, state) {\n            if (data_tabs[value]) {\n                if (state) {\n                    data_tabs[value].addClass(classes.tab_disabled);\n                } else {\n                    data_tabs[value].removeClass(classes.tab_disabled);\n                }\n            }\n        };\n        return wrapper;\n    };\n};"
        },
        "Cookie": {
            "uuid": "99a001ac-c151-4be3-a36a-e4f6a3ccac3e",
            "name": "Cookie",
            "method": "Plugin",
            "desc": "Provides methods to store and retrieve data from the browser cookies.",
            "type": "Plugin",
            "example": "Q.Cookie('key', 'value to store'); Q.Cookie('key'); // returns 'value to store'",
            "dependencies": [],
            "script": "Q.Cookie = function (a, b, c = {}) {\n    const buildOptions = (options) => {\n      let optionsStr = '';\n      if (options.days) optionsStr += `expires=${new Date(Date.now() + options.days * 86400000).toUTCString()}; `;\n      if (options.path) optionsStr += `path=${options.path}; `;\n      if (options.domain) optionsStr += `domain=${options.domain}; `;\n      if (options.secure) optionsStr += 'secure; ';\n      return optionsStr;\n    };\n    if (arguments.length > 1) {\n      if (b === null || b === '') {\n        b = '';\n        c = { ...c, days: -1 };\n      }\n      return document.cookie = `${a}=${b}; ${buildOptions(c)}`;\n    }\n    const allCookies = document.cookie.split('; ');\n    for (let i = 0, len = allCookies.length; i < len; i++) {\n      const currentCookie = allCookies[i];\n      const indexEqual = currentCookie.indexOf('=');\n      if (indexEqual > -1 && currentCookie.slice(0, indexEqual).trim() === a) {\n        return currentCookie.slice(indexEqual + 1);\n      }\n    }\n    return undefined;\n  };"
        },
        "Fetch": {
            "uuid": "8dc85107-559e-4b59-b1eb-b51433821532",
            "name": "Fetch",
            "method": "Plugin",
            "desc": "Fetches data from a URL and returns it to a callback function. Supports retries, timeouts, and custom response validation.",
            "type": "Plugin",
            "example": "Q.fetch('https://api.example.com/data', (error, data) => console.log(error, data));",
            "dependencies": [],
            "script": "Q.Fetch = function (url, b, c = {}) {\n    const {\n        method = 'GET',\n        headers = {},\n        body,\n        contentType = 'application/json',\n        responseType = 'json',\n        credentials = 'same-origin',\n        retries = 3,\n        retryDelay = 1000,\n        exponentialBackoff = false,\n        timeout = 0,\n        validateResponse = (j) => j,\n        query = null,\n        e: externalSignal = null\n    } = c;\n    if (query && typeof query === 'object') {\n        const urlObject = new URL(url, location.origin);\n        Object.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value));\n        url = urlObject.toString();\n    }\n    let requestBody = body;\n    if (body && typeof body === 'object' && contentType === 'application/json' && !(body instanceof FormData)) {\n        try { requestBody = JSON.stringify(body); } catch (k) { b(new Error('Failed to serialize request body'), null); return; }\n    }\n    headers['Content-Type'] = headers['Content-Type'] || contentType;\n    const d = new AbortController();\n    const { e } = d;\n    if (externalSignal) {\n        externalSignal.addEventListener('abort', () => d.abort(), { once: true });\n    }\n    const doFetch = (f) => {\n        let h = null;\n        if (timeout) { h = setTimeout(() => d.abort(), timeout); }\n        fetch(url, { method, headers, body: requestBody, credentials, e })\n            .then(i => {\n                if (!i.ok) throw new Error(`Network i was not ok: ${i.statusText}`);\n                switch (responseType) {\n                    case 'json': return i.json();\n                    case 'text': return i.text();\n                    case 'blob': return i.blob();\n                    case 'arrayBuffer': return i.arrayBuffer();\n                    default: throw new Error('Unsupported i type');\n                }\n            })\n            .then(result => {\n                if (h) clearTimeout(h);\n                return validateResponse(result);\n            })\n            .then(validatedData => b(null, validatedData))\n            .catch(k => {\n                if (h) clearTimeout(h);\n                if (k.name === 'AbortError') {\n                    b(new Error('Fetch request was aborted'), null);\n                } else if (f < retries) {\n                    const delay = exponentialBackoff ? retryDelay * (2 ** f) : retryDelay;\n                    setTimeout(() => doFetch(f + 1), delay);\n                } else {\n                    b(k, null);\n                }\n            });\n    };\n    doFetch(0);\n    return { abort: () => d.abort() };\n};"
        },
        "Form.Button": {
            "uuid": "164b712f-4846-47a7-8325-9f6a95d4e82f",
            "name": "Form.Button",
            "method": "Component",
            "desc": "Button component for Form plugin",
            "type": "Component",
            "example": "var button = Q.Form.Button('Click me'); button.click(function() { alert('Clicked!'); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "text",
                "click"
            ],
            "script": "Form.prototype.Button = function(text = '') {\n    if (!Form.buttonClassesInitialized) {\n        Form.buttonClasses = Q.style(null, `\n            .button {\n                user-select: none;\n                font-family: var(--form-default-font-family);\n                background-color: var(--form-default-button-background-color);\n                color: var(--form-default-button-text-color);\n                box-shadow: inset 0 0 0 1px var(--form-default-button-border-color);\n                border-radius: var(--form-default-border-radius);\n                padding: var(--form-default-padding);\n                font-size: var(--form-default-font-size);\n                cursor: pointer;\n            }\n            .button:hover {\n                background-color: var(--form-default-button-hover-background-color);\n                color: var(--form-default-button-hover-text-color);\n            }\n            .button:active {\n                background-color: var(--form-default-button-active-background-color);\n                color: var(--form-default-button-active-text-color);\n            }\n            .button_disabled {\n                opacity: 0.6;\n                cursor: not-allowed;\n            }\n        `, null, {\n            'button_disabled': 'button_disabled',\n            'button': 'button'\n        });\n        Form.buttonClassesInitialized = true;\n    }\n    const button = Q(`<div class=\"${Form.buttonClasses.button}\">${text}</div>`);\n    button.click = function(callback) {\n        button.on('click', callback);\n        return button;\n    };\n    button.disabled = function(state) {\n        if (state) {\n            button.addClass(Form.buttonClasses.button_disabled);\n        } else {\n            button.removeClass(Form.buttonClasses.button_disabled);\n        }\n        return button;\n    };\n    button.setText = function(newText) {\n        button.text(newText);\n        return button;\n    };\n    button.remove = function() {\n        button.remove();\n        return button;\n    };\n    this.elements.push(button);\n    return button;\n};"
        },
        "Form.CheckBox": {
            "uuid": "4b7d47bc-b872-4a70-ad79-65bf46a27137",
            "name": "Form.CheckBox",
            "method": "Component",
            "desc": "CheckBox component for Form plugin",
            "type": "Component",
            "example": "var checkbox = Q.Form.CheckBox(true, 'Check me'); checkbox.change(function(checked) { console.log(checked); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "prop",
                "trigger",
                "text"
            ],
            "script": "Form.prototype.CheckBox = function(checked = false, text = '') {\n    if (!Form.checkBoxClassesInitialized) {\n        Form.checkBoxClasses = Q.style('', `\n            .q_form_checkbox {\n                display: flex;\n                width: fit-content;\n                align-items: center;\n            }\n            .q_form_checkbox .label:empty {\n                display: none;\n            }\n            .q_form_checkbox .label {\n                padding-left: 5px;\n                user-select: none;\n            }\n            .q_form_cb {\n                position: relative;\n                width: 20px;\n                height: 20px;\n                background-color: var(--form-default-checkbox-background-color);\n                border-radius: var(--form-default-checkbox-radius);\n            }\n            .q_form_cb input[type=\"checkbox\"] {\n                opacity: 0;\n                top: 0;\n                left: 0;\n                padding: 0;\n                margin: 0;\n                width: 100%;\n                height: 100%;\n                position: absolute;\n            }\n            .q_form_cb input[type=\"checkbox\"]:checked+label:before {\n                content: \"\";\n                position: absolute;\n                display: block;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background-color: var(--form-default-checkbox-active-background-color);\n                border-radius: var(--form-default-checkbox-radius);\n            }\n                .q_form_label {\n                padding-left: 5px;\n                color: var(--form-default-checkbox-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n        `, null, {\n            'q_form_checkbox': 'q_form_checkbox',\n            'q_form_cb': 'q_form_cb',\n            'q_form_label': 'q_form_label'\n        });\n        Form.checkBoxClassesInitialized = true;\n    }\n    let ID = '_' + Q.ID();\n    const container = Q('<div class=\"' + Form.classes.q_form + ' ' + Form.checkBoxClasses.q_form_checkbox + '\">');\n    const checkbox_container = Q('<div class=\"' + Form.checkBoxClasses.q_form_cb + '\">');\n    const input = Q(`<input type=\"checkbox\" id=\"${ID}\">`);\n    const label = Q(`<label for=\"${ID}\">${text}</label>`);\n    const labeltext = Q(`<div class=\"${Form.checkBoxClasses.q_form_label}\">${text}</div>`);\n    if (checked) {\n        input.prop('checked', true);\n    }\n    checkbox_container.append(input, label);\n    container.append(checkbox_container, labeltext);\n    container.checked = function(state) {\n        input.prop('checked', state);\n        if (state) {\n            input.trigger('change');\n        }\n    };\n    container.change = function(callback) {\n        input.on('change', function() {\n            callback(this.checked);\n        });\n    };\n    container.disabled = function(state) {\n        input.prop('disabled', state);\n        if (state) {\n            container.addClass(Form.classes.q_form_disabled);\n        } else {\n            container.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    container.text = function(text) {\n        labeltext.text(text);\n    };\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form": {
            "uuid": "02330ceb-8a32-4cb2-bdb1-ef1b8ca51bd3",
            "name": "Form",
            "method": "Plugin",
            "desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
            "type": "Plugin",
            "example": "var containers = Q.Form()",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "hasClass",
                "text",
                "html",
                "val",
                "click",
                "closest",
                "empty",
                "show",
                "hide",
                "css",
                "attr",
                "prop",
                "remove",
                "add"
            ],
            "script": "function Form(options = {}) {\n    if (!(this instanceof Form)) {\n        return new Form(options);\n    }\n    this.elements = [];\n    this.options = options;\n    if (!Form.initialized) {\n        Form.classes = Q.style(`\n            --form-default-border-radius: 5px;\n            --form-default-padding: 5px 10px;\n            --form-default-font-size: 12px;\n            --form-default-font-family: Arial, sans-serif;\n            --form-default-input-background-color:rgb(37, 37, 37);\n            --form-default-input-text-color:rgb(153, 153, 153);\n            --form-default-input-border-color:rgba(255, 255, 255, 0.03);\n            --form-default-checkbox-background-color:rgb(68, 68, 68);\n            --form-default-checkbox-active-background-color:rgb(100, 60, 240);\n            --form-default-checkbox-text-color:rgb(153, 153, 153);\n            --form-default-checkbox-radius: 5px;\n            --form-default-button-background-color:rgb(100, 60, 240);\n            --form-default-button-text-color: #fff;\n            --form-default-button-hover-background-color:rgb(129, 100, 231);\n            --form-default-button-hover-text-color: #fff;\n            --form-default-button-active-background-color:rgb(129, 100, 231);\n            --form-default-button-active-text-color: #fff;\n            --form-default-button-border-color:rgba(255, 255, 255, 0.1);\n        `, `\n            .form_icon {\n                width: 100%;\n                height: 100%;\n                color: #fff;\n                pointer-events: none;\n            }\n        `, null, {});\n        Form.initialized = true;\n        console.log('Form core initialized');\n    }\n}\nForm.prototype.Icon = function (icon) {\n    let iconElement = Q('<div>');\n    iconElement.addClass('svg_' + icon + ' form_icon');\n    return iconElement;\n};\nQ.Form = Form;"
        },
        "Form.Tags": {
            "uuid": "11f88c3e-2184-4d85-949a-8be805b6dc4a",
            "name": "Form.Tags",
            "method": "Component",
            "desc": "Tags component for Form plugin",
            "type": "Component",
            "example": "var tags = Q.Form.Tags('tag1,tag2,tag3', 'Add tags...'); tags.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop",
                "html",
                "before",
                "after",
                "css",
                "find",
                "focus",
                "children"
            ],
            "script": "Form.prototype.Tags = function(value = '', placeholder = '', options = {}) {\n    const defaultOptions = {\n        separator: ',',\n        maxTags: null,\n        minChars: 1\n    };\n    options = Object.assign({}, defaultOptions, options);\n    if (!Form.tagsClassesInitialized) {\n        Form.tagsClasses = Q.style('', `\n            .form_tags_container {\n                display: flex;\n                flex-wrap: wrap;\n                gap: 5px;\n                width: 100%;\n                min-height: 36px;\n                padding: 3px;\n                border: 1px solid var(--form-default-input-border-color);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-input-background-color);\n                cursor: text;\n            }\n            .form_tags_container:focus-within {\n                border-color: var(--form-default-button-background-color);\n                outline: none;\n            }\n            .form_tag {\n                display: inline-flex;\n                align-items: center;\n                padding: 3px 8px;\n                background-color: var(--form-default-button-background-color);\n                color: var(--form-default-button-text-color);\n                border-radius: var(--form-default-border-radius);\n                font-size: var(--form-default-font-size);\n                font-family: var(--form-default-font-family);\n                user-select: none;\n            }\n            .form_tag_editable {\n                background-color: var(--form-default-button-hover-background-color);\n            }\n            .form_tag_remove {\n                margin-left: 5px;\n                cursor: pointer;\n                width: 14px;\n                height: 14px;\n                display: inline-flex;\n                align-items: center;\n                justify-content: center;\n                font-size: 10px;\n                border-radius: 50%;\n                background-color: rgba(255, 255, 255, 0.2);\n            }\n            .form_tag_input {\n                flex-grow: 1;\n                min-width: 60px;\n                border: none;\n                outline: none;\n                padding: 5px;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                background: transparent;\n                color: var(--form-default-input-text-color);\n            }\n            .form_tag.dragging {\n                opacity: 0.5;\n            }\n            .form_tag[draggable=true] {\n                cursor: move;\n            }\n        `, null, {\n            'form_tags_container': 'form_tags_container',\n            'form_tag': 'form_tag',\n            'form_tag_editable': 'form_tag_editable',\n            'form_tag_remove': 'form_tag_remove',\n            'form_tag_input': 'form_tag_input'\n        });\n        Form.tagsClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.classes.q_form} ${Form.tagsClasses.form_tags_container}\"></div>`);\n    const input = Q(`<input class=\"${Form.tagsClasses.form_tag_input}\" placeholder=\"${placeholder}\" type=\"text\">`);\n    const state = {\n        tags: [],\n        draggedTag: null,\n        currentEditTag: null\n    };\n    if (value) {\n        const initialTags = value.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n        initialTags.forEach(tag => addTag(tag));\n    }\n    container.append(input);\n    function addTag(text) {\n        if (!text || text.length < options.minChars) return;\n        if (options.maxTags !== null && state.tags.length >= options.maxTags) return;\n        if (state.tags.includes(text)) return;\n        const tag = Q(`<div class=\"${Form.tagsClasses.form_tag}\" draggable=\"true\"></div>`);\n        const tagText = Q(`<span>${text}</span>`);\n        const removeBtn = Q(`<span class=\"${Form.tagsClasses.form_tag_remove}\">\u00d7</span>`);\n        tag.append(tagText, removeBtn);\n        state.tags.push(text);\n        input.before(tag);\n        setupDragAndDrop(tag);\n        tag.on('click', function(e) {\n            if (e.target.classList.contains(Form.tagsClasses.form_tag_remove.split(' ')[0])) return;\n            tag.html('');\n            tag.addClass(Form.tagsClasses.form_tag_editable);\n            const editInput = Q(`<input type=\"text\" value=\"${text}\" style=\"border:none; background:transparent; color:inherit; outline:none; width:auto;\">`);\n            tag.append(editInput);\n            editInput.focus();\n            state.currentEditTag = { tag, originalText: text };\n            editInput.on('blur', function() {\n                finishEditing(editInput.val());\n            });\n            editInput.on('keydown', function(e) {\n                if (e.key === 'Enter') {\n                    finishEditing(editInput.val());\n                    e.preventDefault();\n                } else if (e.key === 'Escape') {\n                    finishEditing(text); // Restore original text\n                    e.preventDefault();\n                }\n            });\n        });\n        removeBtn.on('click', function() {\n            removeTag(tag, text);\n        });\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function finishEditing(newText) {\n        if (!state.currentEditTag) return;\n        const { tag, originalText } = state.currentEditTag;\n        const index = state.tags.indexOf(originalText);\n        if (index !== -1) {\n            state.tags.splice(index, 1);\n        }\n        if (newText && newText.trim() && newText.length >= options.minChars) {\n            tag.removeClass(Form.tagsClasses.form_tag_editable);\n            tag.html(`<span>${newText}</span><span class=\"${Form.tagsClasses.form_tag_remove}\">\u00d7</span>`);\n            tag.find(`.${Form.tagsClasses.form_tag_remove.split(' ')[0]}`).on('click', function() {\n                removeTag(tag, newText);\n            });\n            state.tags.push(newText);\n        } else {\n            tag.remove();\n        }\n        state.currentEditTag = null;\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function removeTag(tagElement, text) {\n        tagElement.remove();\n        const index = state.tags.indexOf(text);\n        if (index !== -1) {\n            state.tags.splice(index, 1);\n        }\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function setupDragAndDrop(tag) {\n        tag.on('dragstart', function(e) {\n            state.draggedTag = tag;\n            tag.addClass('dragging');\n            if (e.dataTransfer) {\n                e.dataTransfer.setData('text/plain', '');\n                e.dataTransfer.effectAllowed = 'move';\n            }\n        });\n        tag.on('dragend', function() {\n            state.draggedTag = null;\n            tag.removeClass('dragging');\n        });\n        tag.on('dragover', function(e) {\n            if (e.preventDefault) {\n                e.preventDefault(); // Allows drop\n            }\n            return false;\n        });\n        tag.on('dragenter', function(e) {\n            e.preventDefault();\n        });\n        tag.on('drop', function(e) {\n            e.stopPropagation();\n            if (!state.draggedTag || state.draggedTag === tag) {\n                return;\n            }\n            const allTags = Array.from(container.children()).filter(\n                el => el.classList.contains(Form.tagsClasses.form_tag.split(' ')[0])\n            );\n            const fromIndex = allTags.indexOf(state.draggedTag);\n            const toIndex = allTags.indexOf(tag);\n            if (fromIndex < toIndex) {\n                tag.after(state.draggedTag);\n            } else {\n                tag.before(state.draggedTag);\n            }\n            const movedTag = state.tags.splice(fromIndex, 1)[0];\n            state.tags.splice(toIndex, 0, movedTag);\n            if (typeof container.changeCallback === 'function') {\n                container.changeCallback(state.tags.join(options.separator));\n            }\n            return false;\n        });\n    }\n    container.on('click', function(e) {\n        if (e.target === container.element) {\n            input.focus();\n        }\n    });\n    input.on('keydown', function(e) {\n        if (e.key === 'Enter' || e.key === ',' || e.key === ';' || (options.separator === ' ' && e.key === ' ')) {\n            const value = input.val().trim();\n            if (value) {\n                addTag(value);\n                input.val('');\n                e.preventDefault();\n            }\n        }\n        else if (e.key === 'Backspace' && input.val() === '' && state.tags.length > 0) {\n            const allTags = Array.from(container.children()).filter(\n                el => el.classList.contains(Form.tagsClasses.form_tag.split(' ')[0])\n            );\n            if (allTags.length > 0) {\n                const lastTag = allTags[allTags.length - 1];\n                lastTag.click(); // Trigger click to start editing\n            }\n        }\n    });\n    input.on('paste', function(e) {\n        let pastedText;\n        if (window.clipboardData && window.clipboardData.getData) {\n            pastedText = window.clipboardData.getData('Text');\n        } else if (e.clipboardData && e.clipboardData.getData) {\n            pastedText = e.clipboardData.getData('text/plain');\n        }\n        if (pastedText) {\n            e.preventDefault();\n            const tags = pastedText.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n            tags.forEach(tag => addTag(tag));\n            input.val('');\n        }\n    });\n    input.on('blur', function() {\n        const inputValue = input.val();\n        const value = inputValue ? inputValue.trim() : '';\n        if (value) {\n            addTag(value);\n            input.val('');\n        }\n    });\n    container.val = function(value) {\n        if (value === undefined) {\n            return state.tags.join(options.separator);\n        }\n        if (value === '') {\n            const tagElements = container.element.querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n            for (let i = 0; i < tagElements.length; i++) {\n                if (tagElements[i].parentNode) {\n                    tagElements[i].parentNode.removeChild(tagElements[i]);\n                }\n            }\n            state.tags = [];\n        } else {\n            const tagElements = container.element.querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n            for (let i = 0; i < tagElements.length; i++) {\n                if (tagElements[i].parentNode) {\n                    tagElements[i].parentNode.removeChild(tagElements[i]);\n                }\n            }\n            state.tags = [];\n            const newTags = value.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n            newTags.forEach(tag => addTag(tag));\n        }\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n        return container;\n    };\n    container.placeholder = function(text) {\n        input.attr('placeholder', text);\n        return container;\n    };\n    container.disabled = function(state) {\n        input.prop('disabled', state);\n        container.css('pointer-events', state ? 'none' : 'auto');\n        if (state) {\n            container.addClass(Form.classes.q_form_disabled);\n        } else {\n            container.removeClass(Form.classes.q_form_disabled);\n        }\n        return container;\n    };\n    container.setSeparator = function(separator) {\n        options.separator = separator;\n        return container;\n    };\n    container.reset = function() {\n        return container.val('');\n    };\n    container.change = function(callback) {\n        container.changeCallback = callback;\n        return container;\n    };\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form.TextArea": {
            "uuid": "c47d0b9f-07a9-4150-8244-78173b4b7713",
            "name": "Form.TextArea",
            "method": "Component",
            "desc": "TextArea component for Form plugin",
            "type": "Component",
            "example": "var textarea = Q.Form.TextArea('Initial content', 'Enter text...'); textarea.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Form.prototype.TextArea = function(value = '', placeholder = '') {\n    if (!Form.textAreaClassesInitialized) {\n        Form.textAreaClasses = Q.style('', `\n            .form_textarea {\n                width: 100%;\n                padding: var(--form-default-padding);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-input-background-color);\n                color: var(--form-default-input-text-color);\n                border: 1px solid var(--form-default-input-border-color);\n                resize: none;\n                min-height: 100px;\n            }\n            .form_textarea:focus {\n                border-color: var(--form-default-button-background-color);\n                outline: none;\n            }\n        `, null, {\n            'form_textarea': 'form_textarea'\n        });\n        Form.textAreaClassesInitialized = true;\n    }\n    const textarea = Q(`<textarea class=\"${Form.classes.q_form} ${Form.textAreaClasses.form_textarea}\" placeholder=\"${placeholder}\">${value}</textarea>`);\n    textarea.placeholder = function(text) {\n        textarea.attr('placeholder', text);\n    };\n    textarea.disabled = function(state) {\n        textarea.prop('disabled', state);\n        if (state) {\n            textarea.addClass(Form.classes.q_form_disabled);\n        } else {\n            textarea.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    textarea.reset = function() {\n        textarea.val('');\n    };\n    textarea.change = function(callback) {\n        textarea.on('change', function() {\n            callback(this.value);\n        });\n    };\n    this.elements.push(textarea);\n    return textarea;\n};"
        },
        "Form.TextBox": {
            "uuid": "64f19d8e-52be-4f43-9fd4-47d2f41166e1",
            "name": "Form.TextBox",
            "method": "Component",
            "desc": "TextBox component for Form plugin",
            "type": "Component",
            "example": "var textbox = Q.Form.TextBox('text', 'Initial value', 'Enter text...'); textbox.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Form.prototype.TextBox = function(type = 'text', value = '', placeholder = '') {\n    if (!Form.textBoxClassesInitialized) {\n        Form.textBoxClasses = Q.style('', `\n            .q_form_input {\n                width: 100%;\n                font-family: var(--form-default-font-family);\n                padding: var(--form-default-padding);\n                font-size: var(--form-default-font-size);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-input-background-color);\n                color: var(--form-default-input-text-color);\n                border: 1px solid var(--form-default-input-border-color);\n                resize: none;\n            }\n            .q_form_input:focus {\n                border-color: var(--form-default-button-background-color);\n                outline: none;\n            }\n        `, null, {\n            'q_form_input': 'q_form_input'\n        });\n        Form.textBoxClassesInitialized = true;\n    }\n    const input = Q(`<input class=\"${Form.classes.q_form} ${Form.textBoxClasses.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n    input.placeholder = function(text) {\n        input.attr('placeholder', text);\n    };\n    input.disabled = function(state) {\n        input.prop('disabled', state);\n        if (state) {\n            input.addClass(Form.classes.q_form_disabled);\n        } else {\n            input.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    input.reset = function() {\n        input.val('');\n    };\n    input.change = function(callback) {\n        input.on('change', function() {\n            callback(this.value);\n        });\n    };\n    this.elements.push(input);\n    return input;\n};"
        },
        "Icons": {
            "uuid": "23baf78d-fc29-4f28-9b5b-4be677bdb891",
            "name": "Icons",
            "method": "Plugin",
            "desc": "Additional icons for the VulpiniQ library.",
            "type": "Plugin",
            "example": "Q.Icons();",
            "dependencies": [
                "style"
            ],
            "script": "Q.Icons = function () {\n  let glob = Q.getGLOBAL('icons');\n  let classes = {};\n  if (glob && glob.icons) {\n    classes = glob.icons;\n  }\n  else {\n    classes = Q.style(`:root {\n\t--icon_arrow-down: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 100.93685,31.353867 C 82.480099,48.598492 67.319803,62.707709 67.247301,62.707709 c -0.0725,0 -15.232809,-14.109215 -33.689561,-31.353842 L 3.5365448e-8,6.6845858e-7 H 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"M 31.353844,100.93685 C 14.109219,82.480099 1.6018623e-6,67.319803 1.6018623e-6,67.247301 1.6018623e-6,67.174801 14.109217,52.014492 31.353844,33.55774 L 62.70771,0 V 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"m 31.353868,33.55775 c 17.244625,18.456749 31.353842,33.617045 31.353842,33.689547 0,0.0725 -14.109215,15.232809 -31.353842,33.689563 L 1.6018623e-6,134.4946 V 67.247297 0 Z\"/></svg>');\n\t--icon_arrow-up: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 33.55775,31.353843 C 52.014499,14.109218 67.174795,6.6845858e-7 67.247297,6.6845858e-7 67.319797,6.6845858e-7 82.480106,14.109216 100.93686,31.353843 L 134.4946,62.707709 H 67.247297 3.5365448e-8 Z\"/></svg>');\n\t--icon_navigation-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2666.6667 2666.6667\"><path d=\"M 1276.6667,2434.5485 C 950.24325,2418.4963 647.60291,2257.2797 449.65648,1994.0001 360.09366,1874.8766 294.54616,1735.7649 260.06678,1591.6333 c -40.82486,-170.6571 -40.82486,-347.2761 0,-517.9332 71.52438,-298.98806 268.8554,-557.46223 540.12266,-707.48002 258.68606,-143.06006 568.06486,-175.54075 852.57376,-89.50899 276.927,83.73908 511.1437,274.85672 650.2832,530.62227 168.8614,310.40014 177.2264,688.09064 22.2995,1006.84964 -77.0037,158.4335 -189.7203,295.013 -331.3458,401.4939 -205.303,154.3568 -458.4668,231.6017 -717.3334,218.8716 z m 130.2294,-151.2014 c 229.6976,-18.6692 437.2639,-114.273 599.1754,-275.9766 47.6541,-47.593 83.7471,-91.4686 120.133,-146.0371 91.2885,-136.9067 142.8941,-286.0616 157.3086,-454.6667 3.0513,-35.6912 3.0513,-112.3088 0,-148 -9.7543,-114.0948 -35.6813,-216.2096 -79.956,-314.91095 C 2140.8657,803.99837 2044.7703,680.42081 1924.6667,585.10582 1705.8186,411.42656 1421.4281,342.88551 1146,397.43913 961.28159,434.02604 793.07082,524.16769 658.61926,658.61926 508.15954,809.07897 413.50356,1001.5246 386.76219,1211.3334 c -5.50464,43.1886 -7.16468,71.3013 -7.16468,121.3333 0,50.0321 1.66004,78.1448 7.16468,121.3333 31.40785,246.4213 158.34097,471.0271 353.9045,626.2276 118.14734,93.7625 258.15376,158.5796 405.33331,187.6524 50.7995,10.0346 91.5353,14.8142 153.3334,17.9909 18.4799,0.95 83.6306,-0.5787 107.5627,-2.5238 z m 134.7679,-630.3487 -208.3296,-208.3296 -207.9982,207.9951 -207.99834,207.9951 -54.66892,-54.6567 c -30.0679,-30.0612 -54.66892,-55.2602 -54.66892,-55.9978 0,-0.7375 93.30001,-94.6396 207.33338,-208.6711 l 207.3333,-207.3301 -206.6689,-206.6721 -206.66886,-206.67213 55.00599,-54.99402 55.006,-54.99402 206.66127,206.66447 206.6613,206.6646 207.6661,-207.6629 207.666,-207.66288 55.3378,55.32571 55.3378,55.32571 -207.6673,207.67046 -207.6673,207.6705 208.3339,208.3372 208.334,208.3371 -55.0055,54.9935 -55.0054,54.9935 z\"/></svg>');\n\t--icon_navigation-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 282.12556,619.5403 247.03663,609.52248 218.00001,595.4014 129.37889,552.30321 70.013661,466.90205 60.059145,368.19207 51.577814,284.09034 83.346262,198.0417 144.85111,138.52292 212.10881,73.437059 306.81846,45.865772 398.4674,64.691724 519.45153,89.543525 610.11296,190.57708 622.60754,314.47462 c 8.48133,84.10173 -23.28712,170.15036 -84.79196,229.66914 -59.89864,57.96444 -141.4913,86.4009 -224.85943,78.36742 z m 71.04386,-40.49085 c 101.01231,-18.37977 179.6848,-97.26565 198.14953,-198.68699 3.46591,-19.0372 3.48193,-65.25956 0.0291,-84 -18.78642,-101.96514 -96.94357,-180.11939 -198.8453,-198.83796 -18.89894,-3.471598 -65.10105,-3.471598 -84,0 C 197.45585,119.2095 119.27,197.39245 100.48802,299.33334 c -3.452807,18.74044 -3.436783,64.9628 0.0291,84 16.64224,91.4109 82.13775,165.12641 170.46427,191.85833 8.26023,2.49995 21.0186,5.49414 28.35193,6.65376 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 320.66668,412.53122 c -36.66667,-38.4534 -66.66667,-70.49248 -66.66667,-71.19795 0,-0.70547 30.15,-32.79758 67,-71.31579 l 67,-70.03311 v 141.34115 c 0,77.73764 -0.15,141.29162 -0.33333,141.23108 -0.18334,-0.0605 -30.33334,-31.57197 -67,-70.02538 z\"/></svg>');\n\t--icon_navigation-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 103.83077,602.35954 -10.876679,362.01744 104.94177,186.66667 225.81958,3.6559506 499.6699,21.151057 595.4014,218.00001 691.73222,416.0813 532.80292,643.69595 312.95615,622.51118 Z m 71.04386,-40.49085 C 527.6749,555.87785 617.23885,410.16562 575.1842,270.98141 536.24285,142.10102 399.55264,68.634561 270.98141,107.48249 119.67709,153.19925 50.784795,329.22352 130.9177,465.35432 c 35.94209,61.05887 100.57273,105.76313 168.41564,116.49111 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 294.66668,341.34179 V 199.98437 l 67,70.03311 c 36.85,38.51821 67,70.60056 67,71.2941 0,0.69354 -30.15,32.78948 -67,71.32431 l -67,70.06332 z\"/></svg>');\n\t--icon_window-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 2.8176856,98.903421 -4.0360052e-7,96.085741 22.611458,73.473146 45.222917,50.860554 22.611458,28.247962 -4.0360052e-7,5.6353711 2.8176856,2.8176851 5.6353716,-9.1835591e-7 28.247963,22.611458 50.860555,45.222916 73.473147,22.611458 96.085743,-9.1835591e-7 98.903423,2.8176851 101.72111,5.6353711 79.109651,28.247962 56.498193,50.860554 79.109651,73.473146 101.72111,96.085741 98.903423,98.903421 96.085743,101.72111 73.473147,79.109651 50.860555,56.498192 28.247963,79.109651 5.6353716,101.72111 Z\"/></svg>');\n\t--icon_window-full: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 H 50.860555 84.417403 V 50.860554 84.417401 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z\"/></svg>');\n\t--icon_window-minimize: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 0.5252846,83.893071 V 79.698469 H 50.860555 101.19582 v 4.194602 4.19461 H 50.860555 0.5252846 Z\"/></svg>');\n\t--icon_window-windowed: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 h 8.389212 8.389212 V 8.9144961 0.52528408 H 67.638978 101.19582 V 34.082131 67.638977 h -8.389207 -8.38921 v 8.389212 8.389212 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z M 92.806613,34.082131 V 8.9144961 H 67.638978 42.471343 v 4.1946059 4.194606 h 20.973029 20.973031 v 20.973029 20.973029 h 4.1946 4.19461 z\"/></svg>');\n\t--icon_zoom-in: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n\t--icon_zoom-out: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n}\n.svg_icon {-webkit-mask-size: cover;mask-size: cover;-webkit-mask-repeat: no-repeat;mask-repeat: no-repeat;-webkit-mask-position: center;mask-position: center;background-color: currentColor;}\n.svg_iconsize { width:100%;height:100%; }\n.arrow-down { mask-image: var(--icon_arrow-down);}\n.arrow-left { mask-image: var(--icon_arrow-left);}\n.arrow-right { mask-image: var(--icon_arrow-right);}\n.arrow-up { mask-image: var(--icon_arrow-up);}\n.navigation-close { mask-image: var(--icon_navigation-close);}\n.navigation-left { mask-image: var(--icon_navigation-left);}\n.navigation-right { mask-image: var(--icon_navigation-right);}\n.window-close { mask-image: var(--icon_window-close);}\n.window-full { mask-image: var(--icon_window-full);}\n.window-minimize { mask-image: var(--icon_window-minimize);}\n.window-windowed { mask-image: var(--icon_window-windowed);}\n.zoom-in { mask-image: var(--icon_zoom-in);}\n.zoom-out { mask-image: var(--icon_zoom-out);}\n`\n,{\n  \"arrow-down\": \"arrow-down\",\n  \"arrow-left\": \"arrow-left\",\n  \"arrow-right\": \"arrow-right\",\n  \"arrow-up\": \"arrow-up\",\n  \"navigation-close\": \"navigation-close\",\n  \"navigation-left\": \"navigation-left\",\n  \"navigation-right\": \"navigation-right\",\n  \"window-close\": \"window-close\",\n  \"window-full\": \"window-full\",\n  \"window-minimize\": \"window-minimize\",\n  \"window-windowed\": \"window-windowed\",\n  \"zoom-in\": \"zoom-in\",\n  \"zoom-out\": \"zoom-out\",\n  \"svg_icon\": \"svg_icon\",\n  \"svg_iconsize\": \"svg_iconsize\"\n}, true);\n  }\n  return {\n    get: function (name, additional = '') {\n      if (additional === '') {\n        additional = classes['svg_iconsize'];\n      }\n      return Q('<div>', {class: classes['svg_icon'] + ' ' + classes[name] + ' ' + additional});\n    }\n  }\n};"
        },
        "Image.Blur": {
            "uuid": "9cf962a2-633c-42dc-880f-ee55e716e5ec",
            "name": "Image.Blur",
            "method": "Plugin",
            "desc": "Apply standard blur to images.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Blur({ radius: 5 }); // Applies a blur with a radius of 5 <br> image.Blur({ radius: 8, quality: 2 }); // Higher quality blur with larger radius",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Blur = function(blurOptions = {}) {\n        const defaults = {\n            type: 'gaussian', // gaussian, box, motion, lens\n            radius: 5,         // Basic blur radius\n            quality: 1,        // Number of iterations for higher quality\n            direction: 0,      // Angle in degrees\n            distance: 10,      // Distance of motion\n            focalDistance: 0.5,  // 0-1, center of focus\n            shape: 'circle',     // circle, hexagon, pentagon, octagon\n            blades: 6,           // Number of aperture blades (5-8)\n            bladeCurvature: 0,   // 0-1, curvature of blades\n            rotation: 0,         // Rotation angle of the aperture in degrees\n            specularHighlights: 0, // 0-1, brightness of highlights\n            noise: 0              // 0-1, amount of noise\n        };\n        const settings = Object.assign({}, defaults, blurOptions);\n        const canvas_node = this.node;\n        const ctx = canvas_node.getContext('2d', { willReadFrequently: true });\n        const data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        const pixels = data.data;\n        const width = canvas_node.width;\n        const height = canvas_node.height;\n        let blurredPixels;\n        switch(settings.type.toLowerCase()) {\n            case 'box':\n                blurredPixels = applyBoxBlur(pixels, width, height, settings);\n                break;\n            case 'motion':\n                blurredPixels = applyMotionBlur(pixels, width, height, settings);\n                break;\n            case 'lens':\n                blurredPixels = applyLensBlur(pixels, width, height, settings);\n                break;\n            case 'gaussian':\n            default:\n                blurredPixels = applyGaussianBlur(pixels, width, height, settings);\n                break;\n        }\n        for (let i = 0; i < pixels.length; i++) {\n            pixels[i] = blurredPixels[i];\n        }\n        ctx.putImageData(data, 0, 0);\n        this.saveToHistory();\n        return this;\n    };\n    function applyGaussianBlur(pixels, width, height, settings) {\n        const { kernel, size } = gaussianKernel(settings.radius);\n        const half = Math.floor(size / 2);\n        const iterations = Math.round(settings.quality);\n        let currentPixels = new Uint8ClampedArray(pixels);\n        for (let i = 0; i < iterations; i++) {\n            currentPixels = applyBlur(currentPixels, width, height, kernel, size, half);\n        }\n        return currentPixels;\n    }\n    function applyBoxBlur(pixels, width, height, settings) {\n        const radius = Math.round(settings.radius);\n        const iterations = Math.round(settings.quality);\n        const size = 2 * radius + 1;\n        const half = radius;\n        const kernel = new Float32Array(size * size);\n        const weight = 1 / (size * size);\n        for (let i = 0; i < size * size; i++) {\n            kernel[i] = weight;\n        }\n        let currentPixels = new Uint8ClampedArray(pixels);\n        for (let i = 0; i < iterations; i++) {\n            currentPixels = applyBlur(currentPixels, width, height, kernel, size, half);\n        }\n        return currentPixels;\n    }\n    function applyMotionBlur(pixels, width, height, settings) {\n        const radius = Math.max(1, Math.round(settings.radius));\n        const distance = Math.max(1, Math.round(settings.distance));\n        const angle = settings.direction * Math.PI / 180; // Convert to radians\n        const size = 2 * distance + 1;\n        const kernel = new Float32Array(size * size).fill(0);\n        const half = Math.floor(size / 2);\n        let totalWeight = 0;\n        for (let t = -half; t <= half; t++) {\n            const x = Math.round(Math.cos(angle) * t) + half;\n            const y = Math.round(Math.sin(angle) * t) + half;\n            if (x >= 0 && x < size && y >= 0 && y < size) {\n                let weight = 1;\n                if (radius > 1) {\n                    const dist = Math.abs(t) / half;\n                    weight = Math.exp(-dist * dist / (2 * (radius / distance) * (radius / distance)));\n                }\n                kernel[y * size + x] = weight;\n                totalWeight += weight;\n            }\n        }\n        if (totalWeight > 0) {\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= totalWeight;\n            }\n        }\n        return applyBlur(pixels, width, height, kernel, size, half);\n    }\n    function applyLensBlur(pixels, width, height, settings) {\n        const radius = Math.max(1, Math.round(settings.radius));\n        const size = 2 * radius + 1;\n        const half = radius;\n        const kernel = new Float32Array(size * size).fill(0);\n        const rotation = settings.rotation * Math.PI / 180; // Convert to radians\n        const blades = Math.max(5, Math.min(8, settings.blades));\n        const curvature = Math.max(0, Math.min(1, settings.bladeCurvature));\n        let totalWeight = 0;\n        const focalFactor = 1 - settings.focalDistance;\n        for (let y = 0; y < size; y++) {\n            for (let x = 0; x < size; x++) {\n                const dx = x - half;\n                const dy = y - half;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance <= radius) {\n                    const angle = Math.atan2(dy, dx) + rotation;\n                    let weight = 0;\n                    switch (settings.shape) {\n                        case 'hexagon':\n                        case 'pentagon':\n                        case 'octagon':\n                            const bladeAngle = 2 * Math.PI / blades;\n                            const normalizedAngle = (angle % bladeAngle) / bladeAngle - 0.5;\n                            const bladeDistance = radius * (1 - curvature * Math.abs(normalizedAngle));\n                            weight = distance <= bladeDistance ? 1 : 0;\n                            break;\n                        case 'circle':\n                        default:\n                            weight = 1;\n                            const normalizedDist = distance / radius;\n                            if (normalizedDist > focalFactor) {\n                                weight *= Math.max(0, 1 - (normalizedDist - focalFactor) / (1 - focalFactor));\n                            }\n                            break;\n                    }\n                    if (settings.specularHighlights > 0) {\n                        const highlightFactor = Math.max(0, 1 - distance / radius);\n                        weight *= 1 + settings.specularHighlights * highlightFactor * 2;\n                    }\n                    if (settings.noise > 0) {\n                        weight *= 1 + (Math.random() - 0.5) * settings.noise;\n                    }\n                    kernel[y * size + x] = Math.max(0, weight);\n                    totalWeight += kernel[y * size + x];\n                }\n            }\n        }\n        if (totalWeight > 0) {\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= totalWeight;\n            }\n        }\n        return applyBlur(pixels, width, height, kernel, size, half);\n    }\n    function gaussianKernel(radius) {\n        const size = 2 * radius + 1;\n        const kernel = new Float32Array(size * size);\n        const sigma = radius / 3;\n        let sum = 0;\n        const center = radius;\n        for (let y = 0; y < size; y++) {\n            for (let x = 0; x < size; x++) {\n                const dx = x - center;\n                const dy = y - center;\n                const weight = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));\n                kernel[y * size + x] = weight;\n                sum += weight;\n            }\n        }\n        for (let i = 0; i < kernel.length; i++) {\n            kernel[i] /= sum;\n        }\n        return { kernel, size };\n    }\n    function applyBlur(pixels, width, height, kernel, size, half) {\n        const output = new Uint8ClampedArray(pixels.length);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0, a = 0;\n                const dstOff = (y * width + x) * 4;\n                let weightSum = 0;\n                for (let ky = 0; ky < size; ky++) {\n                    for (let kx = 0; kx < size; kx++) {\n                        const ny = y + ky - half;\n                        const nx = x + kx - half;\n                        if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                            const srcOff = (ny * width + nx) * 4;\n                            const weight = kernel[ky * size + kx];\n                            r += pixels[srcOff] * weight;\n                            g += pixels[srcOff + 1] * weight;\n                            b += pixels[srcOff + 2] * weight;\n                            a += pixels[srcOff + 3] * weight;\n                            weightSum += weight;\n                        }\n                    }\n                }\n                if (weightSum > 0) {\n                    r /= weightSum;\n                    g /= weightSum;\n                    b /= weightSum;\n                    a /= weightSum;\n                }\n                output[dstOff] = r;\n                output[dstOff + 1] = g;\n                output[dstOff + 2] = b;\n                output[dstOff + 3] = a;\n            }\n        }\n        return output;\n    }"
        },
        "Image.Brightness": {
            "uuid": "1dff5ede-b4ba-420a-b966-a34c27e921ff",
            "name": "Image.Brightness",
            "method": "Plugin",
            "desc": "Adjust image brightness.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Brightness(20); // Increases brightness by 20 <br> image.Brightness(-15, { clamp: true }); // Decreases brightness with value clamping",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Brightness = function(value, brightOptions = {}) {\n        const defaultOptions = {\n            preserveAlpha: true,\n            clamp: true   // Whether to clamp values to 0-255 range\n        };\n        const finalOptions = Object.assign({}, defaultOptions, brightOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] += value;     // Red\n            pixels[i + 1] += value; // Green\n            pixels[i + 2] += value; // Blue\n            if (finalOptions.clamp) {\n                pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        this.saveToHistory();\n        return this;\n    };"
        },
        "Image.Contrast": {
            "uuid": "3187496b-9395-4de2-8a77-6ce52b8d6d38",
            "name": "Image.Contrast",
            "method": "Plugin",
            "desc": "Adjust image contrast.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Contrast(50); // Increases contrast by 50 <br> image.Contrast(-20, { preserveHue: true }); // Decreases contrast while preserving hue",
            "dependencies": "Image",
            "script": "(function() {\n    const originalImage = Q.Image;\n    Q.Image = function(options = {}) {\n        const Image = originalImage(options);\n        return Image;\n    };\n    Q.Image.prototype.Contrast = function(value, contrastOptions = {}) {\n        const defaultOptions = {\n            preserveHue: true,  \n            clamp: true        \n        };\n        const finalOptions = Object.assign({}, defaultOptions, contrastOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let factor = (259 * (value + 255)) / (255 * (259 - value));\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = factor * (pixels[i] - 128) + 128;\n            pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n            pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n            if (finalOptions.clamp) {\n                pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        this.saveToHistory();\n        return this;\n    };\n})();"
        },
        "Image": {
            "uuid": "fbdb4448-7415-42bc-9df2-a1bc6155200f",
            "name": "Image",
            "method": "Plugin",
            "desc": "Useful to manipulate images.",
            "type": "Component",
            "example": "var image = Q.Image();",
            "dependencies": "RGB2HSL, HSL2RGB",
            "script": "Q.Image = function (options) {\n    const defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        quality: 1,\n        historyLimit: 10,\n        autoSaveHistory: true    \n    };\n    this.options = Object.assign({}, defaultOptions, options);\n    this.canvas = Q('<canvas>');\n    this.node = this.canvas.nodes[0];\n    if (this.options.width && this.options.height) {\n        this.node.width = this.options.width;\n        this.node.height = this.options.height;\n    }\n    this.history = {\n        states: [],        \n        position: -1,      \n        isUndoRedoing: false \n    };\n};\nQ.Image.prototype.Load = function(src, callback) {\n    const img = new Image();\n    img.crossOrigin = 'Anonymous';\n    img.onload = () => {\n        if (this.node.width === 0 || this.node.height === 0 || \n            this.options.width === 0 || this.options.height === 0) {\n            this.node.width = img.width;\n            this.node.height = img.height;\n        }\n        const ctx = this.node.getContext('2d');\n        ctx.clearRect(0, 0, this.node.width, this.node.height);\n        ctx.drawImage(img, 0, 0, img.width, img.height, \n                      0, 0, this.node.width, this.node.height);\n        this.history.states = [];\n        this.history.position = -1;\n        this.saveToHistory();\n        if (callback) callback.call(this, null);\n    };\n    img.onerror = (err) => {\n        console.error('Hiba a k\u00e9p bet\u00f6lt\u00e9sekor:', src, err);\n        if (callback) callback.call(this, new Error('Error loading image'));\n    };\n    img.src = typeof src === 'string' ? src : src.src;\n    return this; // L\u00e1ncolhat\u00f3s\u00e1g!\n};\nQ.Image.prototype.Clear = function(fill = this.options.fill) {\n    let ctx = this.node.getContext('2d');\n    ctx.fillStyle = fill;\n    ctx.fillRect(0, 0, this.node.width, this.node.height);\n    this.saveToHistory();\n    return this; \n};\nQ.Image.prototype.Render = function(target) {\n    const targetNode = (typeof target === 'string')\n        ? document.querySelector(target)\n        : (target?.nodeType === 1)\n            ? target\n            : (target.nodes ? target.nodes[0] : null);\n    if (!targetNode) {\n        console.error('Invalid render target');\n        return this;\n    }\n    let ctxTarget;\n    if (targetNode.tagName.toLowerCase() === 'canvas') {\n        targetNode.width = this.node.width;\n        targetNode.height = this.node.height;\n        ctxTarget = targetNode.getContext('2d');\n        ctxTarget.drawImage(this.node, 0, 0);\n    } else if (targetNode.tagName.toLowerCase() === 'img') {\n        targetNode.src = this.node.toDataURL(`image/${this.options.format}`, this.options.quality);\n    } else {\n        console.error('Unsupported element for rendering');\n    }\n    return this;\n};\nQ.Image.prototype.Save = function(filename) {\n    const dataUrl = this.node.toDataURL('image/' + this.options.format, this.options.quality);\n    const link = document.createElement('a');\n    link.download = filename;\n    link.href = dataUrl;\n    link.click();\n    link.remove();\n    return this;\n};\nQ.Image.prototype.saveToHistory = function() {\n    if (this.history.isUndoRedoing || !this.options.autoSaveHistory) return;\n    if (this.node.width === 0 || this.node.height === 0) return;\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const imageData = ctx.getImageData(0, 0, this.node.width, this.node.height);\n    if (this.history.position < this.history.states.length - 1) {\n        this.history.states.length = this.history.position + 1;\n    }\n    this.history.states.push(imageData);\n    if (this.history.states.length > this.options.historyLimit) {\n        this.history.states.shift();\n        if (this.history.position > 0) {\n            this.history.position--;\n        }\n    } else {\n        this.history.position++;\n    }\n};\n/* \n * IMPORTANT: Every image manipulation method should call saveToHistory() \n * after modifying the canvas to ensure proper history tracking.\n */\nQ.Image.prototype.Undo = function() {\n    return this.History(-1);\n};\nQ.Image.prototype.Redo = function() {\n    return this.History(1);\n};\nQ.Image.prototype.History = function(offset) {\n    if (this.history.states.length === 0) {\n        console.warn('No history states available.');\n        return this;\n    }\n    const target = this.history.position + offset;\n    if (target < 0 || target >= this.history.states.length) {\n        console.warn('Nem lehets\u00e9ges tov\u00e1bbi visszal\u00e9p\u00e9s vagy el\u0151reugr\u00e1s.');\n        return this;\n    }\n    this.history.isUndoRedoing = true;\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const historyState = this.history.states[target];\n    if (this.node.width !== historyState.width || this.node.height !== historyState.height) {\n        this.node.width = historyState.width;\n        this.node.height = historyState.height;\n    }\n    ctx.putImageData(historyState, 0, 0);\n    this.history.position = target;\n    this.history.isUndoRedoing = false;\n    return this;\n};"
        },
        "ImageViewer": {
            "uuid": "36a48ad2-26c8-4eb0-81ab-26073f678a84",
            "name": "ImageViewer",
            "method": "Plugin",
            "desc": "A simple image viewer plugin",
            "type": "Plugin",
            "example": "Q.ImageViewer().selector('.image').open(['image1.jpg', 'image2.jpg']);",
            "dependencies": [
                "Style",
                "Icons"
            ],
            "script": "Q.ImageViewer = function () {\n    let classes = Q.style(`\n.image_viewer_wrapper {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    background: rgba(0, 0, 0, 0.77);\n    transition: background 10s;\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n    color: #fff;\n}\n.image_panel {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n.image_wrapper {\n    width: 100%;\n    height: 100%;\n    opacity: 0;\n    transition: all 0.15s;\n    margin: 0 1px;\n    display: flex;\n    flex-direction: column;\n    animation: fadeInScale 0.3s forwards;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n}\n.image_canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    transition: width 0.3s, height 0.3s;\n}\n.image_ambient {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    filter: blur(25px);\n    opacity: 0.75;\n    z-index: 0;\n}\n@keyframes fadeInScale {\n    to {\n        opacity: 1;\n    }\n}\n.image_viewer_wrapper .image_panel {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.image_top, .image_bottom {\n    width: 100%;\n    z-index: 1;\n    position: absolute;\n}\n.image_top {\n    top: 0;\n    text-align: left;\n    background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);\n}\n.image_bottom {\n    bottom: 0;\n}\n.side_left, .side_right {\n    height: 100%;\n    width: 80px;\n}\n.image_info {\n    max-width: 500px;\n    padding: 10px;\n    text-shadow: 0 1px 3px #000;\n}\n.image_title {\n    font-size: 18px;\n    font-weight: bold;\n    padding-bottom: 5px;\n}\n.image_desc {\n    font-size: 14px;\n}\n.side_left:hover, .side_right:hover {\n    background: rgba(255,255,255,0.05);\n}\n.viewer_left_button, .viewer_right_button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n.viewer_navicon {\n    width: 40px;\n    height: 40px;\n}\n.viewer_left_button:hover, .viewer_right_button:hover, .viewer_close_button:hover {\n    opacity: 1;\n}\n.viewer_button_container {\n    z-index: 10000;\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    display: flex;\n}\n.viewer_close_button, .viewer_zoom_in_button, .viewer_zoom_out_button {\n    width: 30px;\n    height: 30px;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n    `, {\n        'image_viewer_wrapper': 'image_viewer_wrapper',\n        'image_panel': 'image_panel',\n        'image_wrapper': 'image_wrapper',\n        'image_canvas': 'image_canvas',\n        'image_ambient': 'image_ambient',\n        'image_top': 'image_top',\n        'image_bottom': 'image_bottom',\n        'image_info': 'image_info',\n        'viewer_button_container': 'viewer_button_container',\n        'side_left': 'side_left',\n        'side_right': 'side_right',\n        'viewer_left_button': 'viewer_left_button',\n        'viewer_right_button': 'viewer_right_button',\n        'viewer_close_button': 'viewer_close_button',\n        'viewer_zoom_in_button': 'viewer_zoom_in_button',\n        'viewer_zoom_out_button': 'viewer_zoom_out_button',\n        'image_title': 'image_title',\n        'image_desc': 'image_desc',\n        'viewer_navicon': 'viewer_navicon'\n    }, false);\n    class Viewer {\n        constructor() {\n            this.selector = null;\n            this.images = [];\n            this.currentIndex = 0;\n            this.eventHandler = this.handleClick.bind(this);\n            this.addEventListener();\n            this.icons = Q.Icons();\n            this.eventListenerActive = false;\n            this.loaded = false;\n            this.resizing = false;\n            this.thumbs = false;\n            this.scale = 1;\n            this.panX = 0;\n            this.panY = 0;\n            this.isPanning = false;\n            this.startX = 0;\n            this.startY = 0;\n            this.imageCache = {};\n            this.config = {\n                panAndZoom: true,\n                ambient: true,\n                ambientSize: 1.2,\n                dynamicBackground: true\n            };\n        }\n        construct() {\n            this.image_viewer = Q('<div>', { class: classes.image_viewer_wrapper });\n            this.image_panel = Q('<div>', { class: classes.image_panel });\n            this.image_wrapper = Q('<div>', { class: classes.image_wrapper });\n            this.image_canvas = Q('<canvas>', { class: classes.image_canvas });\n            this.image_ambient = Q('<canvas>', { class: classes.image_ambient });\n            this.image_top = Q('<div>', { class: classes.image_top });\n            this.image_bottom = Q('<div>', { class: classes.image_bottom });\n            this.image_info = Q('<div>', { class: classes.image_info });\n            this.button_container = Q('<div>', { class: classes.viewer_button_container });\n            this.side_left = Q('<div>', { class: classes.side_left });\n            this.side_right = Q('<div>', { class: classes.side_right });\n            this.left_button = Q('<div>', { class: classes.viewer_left_button });\n            this.right_button = Q('<div>', { class: classes.viewer_right_button });\n            this.close_button = Q('<div>', { class: classes.viewer_close_button });\n            this.zoom_in_button = Q('<div>', { class: classes.viewer_zoom_in_button });\n            this.zoom_out_button = Q('<div>', { class: classes.viewer_zoom_out_button });\n            this.left_button.append(this.icons.get('navigation-left', classes.viewer_navicon));\n            this.right_button.append(this.icons.get('navigation-right', classes.viewer_navicon));\n            this.close_button.append(this.icons.get('navigation-close'));\n            this.zoom_in_button.append(this.icons.get('zoom-in'));\n            this.zoom_out_button.append(this.icons.get('zoom-out'));\n            this.side_left.append(this.left_button);\n            this.side_right.append(this.right_button);\n            this.image_top.append(this.image_info);\n            this.button_container.append(this.zoom_in_button, this.zoom_out_button, this.close_button);\n            this.image_wrapper.append(this.image_ambient, this.image_canvas, this.image_top, this.image_bottom);\n            this.image_panel.append(this.side_left, this.image_wrapper, this.side_right);\n            this.image_viewer.append(this.image_panel, this.button_container);\n            this.left_button.on('click', () => this.prev());\n            this.right_button.on('click', () => this.next());\n            this.close_button.on('click', () => this.close());\n            this.image_top.on('mouseenter', () => {\n                this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            });\n            this.image_top.on('mouseleave', () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s', 'transition-delay': '3s' });\n            });\n            this.image_canvas.on('wheel', (e) => this.handleZoom(e));\n            this.image_canvas.on('mousedown', (e) => this.startPan(e));\n            this.image_canvas.on('mousemove', (e) => this.pan(e));\n            this.image_canvas.on('mouseup', () => this.endPan());\n            this.image_canvas.on('mouseleave', () => this.endPan());\n            this.image_canvas.on('touchstart', (e) => this.startTouch(e));\n            this.image_canvas.on('touchmove', (e) => this.touchPanZoom(e));\n            this.image_canvas.on('touchend', () => this.endTouch());\n        }\n        handleClick(e) {\n            if (e.target.closest(this.selector)) {\n                const images = Q(this.selector).find('img');\n                if (!images.nodes.length) {\n                    return;\n                }\n                images.each((index, el) => {\n                    let title, desc, src;\n                    if (el.hasAttribute('data-title')) {\n                        title = el.getAttribute('data-title');\n                    }\n                    if (el.hasAttribute('data-desc')) {\n                        desc = el.getAttribute('data-desc');\n                    }\n                    if (el.hasAttribute('data-source')) {\n                        src = el.getAttribute('data-source');\n                    } else {\n                        src = el.src;\n                    }\n                    this.images[index] = {\n                        src: src,\n                        title: title,\n                        desc: desc\n                    }\n                });\n                this.currentIndex = images.nodes.indexOf(e.target);\n                this.open();\n            }\n        }\n        handleResize() {\n            if (!this.resizing) {\n                this.resizing = true;\n                this.image_canvas.css({ filter: 'blur(10px)', transition: 'all 0.1s ease-in-out' });\n            }\n            Q.Debounce('img_viewer', 500, () => {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.updateImage();\n                this.resizing = false;\n                this.image_canvas.css({ filter: 'none', transition: '' });\n            });\n        }\n        handleZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            const rect = this.image_canvas.nodes[0].getBoundingClientRect();\n            const offsetX = (e.clientX - rect.left - this.panX) / this.scale;\n            const offsetY = (e.clientY - rect.top - this.panY) / this.scale;\n            const scaleAmount = e.deltaY > 0 ? 0.9 : 1.1;\n            const newScale = Math.min(Math.max(this.scale * scaleAmount, 0.5), 2.5);\n            const deltaScale = newScale - this.scale;\n            this.panX -= offsetX * deltaScale;\n            this.panY -= offsetY * deltaScale;\n            this.scale = newScale;\n            this.updateImage();\n        }\n        startPan(e) {\n            if (!this.config.panAndZoom) return;\n            this.isPanning = true;\n            this.startX = e.clientX - this.panX;\n            this.startY = e.clientY - this.panY;\n        }\n        pan(e) {\n            if (!this.config.panAndZoom) return;\n            if (!this.isPanning) return;\n            this.panX = e.clientX - this.startX;\n            this.panY = e.clientY - this.startY;\n            this.updateImage();\n        }\n        endPan() {\n            this.isPanning = false;\n        }\n        startTouch(e) {\n            if (!this.config.panAndZoom) return;\n            if (e.touches.length === 1) {\n                this.isPanning = true;\n                this.startX = e.touches[0].clientX - this.panX;\n                this.startY = e.touches[0].clientY - this.panY;\n            } else if (e.touches.length === 2) {\n                this.isPanning = false;\n                this.initialDistance = Math.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                this.initialScale = this.scale;\n            }\n        }\n        touchPanZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            if (e.touches.length === 1 && this.isPanning) {\n                this.panX = e.touches[0].clientX - this.startX;\n                this.panY = e.touches[0].clientY - this.startY;\n                this.updateImage();\n            } else if (e.touches.length === 2) {\n                const currentDistance = Math.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                const scaleAmount = currentDistance / this.initialDistance;\n                this.scale = Math.min(Math.max(this.initialScale * scaleAmount, 0.5), 2.5);\n                this.updateImage();\n            }\n        }\n        endTouch() {\n            this.isPanning = false;\n        }\n        addEventListener() {\n            if (!this.eventListenerActive) {\n                document.addEventListener('click', this.eventHandler);\n                this.eventListenerActive = true;\n            }\n        }\n        removeEventListener() {\n            if (this.eventListenerActive) {\n                document.removeEventListener('click', this.eventHandler);\n                this.eventListenerActive = false;\n            }\n        }\n        fadeTitle() {\n            this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            Q.Debounce('fade_title', 2000, () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s' });\n            });\n        }\n        open() {\n            this.construct();\n            this.updateImage();\n            this.updateNavigation();\n            Q('body').append(this.image_viewer);\n            window.addEventListener('resize', this.handleResize.bind(this));\n        }\n        close() {\n            this.thumbs = false;\n            window.removeEventListener('resize', this.handleResize.bind(this));\n            this.image_viewer.remove();\n        }\n        prev() {\n            if (this.currentIndex > 0) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex--;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        next() {\n            if (this.currentIndex < this.images.length - 1) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex++;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        updateImage() {\n            this.window_width = window.innerWidth;\n            this.window_height = window.innerHeight;\n            this.image_info.empty();\n            if (this.images[this.currentIndex].title) {\n                this.image_info.append(Q('<div>', { class: classes.image_title, text: this.images[this.currentIndex].title }));\n            }\n            if (this.images[this.currentIndex].desc) {\n                this.image_info.append(Q('<div>', { class: classes.image_desc, text: this.images[this.currentIndex].desc }));\n            }\n            const src = this.images[this.currentIndex];\n            const img = this.imageCache[src.src] || new Image();\n            if (!this.imageCache[src.src]) {\n                img.src = src.src;\n                this.imageCache[src.src] = img;\n            }\n            const isAnimated = /\\.(webm|apng|gif)$/i.test(src.src);\n            img.onload = () => {\n                const canvas = this.image_canvas.nodes[0];\n                const ambientCanvas = this.image_ambient.nodes[0];\n                const ctx = canvas.getContext('2d');\n                const ambientCtx = ambientCanvas.getContext('2d');\n                canvas.width = this.image_wrapper.nodes[0].clientWidth;\n                canvas.height = this.image_wrapper.nodes[0].clientHeight;\n                ambientCanvas.width = canvas.width * 1.2;\n                ambientCanvas.height = canvas.height * 1.2;\n                if (isAnimated) {\n                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n                    if (this.config.ambient) {\n                        ambientCtx.drawImage(img, (ambientCanvas.width - canvas.width) / 2, (ambientCanvas.height - canvas.height) / 2, canvas.width, canvas.height);\n                    }\n                    return;\n                }\n                const aspectRatio = img.width / img.height;\n                let width = this.window_width * this.scale;\n                let height = this.window_height * this.scale;\n                if (width / height > aspectRatio) {\n                    width = height * aspectRatio;\n                } else {\n                    height = width / aspectRatio;\n                }\n                const offsetX = (canvas.width - width) / 2;\n                const offsetY = (canvas.height - height) / 2;\n                ctx.setTransform(this.scale, 0, 0, this.scale, this.panX + offsetX, this.panY + offsetY);\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.drawImage(img, 0, 0, width, height);\n                if (this.config.ambient) {\n                    const ambientOffsetX = (ambientCanvas.width - width * this.config.ambientSize) / 2;\n                    const ambientOffsetY = (ambientCanvas.height - height * this.config.ambientSize) / 2;\n                    ambientCtx.setTransform(this.scale * this.config.ambientSize, 0, 0, this.scale * this.config.ambientSize, this.panX * this.config.ambientSize + ambientOffsetX, this.panY * this.config.ambientSize + ambientOffsetY);\n                    ambientCtx.clearRect(0, 0, ambientCanvas.width, ambientCanvas.height);\n                    ambientCtx.drawImage(img, 0, 0, width, height);\n                }\n                if (this.config.dynamicBackground) {\n                    Q.Debounce('update_ambient', 1000, () => {\n                        Q.AvgColor(canvas, 10, (color) => {\n                            this.image_viewer.css('background', `rgba(${color.r}, ${color.g}, ${color.b}, 0.77)`);\n                        });\n                    });\n                }\n            };\n            if (img.complete) {\n                img.onload();\n            }\n        }\n        updateNavigation() {\n            if (this.images.length > 1) {\n                if (this.currentIndex > 0) {\n                    this.left_button.show();\n                } else {\n                    this.left_button.hide();\n                }\n                if (this.currentIndex < this.images.length - 1) {\n                    this.right_button.show();\n                } else {\n                    this.right_button.hide();\n                }\n            } else {\n                this.left_button.hide();\n                this.right_button.hide();\n            }\n        }\n        setSelector(selector) {\n            this.selector = selector;\n            this.addEventListener();\n        }\n        remove() {\n            this.removeEventListener();\n            this.image_viewer.remove();\n        }\n        source(images) {\n            this.images = images.map((img, index) => ({\n                src: img.source,\n                title: img.title,\n                desc: img.desc\n            }));\n            this.currentIndex = 0;\n        }\n    }\n    let viewer = new Viewer();\n    return {\n        selector: function (selector) {\n            viewer.setSelector(selector);\n            return this;\n        },\n        open: function (images) {\n            viewer.open(images);\n            return this;\n        },\n        close: function () {\n            viewer.close();\n            return this;\n        },\n        remove: function () {\n            viewer.remove();\n            return this;\n        },\n        config: function (options) {\n            Object.assign(viewer.config, options);\n            return this;\n        },\n        source: function (images) {\n            viewer.source(images);\n            return this;\n        }\n    };\n}"
        },
        "JSON": {
            "uuid": "dc904e03-9c93-4b2d-a2a5-5e2862a02d12",
            "name": "JSON",
            "method": "Plugin",
            "desc": "Provides methods to parse, deflate, inflate, merge, sort, and flatten JSON objects.",
            "type": "Plugin",
            "example": "//   let json = Q.JSON({ key: 'value' });",
            "dependencies": [],
            "script": "Q.JSON = function (jsonData) {\n    if (!(this instanceof Q.JSON)) return new Q.JSON(jsonData);\n    this.json = jsonData;\n};\nQ.JSON.prototype.Parse = function (options = { modify: false, recursive: false }, callback) {\n    const { modify, recursive } = options;\n    const process = (data) => {\n        if (typeof data === 'object' && data && !Array.isArray(data)) {\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    const newValue = callback(key, data[key]);\n                    if (modify) data[key] = newValue;\n                    if (recursive && typeof data[key] === 'object' && data[key]) process(data[key]);\n                }\n            }\n        }\n    };\n    process(this.json);\n    return this.json;\n};\nQ.JSON.prototype.deflate = function (level) {\n    const map = {}, deflateCounter = { count: 1 };\n    const replaceRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                if (typeof obj[key] === 'object' && obj[key]) replaceRecursive(obj[key]);\n                if (key.length >= level) {\n                    if (!map[key]) { map[key] = `[${deflateCounter.count++}]`; }\n                    const newKey = map[key];\n                    obj[newKey] = obj[key]; delete obj[key];\n                }\n                if (typeof obj[key] === 'string' && obj[key].length >= level) {\n                    if (!map[obj[key]]) { map[obj[key]] = `[${deflateCounter.count++}]`; }\n                    obj[key] = map[obj[key]];\n                }\n            }\n        }\n    };\n    const deflatedData = JSON.parse(JSON.stringify(this.json));\n    replaceRecursive(deflatedData);\n    return { data: deflatedData, map: map };\n};\nQ.JSON.prototype.inflate = function (deflatedJson) {\n    const { data, map } = deflatedJson;\n    const reverseMap = Object.fromEntries(Object.entries(map).map(([k, v]) => [v, k]));\n    const restoreRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                const originalKey = reverseMap[key] || key;\n                const value = obj[key]; delete obj[key];\n                obj[originalKey] = value;\n                if (typeof obj[originalKey] === 'object' && obj[originalKey]) {\n                    restoreRecursive(obj[originalKey]);\n                } else if (reverseMap[obj[originalKey]]) {\n                    obj[originalKey] = reverseMap[obj[originalKey]];\n                }\n            }\n        }\n    };\n    const inflatedData = JSON.parse(JSON.stringify(data));\n    restoreRecursive(inflatedData);\n    return inflatedData;\n};\nQ.JSON.prototype.merge = function (otherJson) {\n    const deepMerge = (target, source) => {\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                if (typeof source[key] === 'object' && source[key] && !Array.isArray(source[key])) {\n                    target[key] = deepMerge(target[key] && typeof target[key] === 'object' ? target[key] : {}, source[key]);\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return deepMerge(this.json, otherJson);\n};\nQ.JSON.prototype.sortKeys = function (recursive = false, reverse = false) {\n    const sortObject = (obj) => {\n        const keys = Object.keys(obj).sort();\n        if (reverse) keys.reverse();\n        const sorted = {};\n        keys.forEach(key => {\n            sorted[key] = (recursive && typeof obj[key] === 'object' && obj[key] && !Array.isArray(obj[key])) ? sortObject(obj[key]) : obj[key];\n        });\n        return sorted;\n    };\n    this.json = sortObject(this.json);\n    return this.json;\n};\nQ.JSON.prototype.sortValues = function (reverse = false) {\n    if (typeof this.json !== 'object' || !this.json) return this.json;\n    const entries = Object.entries(this.json).sort((a, b) => {\n        const aValue = String(a[1]), bValue = String(b[1]);\n        return aValue.localeCompare(bValue);\n    });\n    if (reverse) entries.reverse();\n    const sorted = {};\n    for (const [key, value] of entries) sorted[key] = value;\n    this.json = sorted;\n    return this.json;\n};\nQ.JSON.prototype.sortByValues = function (keyProp, valueProp, reverse = false) {\n    if (!Array.isArray(this.json)) return this.json;\n    this.json.sort((a, b) => {\n        const cmpKey = String(a[keyProp]).localeCompare(String(b[keyProp]));\n        const cmpValue = String(a[valueProp]).localeCompare(String(b[valueProp]));\n        const cmp = cmpKey || cmpValue;\n        return reverse ? -cmp : cmp;\n    });\n    return this.json;\n};\nQ.JSON.prototype.flatten = function (prefix = '') {\n    const result = {};\n    const flattenRec = (obj, path) => {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                const newKey = path ? `${path}.${key}` : key;\n                if (typeof obj[key] === 'object' && obj[key] && !Array.isArray(obj[key])) {\n                    flattenRec(obj[key], newKey);\n                } else {\n                    result[newKey] = obj[key];\n                }\n            }\n        }\n    };\n    flattenRec(this.json, prefix);\n    return result;\n};\nQ.JSON.prototype.unflatten = function (flatObject) {\n    const result = {};\n    Object.keys(flatObject).forEach(compoundKey => {\n        compoundKey.split('.').reduce((accumulator, currentKey, index, keysArray) => {\n            if (index === keysArray.length - 1) {\n                accumulator[currentKey] = flatObject[compoundKey];\n            } else {\n                if (!accumulator[currentKey] || typeof accumulator[currentKey] !== 'object') {\n                    accumulator[currentKey] = {};\n                }\n            }\n            return accumulator[currentKey];\n        }, result);\n    });\n    this.json = result;\n    return result;\n};"
        },
        "NodeBlock": {
            "uuid": "8bae2cc0-b3cb-420c-82b8-18881bab1419",
            "name": "NodeBlock",
            "method": "Plugin",
            "desc": "A plugin for creating UML blocks and connections.",
            "type": "Plugin",
            "example": "var uml = Q.NodeBlock('#canvas', 800, 600); // Create a new UML canvas",
            "dependencies": [
                "ColorBrightness",
                "isDarkColor",
                "Style"
            ],
            "script": "Q.NodeBlock = function (selector, width, height, options) {\n    let classes = Q.style(`\n.node_preferences {\n    position: absolute;\n    background: #181818;\n    overflow: hidden;\n    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);\n}\n.node_preferences_big {\n    width: 350px;\n    max-height: 350px;\n    overflow-y: scroll;\n}\n.node_preferences_small {\nwidth: 200px;\noverflow-y: auto;\n    }\n.pref_content h1, .pref_content h2, .pref_content h3, .pref_content h4, .pref_content h5, .pref_content h6 {\nline-break: anywhere;\nmargin: 0 0 2px 0;\npadding: 0;\n}\n.pref_content h1 { font-size: 150%; }\n.pref_content h2 { font-size: 140%; }\n.pref_content h3 { font-size: 130%; }\n.pref_content h4 { font-size: 120%; }\n.pref_content h5 { font-size: 110%; }\n.pref_content h6 { font-size: 100%; }\n.pref_content p { margin: 0; padding: 0; color: #7a7a7a; }\n.pref_content ul { margin: 5px 5px; padding-left: 15px; color: #7a7a7a; }\n.pref_content li { padding: 0px; margin: 0px; }\n.pref_content table { border-collapse: collapse; width: 100%; }\n.pref_content table, th, td { padding: 0; margin: 0; font-size: 90%; line-break: anywhere; border: 1px solid #222; }\n.pref_content th, td { padding: 1px; text-align: left; }\n.pref_content th { background-color: #222; }\n.pref_content tfoot { background-color: #222; }\n.pref_title {\n    font-size: 12px;\n    margin: 5px;\n    color: #7a7a7a;\n    text-align: center;\n}\n.node_preferences::-webkit-scrollbar {\n    width: 10px;\n}\n.node_preferences::-webkit-scrollbar-track {\n    background: #3a3a3a;\n}\n.node_preferences::-webkit-scrollbar-thumb {\n    background: #242424;\n}\n.node_preferences::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n.pref_content {\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n    padding: 5px 5px;\n}\n.pref_content img {\n    width: 100%;\n    height: auto;\n}\n.connection_content {\n    display: flex;\n    justify-content: space-between;\n}\n.left,\n.right {\n    width: 50%;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin: 5px;\n}\n.connection_wrapper {\n    display: flex;\n    justify-content: space-between;\n    margin: 1px;\n}\n.color_wrapper {\n    position: relative;\n    width: 20px;\n    height: 20px;\n    overflow: hidden;\n    flex-shrink: 0;\n}\n.color {\n    position: absolute;\n    width: 100px;\n    top: -20px;\n    left: -20px;\n    height: 100px;\n}\n.connection {\n    font-size: 12px;\npadding: 0 5px;\n    width: 100%;\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n}\n.button_nodes {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 8px;\n    width: 15px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_nodes_big {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 12px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_add\n{\n    margin:1px;\n    width: 20px;\n    height: 20px;\n}\n        `, {\n        \"node_preferences\": \"node_preferences\",\n        \"node_preferences_small\": \"node_preferences_small\",\n        \"node_preferences_big\": \"node_preferences_big\",\n        \"pref_title\": \"pref_title\",\n        \"pref_content\": \"pref_content\",\n        \"connection_content\": \"connection_content\",\n        \"left\": \"left\",\n        \"right\": \"right\",\n        \"connection_wrapper\": \"connection_wrapper\",\n        \"color_wrapper\": \"color_wrapper\",\n        \"connection\": \"connection\",\n        \"button_nodes\": \"button_nodes\",\n        \"button_nodes_big\": \"button_nodes_big\",\n        \"button_add\": \"button_add\",\n        \"name\": \"_name\",\n        \"content\": \"_content\",\n        \"manipulation\": \"manipulation\",\n        \"color\": \"color\",\n        \"pref_section\": \"pref_section\",\n    }, false);\n    class UMLBlock {\n        constructor(custom_style, appearance, id, name, text, x, y, width, connLeft = [], connRight = [], connections = []) {\n            this.name = name;\n            this.text = text;\n            this.t_text = \"\";\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.connections = connections;\n            this.connLeft = connLeft;\n            this.connRight = connRight;\n            this.height = 0;\n            this.isDragging = false;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            this.img = null;\n            this.content = null;\n            this.contentHeight = 0;\n            this.unescapedBase64Data = null;\n            this.appearance = appearance;\n            this.custom_style = custom_style;\n            this.appearance = Object.assign({}, this.appearance, custom_style);\n            this.darkText = '#ffffff';\n            this.lightText = '#000000';\n            this.update = true;\n            this.compiled_render = document.createElement('canvas');\n            this.block_context = this.compiled_render.getContext('2d');\n            this._processColors();\n        }\n        _restyle(object) {\n            this.custom_style = object;\n            this.appearance = Object.assign({}, this.appearance, object);\n            this._processColors();\n            this.t_text = '';\n        }\n        _processColors() {\n            const {\n                background,\n                factorTitleBackground,\n                factorDarkColorMargin,\n                factorDarkColorThreshold,\n                factorLightColors,\n                factorDarkColors,\n                darkTextColor,\n                lightTextColor\n            } = this.appearance;\n            const titleBg = Q.ColorBrightness(background, factorTitleBackground);\n            const isDark = Q.isDarkColor(background, factorDarkColorMargin, factorDarkColorThreshold);\n            const textColor = isDark ? darkTextColor : lightTextColor;\n            const borderColor = Q.ColorBrightness(background, isDark ? factorLightColors : factorDarkColors);\n            Object.assign(this.appearance, {\n                titleBackground: titleBg,\n                titleColor: textColor,\n                connectionTextColor: textColor,\n                textColor: textColor,\n                node_table_color: borderColor\n            });\n        }\n        _drawContainer(ctx, x, y, width, height) {\n            const { shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, background, radius, connectionPointSize } = this.appearance;\n            ctx.save();\n            Object.assign(ctx, {\n                fillStyle: background,\n                shadowColor,\n                shadowBlur,\n                shadowOffsetX,\n                shadowOffsetY\n            });\n            ctx.beginPath();\n            ctx.moveTo(x + radius, y);\n            ctx.lineTo(x + width - radius, y);\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n            ctx.lineTo(x + width, y + height - radius);\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n            ctx.lineTo(x + radius, y + height);\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n            ctx.lineTo(x, y + radius);\n            ctx.quadraticCurveTo(x, y, x + radius, y);\n            ctx.fill();\n            ctx.restore();\n        }\n        _drawTitle(ctx, x, y, width, height, title) {\n            ctx.fillStyle = this.appearance.titleBackground;\n            ctx.beginPath();\n            ctx.moveTo(x + this.appearance.radius, y);\n            ctx.arcTo(x + width, y, x + width, y + height, this.appearance.radius);\n            ctx.arcTo(x + width, y + height, x, y + height, 0);\n            ctx.arcTo(x, y + height, x, y, 0);\n            ctx.arcTo(x, y, x + width, y, this.appearance.radius);\n            ctx.closePath();\n            ctx.fill();\n            ctx.fillStyle = this.appearance.titleColor;\n            ctx.font = 'bold ' + this.appearance.fontSizeTitle + 'px ' + this.appearance.font;\n            const titleX = x + (width - ctx.measureText(title).width) / 2;\n            const titleY = y + (height + this.appearance.fontSizeTitle) / 2;\n            ctx.fillText(title, titleX, titleY);\n        }\n        parseHTML2Canvas(html, callback) {\n            const renderElements = () => {\n                if (this.t_text == html) {\n                    callback(this.content, this.contentHeight);\n                    return;\n                }\n                this.t_text = html;\n                let tempContainer = document.createElement('div');\n                tempContainer.style.position = 'absolute';\n                tempContainer.style.visibility = 'hidden';\n                tempContainer.style.width = (this.width - this.appearance.fontSize) + 'px';\n                document.body.appendChild(tempContainer);\n                let style = document.createElement('style');\n                let st = `\n        table {border-collapse: collapse; width: 100%;}\n        table, th, td {padding: 0; margin: 0; font-size: ${(this.appearance.fontSize * 0.9)}px; line-break: anywhere;border: 1px solid ${this.appearance.node_table_color};}\n        th, td {padding: 1px; text-align: left;}\n        th {background-color: ${this.appearance.node_table_color};}\n        tfoot {background-color: ${this.appearance.node_table_color};}\n        h1, h2, h3, h4, h5, h6 {line-break: anywhere; margin: 0 0 2px 0; padding: 0;}\n        h1 {font-size: ${(this.appearance.fontSize * 1.5)}px;}\n        h2 {font-size: ${(this.appearance.fontSize * 1.4)}px;}\n        h3 {font-size: ${(this.appearance.fontSize * 1.3)}px;}\n        h4 {font-size: ${(this.appearance.fontSize * 1.2)}px;}\n        h5 {font-size: ${(this.appearance.fontSize * 1.1)}px;}\n        h6 {font-size: ${(this.appearance.fontSize * 1.0)}px;}\n                        p { margin: 0; padding: 0; color: ${this.appearance.textColor}; }\n                        ul { margin: 5px 5px; padding-left: 15px; color: ${this.appearance.textColor}; }\n                        li { padding: 0px; margin: 0px; }\n                        div {font-family: ${this.appearance.font}, sans-serif; font-size: ${this.appearance.fontSize}px; color: ${this.appearance.textColor}; }\n                    `;\n                style.innerHTML = st;\n                document.head.appendChild(style);\n                tempContainer.innerHTML = html;\n                this.contentHeight = tempContainer.offsetHeight + this.appearance.padding;\n                document.body.removeChild(tempContainer);\n                document.head.removeChild(style);\n                this.content = document.createElement('canvas');\n                this.content.width = this.width;\n                this.content.height = this.contentHeight;\n                let ctx = this.content.getContext('2d');\n                let data = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + (this.width - (this.appearance.padding * 2)) + '\" height=\"' + this.contentHeight + '\">' + // Update SVG height\n                    '<foreignObject width=\"100%\" height=\"100%\">' +\n                    '<style>' +\n                    st +\n                    '</style>' +\n                    '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +\n                    html +\n                    '</div>' +\n                    '</foreignObject>' +\n                    '</svg>';\n                let DOMURL = window.URL || window.webkitURL || window;\n                let img = new Image();\n                let svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });\n                let url = DOMURL.createObjectURL(svg);\n                img.onload = () => {\n                    ctx.drawImage(img, 0, 0);\n                    DOMURL.revokeObjectURL(url);\n                    callback(this.content, this.contentHeight);\n                };\n                img.src = url;\n            };\n            html = html.replace(/style=\"[^\"]*\"/g, '');\n            let images = [];\n            html = html.replace(/<br>/g, '');\n            if (html.includes('<img')) {\n                let imgTags = html.match(/<img[^>]+>/g);\n                imgTags.forEach((imgTag, index) => {\n                    let src = imgTag.match(/src=\"([^\"]*)\"/)[1];\n                    let img = new Image();\n                    img.src = src;\n                    img.onload = () => {\n                        images[index] = img;\n                        if (images.length === imgTags.length) {\n                            renderElements();\n                        }\n                    };\n                });\n            }\n            else {\n                renderElements();\n            }\n        }\n        draw(main_context) {\n            const TITLE_HEIGHT = this.appearance.fontSizeTitle + (this.appearance.padding * 2);\n            const CONNECTION_HEIGHT = this.appearance.padding + TITLE_HEIGHT;\n            const CONNECTION_PADDING = (this.appearance.connectionPointSize * 2) + this.appearance.connectionPointPadding;\n            const maxConnectionsHeight = Math.max(this.connLeft.length, this.connRight.length) * CONNECTION_PADDING;\n            if (this.update) {\n                const updateContainerHeight = (contentHeight) => {\n                    this.height = TITLE_HEIGHT + (this.appearance.padding * 2) + maxConnectionsHeight + contentHeight + this.appearance.padding;\n                    this.block_context.canvas.height = this.height;\n                    this.block_context.canvas.width = this.width + (this.appearance.connectionPointSize * 2);\n                };\n                this.parseHTML2Canvas(this.text, (canvas, contentHeight) => {\n                    updateContainerHeight(contentHeight);\n                    this._drawContainer(this.block_context, this.appearance.connectionPointSize, 0, this.width - 5, this.height, this.appearance.radius);\n                    this._drawTitle(this.block_context, this.appearance.connectionPointSize, 0, this.width - this.appearance.connectionPointSize, TITLE_HEIGHT, this.name);\n                    this.block_context.drawImage(canvas, this.appearance.padding, TITLE_HEIGHT + this.appearance.padding + maxConnectionsHeight);\n                    this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                    main_context.drawImage(this.compiled_render, this.x, this.y);\n                });\n                this.update = false;\n            }\n            else {\n                this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                main_context.drawImage(this.compiled_render, this.x, this.y);\n            }\n            return;\n        }\n        drawConnectionPoints(ctx, paddingTop, height) {\n            const connectionY = paddingTop;\n            const font = `bold ${this.appearance.fontSizeConnection}px ${this.appearance.font}`;\n            const pointSize = this.appearance.connectionPointSize;\n            const connectionPaddingX = this.appearance.connectionTextPaddingX;\n            const middleYOffset = ((pointSize / 2) + (this.appearance.fontSizeConnection / 2)) - this.appearance.connectionTextPaddingY;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            ctx.font = font;\n            const drawConnectionPoints = (connList, coordsArray, baseX, getTextX) => {\n                connList.forEach((conn, index) => {\n                    const connY = connectionY + index * height;\n                    coordsArray.push({ x: baseX, y: connY });\n                    ctx.fillStyle = conn.color || this.appearance.connectionColor;\n                    ctx.beginPath();\n                    ctx.arc(baseX, connY, pointSize, 0, 2 * Math.PI);\n                    ctx.fill();\n                    ctx.fillStyle = this.appearance.connectionTextColor;\n                    ctx.fillText(conn.title, getTextX(conn.title, baseX), connY + middleYOffset);\n                });\n            };\n            if (Array.isArray(this.connLeft)) {\n                drawConnectionPoints(this.connLeft, this.leftConnCoords, this.appearance.connectionPointSize, (title, baseX) => baseX + connectionPaddingX * 2);\n            }\n            if (Array.isArray(this.connRight)) {\n                drawConnectionPoints(this.connRight, this.rightConnCoords, this.width, (title, baseX) => baseX - ctx.measureText(title).width - connectionPaddingX * 2);\n            }\n        }\n        addConnection(conn) {\n            this.connections.push(conn);\n        }\n        removeConnection(conn) {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n        }\n        isMouseOver(mouseX, mouseY) {\n            return mouseX >= this.x && mouseX <= this.x + this.width && mouseY >= this.y && mouseY <= this.y + this.height;\n        }\n        getAllConnectionCoords() {\n            return [\n                ...this.leftConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y })),\n                ...this.rightConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y }))\n            ];\n        }\n        getConnectionCoord(point, index) {\n            return point === 'left' ? this.leftConnCoords[index] : this.rightConnCoords[index];\n        }\n    }\n    class UMLCanvas {\n        constructor(selector, width, height, appearance, classes) {\n            this.element_parent = Q(selector);\n            this.canvas = Q('<canvas>', { width: width, height: height });\n            this.width = width;\n            this.height = height;\n            this.element_parent.append(this.canvas);\n            this.canvas_context = this.canvas.nodes[0].getContext('2d');\n            this.blocks = [];\n            this.connections = [];\n            this.draggingBlock = null;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.connection_start = null;\n            this.connection_end = null;\n            this.mouseX = 0;\n            this.mouseY = 0;\n            this.isMenuPreferences = false;\n            this.isDraggingBlock = false;\n            this.isOverConnection = false;\n            this.appearance = appearance;\n            this.classes = classes;\n            this.canvas.on('click', this._event_click.bind(this));\n            this.canvas.on('mousedown', this._event_pointer_down.bind(this));\n            this.canvas.on('mousemove', this._event_pointer_move.bind(this));\n            this.canvas.on('mouseup', this._event_pointer_up.bind(this));\n            this.canvas.on('contextmenu', this._event_click_right.bind(this), false);\n        }\n        import(uml) {\n            const blockCreationPromises = uml.blocks.map(async (block) => {\n                const newBlock = new UMLBlock(\n                    block.custom_style,\n                    this.appearance,\n                    block.id, block.name, block.text, block.x, block.y, block.width,\n                    block.connLeft.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connRight.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connections\n                );\n                this.addBlock(newBlock);\n            });\n            Promise.all(blockCreationPromises).then(() => {\n                uml.connections.forEach(conn => {\n                    const startBlock = this.blocks.find(b => b.id === conn.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.target);\n                    const startCoords = this._point_coords(startBlock, conn.point);\n                    const endCoords = this._point_coords(endBlock, conn.targetPoint);\n                    if (startCoords && endCoords) {\n                        this._connection_create(\n                            { block: startBlock, point: conn.point, x: startCoords.x, y: startCoords.y },\n                            { block: endBlock, point: conn.targetPoint, x: endCoords.x, y: endCoords.y }\n                        );\n                    } else {\n                        console.error('Connection failed to initialize:', startBlock, endBlock);\n                    }\n                });\n            }).catch(err => {\n                console.error('Error during block initialization:', err);\n            });\n        }\n        export() {\n            return {\n                blocks: this.blocks.map(block => ({\n                    custom_style: block.custom_style,\n                    id: block.id,\n                    name: block.name,\n                    text: block.text,\n                    x: block.x,\n                    y: block.y,\n                    width: block.width,\n                    connLeft: block.connLeft,\n                    connRight: block.connRight,\n                    connections: block.connections\n                })),\n                connections: this.connections.map(conn => ({\n                    id: conn.start.block.id,\n                    point: conn.start.point,\n                    target: conn.end.block.id,\n                    targetPoint: conn.end.point\n                }))\n            };\n        }\n        async addBlock(block) {\n            this.blocks.push(block);\n            await this._connections_init(block);\n            this.render();\n        }\n        removeBlock(block) {\n            this.blocks = this.blocks.filter(b => b.id !== block.id);\n            this.connections = this.connections.filter(conn =>\n                conn.start.block.id !== block.id && conn.end.block.id !== block.id\n            );\n            this.render();\n        }\n        getJointContent() {\n            let block = this.blocks[0];\n            let content = block.text;\n            let connections = block.connections;\n            let nextBlock = null;\n            while (connections.length > 0) {\n                let conn = connections[0];\n                nextBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                content += nextBlock.text;\n                connections = nextBlock.connections;\n            }\n            return content;\n        }\n        duplicateBlock(block) {\n            let id = this._id();\n            const newBlock = new UMLBlock(\n                block.custom_style,\n                this.appearance,\n                id, block.name, block.text, block.x + 50, block.y + 50, block.width,\n                block.connLeft, block.connRight, []\n            );\n            this.addBlock(newBlock);\n        }\n        render_grid() {\n            let ctx = this.canvas_context;\n            let w = this.width;\n            let h = this.height;\n            let grid_size = this.appearance.gridSize;\n            let grid_color = this.appearance.gridColor;\n            ctx.strokeStyle = grid_color;\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            for (let x = 0; x <= w; x += grid_size) {\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, h);\n            }\n            for (let y = 0; y <= h; y += grid_size) {\n                ctx.moveTo(0, y);\n                ctx.lineTo(w, y);\n            }\n            ctx.stroke();\n        }\n        render() {\n            this.canvas_context.clearRect(0, 0, this.width, this.height);\n            this.render_grid();\n            this.connections.forEach(conn => {\n                let startBlock = conn.start.block;\n                let endBlock = conn.end.block;\n                let startColor = this._getConnectionColor(startBlock, conn.start.point);\n                let endColor = this._getConnectionColor(endBlock, conn.end.point);\n                this.canvas_context.strokeStyle = 'rgb(150, 150, 150)';\n                this.canvas_context.beginPath();\n                this.canvas_context.lineWidth = 2;\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + conn.start.x, startBlock.y + conn.start.y,\n                    endBlock.x + conn.end.x, endBlock.y + conn.end.y\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, endColor);\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.moveTo(startBlock.x + conn.start.x, startBlock.y + conn.start.y);\n                this.canvas_context.lineTo(endBlock.x + conn.end.x, endBlock.y + conn.end.y);\n                this.canvas_context.stroke();\n                let dx = (endBlock.x + conn.end.x) - (startBlock.x + conn.start.x);\n                let dy = (endBlock.y + conn.end.y) - (startBlock.y + conn.start.y);\n                let length = Math.sqrt(dx * dx + dy * dy);\n                let unitDx = dx / length;\n                let unitDy = dy / length;\n                let arrowLength = 10;\n                let arrowWidth = 5;\n                for (let i = 100; i < length; i += 200) {\n                    let x = (startBlock.x + conn.start.x) + unitDx * i;\n                    let y = (startBlock.y + conn.start.y) + unitDy * i;\n                    this.canvas_context.beginPath();\n                    this.canvas_context.moveTo(x, y);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx + arrowWidth * unitDy, y - arrowLength * unitDy - arrowWidth * unitDx);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx - arrowWidth * unitDy, y - arrowLength * unitDy + arrowWidth * unitDx);\n                    this.canvas_context.closePath();\n                    this.canvas_context.fillStyle = gradient;\n                    this.canvas_context.fill();\n                }\n            });\n            if (this.connection_start && this.connection_end === null) {\n                let startBlock = this.connection_start.block;\n                let startColor = this._getConnectionColor(startBlock, this.connection_start.point);\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y,\n                    this.mouseX, this.mouseY\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, \"rgb(150, 150, 150)\");\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.beginPath();\n                this.canvas_context.moveTo(startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y);\n                this.canvas_context.lineTo(this.mouseX, this.mouseY);\n                this.canvas_context.stroke();\n            }\n            this.blocks.forEach(block => {\n                block.draw(this.canvas_context);\n            });\n            this._connection_update();\n        }\n        _getConnectionColor(block, pointId) {\n            const connection = [...block.connLeft, ...block.connRight]\n                .find(conn => conn.id === pointId);\n            return connection ? connection.color : null;\n        }\n        updateConnections(block) {\n            const preferences = Q('.' + classes.node_preferences);\n            const collectConnections = (sideClass) => {\n                const side = preferences.find('.' + sideClass);\n                const connections = [];\n                side.find('.' + classes.connection_wrapper).walk((element) => {\n                    const id = element.id();\n                    const title = element.find('.' + classes.connection).val() || '';\n                    const color = element.find('.' + classes.color).val();\n                    connections.push({ id, title, color });\n                }, true);\n                return connections;\n            };\n            const newLeftConnections = collectConnections(classes.left);\n            const newRightConnections = collectConnections(classes.right);\n            const newConnections = [...newLeftConnections, ...newRightConnections];\n            const existingConnections = [...block.connLeft, ...block.connRight];\n            newConnections.forEach(newConn => {\n                const existingConn = existingConnections.find(conn => conn.id === newConn.id);\n                if (existingConn) {\n                    existingConn.title = newConn.title;\n                    existingConn.color = newConn.color;\n                } else {\n                    existingConnections.push(newConn);\n                }\n            });\n        }\n        updateBlock(selectedblock = null, callback) {\n            let preferences = Q('.' + classes.node_preferences);\n            let block;\n            if (selectedblock) {\n                block = selectedblock;\n            }\n            else {\n                block = this.blocks.find(b => b.id === preferences.id());\n            }\n            let name = preferences.find('#' + classes.name).text();\n            let content = preferences.find('#' + classes.content).html();\n            block.name = name;\n            block.text = content;\n            block.update = true;\n            if (callback) callback(block);\n        }\n        _event_pointer_down(event) {\n            if (event.button === 2) return;\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                let block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this.isDraggingBlock = true;\n                    this.draggingBlock = block;\n                    this.offsetX = mouseX - block.x;\n                    this.offsetY = mouseY - block.y;\n                    block.isDragging = true;\n                    break;\n                }\n            }\n        }\n        _event_pointer_move(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.draggingBlock) {\n                if (this.appearance.snapToGrid) {\n                    this.draggingBlock.x = Math.round(this.draggingBlock.x / this.appearance.gridSize) * this.appearance.gridSize;\n                    this.draggingBlock.y = Math.round(this.draggingBlock.y / this.appearance.gridSize) * this.appearance.gridSize;\n                    if (!this.lastMouseX || Math.abs(mouseX - this.lastMouseX) >= this.appearance.gridSize || Math.abs(mouseY - this.lastMouseY) >= this.appearance.gridSize) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                } else {\n                    if (!this.lastMouseX || Math.abs(mouseX - this.lastMouseX) >= this.appearance.movementResolution || Math.abs(mouseY - this.lastMouseY) >= this.appearance.movementResolution) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                }\n                return;\n            }\n            if (this.connection_start && this.connection_end === null) {\n                this.mouseX = mouseX;\n                this.mouseY = mouseY;\n                this.render();\n                return;\n            }\n            if (this.isOverConnection) {\n                this.isOverConnection = false;\n                this.render();\n            }\n            this.connections.forEach(conn => {\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    if (!this.isOverConnection) {\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y, this.appearance.connectionPointSize + 2, 0, 2 * Math.PI);\n                        let startColor = this._getConnectionColor(conn.start.block, conn.start.point);\n                        this.canvas_context.strokeStyle = startColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y, this.appearance.connectionPointSize + 2, 0, 2 * Math.PI);\n                        let endColor = this._getConnectionColor(conn.end.block, conn.end.point);\n                        this.canvas_context.strokeStyle = endColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.isOverConnection = true;\n                    }\n                }\n            });\n        }\n        _event_pointer_up(event) {\n            if (this.draggingBlock) {\n                this.isDraggingBlock = false;\n                this.draggingBlock.isDragging = false;\n                this.draggingBlock = null;\n                this.render();\n            }\n            if (this.connection_start && this.connection_end === null) {\n                setTimeout(() => {\n                    this.connection_start = null;\n                    this.mouseX = 0;\n                    this.mouseY = 0;\n                    this.render();\n                }, 100);\n            }\n        }\n        _event_click(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            for (let block of this.blocks) {\n                if (this._connection_over_point(block, mouseX, mouseY)) {\n                    if (this.connection_start === null) {\n                        this.connection_start = this._point_details(block, mouseX, mouseY);\n                    }\n                    else if (this.connection_end === null) {\n                        this.connection_end = this._point_details(block, mouseX, mouseY);\n                        if (this.connection_start.block !== this.connection_end.block &&\n                            !this._connection_exists(this.connection_start, this.connection_end)) {\n                            this._connection_create(this.connection_start, this.connection_end);\n                            block.addConnection({ id: this.connection_start.block.id, point: this.connection_start.point });\n                        } else {\n                            this.connection_start = null;\n                            this.connection_end = null;\n                            this.render();\n                        }\n                        this.connection_start = null;\n                        this.connection_end = null;\n                    }\n                    return;\n                }\n            }\n        }\n        _menu_context(x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_small], style: { position: 'absolute', left: x + 'px', top: y + 'px' } });\n            this.isMenuPreferences = true;\n            let add = Q('<div>', { class: ['button_nodes_big'], text: 'Create Block' });\n            add.on('click', () => {\n                let id = this._id();\n                let nodes = this.blocks.length + 1;\n                let block = new UMLBlock({}, this.appearance, id, 'Node ' + nodes, 'Content', x, y, this.appearance.blockWidth, [{ id: this._id(), title: '', color: this.appearance.connectionColor }], [{ id: this._id(), title: '', color: this.appearance.connectionColor }]);\n                this.addBlock(block);\n                this._menu_remove();\n            });\n            div.append(add);\n            this.element_parent.append(div);\n        }\n        _event_click_right(event) {\n            event.preventDefault();\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                const block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this._menu_remove();\n                    this._menu_preferences(block, mouseX, mouseY);\n                    return;\n                }\n            }\n            for (let i = 0; i < this.connections.length; i++) {\n                const conn = this.connections[i];\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    const startBlock = this.blocks.find(b => b.id === conn.start.block.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                    if (startBlock && endBlock) {\n                        startBlock.removeConnection({ id: endBlock.id, point: conn.start.point });\n                    }\n                    this.connections.splice(i, 1);\n                    this.render();\n                    return;\n                }\n            }\n            this._menu_context(mouseX, mouseY);\n            this.render();\n        }\n        _id() {\n            return '_' + Math.random().toString(36).substr(2, 9);\n        }\n        _menu_remove() {\n            Q('.' + classes.node_preferences).remove();\n            this.isMenuPreferences = false;\n        }\n        _menu_item_section(title, content) {\n            let div = Q('<div>', { class: [classes.pref_section] });\n            let titleDiv = Q('<div>', { class: [classes.pref_title], text: title });\n            div.append(titleDiv, content);\n            return div;\n        }\n        _menu_item_input(id, content, placeholder) {\n            let input = Q('<div>', { class: [classes.pref_content], id: id, contentEditable: true, html: content, placeholder: placeholder });\n            return input;\n        }\n        _menu_item_connections(block) {\n            let div = Q('<div>', { class: [classes.connection_content] });\n            let left = Q('<div>', { class: [classes.left] });\n            let right = Q('<div>', { class: [classes.right] });\n            const connItem = (pos, conn) => {\n                let connection_wrapper = Q('<div>', { class: [classes.connection_wrapper], id: conn.id });\n                let connection = Q('<input>', { class: [classes.connection], type: 'text', value: conn.title, placeholder: 'Point...', maxLength: 10 });\n                let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n                let color = Q('<input>', { class: [classes.color], type: 'color', value: conn.color });\n                color_wrapper.append(color);\n                color.on('change', () => {\n                    conn.color = color.val();\n                    this.render();\n                });\n                connection.on('input', () => {\n                    let contitle = connection.val();\n                    conn.title = (conn.title && contitle !== null) ? contitle : '';\n                    this.updateConnections(block);\n                    this.render();\n                });\n                connection_wrapper.append(color_wrapper, connection);\n                let remove = Q('<div>', { class: [classes.button_nodes], text: 'X' });\n                remove.on('click', () => {\n                    connection_wrapper.remove();\n                    this.connections = this.connections.filter(c => {\n                        if (c.start.block.id === block.id && c.start.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.end.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.end.point });\n                            return false;\n                        }\n                        if (c.end.block.id === block.id && c.end.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.start.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.start.point });\n                            return false;\n                        }\n                        return true;\n                    });\n                    if (pos === 'left') { block.connLeft = block.connLeft.filter(c => c.id !== conn.id); }\n                    if (pos === 'right') { block.connRight = block.connRight.filter(c => c.id !== conn.id); }\n                    this.render();\n                });\n                connection_wrapper.append(remove);\n                return connection_wrapper;\n            };\n            block.connLeft.forEach(conn => {\n                let connection_wrapper = connItem('left', conn);\n                left.append(connection_wrapper);\n            });\n            block.connRight.forEach(conn => {\n                let connection_wrapper = connItem('right', conn);\n                right.append(connection_wrapper);\n            });\n            let add = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            add.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connLeft.push(connection);\n                left.append(connItem('left', connection));\n                left.append(add);\n                this.render();\n            });\n            left.append(add);\n            let addRight = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            addRight.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connRight.push(connection);\n                right.append(connItem('right', connection));\n                right.append(addRight);\n                this.render();\n            });\n            right.append(addRight);\n            div.append(left, right);\n            return div;\n        }\n        _menu_manipulation(block) {\n            let div = Q('<div>', { class: [classes.manipulation] });\n            let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n            let color = Q('<input>', { class: [classes.color], type: 'color', value: block.appearance.background });\n            color_wrapper.append(color);\n            color.on('change', () => {\n                block._restyle({ background: color.val() });\n                this.render();\n            });\n            div.append(color_wrapper);\n            let delete_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Delete Block' });\n            delete_button.on('click', () => {\n                this.removeBlock(block);\n                this._menu_remove();\n            });\n            let duplicate_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Duplicate Block' });\n            duplicate_button.on('click', () => {\n                this.duplicateBlock(block);\n                this._menu_remove();\n            });\n            div.append(color_wrapper, delete_button, duplicate_button);\n            return div;\n        }\n        _menu_preferences(block, x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_big], id: block.id });\n            div.css({ position: 'absolute', left: x + 'px', top: y + 'px' });\n            let title = this._menu_item_section('Class', this._menu_item_input(classes.name, block.name, 'Class name...'));\n            let content = this._menu_item_section('Content', this._menu_item_input(classes.content, block.text, 'Content...'));\n            let connections = this._menu_item_section('Connections', this._menu_item_connections(block));\n            let manipulation = this._menu_item_section('Manipulation', this._menu_manipulation(block));\n            div.append(title, content, connections, manipulation);\n            this.element_parent.append(div);\n            this.isMenuPreferences = true;\n        }\n        _connections_init(block) {\n            block.connections.forEach(conn => {\n                const targetBlock = this.blocks.find(b => b.id === conn.id);\n                if (targetBlock) {\n                    const startCoords = this._point_coords(block, 'right');\n                    const endCoords = this._point_coords(targetBlock, 'left');\n                    this._connection_create(\n                        { block: block, point: 'right', x: startCoords.x, y: startCoords.y },\n                        { block: targetBlock, point: conn.point, x: endCoords.x, y: endCoords.y }\n                    );\n                }\n            });\n        }\n        _blocks_connected(block1, block2) {\n            return this.connections.some(connection =>\n                (connection.start.block === block1 && connection.end.block === block2) ||\n                (connection.start.block === block2 && connection.end.block === block1)\n            );\n        }\n        _connection_exists(startConn, endConn) {\n            return this.connections.some(conn => {\n                const isDirectMatch =\n                    conn.start.block === startConn.block && conn.start.point === startConn.point &&\n                    conn.end.block === endConn.block && conn.end.point === endConn.point;\n                const isReverseMatch =\n                    conn.start.block === endConn.block && conn.start.point === endConn.point &&\n                    conn.end.block === startConn.block && conn.end.point === startConn.point;\n                return isDirectMatch || isReverseMatch;\n            });\n        }\n        _connection_create(startConn, endConn) {\n            this.connections.push({\n                start: { block: startConn.block, point: startConn.point, x: startConn.x, y: startConn.y },\n                end: { block: endConn.block, point: endConn.point, x: endConn.x, y: endConn.y }\n            });\n            startConn.block.addConnection({ id: endConn.block.id, point: startConn.point });\n            endConn.block.addConnection({ id: startConn.block.id, point: endConn.point });\n            this.render();\n        }\n        _connection_update() {\n            this.connections.forEach(conn => {\n                Object.assign(conn.start, this._point_coords(conn.start.block, conn.start.point));\n                Object.assign(conn.end, this._point_coords(conn.end.block, conn.end.point));\n            });\n        }\n        _point_coords(block, pointId) {\n            const connections = [\n                { coords: block.leftConnCoords, conns: block.connLeft },\n                { coords: block.rightConnCoords, conns: block.connRight }\n            ];\n            for (const { coords, conns } of connections) {\n                const index = conns.findIndex(conn => conn.id === pointId);\n                if (index !== -1) {\n                    return { x: coords[index].x, y: coords[index].y };\n                }\n            }\n            return { x: block.x, y: block.y };\n        }\n        _connection_over_point(block, x, y) {\n            const radius = 5;\n            return block.getAllConnectionCoords().some(coord => Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius);\n        }\n        _point_details(block, x, y) {\n            x -= block.x;\n            y -= block.y;\n            const radius = 5;\n            let matchedPoint = null;\n            block.leftConnCoords.forEach((coord, index) => {\n                if (Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius) {\n                    matchedPoint = { block: block, point: block.connLeft[index].id, x: coord.x, y: coord.y, index: index };\n                }\n            });\n            if (!matchedPoint) {\n                block.rightConnCoords.forEach((coord, index) => {\n                    if (Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius) {\n                        matchedPoint = { block: block, point: block.connRight[index].id, x: coord.x, y: coord.y, index: index };\n                    }\n                });\n            }\n            return matchedPoint;\n        }\n        _point_line_segment(px, py, x1, y1, x2, y2) {\n            const d1 = Math.hypot(px - x1, py - y1);\n            const d2 = Math.hypot(px - x2, py - y2);\n            const lineLen = Math.hypot(x2 - x1, y2 - y1);\n            return d1 + d2 >= lineLen - 0.1 && d1 + d2 <= lineLen + 0.1;\n        }\n        _point_line_distance(px, py, x1, y1, x2, y2) {\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            const lenSq = dx * dx + dy * dy;\n            let t = 0;\n            if (lenSq !== 0) {\n                t = ((px - x1) * dx + (py - y1) * dy) / lenSq;\n                t = Math.max(0, Math.min(1, t));\n            }\n            const projX = x1 + t * dx;\n            const projY = y1 + t * dy;\n            return Math.hypot(px - projX, py - projY);\n        }\n    }\n    let appearance = {\n        darkTextColor: '#888',\n        lightTextColor: '#222',\n        background: '#181818',\n        grid: true,\n        gridColor: '#161616',\n        gridSize: 20,\n        snapToGrid: false,\n        movementResolution: 3,\n        factorTitleBackground: -20,\n        factorDarkColors: -30,\n        factorLightColors: 80,\n        factorDarkColorMargin: 20,\n        factorDarkColorThreshold: 127,\n        blockWidth: 200,\n        connectionColor: '#333333',\n        connectionPointSize: 5,\n        connectionPointPadding: 5,\n        connectionTextPaddingX: 5,\n        connectionTextPaddingY: 5,\n        shadowBlur: 10,\n        shadowColor: 'rgba(0, 0, 0, 0.2)',\n        shadowOffsetX: 0,\n        shadowOffsetY: 5,\n        font: 'Arial',\n        fontSize: 12,\n        fontSizeTitle: 12,\n        fontSizeConnection: 10,\n        padding: 5,\n        radius: 10\n    };\n    appearance = Object.assign(appearance, options);\n    let uml = new UMLCanvas(selector, width, height, appearance, classes);\n    return {\n        import: function (data) {\n            uml.import(data);\n        },\n        export: function () {\n            return uml.export();\n        },\n        addBlock: function (block) {\n            uml.addBlock(block);\n        },\n        removeBlock: function (block) {\n            uml.removeBlock(block);\n        }\n    };\n}"
        },
        "Socket": {
            "uuid": "7739b88a-5e8e-4b5a-a2b4-65f5aa1e0299",
            "name": "Socket",
            "method": "Plugin",
            "desc": "Provides a WebSocket implementation with automatic reconnection and status callbacks.",
            "type": "Plugin",
            "example": "var socket = Q.Socket('ws://localhost:8080', console.log, console.log);",
            "dependencies": [],
            "script": "Q.Socket = function (url, onMessage, onStatus, options = {}) {\n    const {\n        retries = 5,                   // Number of reconnection attempts (0 means unlimited)\n        delay = 1000,                  // Initial delay between reconnections in ms\n        protocols = [],                // WebSocket sub-protocols\n        backoff = false,               // Exponential backoff toggle\n        pingInterval = 0,              // Interval for heartbeat pings (ms); 0 disables\n        pingMessage = 'ping',          // Message to send for heartbeat\n        queueMessages = false,         // Queue messages if socket is not open yet\n        autoReconnect = true,          // Automatically reconnect on close\n        onOpen = null,                 // Additional callback on open\n        onClose = null,                // Additional callback on close\n        onError = null                 // Additional callback on error\n    } = options;\n    let socket, attempts = 0, currentDelay = delay, pingId = null;\n    const messageQueue = [];\n    const connect = () => {\n        socket = new WebSocket(url, protocols);\n        socket.onopen = () => {\n            attempts = 0;\n            currentDelay = delay;\n            onStatus?.('connected');\n            onOpen?.();\n            if (queueMessages && messageQueue.length) {\n                while (messageQueue.length) {\n                    socket.send(messageQueue.shift());\n                }\n            }\n            if (pingInterval) {\n                pingId && clearInterval(pingId);\n                pingId = setInterval(() => {\n                    if (socket.readyState === WebSocket.OPEN) {\n                        socket.send(pingMessage);\n                    }\n                }, pingInterval);\n            }\n        };\n        socket.onmessage = event => onMessage?.(event.data);\n        socket.onerror = error => {\n            onStatus?.('error', error);\n            onError?.(error);\n        };\n        socket.onclose = event => {\n            onClose?.(event);\n            pingId && clearInterval(pingId);\n            if (autoReconnect && (retries === 0 || attempts < retries)) {\n                onStatus?.('closed');\n                attempts++;\n                setTimeout(() => {\n                    connect();\n                    if (backoff) {\n                        currentDelay *= 2;\n                    }\n                }, currentDelay);\n            } else {\n                onStatus?.('Max retries exceeded');\n            }\n        };\n    };\n    connect();\n    return {\n        send: message => {\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                socket.send(message);\n            } else if (queueMessages) {\n                messageQueue.push(message);\n            }\n        },\n        reconnect: () => connect(),\n        close: () => {\n            autoReconnect = false;\n            pingId && clearInterval(pingId);\n            socket.close();\n        },\n        getState: () => socket?.readyState\n    };\n};"
        },
        "String": {
            "uuid": "a77518b0-9f67-41b5-b654-27acdcbd8317",
            "name": "String",
            "method": "Plugin",
            "desc": "Provides methods to manipulate strings.",
            "type": "Plugin",
            "example": "Q.String('hello').capitalize(); // returns 'Hello'",
            "dependencies": [],
            "script": "Q.String = function (string) {\n    if (!(this instanceof Q.String)) {\n        return new Q.String(string);\n    }\n    this.string = string;\n};\nQ.String.prototype.capitalize = function () {\n    return this.string.charAt(0).toUpperCase() + this.string.slice(1);\n};\nQ.String.prototype.levenshtein = function (string) {\n    const a = this.string, b = string;\n    const matrix = Array.from({ length: a.length + 1 }, (_, i) => Array.from({ length: b.length + 1 }, (_, j) => i || j));\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\nQ.String.prototype.find = function (stringOrRegex) {\n    return this.string.match(stringOrRegex);\n};\nQ.String.prototype.replaceAll = function (stringOrRegex, replacement) {\n    return this.string.replace(new RegExp(stringOrRegex, 'g'), replacement);\n};"
        },
        "Thread": {
            "uuid": "74f8a315-e690-4d57-b8b3-a1bf650c6cfd",
            "name": "Thread",
            "method": "Plugin",
            "desc": "Thread is a utility for managing Web Workers in a thread pool. It allows developers to execute functions in parallel, offloading heavy tasks to separate threads and improving performance. <br> Thread provides a simple interface for creating, managing, and controlling worker threads, enabling developers to execute multiple tasks concurrently without blocking the main thread. <br> By distributing workloads across multiple threads, developers can optimize performance and enhance user experience.",
            "type": "Plugin",
            "example": "const thread = Q.Thread(4); // Creates a thread pool with 4 workers <br> thread.Push(() => heavyTask(1, 2, 3)).then(result => console.log(result)); // Executes heavyTask in a worker thread <br> thread.Push(heavyTask, 1, 2, 3).then(result => console.log(result)); // Executes heavyTask in a worker thread <br> thread.Workers(2); // Sets the number of workers to 2 <br> thread.Result(({ id, result, error }) => console.log(id, result, error)); // Logs the result of each task <br> thread.Done(() => console.log('All tasks completed')); // Logs when all tasks are completed <br> thread.Abort(); // Aborts all tasks and terminates worker threads",
            "dependencies": [],
            "script": "(() => {\n    class ThreadPool {\n      constructor(maxWorkers = 1) {\n        this.maxWorkers = maxWorkers;\n        this.workers = [];\n        this.taskQueue = [];\n        this.activeTasks = new Map();\n        this.taskIdCounter = 0;\n        this.resultCallbacks = [];\n        this.doneCallbacks = [];\n        this.aborted = false;\n        this.blobURL = ThreadPool._createWorkerBlob();\n        for (let index = 0; index < maxWorkers; index++) {\n          this._addWorker();\n        }\n      }\n      static _createWorkerBlob() {\n        const code = `\n          self.onmessage = event => {\n            const { taskId, functionCode, parameters } = event.data;\n            let executionFunction;\n            try {\n              executionFunction = eval('(' + functionCode + ')');\n            } catch (error) {\n              self.postMessage({ taskId, error: error.toString() });\n              return;\n            }\n            Promise.resolve().then(() => executionFunction(...parameters)).then(\n              result => self.postMessage({ taskId, result }),\n              error => self.postMessage({ taskId, error: error.toString() })\n            );\n          };\n        `;\n        return URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));\n      }\n      _addWorker() {\n        const workerInstance = new Worker(this.blobURL);\n        workerInstance.busy = false;\n        workerInstance.onmessage = event => {\n          const { taskId, result, error } = event.data;\n          workerInstance.busy = false;\n          const task = this.activeTasks.get(taskId);\n          if (task) {\n            error !== undefined ? task.reject(new Error(error)) : task.resolve(result);\n            this.resultCallbacks.forEach(callbackFunction => callbackFunction({ id: taskId, result, error }));\n            this.activeTasks.delete(taskId);\n          }\n          this._processQueue();\n        };\n        workerInstance.onerror = () => { workerInstance.busy = false; };\n        this.workers.push(workerInstance);\n      }\n      _processQueue() {\n        if (this.aborted) return;\n        while (true) {\n          const idleIndex = this.workers.findIndex(workerInstance => !workerInstance.busy);\n          if (idleIndex === -1 || this.workers.length <= this.maxWorkers) break;\n          this.workers[idleIndex].terminate();\n          this.workers.splice(idleIndex, 1);\n        }\n        for (const workerInstance of this.workers) {\n          if (!workerInstance.busy && this.taskQueue.length) {\n            const task = this.taskQueue.shift();\n            workerInstance.busy = true;\n            this.activeTasks.set(task.id, task);\n            workerInstance.postMessage({ taskId: task.id, functionCode: task.functionCode, parameters: task.parameters });\n          }\n        }\n        if (!this.taskQueue.length && !this.activeTasks.size) {\n          const callbacks = this.doneCallbacks.slice();\n          this.doneCallbacks.length = 0;\n          callbacks.forEach(callbackFunction => callbackFunction());\n        }\n      }\n      Workers(newWorkerCount) {\n        if (this.aborted) return this;\n        this.maxWorkers = newWorkerCount;\n        if (newWorkerCount > this.workers.length) {\n          for (let index = 0, difference = newWorkerCount - this.workers.length; index < difference; index++) {\n            this._addWorker();\n          }\n        } else {\n          this._processQueue();\n        }\n        return this;\n      }\n      Push(taskInput, ...parameters) {\n        if (this.aborted) return Promise.reject(new Error('Thread aborted'));\n        const taskFunction = typeof taskInput === 'function' ? taskInput : (() => taskInput);\n        const taskId = ++this.taskIdCounter;\n        const task = { id: taskId, functionCode: taskFunction.toString(), parameters, resolve: null, reject: null };\n        const promiseResult = new Promise((resolve, reject) => { task.resolve = resolve; task.reject = reject; });\n        this.taskQueue.push(task);\n        this._processQueue();\n        return promiseResult;\n      }\n      Result(callbackFunction) {\n        if (typeof callbackFunction === 'function') this.resultCallbacks.push(callbackFunction);\n        return this;\n      }\n      Done(callbackFunction) {\n        if (typeof callbackFunction !== 'function') return this;\n        if (!this.taskQueue.length && !this.activeTasks.size) callbackFunction();\n        else this.doneCallbacks.push(callbackFunction);\n        return this;\n      }\n      Abort() {\n        this.aborted = true;\n        while (this.taskQueue.length) this.taskQueue.shift().reject(new Error('Task aborted'));\n        this.activeTasks.forEach(task => task.reject(new Error('Task aborted')));\n        this.activeTasks.clear();\n        this.workers.forEach(workerInstance => workerInstance.terminate());\n        this.workers = [];\n        this.doneCallbacks.length = 0;\n        this.resultCallbacks.length = 0;\n        URL.revokeObjectURL(this.blobURL);\n        return this;\n      }\n    }\n    Q.Thread = (maxWorkers = 1) => new ThreadPool(maxWorkers);\n  })();"
        },
        "Timer": {
            "uuid": "886cb7d2-1ab0-4a97-a8f9-94a743a97fb9",
            "name": "Timer",
            "method": "Plugin",
            "desc": "Provides a timer implementation with automatic stop and interrupt. Useful for running tasks at intervals or for a specific duration.",
            "type": "Plugin",
            "example": "Q.Timer(() => console.log('Tick'), 'timer1', { tick: 5, delay: 1000, interrupt: true });",
            "dependencies": [],
            "script": "Q.Timer = (callback, identifier, options = {}) => {\n    const defaults = { tick: 1, delay: 1000, interrupt: false, autoStart: true, done: null };\n    const config = { ...defaults, ...options };\n    if (!Q.Timer.activeTimers) Q.Timer.activeTimers = new Map();\n    if (config.interrupt && Q.Timer.activeTimers.has(identifier)) Q.Timer.stop(identifier);\n    const timerControl = {\n      id: identifier,\n      tickCount: 0,\n      isPaused: false,\n      remainingDelay: config.delay,\n      startTime: 0,\n      timerHandle: null,\n      pause() {\n        if (!this.isPaused) {\n          this.isPaused = true;\n          clearTimeout(this.timerHandle);\n          const elapsed = Date.now() - this.startTime;\n          this.remainingDelay = config.delay - elapsed;\n        }\n        return this;\n      },\n      resume() {\n        if (this.isPaused) {\n          this.isPaused = false;\n          startTick(this.remainingDelay);\n        }\n        return this;\n      },\n      stop() { Q.Timer.stop(this.id); }\n    };\n    const startTick = (delayTime) => {\n      timerControl.startTime = Date.now();\n      timerControl.timerHandle = setTimeout(function tickHandler() {\n        callback();\n        timerControl.tickCount++;\n        if (config.tick > 0 && timerControl.tickCount >= config.tick) {\n          Q.Timer.stop(identifier);\n          if (typeof config.done === 'function') config.done();\n        } else {\n          timerControl.startTime = Date.now();\n          timerControl.timerHandle = setTimeout(tickHandler, config.delay);\n        }\n      }, delayTime);\n    };\n    if (config.autoStart) startTick(config.delay);\n    Q.Timer.activeTimers.set(identifier, timerControl);\n    return timerControl;\n  };\n  Q.Timer.stop = (identifier) => {\n    if (Q.Timer.activeTimers?.has(identifier)) {\n      const timerControl = Q.Timer.activeTimers.get(identifier);\n      clearTimeout(timerControl.timerHandle);\n      Q.Timer.activeTimers.delete(identifier);\n    }\n  };\n  Q.Timer.stopAll = () => {\n    if (Q.Timer.activeTimers) {\n      Q.Timer.activeTimers.forEach(timerControl => clearTimeout(timerControl.timerHandle));\n      Q.Timer.activeTimers.clear();\n    }\n  };"
        }
    },
    "statics": {
        "AvgColor": {
            "uuid": "4e69d096-bf12-45ec-91a0-71263c10538a",
            "name": "AvgColor",
            "method": "Utility",
            "desc": "Calculates the average color of an image by creating a canvas element, drawing the image on it, and analyzing the pixel data to determine the average color. <br> This technique is useful for generating color palettes, creating visual effects, or enhancing user interface elements based on the predominant colors in an image.",
            "type": "Image Processing",
            "example": "Q.AvgColor('image.jpg or canvas', sampleSize, callback); // Returns the average color of the image or canvas",
            "dependencies": [],
            "script": "Q.AvgColor = (source, sampleSize, callback) => {\n    const image = new Image();\n    image.crossOrigin = 'Anonymous';\n    if (typeof source === 'string') image.src = source;\n    else if (source instanceof HTMLCanvasElement) image.src = source.toDataURL();\n    else return console.error(\"Invalid image source provided.\");\n    image.onload = () => {\n      const canvas = Object.assign(document.createElement('canvas'), { width: image.width, height: image.height });\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const data = context.getImageData(0, 0, image.width, image.height).data;\n      const samplingRate = sampleSize === 'auto'\n        ? Math.max(1, Math.ceil(Math.sqrt(image.width * image.height) / 32))\n        : (typeof sampleSize === 'number' && sampleSize > 0 ? sampleSize : 1);\n      let totalRed = 0, totalGreen = 0, totalBlue = 0, count = 0;\n      for (let index = 0, len = data.length; index < len; index += samplingRate * 4) {\n        totalRed   += data[index];\n        totalGreen += data[index + 1];\n        totalBlue  += data[index + 2];\n        count++;\n      }\n      const avgColor = { r: (totalRed / count) | 0, g: (totalGreen / count) | 0, b: (totalBlue / count) | 0 };\n      typeof callback === 'function' && callback(avgColor);\n    };\n    image.onerror = () => console.error(\"Failed to load image.\");\n  };"
        },
        "ColorBrightness": {
            "uuid": "66130543-7dd3-45a8-b721-337d2c2cc299",
            "name": "ColorBrightness",
            "method": "Utility",
            "desc": "Adjusts the brightness of a given color by a specified percentage, making the color lighter or darker. <br> This function can be used to dynamically change colors for various UI elements, providing visual feedback or creating color schemes with different shades. <br> It supports both hexadecimal and RGB/RGBA color formats, making it flexible for different use cases in web design or graphics.",
            "type": "Color",
            "example": "Q.ColorBrightness('#000000', 50); // #7f7f7f (black +50%) <br> Q.ColorBrightness('rgb(255, 0, 0)', -30); // rgb(178, 0, 0) (red -30%) <br> Q.ColorBrightness('rgba(0, 0, 255, 0.5)', 20); // rgba(51, 51, 255, 0.5) (blue +20%)",
            "dependencies": [],
            "script": "Q.ColorBrightness = (inputColor, percent) => {\n    if (!/^#|^rgb/.test(inputColor)) throw new Error('Unsupported c format');\n    let red, green, blue, alpha = 1, isHex = false, factor = 1 + percent / 100;\n    if (inputColor[0] === '#') {\n      isHex = true;\n      const hexString = inputColor.slice(1);\n      if (hexString.length === 3) {\n        red = parseInt(hexString[0] + hexString[0], 16);\n        green = parseInt(hexString[1] + hexString[1], 16);\n        blue = parseInt(hexString[2] + hexString[2], 16);\n      } else if (hexString.length === 6) {\n        red = parseInt(hexString.slice(0, 2), 16);\n        green = parseInt(hexString.slice(2, 4), 16);\n        blue = parseInt(hexString.slice(4, 6), 16);\n      }\n    } else {\n      const match = inputColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n      if (match) {\n        red = +match[1];\n        green = +match[2];\n        blue = +match[3];\n        if (match[4] != null) alpha = parseFloat(match[4]);\n      }\n    }\n    const clamp = value => Math.min(255, Math.max(0, Math.round(value * factor)));\n    red = clamp(red);\n    green = clamp(green);\n    blue = clamp(blue);\n    return isHex\n      ? '#' + [red, green, blue].map(component => (`0${component.toString(16)}`).slice(-2)).join('')\n      : (alpha === 1 ? `rgb(${red}, ${green}, ${blue})` : `rgba(${red}, ${green}, ${blue}, ${alpha})`);\n  };"
        },
        "Debounce": {
            "uuid": "d1314e48-1e47-4679-8e62-e556d808a1f4",
            "name": "Debounce",
            "method": "Utility",
            "desc": "Debounces a function to ensure it is only called after a specified delay since the last invocation, effectively preventing multiple calls in rapid succession. <br> This technique is particularly useful in scenarios like resizing windows, scrolling, or typing events, where multiple triggers can lead to performance issues or unintended behavior. <br> By controlling the rate at which a function can fire, developers can optimize performance and enhance user experience.",
            "type": "Event Handling",
            "example": "Q.Debounce('myFunction', 500, myFunction); // Calls myFunction after 500ms of inactivity <br> Q.Debounce('resizeEvent', 300, handleResize); // Debounces resize handling function",
            "dependencies": [],
            "script": "Q.Debounce = (id, b, c) => {\n    const debounceStorage = Q.getGLOBAL('Debounce') || {};\n    debounceStorage[id] && clearTimeout(debounceStorage[id]);\n    debounceStorage[id] = setTimeout(c, b);\n    Q.setGLOBAL({ Debounce: debounceStorage });\n  };"
        },
        "HSL2RGB": {
            "uuid": "08ca6b9b-83ca-427c-85d7-ecd266b0def6",
            "name": "HSL2RGB",
            "method": "Utility",
            "desc": "Converts HSL (Hue, Saturation, Lightness) color values to RGB (Red, Green, Blue) format. <br> This function is essential for applications that require color transformations, allowing developers to switch between different color representations easily. <br> Understanding color models is key in design, and this utility helps bridge the gap between HSL, which is often more intuitive for humans, and RGB, which is commonly used in digital displays.",
            "type": "Color",
            "example": "Q.HSL2RGB(0, 0, 1); // [255, 255, 255] <br> Q.HSL2RGB(0, 1, 0.5); // [255, 0, 0] <br> Q.HSL2RGB(0.33, 1, 0.5); // [0, 255, 0]",
            "dependencies": [],
            "script": "Q.HSL2RGB = (h, s, l) => {\n    if (s === 0) {\n      const gray = l * 255;\n      return [gray, gray, gray];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s,\n          p = 2 * l - q,\n          hueToRgb = (t) => {\n            t < 0 && (t += 1);\n            t > 1 && (t -= 1);\n            return t < 1 / 6 ? p + (q - p) * 6 * t\n                 : t < 1 / 2 ? q\n                 : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t)\n                 : p;\n          };\n    return [hueToRgb(h + 1 / 3) * 255, hueToRgb(h) * 255, hueToRgb(h - 1 / 3) * 255];\n  };"
        },
        "ID": {
            "uuid": "b07a163d-9194-48c0-a71a-ec6cd19446c7",
            "name": "ID",
            "method": "Utility",
            "desc": "It's useful for creating unique identifiers for users, sessions, or any items requiring distinct identification. <br> The ID is generated using random hexadecimal digits (0-9 and a-f) and can be customized with a prefix for better context or categorization.",
            "type": "Utility",
            "example": "Q.ID(8, 'user-'); // user-1a2b3c4d <br> Q.ID(); // 1a2b3c4d <br> Q.ID(12, 'session-'); // session-1a2b3c4d5e6f",
            "dependencies": [],
            "script": "Q.ID = (length = 8, b = '') =>\n    b + Array.from({ length }, () => (Math.random() * 16 | 0).toString(16)).join('');"
        },
        "isDarkColor": {
            "uuid": "fb97af9d-ffaf-497f-a1b7-797948b1799a",
            "name": "isDarkColor",
            "method": "Utility",
            "desc": "Determines if a color is dark or light based on the HSP (Hue, Saturation, Perceived brightness) model. <br> This utility helps in designing user interfaces by ensuring adequate contrast between text and background colors, enhancing readability and accessibility. <br> Users can adjust the margin and threshold parameters to fine-tune sensitivity according to their design needs.",
            "type": "Color",
            "example": "Q.isDarkColor('#000000'); // true <br> Q.isDarkColor('#ffffff'); // false <br> Q.isDarkColor('#4c4c4c', 30, 90); // true",
            "dependencies": [],
            "script": "Q.isDarkColor = (color, b = 20, c = 100) => {\n    let red, green, blue;\n    if (color[0] === '#') {\n      const f = color.slice(1);\n      const parts = f.length === 3\n        ? [f[0] + f[0], f[1] + f[1], f[2] + f[2]]\n        : f.length === 6\n        ? [f.slice(0, 2), f.slice(2, 4), f.slice(4, 6)]\n        : null;\n      if (!parts) throw Error('Invalid f color format');\n      [red, green, blue] = parts.map(v => parseInt(v, 16));\n    } else if (color.startsWith('rgb')) {\n      const arr = color.match(/\\d+/g);\n      if (arr && arr.length >= 3) [red, green, blue] = arr.map(Number);\n      else throw Error('Invalid color format');\n    } else throw Error('Unsupported color format');\n    return Math.sqrt(0.299 * red ** 2 + 0.587 * green ** 2 + 0.114 * blue ** 2) + b < c;\n  };"
        },
        "RGB2HSL": {
            "uuid": "872a3527-e884-4140-97a1-162283238343",
            "name": "RGB2HSL",
            "method": "Utility",
            "desc": "Converts RGB color values to HSL format, providing a different way to represent colors that can be more intuitive for artists and designers. <br> HSL stands for Hue, Saturation, and Lightness, making it easier to manipulate colors based on human perception. <br> This conversion is essential for applications requiring color manipulation, such as image editing or web design, where understanding color relationships is crucial.",
            "type": "Color",
            "example": "Q.RGB2HSL(255, 255, 255); // [0, 0, 1] <br> Q.RGB2HSL(0, 0, 0); // [0, 0, 0] <br> Q.RGB2HSL(255, 0, 0); // [0, 1, 0.5]",
            "dependencies": [],
            "script": "Q.RGB2HSL = (r, g, b) => {\n    r /= 255, g /= 255, b /= 255;\n    const max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2, d = max - min;\n    if (!d) h = s = 0;\n    else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0)\n        : max === g ? (b - r) / d + 2\n        : (r - g) / d + 4;\n      h /= 6;\n    }\n    return [h, s, l];\n  };"
        }
    }
};
function Highlight(code) {
    // Function to escape HTML characters in code
    const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    code = escapeHTML(code);

    let patterns = [];

    let dictionary = [
        {
            find: ["Q"],
            open: "", 
            close: "", 
            className: "class",
            regex: "single",
            allowNested: false
        },
        {
            find: ["(", ")", "{", "}", "[", "]"],
            open: "", 
            close: "", 
            className: "bracket",
            regex: "single",
            allowNested: false
        },
        {
            find: ["'", '"'],
            open: "", 
            close: "", 
            className: "string",
            regex: "single",
            allowNested: false
        },
        {
            find: ["*"],
            open: "//", 
            close: "<br>", 
            className: "comment",
            regex: "between",
            allowNested: false
        },
        {
            find: ["function", "return", "if", "else", "for", "while"],
            open: "", 
            close: "", 
            className: "keyword",
            regex: "single",
            allowNested: false
        },
        {
            find: ["let", "var", "const"],
            open: "", 
            close: "", 
            className: "variable",
            regex: "single",
            allowNested: false
        }
    ];

    // Generate patterns from the dictionary
    dictionary.forEach(({ find, open, close, className, regex, allowNested }) => {
        let regexString = "";
        if (regex === "single") {
            // Join keywords with | for a single word match, using \b word boundaries
            regexString = `\\b(${find.map(item => item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join("|")})\\b`;
        } else if (regex === "between") {
            // Use non-capturing groups and lookahead/lookbehind for the between match
            regexString = `(${open})((?:(?!${close}).)*?)(${close})`;
        } else {
            regexString = regex; // Assume a custom regex is provided
        }

        patterns.push({
            regex: new RegExp(regexString, "g"),
            replace: `<span class='hl ${className}'>$&</span>`,
            allowNested
        });
    });

    // Apply patterns to the code
    patterns.forEach(({ regex, replace, allowNested }) => {
        code = code.replace(regex, (match, ...groups) => {
            // If allowNested is false, un-nest any nested spans inside
            if (!allowNested) {
                match = match.replace(/<span.*?>(.*?)<\/span>/g, '$1');
            }
            return replace.replace('$&', match);
        });
    });

    // Use a temporary container to parse and process the HTML
    let temp = document.createElement("div");
    temp.innerHTML = code;

    // Remove nested spans if necessary
    temp.querySelectorAll("span span").forEach(nested => {
        const parent = nested.parentElement;
        if (nested.classList.contains("hl")) {
            parent.replaceChild(document.createTextNode(nested.textContent), nested);
        }
    });

    return temp.innerHTML;
}

// function Highlight(code) {
    
//     const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
//     code = code.replace(/\"(.*?)\"/g, (_, p1) => `"${escapeHTML(p1)}"`);

//     let patterns = [];

//     let dictionary = [
//         {
//         find:["Q"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"class", // span class name
//         regex: "single", // single, between, regex (direct regex) 
//         allowNested: false // allow or remove nested (convert to plain text)
//         },
//         {
//         find:["(", ")", "{", "}", "[", "]"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"bracket", // span class name
//         regex: "single", // single, between, regex (direct regex)
//         allowNested: false // allow or remove nested (convert to plain text)
//         }
//     ];


//     dictionary.forEach(({find, open, close, className, regex, allowNested}) => {
//         let regexString = "";
//         if (regex === "single") {
//             regexString = `\\b(${find.join("|")})\\b`;
//         } else if (regex === "between") {
//             regexString = `\\b(${open})((?:(?!${close}).)*)\\b(${close})`;
//         } else {
//             regexString = regex;
//         }

//         patterns.push({
//             regex: new RegExp(regexString, "g"),
//             replace: `<span class='hl ${className}'>$&</span>`
//         });
//     });


//     // const patterns = [
//     //     { regex: /(['"`])(.*?)\1/g, replace: "<span class='hl string'>$1$2$1</span>" },
//     //             { regex: /\b(\d+)\b/g, replace: "<span class='hl number'>$1</span>" },

//     //     { regex: /Q\(/g, replace: "<span class='hl class'>Q</span>(" },
//     //     { regex: /Q\./g, replace: "<span class='hl object'>Q.</span>" },
//     //     // { regex: /\((.*?)\)/g, replace: "(<span class='bracket_inner'>$1</span>)" },
//     //     // { regex: /\{(.*?)\}/g, replace: "{<span class='bracket_inner'>$1</span>}" },
//     //     // { regex: /\[(.*?)\]/g, replace: "[<span class='bracket_inner'>$1</span>]" },
//     //     { regex: /\{|\}|\(|\)|\[|\]/g, replace: "<span class='hl bracket'>$&</span>" },
//     //     { regex: /\b(function|return|if|else|for|while)\b/g, replace: "<span class='hl keyword'>$1</span>" },
//     //     //variables
//     //     { regex: /\b(let|var|const)\b/g, replace: "<span class='hl variable'>$1</span>" },

//     //     {
//     //         regex: /\/\/(?!https?:\/\/|ftp:\/\/|ws:\/\/)(.*?)(?=<br>|$)/g, replace: "<span class='hl comment'>//$1</span>"
//     //     }
//     // ];

//     patterns.forEach(({ regex, replace }) => code = code.replace(regex, replace));

//     let temp = document.createElement("div");
//     temp.innerHTML = code;

//     temp.querySelectorAll("span span").forEach(nested => {
        
//         if (nested.classList.contains("hl")) {
//             const parent = nested.parentElement;
//             parent.replaceChild(document.createTextNode(nested.textContent), nested);
//         }
//     });

//     return temp.innerHTML;
// }

const IDS = {};

function CodeBuilder() {
    const activeBlocks = document.querySelectorAll(".block.active");


    const applyScript = (script) => {
        const sizedata = document.querySelector(".sizedata");
        let BaseScript = JSON.parse(JSON.stringify(DATA.frame));
        BaseScript = BaseScript.replace("return Q;", script + "\nreturn Q;");
        let codeBlock = document.querySelector(".codeData");
        codeBlock.innerHTML = minify(BaseScript);
        sizedata.innerHTML = "Library size: " + CalculateSizeKB(BaseScript);
    }




    if (!activeBlocks.length) {
        applyScript("");
        return;
    }

    const script = Array.from(activeBlocks)
        .map(block => {
            let blockScript = "";
            // Traverse the IDS structure to find the matching script
            for (const name in IDS) {
                const blockData = IDS[name];
                if (blockData.uuid == block.id) {
                    blockScript = blockData.script || "";
                    break;
                }
            }
            return blockScript;
        })
        .join("");

    applyScript(script);

    // console.log(script);
}


function classFormat(text) {
    return text.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");
}

function minify(code) {
    return code.replace(/^\s*/gm, "").replace(/\n/g, "");
}

function CalculateSizeKB(code) {
    return (new Blob([code]).size / 1024).toFixed(2) + " KB";
}

function createTags(tags) {
    const tagsContainer = document.createElement("div");
    tagsContainer.className = "tags";
    tags.forEach(tag => {
        const tagElement = document.createElement("span");
        tagElement.className = "tag";
        tagElement.innerHTML = tag;
        tagsContainer.appendChild(tagElement);
    });
    return tagsContainer;
}

function createCodeCategory(title) {
    const categoryContainer = document.createElement("div");
    categoryContainer.className = "code_category";
    categoryContainer.innerHTML = `<h2 class='code_category_title'>${title}</h2>`;
    const categoryContent = document.createElement("div");
    categoryContent.className = "code_content";
    categoryContent.id = classFormat(title);
    categoryContainer.appendChild(categoryContent);
    return categoryContainer;
}

function createBlock(contentData) {
    const { uuid, name, desc, example, dependencies } = contentData;
    const block = document.createElement("div");
    block.className = "block";
    block.id = uuid;
    block.innerHTML = `<h2>${name}</h2>`;

    const blockContent = document.createElement("div");
    blockContent.className = "block_content";
    block.appendChild(blockContent);

    blockContent.innerHTML = `<p>${desc}</p>`;
    const blockExample = document.createElement("div");
    blockExample.className = "block_example";
    blockExample.innerHTML = Highlight(example.replace(/\n/g, "<br>"));
    blockContent.appendChild(blockExample);

    if (dependencies.length > 0) {
        const blockDependencies = document.createElement("div");
        blockDependencies.className = "block_dependencies";
        blockDependencies.innerHTML = "<b>Dependencies</b>";
        blockDependencies.appendChild(createTags(dependencies));
        blockContent.appendChild(blockDependencies);
    }

    block.addEventListener("click", function (event) {
        if (event.currentTarget.contains(event.target)) {
            block.classList.toggle("active");
            if (block.classList.contains("active")) {
                dependencies.forEach(dep => {
                    const depBlock = document.getElementById(IDS[dep]?.uuid);
                    if (depBlock && !depBlock.classList.contains("active")) {
                        depBlock.click();
                    }
                });
            }
            CodeBuilder();
        }
    });

    return block;
}

function createTab(name, identifier, contentData) {
    const tabHeader = document.querySelector(".tab_header");
    const tabContainer = document.querySelector(".tab_container");

    const tab = document.createElement("div");
    tab.className = "tab";
    tab.innerHTML = name;
    tab.setAttribute("data-identifier", identifier);

    const tabContent = document.createElement("div");
    tabContent.className = "tab_content";
    tabContent.setAttribute("data-identifier", identifier);

    const types = [...new Set(contentData.map(c => c.type))];
    types.forEach(type => tabContent.appendChild(createCodeCategory(type)));
    contentData.forEach(content => {
        tabContent.querySelector(`#${classFormat(content.type)}`).appendChild(createBlock(content));
    });

    tab.addEventListener("click", function () {
        document.querySelectorAll(".tab, .tab_content").forEach(el => el.classList.remove("active"));
        tab.classList.add("active");
        tabContent.classList.add("active");
    });

    tabHeader.appendChild(tab);
    tabContainer.appendChild(tabContent);

    return tab;
}

function createTabs() {
    const methods = new Set();
    Object.values(DATA).forEach(category => {
        if (typeof category === 'object') {
            console.log(category);
            const contentData = [];
            Object.values(category).forEach(({ method, uuid, desc, type, example, dependencies, script }) => {
                if (!methods.has(method)) {
                    methods.add(method);
                    Object.values(category).forEach(block => {
                        contentData.push({ ...block });
                        if (block.dependencies === undefined) {
                            block.dependencies = [];
                        }
                        IDS[block.name] = { uuid: block.uuid, script: block.script, dependencies: block.dependencies };
                    });
                    createTab(method, method, contentData);
                }
            });
        }
    });


    //choose .download button
    const downloadButton = document.querySelector(".download");
    const codeBlock = document.querySelector(".codeData");

    //add event listener to download button
    downloadButton.addEventListener("click", () => {
        const code = codeBlock.innerText;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vulpiniq.js";
        a.click();
        URL.revokeObjectURL(url);
    });


}

document.addEventListener("DOMContentLoaded", createTabs);
</script>
</head>

<body>

    <div class="container">
<div class="left_side">

<div class="header">
    <h1>VulpiniQ</h1>
    <p>Build your own VulpiniQ Library</p>
    </div>

<textarea class="codeData" placeholder="Enter your code here"></textarea>

<div class="footer">
    <div class="sizedata">No code recently</div>
    <button class="btn download">Download</button>
</div>

</div>


<div class="right_side">
    <div class="tab_header">
    </div>

    <div class="tab_container">



    </div>

</div>




    </div>

    <!-- <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>

    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div> -->

</body>

</html>