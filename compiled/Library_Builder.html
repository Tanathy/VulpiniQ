<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>
    <link rel="stylesheet" href="builder.css">
<style>* { margin: 0; padding: 0; box-sizing: border-box; /* outline: 1px solid rgba(255, 255, 255, 0.2); */}body { font-family: 'Arial', sans-serif; background-color: #0e0e0e; color: #a3a3a3; line-height: 1.6; font-size: 12px;}::-webkit-scrollbar { width: 8px; height: 8px;}::-webkit-scrollbar-track { background: #2e2e2e;}::-webkit-scrollbar-thumb { background: #555; border-radius: 4px;}::-webkit-scrollbar-thumb:hover { background: #777;}.container{ display: flex;}.left_side{width: 50%;background-color: #0000003d;border-right: 1px solid #ffffff15;}.right_side{ flex-shrink: 0; width: 50%;padding-left:5px}.tab_header{display:flex;}.tab{padding: 5px 15px;cursor: pointer;}.tab.active{background: rgba(255, 255, 255, 0.2);color: #c4c4c4;}.tab_container{overflow-x: hidden;height: calc(100vh - 30px);padding: 0 5px;}.tags{display: flex;flex-wrap: wrap;}.tag{ padding: 0px 9px; margin: 3px; background: #333; border-radius: 5px; cursor: default;}.block{ cursor: default;padding:10px; background: #ffffff09; border-radius: 10px; /* outline: 1px solid #ffffff10; */ width: 100%;}.block.active { background: #ffffff18;}.block_example{ padding: 8px; background: #00000033; border-radius: 12px; width: 100%; margin-top: 10px;}.block_example pre { background: #181818; color: #a3a3a3; border-radius: 8px; padding: 10px; margin: 8px 0 0 0; font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace; font-size: 13px; overflow-x: auto; white-space: pre-wrap; word-break: break-word; line-height: 1.6;}.code_content{ display: grid; grid-template-columns: repeat(2, 1fr); /* Create 3 equal columns */ gap: 10px; /* Add gap between grid items */}.block_dependencies{ margin-top: 10px;}.block_title{ font-size: 16px; font-weight: bold; margin-bottom: 20px;}.code_category_title{ font-size: 20px; font-weight: bold; margin: 15px 0}.code_category{margin-bottom: 40px;}.codeData{ padding: 10px; background: #00000033; border-radius: 12px; width: calc(100% - 10px); height: 200px; margin-top: 10px; color: #a3a3a3; text-align: justify; border: 1px solid #ffffff10; box-sizing: border-box; margin: 5px; resize: vertical; max-height: 400px;}.codeData:focus{ outline: none;}.footer{display:flex;}.sizedata{ margin: 0 20px; display: flex; align-items: center;}.btn { padding: 5px 10px; background: #333; color: #a3a3a3; border: none; border-radius: 5px; cursor: pointer;}.tab_content{ display: none;}.tab_content.active{ display: block;}.bracket { color: #d4d4d4; /* VSCode: Default foreground */}.bracket_inner { color: #b5cea8; /* VSCode: Bracket pair color */}.class,.object { color: #4ec9b0; /* VSCode: class name */ font-weight: normal;}.keyword { color: #569cd6; /* VSCode: keyword */}.operator { color: #d4d4d4; /* VSCode: operator */}.method { color: #dcdcaa; /* VSCode: function/method */}.string { color: #ce9178; /* VSCode: string */ font-weight: normal;}.number { color: #b5cea8; /* VSCode: number */}.comment { color: #6a9955 !important; /* VSCode: comment */ font-style: italic;}.variable { color: #9cdcfe; /* VSCode: variable */}</style>
<script>
var DATA = {
    "base": "const Q = (() => {\n    'use strict';\n    const _ob = Object, _ar = Array, _ma = Math, _da = Date, _re = RegExp,\n        _st = setTimeout, _un = undefined, _n = null, _nl = NodeList,\n        _el = Element, _si = setInterval, _c = console, _ct = clearTimeout,\n        _ci = clearInterval, _pr = Promise, _str = String, _nu = Number,\n        _bo = Boolean, _json = JSON, _map = Map, _set = Set, _sym = Symbol,\n        _win = window, _doc = document, _loc = location, _hist = history,\n        _ls = localStorage, _ss = sessionStorage, _f = fetch, _ev = Event,\n        _ac = AbortController, _as = AbortSignal, _err = Error;\n    let GLOBAL = {};\n    let styleData = {\n        elements: [],\n        root: '',\n        generic: \"\",\n        responsive: {},\n        element: _n,\n        init: false\n    };\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib_set') || createStyleElement();\n            styleData.init = true;\n        }\n        let finalStyles = styleData.root ? `:root {${styleData.root}}\\n` : '';\n        finalStyles += styleData.generic;\n        const breakpoints = _ob.keys(styleData.responsive);\n        for (let i = 0; i < breakpoints.length; i++) {\n            const size = breakpoints[i];\n            const css = styleData.responsive[size];\n            if (css) {\n                finalStyles += `\\n@media (max-width: ${size}) {\\n${css}\\n}`;\n            }\n        }\n        styleData.element.textContent = finalStyles;\n    }\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib_set';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n    if (document.readyState === 'complete' || document.readyState === 'interactive') {\n        applyStyles();\n    } else {\n        window.addEventListener('load', applyStyles, { once: true });\n    }\n    function Q(identifier, attributes, props) {\n        if (!(this instanceof Q)) return new Q(identifier, attributes, props);\n        if (identifier && identifier.nodeType) {\n            this.nodes = [identifier];\n            return;\n        }\n        if (identifier instanceof Q) {\n            this.nodes = identifier.nodes;\n            return;\n        }\n        if (identifier?.constructor === _nl) {\n            this.nodes = _ar.from(identifier);\n            return;\n        }\n        if (typeof identifier === 'string') {\n            const isCreating = attributes || identifier.indexOf('<') > -1;\n            if (isCreating) {\n                const svgTags = ['svg','g','line','polyline','rect','circle','ellipse','text','path','polygon'];\n                const tagMatch = identifier.match(/^<([a-zA-Z0-9\\-]+)(\\s|>|\\/)*/);\n                const tag = tagMatch ? tagMatch[1].toLowerCase() : null;\n                if (tag && svgTags.includes(tag)) {\n                    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n                    if (attributes) {\n                        for (const [k, v] of Object.entries(attributes)) {\n                            if (k === 'children' && Array.isArray(v)) {\n                                v.forEach(child => {\n                                    if (child instanceof Node) {\n                                        el.appendChild(child);\n                                    } else if (child instanceof Q) {\n                                        child.nodes.forEach(n => el.appendChild(n));\n                                    } else if (typeof child === 'string') {\n                                        const temp = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n                                        temp.innerHTML = child;\n                                        Array.from(temp.childNodes).forEach(n => el.appendChild(n));\n                                    }\n                                });\n                            } else if (k !== 'children') {\n                                el.setAttribute(k, v);\n                            }\n                        }\n                    }\n                    const inner = identifier.replace(/^<[^>]+>/, '').replace(/<\\/[a-zA-Z0-9\\-]+>$/, '');\n                    if (inner.trim()) {\n                        const temp = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n                        temp.innerHTML = inner;\n                        Array.from(temp.childNodes).forEach(n => el.appendChild(n));\n                    }\n                    this.nodes = [el];\n                    return;\n                }\n                const template = document.createElement('template');\n                template.innerHTML = identifier.trim();\n                this.nodes = _ar.from(template.content.childNodes);\n                if (attributes) {\n                    const attrEntries = _ob.entries(attributes);\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = attrEntries.length; j < m; j++) {\n                            const [attr, val] = attrEntries[j];\n                            if (attr === 'class') {\n                                element.classList.add(...(Array.isArray(val) ? val : val.split(/\\s+/)));\n                            } else if (attr === 'style') {\n                                if (typeof val === 'object') {\n                                    const styleEntries = _ob.entries(val);\n                                    for (let k = 0, p = styleEntries.length; k < p; k++) {\n                                        const [prop, propVal] = styleEntries[k];\n                                        element.style[prop] = propVal;\n                                    }\n                                } else {\n                                    element.style.cssText = val;\n                                }\n                            } else if (attr === 'text') {\n                                element.textContent = val;\n                            } else if (attr === 'html') {\n                                element.innerHTML = val;\n                            } else {\n                                element.setAttribute(attr, val);\n                            }\n                        }\n                    }\n                }\n                if (props) {\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = props.length; j < m; j++) {\n                            element[props[j]] = true;\n                        }\n                    }\n                }\n            } else {\n                this.nodes = _ar.from(document.querySelectorAll(identifier));\n            }\n        }\n    }\n    Q.Ext = (methodName, functionImplementation) =>\n        (Q.prototype[methodName] = functionImplementation, Q);\n    Q.getGLOBAL = key => GLOBAL[key];\n    Q.setGLOBAL = value => (GLOBAL = { ...GLOBAL, ...value });\n    Q.style = (root = _n, style = '', responsive = _n, mapping = _n, enable_mapping = true) => {\n        const cleanUp = (str) => {\n            str= str.replace(/^\\s*[\\r\\n]/gm, '');\n            str = str.replace(/\\s+/g, ' ');\n            str = str.replace(/;;/g, ';');\n            return str.trim();\n        }\n        if (mapping && enable_mapping) {\n            const keys = _ob.keys(mapping);\n            const generateSecureCSSClassName = () => {\n                const letters = 'abcdefghijklmnopqrstuvwxyz';\n                const allChars = letters + '0123456789';\n                const length = _ma.floor(_ma.random() * 3) + 6;  \n                const firstChar = letters.charAt(_ma.floor(_ma.random() * letters.length));\n                const remainingChars = Array.from({ length: length - 1 }, () => \n                    allChars.charAt(_ma.floor(_ma.random() * allChars.length))\n                ).join('');\n                return firstChar + remainingChars;\n            };\n            const getUniqueClassName = () => {\n                let newKey;\n                do {\n                    newKey = generateSecureCSSClassName();\n                } while (styleData.elements.includes(newKey));\n                styleData.elements.push(newKey);\n                return newKey;\n            };\n            keys.forEach((key) => {\n                let newKey = getUniqueClassName();\n                if (style && typeof style === 'string') {\n                    style = style.replace(new _re(`\\\\.${key}\\\\b`, 'gm'), `.${newKey}`);\n                    style = style.replace(new _re(`^\\\\s*\\\\.${key}\\\\s*{`, 'gm'), `.${newKey} {`);\n                    style = style.replace(new _re(`(,\\\\s*)\\\\.${key}\\\\b`, 'gm'), `$1.${newKey}`);\n                    style = style.replace(new _re(`(\\\\s+)\\\\.${key}\\\\b`, 'gm'), `$1.${newKey}`);\n                }\n                mapping[key] = mapping[key].replace(key, newKey);\n            });\n        }\n        if (root && typeof root === 'string') {\n            styleData.root += root.trim();\n            styleData.root = cleanUp(styleData.root);\n        }\n        if (style && typeof style === 'string') {\n            styleData.generic += style;\n            styleData.generic = cleanUp(styleData.generic);\n        }\n        if (responsive && typeof responsive === 'object') {\n            const breakpoints = _ob.entries(responsive);\n            for (let i = 0; i < breakpoints.length; i++) {\n                const [size, css] = breakpoints[i];\n                if (css && typeof css === 'string') {\n                    if (!styleData.responsive[size]) {\n                        styleData.responsive[size] = '';\n                    }\n                    styleData.responsive[size] += css + '\\n';\n                }\n            }\n        }\n        if (document.readyState === 'complete') {\n            applyStyles();\n        }\n        return mapping;\n    };\n    Q._ = {\n        ob: _ob, ar: _ar, ma: _ma, da: _da, re: _re, st: _st, un: _un,\n        n: _n, nl: _nl, el: _el, si: _si, c: _c, ct: _ct, ci: _ci,\n        pr: _pr, str: _str, nu: _nu, bo: _bo, json: _json, map: _map,\n        set: _set, sym: _sym, win: _win, doc: _doc, loc: _loc, hist: _hist,\n        ls: _ls, ss: _ss, f: _f, ev: _ev, ac: _ac, as: _as, err: _err\n    };\n    return Q;\n})();",
    "scripts": {
        "basics": {
            "Done": {
                "uuid": "f7627aee-8826-4d4d-94ab-e754c0b08959",
                "name": "Done",
                "method": "Static",
                "desc": "Executes a function once the window's load event is fired, indicating all resources are loaded.",
                "type": "Event Handling",
                "example": [
                    "Q.Done(() => console.log('All resources loaded!'));",
                    "let postLoad = () => { document.body.classList.add('loaded'); }; Q.Done(postLoad);",
                    "Q.Done(() => { document.getElementById('preloader').classList.add('fade-out'); });",
                    "const calculateLayout = () => { const imageHeights = Array.from(document.images).map(img => img.height); console.log('All image heights:', imageHeights); }; Q.Done(calculateLayout);"
                ],
                "dependencies": [],
                "script": "Q.Done=((c)=>{\n    window.addEventListener(\"load\",()=>{while(c.length)c.shift()();c=0});\n    return f=>c?c.push(f):f()\n})([]);"
            },
            "Leaving": {
                "uuid": "e17d5a06-4e8b-4ea2-ac5a-f380173eb79c",
                "name": "Leaving",
                "method": "Static",
                "desc": "Attaches a function to the window's beforeunload event, allowing actions before the page is closed or refreshed.",
                "type": "Event Handling",
                "example": [
                    "Q.Leaving(e => e.preventDefault());",
                    "let goodbyeMessage = e => { e.preventDefault(); e.returnValue = 'Are you sure you want to leave?'; }; Q.Leaving(goodbyeMessage);",
                    "Q.Leaving(event => { if (document.querySelector('form').dataset.modified === 'true') { event.preventDefault(); event.returnValue = 'You have unsaved changes'; } });",
                    "const saveState = e => { localStorage.setItem('appState', JSON.stringify(currentState)); }; Q.Leaving(saveState);"
                ],
                "dependencies": [],
                "script": "Q.Leaving=((c)=>{\n    let ev;\n    window.addEventListener(\"beforeunload\",e=>{\n      ev=e;while(c.length)c.shift()(e);c=0\n    });\n    return f=>c?c.push(f):f(ev)\n  })([]);"
            },
            "Ready": {
                "uuid": "bbf41178-9b90-4e56-8041-9e354de501b8",
                "name": "Ready",
                "method": "Static",
                "desc": "Executes a function when the document is fully loaded, ensuring all elements are accessible.",
                "type": "Event Handling",
                "example": [
                    "Q.Ready(() => console.log('Document is ready!'));",
                    "let init = () => { console.log('Initialization complete.'); }; Q.Ready(init);",
                    "Q.Ready(() => { document.getElementById('loader').style.display = 'none'; document.getElementById('content').style.display = 'block'; });",
                    "const setupEventListeners = () => { document.querySelectorAll('.clickable').forEach(el => el.addEventListener('click', handleClick)); }; Q.Ready(setupEventListeners);"
                ],
                "dependencies": [],
                "script": "Q.Ready=((c)=>{\n    document.readyState==='loading'?document.addEventListener(\"DOMContentLoaded\",()=>{while(c.length)c.shift()();c=0},{once:1}):c=0;\n    return f=>c?c.push(f):f();\n  })([]);"
            },
            "Resize": {
                "uuid": "d52b1cb4-b78b-48fe-b2e4-e5e12269ca6e",
                "name": "Resize",
                "method": "Static",
                "desc": "Attaches a function to the window's resize event, executing it with the new innerWidth and innerHeight.",
                "type": "Event Handling",
                "example": [
                    "Q.Resize((width, height) => console.log(`Window resized to ${width}x${height}`));",
                    "let resizeHandler = (width, height) => { document.body.style.fontSize = (width / 100) + 'em'; }; Q.Resize(resizeHandler);",
                    "Q.Resize((width, height) => { const ratio = width / height; document.getElementById('container').style.aspectRatio = ratio; });",
                    "const updateLayout = (w, h) => { if (w < 768) { document.body.classList.add('mobile'); } else { document.body.classList.remove('mobile'); } }; Q.Resize(updateLayout);"
                ],
                "dependencies": [],
                "script": "Q.Resize=((c)=>{\n    addEventListener(\"resize\",()=>{\n      for(let i=0,l=c.length;i<l;) c[i++](innerWidth,innerHeight)\n    });\n    return f=>c.push(f)\n  })([]);"
            }
        },
        "methods": {
            "addClass": {
                "uuid": "03425b1e-e55c-465b-95d6-473624208716",
                "name": "addClass",
                "method": "Prototype",
                "desc": "Adds one or more classes to each node, ignoring duplicates.",
                "type": "Class Manipulation",
                "example": [
                    "Q(selector).addClass(\"class1\");",
                    "Q(selector).addClass(\"class1 class2\");"
                ],
                "dependencies": [],
                "script": "Q.Ext('addClass', function (classes) {\n    var list = classes.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].classList.add.apply(nodes[i].classList, list);\n    }\n    return this;\n});"
            },
            "after": {
                "uuid": "9ec89790-b302-4edd-9ffe-f4f1fc32bc5d",
                "name": "after",
                "method": "Prototype",
                "desc": "Inserts content after each element in the current set of matched elements.",
                "type": "DOM Manipulation",
                "example": [
                    "Q(selector).after(\"<p>New paragraph</p>\");",
                    "Q(selector).after(document.createElement(\"div\"));",
                    "Q(selector).after(Q(otherSelector));",
                    "Q(selector).after([document.createElement(\"span\"), document.createElement(\"img\")]);"
                ],
                "dependencies": [],
                "script": "Q.Ext('after', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const target = nodes[i];\n    const parent = target.parentNode;\n    if (!parent) continue;\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const content = contents[j];\n      if (typeof content === \"string\") {\n        target.insertAdjacentHTML('afterend', content);\n      } else if (content instanceof HTMLElement) {\n        if (target.nextSibling) {\n          parent.insertBefore(content, target.nextSibling);\n        } else {\n          parent.appendChild(content);\n        }\n      } else if (content instanceof Q) {\n        if (target.nextSibling) {\n          parent.insertBefore(content.nodes[0], target.nextSibling);\n        } else {\n          parent.appendChild(content.nodes[0]);\n        }\n      } else if (Array.isArray(content) || content instanceof NodeList) {\n        const subNodes = Array.from(content);\n        let nextSibling = target.nextSibling;\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          if (nextSibling) {\n            parent.insertBefore(subNodes[k], nextSibling);\n            nextSibling = subNodes[k].nextSibling;\n          } else {\n            parent.appendChild(subNodes[k]);\n          }\n        }\n      }\n    }\n  }\n  return this;\n});"
            },
            "animate": {
                "uuid": "ae4b7de9-079b-40c2-a434-2eefc3972489",
                "name": "animate",
                "method": "Prototype",
                "desc": "Animates each node using specified CSS properties over a given duration, with an optional callback when complete.",
                "type": "Animation",
                "example": [
                    "Q(selector).animate(500, { opacity: 0 }, () => { console.log('Fade out complete'); });",
                    "Q(selector).animate(1000, { left: \"100px\", top: \"50px\" });",
                    "Q(selector).animate(700, { opacity: 1, backgroundColor: \"#ff0000\" }, () => { alert('Animation finished!'); });"
                ],
                "dependencies": [],
                "script": "Q.Ext('animate', function (duration, properties, callback) {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var element = nodes[i],\n        keys = Object.keys(properties),\n        transitionProperties = '';\n    for (var j = 0, klen = keys.length; j < klen; j++) {\n      transitionProperties += keys[j] + ' ' + duration + 'ms' + (j < klen - 1 ? ', ' : '');\n    }\n    element.style.transition = transitionProperties;\n    for (var j = 0; j < klen; j++) {\n      var prop = keys[j];\n      element.style[prop] = properties[prop];\n    }\n    if (typeof callback === 'function') {\n      setTimeout((function(el){\n          return function(){ callback.call(el); };\n      })(element), duration);\n    }\n  }\n  return this;\n});"
            },
            "append": {
                "uuid": "a4976c2f-7699-4859-9999-c0892e08fd7d",
                "name": "append",
                "method": "Prototype",
                "desc": "Appends child nodes, HTML, or multiple elements to each node.",
                "type": "DOM Manipulation",
                "example": [
                    "Q(selector).append(\"<p>New paragraph</p>\");",
                    "Q(selector).append(document.createElement(\"div\"));",
                    "Q(selector).append(Q(otherSelector));",
                    "Q(selector).append([document.createElement(\"span\"), document.createElement(\"img\")]);",
                    "Q(selector).append(document.querySelectorAll(\".items\"));"
                ],
                "dependencies": [],
                "script": "Q.Ext('append', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const child = contents[j];\n      if (typeof child === \"string\") {\n        if (parent instanceof SVGElement) {\n          const temp = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n          temp.innerHTML = child;\n          Array.from(temp.childNodes).forEach(n => parent.appendChild(n));\n        } else {\n          parent.insertAdjacentHTML('beforeend', child);\n        }\n      } else if (child instanceof HTMLElement || child instanceof Q || child instanceof SVGElement) {\n        parent.appendChild(child.nodes ? child.nodes[0] : child);\n      } else if (Array.isArray(child) || child instanceof NodeList) {\n        const subNodes = Array.from(child);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.appendChild(subNodes[k]);\n        }\n      }\n    }\n  }\n  return this;\n});"
            },
            "attr": {
                "uuid": "197ef56e-15a4-43b1-b154-418b0b1260d3",
                "name": "attr",
                "method": "Prototype",
                "desc": "Gets or sets attributes on the nodes, supporting multiple attributes at once.",
                "type": "Attribute Manipulation",
                "example": [
                    "Q(selector).attr(\"id\", \"newId\");",
                    "Q(selector).attr({ \"src\": \"image.jpg\", \"alt\": \"An image\" });",
                    "Q(selector).attr(\"href\");"
                ],
                "dependencies": [],
                "script": "Q.Ext('attr', function (attribute, value) {\n    var nodes = this.nodes;\n    if (typeof attribute === 'object') {\n        var keys = Object.keys(attribute);\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            var node = nodes[i];\n            for (var j = 0, klen = keys.length; j < klen; j++) {\n                node.setAttribute(keys[j], attribute[keys[j]]);\n            }\n        }\n        return this;\n    } else {\n        if (value === undefined) {\n            return nodes[0] && nodes[0].getAttribute(attribute) || null;\n        }\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            nodes[i].setAttribute(attribute, value);\n        }\n        return this;\n    }\n});"
            },
            "before": {
                "uuid": "d106dcfd-0c6a-4680-8b65-899a61ff7471",
                "name": "before",
                "method": "Prototype",
                "desc": "Inserts content before each element in the current set of matched elements.",
                "type": "DOM Manipulation",
                "example": [
                    "Q(selector).before(\"<p>New paragraph</p>\");",
                    "Q(selector).before(document.createElement(\"div\"));",
                    "Q(selector).before(Q(otherSelector));",
                    "Q(selector).before([document.createElement(\"span\"), document.createElement(\"img\")]);"
                ],
                "dependencies": [],
                "script": "Q.Ext('before', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const target = nodes[i];\n    const parent = target.parentNode;\n    if (!parent) continue;\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const content = contents[j];\n      if (typeof content === \"string\") {\n        target.insertAdjacentHTML('beforebegin', content);\n      } else if (content instanceof HTMLElement) {\n        parent.insertBefore(content, target);\n      } else if (content instanceof Q) {\n        parent.insertBefore(content.nodes[0], target);\n      } else if (Array.isArray(content) || content instanceof NodeList) {\n        const subNodes = Array.from(content);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.insertBefore(subNodes[k], target);\n        }\n      }\n    }\n  }\n  return this;\n});"
            },
            "bind": {
                "uuid": "71e974c8-f6a0-4e32-8724-985b47d1fdaa",
                "name": "bind",
                "method": "Prototype",
                "desc": "Adds an event listener to each node, allowing for event delegation to improve performance.",
                "type": "Event Handling",
                "example": [
                    "Q(selector).bind(\"click\", () => console.log(\"Clicked\"));",
                    "Q('.btn').bind(\"mouseover\", (e) => { console.log(`Hovered over: ${e.target.tagName}`); });"
                ],
                "dependencies": [],
                "script": "Q.Ext('bind', function (event, handler) {\n    if (!this._eventDelegation) {\n        this._eventDelegation = {};\n    }\n    if (!this._eventDelegation[event]) {\n        document.addEventListener(event, (e) => {\n            var nodes = this.nodes;\n            for (var i = 0, l = nodes.length; i < l; i++) {\n                if (nodes[i].contains(e.target)) {\n                    handler.call(e.target, e);\n                }\n            }\n        });\n        this._eventDelegation[event] = true;\n    }\n    return this;\n});"
            },
            "blur": {
                "uuid": "e79b699a-2717-4d48-acb9-419c36c57b03",
                "name": "blur",
                "method": "Prototype",
                "desc": "Removes focus from the first node in the selection, effectively blurring it.",
                "type": "Form Manipulation",
                "example": [
                    "Q(selector).blur();",
                    "Q('.active').blur();",
                    "Q('textarea').blur();"
                ],
                "dependencies": [],
                "script": "Q.Ext('blur', function () {\n    var nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].blur();\n    }\n    return this;\n});"
            },
            "children": {
                "uuid": "dfc77fa9-470f-4893-a956-db0b2562efb2",
                "name": "children",
                "method": "Prototype",
                "desc": "Gets the direct child elements of each node, optionally filtered by a selector.",
                "type": "Traversal",
                "example": [
                    "const items = Q('ul').children();",
                    "Q('#menu').children('.active').addClass('highlight');",
                    "const visibleItems = Q('.container').children(':visible');",
                    "const selector = 'li'; Q('nav').children(selector).css('display', 'inline-block');"
                ],
                "dependencies": [],
                "script": "Q.Ext('children', function (selector) {\n  const result = [];\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    if (!parent || !parent.children) continue;\n    const childElements = parent.children;\n    if (selector) {\n      for (let j = 0; j < childElements.length; j++) {\n        if (childElements[j].matches && childElements[j].matches(selector)) {\n          result.push(childElements[j]);\n        }\n      }\n    } else {\n      for (let j = 0; j < childElements.length; j++) {\n        result.push(childElements[j]);\n      }\n    }\n  }\n  return new Q(result);\n});"
            },
            "click": {
                "uuid": "9f178b2d-2db3-4e44-8576-6b0943a75b05",
                "name": "click",
                "method": "Prototype",
                "desc": "Simulates a click event on each node in the selection.",
                "type": "Event Handling",
                "example": [
                    "Q(selector).click();",
                    "Q('.button').click();"
                ],
                "dependencies": [],
                "script": "Q.Ext('click', function () {\n    var nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].click();\n    }\n    return this;\n});"
            },
            "clone": {
                "uuid": "918e9227-86e0-406f-bec9-7ab279cbb0be",
                "name": "clone",
                "method": "Prototype",
                "desc": "Creates a deep copy of the first node in the selection, including its child nodes.",
                "type": "DOM Manipulation",
                "example": [
                    "let clonedNode = Q(selector).clone();",
                    "Q(selector).clone().appendTo('#target');"
                ],
                "dependencies": [],
                "script": "Q.Ext('clone', function () {\n    return new Q(this.nodes[0].cloneNode(true));\n});"
            },
            "closest": {
                "uuid": "0917d381-c2b2-49c3-8082-7a2d7a8c17ab",
                "name": "closest",
                "method": "Prototype",
                "desc": "Finds the nearest ancestor node of the first node that matches a given selector.",
                "type": "Traversal",
                "example": [
                    "Q(selector).closest('.parent');",
                    "Q(selector).closest('#container');",
                    "Q(selector).closest('[data-role=wrapper]');"
                ],
                "dependencies": [],
                "script": "Q.Ext('closest', function (selector) {\n    let node = this.nodes[0];\n    while (node) {\n        if (node.matches && node.matches(selector)) {\n            return new Q(node);\n        }\n        node = node.parentElement;\n    }\n    return null;\n});"
            },
            "css": {
                "uuid": "d7ba11cc-5a1b-464e-a4db-41fb55df3dd1",
                "name": "css",
                "method": "Prototype",
                "desc": "Gets or sets one or more CSS properties for the nodes.",
                "type": "CSS Manipulation",
                "example": [
                    "const color = Q('#element').css('color');",
                    "Q('.highlight').css('background-color', '#ffff00');",
                    "Q('header').css({ position: 'fixed', top: 0, width: '100%' });",
                    "const fontSize = 16; Q('.text').css('font-size', fontSize + 'px');"
                ],
                "dependencies": [],
                "script": "Q.Ext('css', function(property, value) {\n  const nodes = this.nodes;\n  if (typeof property === 'object') {\n      for (let i = 0, len = nodes.length; i < len; i++) {\n          const elemStyle = nodes[i].style;\n          for (const key in property) {\n              elemStyle[key] = property[key];\n          }\n      }\n      return this;\n  }\n  if (value === Q._.un) return getComputedStyle(nodes[0])[property];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].style[property] = value;\n  }\n  return this;\n});"
            },
            "data": {
                "uuid": "61d9c87e-8b78-4b78-8f7d-f5bea7c506c0",
                "name": "data",
                "method": "Prototype",
                "desc": "Retrieves or sets data-* attributes on the selected nodes. Provides an easy way to store and access custom data associated with the elements.",
                "type": "Data Manipulation",
                "example": [
                    "Q(selector).data('userId', 123);",
                    "const userId = Q('#user').data('userId');",
                    "Q('#user').data('role', 'admin');"
                ],
                "dependencies": [],
                "script": "Q.Ext('data', function (key, value) {\n    const nodes = this.nodes;\n    if (value === Q._.un) {\n        return nodes[0] && nodes[0].dataset[key] || Q._.n;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].dataset[key] = value;\n    }\n    return this;\n});"
            },
            "detach": {
                "uuid": "514b16a8-d973-4db2-9be3-58677265018d",
                "name": "detach",
                "method": "Method",
                "desc": "Removes the elements from the DOM but keeps them in memory for later reattachment.",
                "type": "Method",
                "example": [
                    "const element = Q('#myElement').detach();",
                    "Q('#container').append(element);"
                ],
                "dependencies": [],
                "script": "Q.Ext('detach', function() {\n    const nodes = this.nodes;\n    const detachedNodes = [];\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        const parent = node.parentNode;\n        if (parent) {\n            detachedNodes.push(node);\n            parent.removeChild(node);\n        }\n    }\n    this.nodes = detachedNodes;\n    return this;\n});"
            },
            "each": {
                "uuid": "299c772f-721a-4bca-89f7-5b8d476982c3",
                "name": "each",
                "method": "Prototype",
                "desc": "Iterates over all nodes in the Q object and executes a callback on each node, providing access to the index and element. Chainable. Does nothing for empty selection.",
                "type": "Iteration",
                "example": [
                    "Q(selector).each((index, element) => console.log(index, element)); // Log index and element",
                    "Q('.items').each((i, el) => el.style.color = 'red'); // Set color",
                    "Q('li').each((i, el) => el.textContent = `Item ${i+1}`).addClass('numbered'); // Chaining after each",
                    "Q('.missing').each((i, el) => console.log(i, el)); // Does nothing for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('each', function (callback) {\n    if (!this.nodes) return this;\n    const nodes = this.nodes;\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        callback.call(nodes[i], i, nodes[i]);\n    }\n    return this;\n});"
            },
            "empty": {
                "uuid": "ffeefa43-0994-4127-96f2-a4cea68deaa4",
                "name": "empty",
                "method": "Prototype",
                "desc": "Empties the innerHTML of each node.",
                "type": "Content Manipulation",
                "example": [
                    "Q(selector).empty();",
                    "Q('.container').empty();",
                    "Q('#main').empty();",
                    "Q('div').empty();"
                ],
                "dependencies": [],
                "script": "Q.Ext('empty', function () {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].innerHTML = '';\n  }\n  return this;\n});"
            },
            "eq": {
                "uuid": "f0f31f63-daa5-47cf-8f9f-18ea92aee03d",
                "name": "eq",
                "method": "Prototype",
                "desc": "Returns a specific node by index.",
                "type": "Traversal",
                "example": [
                    "Q(selector).eq(1);",
                    "const secondItem = Q('.list-item').eq(1);"
                ],
                "dependencies": [],
                "script": "Q.Ext('eq', function (index) {\n  var node = this.nodes[index];\n  return node ? new Q(node) : null;\n});"
            },
            "fadeIn": {
                "uuid": "fa694c30-838a-40f7-b8ee-47cb687357ae",
                "name": "fadeIn",
                "method": "Prototype",
                "desc": "Fades in all nodes over a specified duration.",
                "type": "Animation",
                "example": [
                    "Q('#notification').fadeIn(500);",
                    "Q('.hidden-content').fadeIn();",
                    "Q('.modal').fadeIn(300, () => Q('.modal-content').slideDown());",
                    "const duration = 1000; Q('#welcome-message').fadeIn(duration, () => console.log('Animation complete'));"
                ],
                "dependencies": [],
                "script": "Q.Ext('fadeIn', function(duration, callback) {\n    duration = duration || 400;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var elemStyle = el.style;\n            elemStyle.display = '';\n            elemStyle.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            elemStyle.opacity = 1;\n            setTimeout(function() {\n                elemStyle.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
            },
            "fadeOut": {
                "uuid": "2d79884b-bc72-4d34-b7d7-45b1ada32961",
                "name": "fadeOut",
                "method": "Prototype",
                "desc": "Fades out all nodes over a specified duration and then sets display to none.",
                "type": "Animation",
                "example": [
                    "Q('#notification').fadeOut(500);",
                    "Q('.temporary-message').fadeOut();",
                    "Q('.modal').fadeOut(300, () => Q('.modal-backdrop').fadeOut());",
                    "const duration = 800; Q('#splash-screen').fadeOut(duration, () => console.log('Animation complete'));"
                ],
                "dependencies": [],
                "script": "Q.Ext('fadeOut', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var elemStyle = el.style;\n            elemStyle.transition = 'opacity ' + duration + 'ms';\n            elemStyle.opacity = 0;\n            setTimeout(function() {\n                elemStyle.transition = '';\n                elemStyle.display = 'none';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
            },
            "fadeTo": {
                "uuid": "b34df0c3-30f0-41c4-923c-b94d49b091ef",
                "name": "fadeTo",
                "method": "Prototype",
                "desc": "Fades each node to a specific opacity.",
                "type": "Display",
                "example": [
                    "Q(selector).fadeTo(0.5, 400, function() { console.log('Faded to 50%'); });",
                    "Q('.element').fadeTo(0.75, 1000);",
                    "Q('#box').fadeTo(0, 200).fadeTo(1, 200);"
                ],
                "dependencies": [],
                "script": "Q.Ext('fadeTo', function(opacity, duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            style.opacity = opacity;\n            setTimeout(function() {\n                style.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
            },
            "fadeToggle": {
                "uuid": "903746fa-0f87-4cfa-9d34-c0ba76863571",
                "name": "fadeToggle",
                "method": "Prototype",
                "desc": "Toggles the fade state of each node.",
                "type": "Display",
                "example": [
                    "Q(selector).fadeToggle(1000);",
                    "Q('.menu-items').fadeToggle(500);",
                    "Q('#notification').fadeToggle(800, function() { console.log('Animation complete'); });"
                ],
                "dependencies": [],
                "script": "Q.Ext('fadeToggle', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var computed = window.getComputedStyle(nodes[i]);\n        if (computed.opacity === '0') {\n            this.fadeIn(duration, callback);\n        } else {\n            this.fadeOut(duration, callback);\n        }\n    }\n    return this;\n});"
            },
            "find": {
                "uuid": "24aa3cd1-cd3d-4408-acf7-05529f2df96f",
                "name": "find",
                "method": "Prototype",
                "desc": "Finds descendants of each node that match the selector.",
                "type": "Traversal",
                "example": [
                    "Q('#container').find('.item');",
                    "const nestedImages = Q('.article').find('img');",
                    "const selector = '[data-role=\"button\"]'; Q('nav').find(selector);",
                    "Q('form').find('input:invalid').addClass('error');"
                ],
                "dependencies": [],
                "script": "Q.Ext('find', function(selector) {\n    var parent = this.nodes[0];\n    if (!parent) return null;\n    var found = parent.querySelectorAll(selector);\n    return found.length ? Q(found) : null;\n});"
            },
            "first": {
                "uuid": "4eee3d08-9496-4520-ab71-0a3302c786bb",
                "name": "first",
                "method": "Prototype",
                "desc": "Returns the first node.",
                "type": "Traversal",
                "example": [
                    "Q(selector).first();",
                    "Q('li').first();",
                    "Q('.item').first().addClass('active');"
                ],
                "dependencies": [],
                "script": "Q.Ext('first', function () {\n    return new Q(this.nodes[0]);\n});"
            },
            "focus": {
                "uuid": "96237f35-911a-48f0-9257-46a97198e7bf",
                "name": "focus",
                "method": "Prototype",
                "desc": "Focuses on the first node.",
                "type": "Form Manipulation",
                "example": [
                    "Q('input#username').focus();",
                    "Q('.search-box').focus();",
                    "Q(selector).click(function() { Q('#target-field').focus(); });"
                ],
                "dependencies": [],
                "script": "Q.Ext('focus', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].focus();\n    }\n    return this;\n});"
            },
            "hasClass": {
                "uuid": "0cafeba5-f953-4ae0-acbd-d4f00981fab8",
                "name": "hasClass",
                "method": "Prototype",
                "desc": "Checks if the first node has a specific class.",
                "type": "Class Manipulation",
                "example": [
                    "var hasActiveClass = Q(selector).hasClass('active');",
                    "if (Q(selector).hasClass('disabled')) { /* disable functionality */ }",
                    "Q(selector).hasClass('highlight') ? doSomething() : doSomethingElse();"
                ],
                "dependencies": [],
                "script": "Q.Ext('hasClass', function(className) {\n    var node = this.nodes[0];\n    return (node && node.classList.contains(className)) || false;\n});"
            },
            "height": {
                "uuid": "821c97a8-8f19-4ccb-b192-4abaf2ab082f",
                "name": "height",
                "method": "Prototype",
                "desc": "Gets or sets the height of the first node, or sets the height for all nodes. Returns undefined for empty selection.",
                "type": "Dimensions",
                "example": [
                    "Q(selector).height(); // Get height of first element (px)",
                    "Q('#content').height('300px'); // Set height in px",
                    "const elemHeight = Q('.box').height(); // Get height of .box",
                    "Q('.panel').height('50vh'); // Set height in viewport units",
                    "Q('.column').height('60%').addClass('tall'); // Chaining after set",
                    "Q('.missing').height(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('height', function (value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0].offsetHeight;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.height = value;\n    }\n    return this;\n});"
            },
            "hide": {
                "uuid": "dccb7bc7-2e64-4add-ad1a-e5820cd1d72e",
                "name": "hide",
                "method": "Prototype",
                "desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
                "type": "Display",
                "example": [
                    "Q(selector).hide();",
                    "Q(selector).hide(500);",
                    "Q(selector).hide(1000, function() { console.log('Element hidden'); });"
                ],
                "dependencies": [],
                "script": "Q.Ext('hide', function (duration, callback) {\n    duration = duration || 0;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        if (duration === 0) {\n            node.style.display = 'none';\n            if (callback) callback();\n        } else {\n            node.style.transition = 'opacity ' + duration + 'ms';\n            node.style.opacity = 1;\n            setTimeout((function(n) {\n                return function() {\n                    n.style.opacity = 0;\n                    n.addEventListener('transitionend', function handler() {\n                        n.style.display = 'none';\n                        n.style.transition = '';\n                        n.removeEventListener('transitionend', handler);\n                        if (callback) callback();\n                    });\n                };\n            })(node), 0);\n        }\n    }\n    return this;\n});"
            },
            "html": {
                "uuid": "7976c0f8-486e-4921-9a87-ba07f5319fc1",
                "name": "html",
                "method": "Prototype",
                "desc": "Gets or sets the innerHTML of the nodes. This method allows for easy manipulation of the content inside the selected elements.",
                "type": "Content Manipulation",
                "example": [
                    "const currentHtml = Q(selector).html();",
                    "Q(selector).html('<div>New Content</div>');",
                    "Q(selector).html(['<span>First</span>', '<span>Second</span>']);",
                    "const newNode = Q('<p>Paragraph</p>'); Q(selector).html(newNode);",
                    "Q(selector).html(document.createElement('div'));",
                    "const nodeList = document.querySelectorAll('.child'); Q(selector).html(nodeList);",
                    "Q(selector).html([]);",
                    "Q(selector).html(null);"
                ],
                "dependencies": [],
                "script": "Q.Ext('html', function (content) {\n    var nodes = this.nodes;\n    if (content === undefined) {\n        return nodes[0] ? nodes[0].innerHTML : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        node.innerHTML = '';\n        var appendContent = function(child) {\n            if (typeof child === 'string') {\n                node.insertAdjacentHTML('beforeend', child);\n            } else if (child instanceof Q) {\n                for (var j = 0, clen = child.nodes.length; j < clen; j++) {\n                    node.appendChild(child.nodes[j]);\n                }\n            } else if (child instanceof HTMLElement || child instanceof Node) {\n                node.appendChild(child);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                var subs = Array.from(child);\n                for (var k = 0, slen = subs.length; k < slen; k++) {\n                    node.appendChild(subs[k]);\n                }\n            }\n        };\n        if (Array.isArray(content) || content instanceof NodeList) {\n            var contArr = Array.from(content);\n            for (var m = 0, mlen = contArr.length; m < mlen; m++) {\n                appendContent(contArr[m]);\n            }\n        } else {\n            appendContent(content);\n        }\n    }\n    return this;\n});"
            },
            "id": {
                "uuid": "74da5698-f333-4458-b830-008bf8aad8fa",
                "name": "id",
                "method": "Prototype",
                "desc": "Gets or sets the id attribute of the first node.",
                "type": "Attributes",
                "example": [
                    "const elementId = Q(selector).id(); // Retrieves the id",
                    "Q(selector).id('new-id'); // Sets the id to 'new-id'",
                    "const oldId = Q('#element').id(); // Get current id",
                    "Q('.element').id('dynamic-id-' + index); // Set dynamic id"
                ],
                "dependencies": [],
                "script": "Q.Ext('id', function (ident) {\n    var node = this.nodes[0];\n    if (ident === undefined) return node.id;\n    node.id = ident;\n    return this;\n});"
            },
            "index": {
                "uuid": "55959b38-f734-4d1f-ae9e-f05d21e0f118",
                "name": "index",
                "method": "Prototype",
                "desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
                "type": "Traversal",
                "example": [
                    "const position = Q('.item').index(); // Get position of element",
                    "Q('.moveMe').index(2); // Move element to third position",
                    "Q('.item').index(0); // Move to first position",
                    "Q('.item').index(999); // Move to last position (appends)"
                ],
                "dependencies": [],
                "script": "Q.Ext('index', function (index) {\n    var first = this.nodes[0];\n    if (index === undefined) {\n        return Array.prototype.indexOf.call(first.parentNode.children, first);\n    }\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i],\n            parent = node.parentNode;\n        if (!parent) continue;\n        var children = Array.from(parent.children);\n        parent.removeChild(node);\n        if (index >= children.length) {\n            parent.appendChild(node);\n        } else {\n            parent.insertBefore(node, children[index]);\n        }\n    }\n    return this;\n});"
            },
            "inside": {
                "uuid": "65807451-b7b3-4e94-92bc-3f465a4e7870",
                "name": "inside",
                "method": "Prototype",
                "desc": "Checks if the first node is inside another node, determined by a specific selector.",
                "type": "Traversal",
                "example": [
                    "Q(selector).inside(\".parent\");",
                    "if(Q('.child').inside('#container')) { /* do something */ }",
                    "Q('.item').inside('section.content')"
                ],
                "dependencies": [],
                "script": "Q.Ext('inside', function (selector) {\n    var node = this.nodes[0];\n    return node ? node.closest(selector) !== null : false;\n});"
            },
            "is": {
                "uuid": "863204fe-f570-48b7-9a84-c01e6237a8be",
                "name": "is",
                "method": "Prototype",
                "desc": "Checks if the first node matches a specific selector or condition, allowing for dynamic queries and element comparisons.",
                "type": "Utilities",
                "example": [
                    "Q(selector).is(':visible');",
                    "Q(selector).is('.active');",
                    "Q(selector).is(function() { return this.tagName === 'DIV'; });",
                    "Q(selector).is(anotherElement);",
                    "Q(selector).is(Q('.comparable'));",
                    "if(Q('input').is(':checked')) { /* process checked input */ }"
                ],
                "dependencies": [],
                "script": "Q.Ext('is', function (selector) {\n    var node = this.nodes[0];\n    if (!node) return false;\n    if (typeof selector === 'function') {\n        return selector.call(node, 0, node);\n    }\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return node.offsetWidth > 0 && node.offsetHeight > 0;\n            case ':hidden':\n                return node.offsetWidth === 0 || node.offsetHeight === 0;\n            case ':hover':\n                return node === document.querySelector(':hover');\n            case ':focus':\n                return node === document.activeElement;\n            case ':blur':\n                return node !== document.activeElement;\n            case ':checked':\n                return node.checked;\n            case ':selected':\n                return node.selected;\n            case ':disabled':\n                return node.disabled;\n            case ':enabled':\n                return !node.disabled;\n            default:\n                return node.matches(selector);\n        }\n    }\n    if (selector instanceof HTMLElement || selector instanceof Node) {\n        return node === selector;\n    }\n    if (selector instanceof Q) {\n        return node === selector.nodes[0];\n    }\n    return false;\n});"
            },
            "isExists": {
                "uuid": "d1e17816-efea-4c54-8911-e315bae8207a",
                "name": "isExists",
                "method": "Prototype",
                "desc": "Checks if the first node exists in the DOM.",
                "type": "Utilities",
                "example": [
                    "Q(selector).isExists();",
                    "Q.isExists('.ok')",
                    "if(Q('#myElement').isExists()) { /* do something */ }"
                ],
                "dependencies": [],
                "script": "Q.Ext('isExists', function () {\n    var node = this.nodes[0];\n    return node ? document.body.contains(node) : false;\n});\nQ.isExists = function (selector) {\n    return document.querySelector(selector) !== null;\n};"
            },
            "last": {
                "uuid": "9cf33c93-07cb-499f-98dc-44b00bfc3683",
                "name": "last",
                "method": "Prototype",
                "desc": "Returns the last node.",
                "type": "Traversal",
                "example": [
                    "Q(selector).last();",
                    "Q('li').last().addClass('last-item');",
                    "const lastParagraph = Q('p').last();",
                    "Q('.section').last().css('margin-bottom', '0');"
                ],
                "dependencies": [],
                "script": "Q.Ext('last', function () {\n    var nodes = this.nodes;\n    return new Q(nodes[nodes.length - 1]);\n});"
            },
            "map": {
                "uuid": "bfb41ba3-18e5-4a1a-97c9-4004f395affd",
                "name": "map",
                "method": "Prototype",
                "desc": "Maps each node to a new array.",
                "type": "Array",
                "example": [
                    "Q(selector).map(el => el.innerHTML);",
                    "const heights = Q('.box').map(el => el.prop('offsetHeight'));",
                    "const texts = Q('p').map(el => el.text());",
                    "const data = Q('[data-value]').map(el => el.attr('data-value'));"
                ],
                "dependencies": [],
                "script": "Q.Ext('map', function (callback) {\n    var result = [],\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        result.push(callback(new Q(nodes[i])));\n    }\n    return result;\n});"
            },
            "next": {
                "uuid": "8f030ab1-97ef-4e5c-9654-7e09fb56b670",
                "name": "next",
                "method": "Prototype",
                "desc": "Gets the next sibling element of each node, optionally filtered by a selector.",
                "type": "Traversal",
                "example": [
                    "const nextElement = Q('#current').next();",
                    "Q('li.active').next().addClass('upcoming');",
                    "Q('.panel').next('div.panel').toggle();",
                    "const nextSlide = Q('.current-slide').next('.slide');"
                ],
                "dependencies": [],
                "script": "Q.Ext('next', function(selector) {\n    const result = [];\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        let next = node.nextElementSibling;\n        if (next && (!selector || next.matches(selector))) {\n            result.push(next);\n        }\n    }\n    const instance = new Q();\n    instance.nodes = result;\n    return instance;\n});"
            },
            "off": {
                "uuid": "74528ee5-d436-4015-a560-72d8d8e92393",
                "name": "off",
                "method": "Prototype",
                "desc": "Removes an event listener from each node.",
                "type": "Event Handling",
                "example": [
                    "Q(selector).off(\"click\", handler);",
                    "Q('button').off('click touchstart', handleInteraction);",
                    "Q('#form').off('submit', validateForm);",
                    "Q('.dropdown').off('mouseenter mouseleave', toggleMenu, { capture: true });"
                ],
                "dependencies": [],
                "script": "Q.Ext('off', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].removeEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
            },
            "offset": {
                "uuid": "166ea307-3bd8-41ee-a381-682935664a9e",
                "name": "offset",
                "method": "Prototype",
                "desc": "Gets the position of the first node relative to the document. Returns undefined for empty selection.",
                "type": "Position",
                "example": [
                    "const pos = Q('#element').offset(); // { top: ..., left: ... } or undefined",
                    "const { top, left } = Q('.tooltip-trigger').offset() || {}; // Destructuring with fallback",
                    "Q('#popup').css({ top: Q('#reference').offset().top + 10 + 'px' }); // Use offset for positioning",
                    "const coords = Q('button').offset(); console.log(`Document position: ${coords?.left}, ${coords?.top}`); // Safe logging",
                    "Q('.missing').offset(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('offset', function () {\n    var node = this.nodes[0],\n        rect = node.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX\n    };\n});"
            },
            "on": {
                "uuid": "d915a504-b91f-4ec7-9e69-c477c019c331",
                "name": "on",
                "method": "Prototype",
                "desc": "Adds an event listener to each node.",
                "type": "Event Handling",
                "example": [
                    "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
                    "Q('button').on('click keypress', handleInteraction);",
                    "Q('#form').on('submit', function(e) { e.preventDefault(); });",
                    "Q('.draggable').on('mousedown', startDrag, { passive: true });"
                ],
                "dependencies": [],
                "script": "Q.Ext('on', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].addEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
            },
            "parent": {
                "uuid": "a6cbc8c6-1326-4189-91e0-88ad72af223a",
                "name": "parent",
                "method": "Prototype",
                "desc": "Gets the parent element of each node, optionally filtered by a selector.",
                "type": "Traversal",
                "example": [
                    "const container = Q('#element').parent();",
                    "Q('li.active').parent().addClass('has-active-item');",
                    "Q('.error-message').parent('form').addClass('has-error');",
                    "const formParent = Q('input[name=\"email\"]').parent('.form-group');"
                ],
                "dependencies": [],
                "script": "Q.Ext('parent', function () {\n    var node = this.nodes[0];\n    return new Q(node ? node.parentNode : null);\n});"
            },
            "position": {
                "uuid": "0306efde-ede9-407f-9bd5-7c06e0481fa8",
                "name": "position",
                "method": "Prototype",
                "desc": "Gets the position of the first node relative to its offset parent. Returns undefined for empty selection.",
                "type": "Position",
                "example": [
                    "const pos = Q('#element').position(); // { top: ..., left: ... } or undefined",
                    "const { top, left } = Q('.item').position() || {}; // Destructuring with fallback",
                    "Q('#tooltip').css({ top: Q('#target').position().top + 20 + 'px' }); // Use position for positioning",
                    "const buttonPos = Q('button').position(); console.log(`X: ${buttonPos?.left}, Y: ${buttonPos?.top}`); // Safe logging",
                    "Q('.missing').position(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('position', function () {\n    var node = this.nodes[0];\n    return {\n        top: node.offsetTop,\n        left: node.offsetLeft\n    };\n});"
            },
            "prepend": {
                "uuid": "b9396341-c685-4318-adce-98a104891985",
                "name": "prepend",
                "method": "Prototype",
                "desc": "Inserts content at the beginning of each node.",
                "type": "DOM Manipulation",
                "example": [
                    "Q(selector).prepend('<span>New content</span>');",
                    "Q('.list').prepend('<li>First item</li>');",
                    "const newElement = document.createElement('div'); Q('#container').prepend(newElement);",
                    "Q('.message').prepend(`<strong class=\"prefix\">${prefix}:</strong> `);"
                ],
                "dependencies": [],
                "script": "Q.Ext('prepend', function () {\n    var nodes = this.nodes,\n        contents = Array.prototype.slice.call(arguments),\n        i, j, k, parent, child, subNodes;\n    for (i = 0; i < nodes.length; i++) {\n        parent = nodes[i];\n        for (j = 0; j < contents.length; j++) {\n            child = contents[j];\n            if (typeof child === 'string') {\n                parent.insertAdjacentHTML('afterbegin', child);\n            } else if (child instanceof Q) {\n                parent.insertBefore(child.nodes[0], parent.firstChild);\n            } else if (child instanceof HTMLElement || child instanceof Node) {\n                parent.insertBefore(child, parent.firstChild);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                subNodes = Array.from(child);\n                for (k = 0; k < subNodes.length; k++) {\n                    parent.insertBefore(subNodes[k], parent.firstChild);\n                }\n            }\n        }\n    }\n    return this;\n});"
            },
            "prev": {
                "uuid": "e13be9fd-6620-4875-9c26-2cd9bcfbbdd1",
                "name": "prev",
                "method": "Prototype",
                "desc": "Gets the previous sibling element of each node, optionally filtered by a selector.",
                "type": "Traversal",
                "example": [
                    "const previousElement = Q('#current').prev();",
                    "Q('li.active').prev().addClass('completed');",
                    "Q('.step-3').prev('.step').trigger('focus');",
                    "const prevSlide = Q('.current-slide').prev('.slide');"
                ],
                "dependencies": [],
                "script": "Q.Ext('prev', function(selector) {\n    const result = [];\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        let previous = node.previousElementSibling;\n        if (previous && (!selector || previous.matches(selector))) {\n            result.push(previous);\n        }\n    }\n    const instance = new Q();\n    instance.nodes = result;\n    return instance;\n});"
            },
            "prop": {
                "uuid": "1413dee3-07ba-4767-b918-3d5768027ad0",
                "name": "prop",
                "method": "Prototype",
                "desc": "Gets or sets a property on the nodes.",
                "type": "Property Manipulation",
                "example": [
                    "Q(selector).prop(property, value);",
                    "Q('input[type=\"checkbox\"]').prop('checked', true);",
                    "const isDisabled = Q('#submit-button').prop('disabled');",
                    "Q('textarea').prop('readOnly', false);"
                ],
                "dependencies": [],
                "script": "Q.Ext('prop', function (property, value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0] ? nodes[0][property] : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i][property] = value;\n    }\n    return this;\n});"
            },
            "remove": {
                "uuid": "f3adf80d-edef-43e7-baaa-f0dcfe2f6e3b",
                "name": "remove",
                "method": "Prototype",
                "desc": "Removes all nodes from the DOM.",
                "type": "DOM Manipulation",
                "example": [
                    "Q(selector).remove();",
                    "Q('.temporary-message').remove();",
                    "Q('#confirm-dialog').fadeOut().remove();",
                    "if (shouldDelete) { Q('.deleted-items').remove(); }"
                ],
                "dependencies": [],
                "script": "Q.Ext('remove', function() {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].remove();\n    }\n    return this;\n});"
            },
            "removeAttr": {
                "uuid": "ee4da6e1-3c03-4e86-9dc7-539b25e109a5",
                "name": "removeAttr",
                "method": "Prototype",
                "desc": "Removes an attribute from each node.",
                "type": "Attribute Manipulation",
                "example": [
                    "Q(selector).removeAttr(attribute);",
                    "Q('input').removeAttr('disabled');",
                    "Q('.product').removeAttr('data-id');",
                    "Q('img').removeAttr('src');"
                ],
                "dependencies": [],
                "script": "Q.Ext('removeAttr', function (attribute) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].removeAttribute(attribute);\n    }\n    return this;\n});"
            },
            "removeClass": {
                "uuid": "8a7086d8-4a68-47df-ae84-c152f087e02f",
                "name": "removeClass",
                "method": "Prototype",
                "desc": "Removes the specified class from each node.",
                "type": "Class Manipulation",
                "example": [
                    "Q(selector).removeClass('highlight');",
                    "Q('.card').removeClass('active selected');",
                    "const errorClass = 'invalid'; Q('.form-input').removeClass(errorClass);",
                    "Q('.temp-element').removeClass(); // Removes all classes"
                ],
                "dependencies": [],
                "script": "Q.Ext('removeClass', function (classes) {\n    var list = classes.split(' ');\n    for (var i = 0, len = this.nodes.length; i < len; i++) {\n        this.nodes[i].classList.remove.apply(this.nodes[i].classList, list);\n    }\n    return this;\n});"
            },
            "removeData": {
                "uuid": "edb05f4f-9e8c-4f44-b8cb-5ad8e25bc9cd",
                "name": "removeData",
                "method": "Prototype",
                "desc": "Removes a data-* attribute from each node.",
                "type": "Data Manipulation",
                "example": [
                    "Q(selector).removeData(key);",
                    "Q('.user-cards').removeData('userId');",
                    "Q('#product').removeData('price');"
                ],
                "dependencies": [],
                "script": "Q.Ext('removeData', function (key) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i].dataset[key];\n    }\n    return this;\n});"
            },
            "removeProp": {
                "uuid": "b8c3d7c1-4d9d-4727-b87c-b0c3da33b8d8",
                "name": "removeProp",
                "method": "Prototype",
                "desc": "Removes a property from each node.",
                "type": "Property Manipulation",
                "example": [
                    "Q(selector).removeProp(property);",
                    "Q('.elements').removeProp('customProperty');",
                    "Q('#form-elements').removeProp('validated');"
                ],
                "dependencies": [],
                "script": "Q.Ext('removeProp', function (property) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i][property];\n    }\n    return this;\n});"
            },
            "removeTransition": {
                "uuid": "6fe7943c-ab0d-4f91-933f-f7e479646382",
                "name": "removeTransition",
                "method": "Prototype",
                "desc": "Removes the transition from each node.",
                "type": "Display",
                "example": [
                    "Q(selector).removeTransition();",
                    "Q('.animated-elements').removeTransition();",
                    "Q('#modal').removeTransition().hide();"
                ],
                "dependencies": [],
                "script": "Q.Ext('removeTransition', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.transition = '';\n    }\n    return this;\n});"
            },
            "scrollHeight": {
                "uuid": "7ce41406-aaf3-4a6e-9de9-3011558586ed",
                "name": "scrollHeight",
                "method": "Prototype",
                "desc": "Returns the scroll height of the first node. Returns undefined for empty selection.",
                "type": "Dimensions",
                "example": [
                    "const height = Q('#content').scrollHeight(); // Get scrollHeight or undefined",
                    "if (Q('.panel').scrollHeight() > Q('.panel').height()) { /* content is overflowing */ }",
                    "const totalHeight = Q('#long-text').scrollHeight();",
                    "const scrollPercentage = Q('#container').scrollTop() / (Q('#container').scrollHeight() - Q('#container').height());",
                    "Q('.missing').scrollHeight(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('scrollHeight', function () {\n    var node = this.nodes[0];\n    return node.scrollHeight;\n});"
            },
            "scrollLeft": {
                "uuid": "1165e645-d99f-4d85-b9fe-5c5e8cab4063",
                "name": "scrollLeft",
                "method": "Prototype",
                "desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment. Returns undefined for empty selection.",
                "type": "Scroll Manipulation",
                "example": [
                    "const position = Q('.scrollable').scrollLeft(); // Get scroll position",
                    "Q('#horizontal-container').scrollLeft(200); // Set scroll position",
                    "Q('.slider').scrollLeft(50, true); // Increment by 50px",
                    "const scrollAmount = 100; Q('.carousel').scrollLeft(scrollAmount, true); // Increment by variable",
                    "Q('.carousel').scrollLeft(300).addClass('scrolled'); // Chaining after set",
                    "Q('.missing').scrollLeft(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('scrollLeft', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollLeft;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollLeft = current.scrollWidth - current.clientWidth;\n        current.scrollLeft = increment \n            ? Math.min(current.scrollLeft + value, maxScrollLeft) \n            : Math.min(value, maxScrollLeft);\n    }\n    return this;\n});"
            },
            "scrollTop": {
                "uuid": "df080ea9-eb78-4e1c-8874-d7ce96bbe323",
                "name": "scrollTop",
                "method": "Prototype",
                "desc": "Gets or sets the vertical scroll position of the first node, with an option to increment. Returns undefined for empty selection.",
                "type": "Scroll Manipulation",
                "example": [
                    "const position = Q('#container').scrollTop(); // Get scroll position",
                    "Q('.scroll-area').scrollTop(300); // Set scroll position",
                    "Q('#content').scrollTop(100, true); // Increment by 100px",
                    "const scrollAmount = 50; Q('.panel').scrollTop(scrollAmount, true); // Increment by variable",
                    "Q('.panel').scrollTop(200).addClass('scrolled'); // Chaining after set",
                    "Q('.missing').scrollTop(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('scrollTop', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollTop;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollTop = current.scrollHeight - current.clientHeight;\n        current.scrollTop = increment \n            ? Math.min(current.scrollTop + value, maxScrollTop) \n            : Math.min(value, maxScrollTop);\n    }\n    return this;\n});"
            },
            "scrollWidth": {
                "uuid": "b5ca72df-4fdb-4cd5-b19e-67f43e358b28",
                "name": "scrollWidth",
                "method": "Prototype",
                "desc": "Returns the scroll width of the first node. Returns undefined for empty selection.",
                "type": "Dimensions",
                "example": [
                    "const width = Q('#content').scrollWidth(); // Get scrollWidth or undefined",
                    "if (Q('.panel').scrollWidth() > Q('.panel').width()) { /* content is overflowing */ }",
                    "const scrollableWidth = Q('#scrollable-area').scrollWidth();",
                    "const scrollPercentage = Q('#container').scrollLeft() / (Q('#container').scrollWidth() - Q('#container').width());",
                    "Q('.missing').scrollWidth(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('scrollWidth', function () {\n    var node = this.nodes[0];\n    return node.scrollWidth;\n});"
            },
            "show": {
                "uuid": "d33fbf12-408a-4cf1-8bb8-803021b1598b",
                "name": "show",
                "method": "Prototype",
                "desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
                "type": "Display",
                "example": [
                    "Q(selector).show();",
                    "Q('#modal').show(500);",
                    "Q('.notification').show(300, () => console.log('Animation completed'));",
                    "const fadeTime = 800; Q('.hidden-content').show(fadeTime);"
                ],
                "dependencies": [],
                "script": "Q.Ext('show', function (duration = 0, callback) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const element = this.nodes[i];\n        if (duration === 0) {\n            element.style.display = '';\n            if (callback) callback();\n        } else {\n            element.style.transition = `opacity ${duration}ms`;\n            element.style.opacity = 0;\n            element.style.display = '';\n            setTimeout(() => {\n                element.style.opacity = 1;\n                element.addEventListener('transitionend', () => {\n                    element.style.transition = '';\n                    if (callback) callback();\n                }, { once: true });\n            }, 0);\n        }\n    }\n    return this;\n});"
            },
            "siblings": {
                "uuid": "129e48a3-747c-45f3-9322-fe7507137caa",
                "name": "siblings",
                "method": "Prototype",
                "desc": "Gets all sibling elements of each node, optionally filtered by a selector.",
                "type": "Traversal",
                "example": [
                    "const allSiblings = Q('#middle').siblings();",
                    "Q('.active').siblings().removeClass('active');",
                    "Q('li.selected').siblings('li.optional').hide();",
                    "const siblingLinks = Q('.current-page').siblings('a');"
                ],
                "dependencies": [],
                "script": "Q.Ext('siblings', function(selector) {\n    const result = [];\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        const parent = node.parentNode;\n        if (parent) {\n            const children = parent.children;\n            for (let j = 0; j < children.length; j++) {\n                if (children[j] !== node) {\n                    if (!selector || children[j].matches(selector)) {\n                        result.push(children[j]);\n                    }\n                }\n            }\n        }\n    }\n    const instance = new Q();\n    instance.nodes = result;\n    return instance;\n});"
            },
            "size": {
                "uuid": "d6f42266-4084-4143-b8e5-f0735655d34d",
                "name": "size",
                "method": "Prototype",
                "desc": "Returns the width and height of the first node.",
                "type": "Dimensions",
                "example": [
                    "const dimensions = Q('#box').size();",
                    "const { width, height } = Q('.container').size();",
                    "if (Q('#element').size().width > 500) { /* logic here */ }",
                    "const ratio = Q('.image').size().width / Q('.image').size().height;"
                ],
                "dependencies": [],
                "script": "Q.Ext('size', function () {\n    const node = this.nodes[0];\n\treturn {\n\t\twidth: node.offsetWidth,\n\t\theight: node.offsetHeight\n\t};\n});"
            },
            "text": {
                "uuid": "dce297e5-5b23-4f1e-bf0f-0de95d859a08",
                "name": "text",
                "method": "Prototype",
                "desc": "Gets or sets the text content of the nodes. Returns null for empty selection. Chainable as setter.",
                "type": "Content Manipulation",
                "example": [
                    "Q(selector).text('Hello'); // Set text for all",
                    "const message = Q('#notification').text(); // Get text from #notification",
                    "Q('.error').text('An error occurred'); // Set error message",
                    "Q('li').text((i) => `Item ${i+1}`); // Set text with function (if supported)",
                    "Q('.panel').text('Panel').addClass('labeled'); // Chaining after set",
                    "Q('.missing').text(); // Returns null for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('text', function (content) {\n    if (content === undefined) {\n        return this.nodes[0]?.textContent || null;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].textContent = content;\n    }\n    return this;\n});"
            },
            "toggle": {
                "uuid": "8d6e44e2-204b-4a56-a15c-d96311b36ac8",
                "name": "toggle",
                "method": "Prototype",
                "desc": "Toggles the display of each node. Chainable. Does nothing for empty selection.",
                "type": "Display",
                "example": [
                    "Q(selector).toggle(); // Toggle display",
                    "Q('#details').toggle(); // Toggle #details",
                    "Q('.expandable').click(function() { Q(this).next().toggle(); }); // Toggle next element on click",
                    "const panels = Q('.panel'); panels.toggle(); // Toggle all panels",
                    "Q('.panel').toggle().addClass('toggled'); // Chaining after toggle",
                    "Q('.missing').toggle(); // Does nothing for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('toggle', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.display = (nodes[i].style.display === 'none' ? '' : 'none');\n    }\n    return this;\n});"
            },
            "toggleClass": {
                "uuid": "d71cade6-60dd-417e-b85a-131ab6478862",
                "name": "toggleClass",
                "method": "Prototype",
                "desc": "Toggles a class on each node. Chainable. Does nothing for empty selection.",
                "type": "Class Manipulation",
                "example": [
                    "Q(selector).toggleClass('active'); // Toggle 'active' class",
                    "Q('#menu-button').toggleClass('open'); // Toggle 'open' class",
                    "const highlightClass = 'highlight'; Q('.selectable').toggleClass(highlightClass); // Toggle variable class",
                    "Q(event.target).toggleClass('selected').siblings().toggleClass('dimmed'); // Chaining with siblings",
                    "Q('.panel').toggleClass('expanded').addClass('checked'); // Chaining after toggleClass",
                    "Q('.missing').toggleClass('foo'); // Does nothing for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('toggleClass', function (className) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].classList.toggle(className);\n    }\n    return this;\n});"
            },
            "trigger": {
                "uuid": "00251e8c-78aa-40be-a6ad-43f0f0d020a2",
                "name": "trigger",
                "method": "Prototype",
                "desc": "Triggers a specific event on each node. Chainable. Does nothing for empty selection.",
                "type": "Event Handling",
                "example": [
                    "Q('#submitButton').trigger('click'); // Trigger click event",
                    "Q('.accordion-header').trigger('mouseenter'); // Trigger mouseenter",
                    "const eventName = 'change'; Q('input').trigger(eventName); // Dynamic event name",
                    "Q('.custom-element').trigger('customEvent'); // Custom event",
                    "Q('.panel').trigger('show').addClass('shown'); // Chaining after trigger",
                    "Q('.missing').trigger('foo'); // Does nothing for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('trigger', function (event) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].dispatchEvent(new Event(event));\n    }\n    return this;\n});"
            },
            "unwrap": {
                "uuid": "10920f8e-223f-4345-8428-aacc06639a9a",
                "name": "unwrap",
                "method": "Prototype",
                "desc": "Removes the parent wrapper of each node. Chainable. Does nothing for empty selection.",
                "type": "DOM Manipulation",
                "example": [
                    "Q(selector).unwrap(); // Remove parent wrapper",
                    "Q('span.highlight').unwrap(); // Unwrap highlighted spans",
                    "Q('.inner-content').unwrap().addClass('standalone'); // Chaining after unwrap",
                    "if (shouldRemoveWrapper) { Q('.wrapped-items').unwrap(); } // Conditional unwrap",
                    "Q('.missing').unwrap(); // Does nothing for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('unwrap', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const el = this.nodes[i];\n        const parent = el.parentNode;\n        if (parent && parent !== document.body) {\n            parent.replaceWith(...parent.childNodes);\n        }\n    }\n    return this;\n});"
            },
            "val": {
                "uuid": "799adf9d-4f56-4ebc-94f5-bd83d77b52f4",
                "name": "val",
                "method": "Prototype",
                "desc": "Gets or sets the value of form elements in the nodes. Returns null for empty selection. Chainable as setter.",
                "type": "Form Manipulation",
                "example": [
                    "Q('input').val('New text'); // Set value for all inputs",
                    "const username = Q('#username').val(); // Get value from #username input",
                    "Q('select').val('option2'); // Set value for all selects",
                    "Q('textarea').val('').val(Q('#template').text()); // Chain set and get",
                    "Q('.non-input').val(); // Returns null for non-input elements",
                    "Q('input').val('A').addClass('changed'); // Chaining after set",
                    "Q('.missing').val(); // Returns null for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('val', function(input) {\n    if (input === undefined) return this.nodes[0]?.value || null;\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].value = input;\n    }\n    return this;\n});"
            },
            "wait": {
                "uuid": "189a14f2-c6c9-4b09-9d2d-79d40b01b548",
                "name": "wait",
                "method": "Prototype",
                "desc": "Returns a promise that resolves with the Q object after a given time. Enables async chainable actions.",
                "type": "Utility",
                "example": [
                    "Q('.text').wait(1000).then(q => q.text('Hello, World!')); // Promise chaining",
                    "async function animate() { await Q('#element').addClass('start').wait(500); Q('#element').addClass('end'); } // Async/await",
                    "Q('.notification').show().wait(3000).then(q => q.hide()); // Hide after delay",
                    "const delay = 800; Q('.message').fadeIn().wait(delay).then(q => q.fadeOut()); // Dynamic delay",
                    "Q('.missing').wait(100).then(q => q.addClass('checked')); // Works for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('wait', function(ms) {\n\treturn new Promise(resolve => setTimeout(() => resolve(this), ms));\n});"
            },
            "walk": {
                "uuid": "1bf85b1a-a024-4bb0-9014-27b73eaab7a5",
                "name": "walk",
                "method": "Prototype",
                "desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter. Chainable. Does nothing for empty selection.",
                "type": "Iteration",
                "example": [
                    "Q(selector).walk((node) => console.log(node)); // Walk all nodes, raw element",
                    "Q('li').walk((node, index) => node.textContent = `Item ${index + 1}`); // Set text by index",
                    "Q('.items').walk((node) => node.classList.add('processed'), true); // Use Q object",
                    "let total = 0; Q('input').walk((node) => total += parseInt(node.value) || 0); // Aggregate values",
                    "Q('.panel').walk((node) => node.classList.add('checked')).addClass('done'); // Chaining after walk",
                    "Q('.missing').walk((node) => console.log(node)); // Does nothing for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('walk', function (callback, useQObject = false) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = useQObject ? Q(this.nodes[i]) : this.nodes[i];\n        callback.call(this.nodes[i], node, i);\n    }\n    return this;\n});"
            },
            "width": {
                "uuid": "6bc31913-0c4f-4e4c-b439-9c71fd2f6588",
                "name": "width",
                "method": "Prototype",
                "desc": "Gets or sets the width of the first node, or sets the width for all nodes. Returns undefined for empty selection.",
                "type": "Dimensions",
                "example": [
                    "Q(selector).width(); // Get width of first element (px)",
                    "Q('#content').width('500px'); // Set width in px",
                    "const elemWidth = Q('.box').width(); // Get width of .box",
                    "Q('.column').width('50%'); // Set width in percent",
                    "Q('.panel').width('80vw').addClass('wide'); // Chaining after set",
                    "Q('.missing').width(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('width', function (value) {\n    if (typeof value === 'undefined') {\n        return this.nodes[0] ? this.nodes[0].offsetWidth : undefined;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.width = value;\n    }\n    return this;\n});"
            },
            "wrap": {
                "uuid": "21494725-f7dd-4103-939e-3f24a2a15ab7",
                "name": "wrap",
                "method": "Prototype",
                "desc": "Wraps each node with the specified wrapper element.",
                "type": "DOM Manipulation",
                "example": [
                    "Q('.item').wrap('<div class=\"wrapper\"></div>'); // Wrap each .item in a div",
                    "Q('p').wrap('<article class=\"content\"></article>'); // Wrap each p in article",
                    "const wrapperDiv = document.createElement('div'); Q('.list-item').wrap(wrapperDiv); // Wrap with element",
                    "Q('.to-wrap').wrap('<span class=\"outer\"></span>').addClass('wrapped'); // Chaining after wrap",
                    "Q('.multi').wrap('<div></div>'); // Multiple elements wrapped individually"
                ],
                "dependencies": [],
                "script": "Q.Ext('wrap', function (wrapper) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        const parent_Node = node.parentNode;\n        let newParentElement;\n        if (typeof wrapper === 'string') {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = wrapper.trim();\n            newParentElement = tempDiv.firstElementChild.cloneNode(true);\n        } else {\n            newParentElement = wrapper;\n        }\n        parent_Node.insertBefore(newParentElement, node);\n        newParentElement.appendChild(node);\n    }\n    return this;\n});"
            },
            "wrapAll": {
                "uuid": "d5211f1f-0288-4230-a081-9800f3cbba47",
                "name": "wrapAll",
                "method": "Prototype",
                "desc": "Wraps all nodes together in a single wrapper element.",
                "type": "DOM Manipulation",
                "example": [
                    "Q('.item').wrapAll('<div class=\"wrapper\"></div>'); // Wrap all .item in a div",
                    "Q('.items').wrapAll('<section id=\"container\"></section>'); // Wrap in a section",
                    "const wrapperElement = document.createElement('div'); Q('.related-posts').wrapAll(wrapperElement); // Wrap with element",
                    "Q('.to-group').wrapAll('<ul></ul>').addClass('grouped'); // Chaining after wrapAll",
                    "Q('.deep').wrapAll('<div class=\"outer\"><div class=\"inner\"></div></div>'); // Deeply nested wrapper"
                ],
                "dependencies": [],
                "script": "Q.Ext('wrapAll', function (wrapper) {\n    if (!this.nodes.length) return this;\n    const parent = this.nodes[0].parentNode;\n    let newParent = typeof wrapper === 'string'\n        ? ((tempDiv => (tempDiv.innerHTML = wrapper.trim(), tempDiv.firstElementChild))\n           (document.createElement('div')))\n        : wrapper;\n    parent.insertBefore(newParent, this.nodes[0]);\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        newParent.appendChild(this.nodes[i]);\n    }\n    return this;\n});"
            },
            "zIndex": {
                "uuid": "d4711fef-31df-4366-971a-e58a168966d4",
                "name": "zIndex",
                "method": "Prototype",
                "desc": "Gets or sets the z-index of the first node, or sets the z-index for all nodes. Returns undefined for empty selection.",
                "type": "Display",
                "example": [
                    "Q(selector).zIndex(); // Get z-index of first element or undefined",
                    "Q('.overlay').zIndex(10); // Set z-index for all .overlay elements",
                    "const currentIndex = Q('#popup').zIndex(); // Get z-index for #popup",
                    "Q('.modal').zIndex(Q('.header').zIndex() + 5); // Set relative z-index",
                    "Q('.modal').zIndex(100).addClass('on-top'); // Chaining after set",
                    "Q('.missing').zIndex(); // Returns undefined for empty selection"
                ],
                "dependencies": [],
                "script": "Q.Ext('zIndex', function (value) {\n    const node = this.nodes[0];\n    if (!node) return;\n    if (value === undefined) {\n        let Index = node.style.zIndex || window.getComputedStyle(node).zIndex;\n        return Index;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.zIndex = value;\n    }\n    return this;\n});"
            }
        },
        "plugins": {
            "Container.Frame": {
                "uuid": "eaf436c4-232a-40b5-8a0d-cd5d02706023",
                "name": "Container.Frame",
                "method": "Prototype",
                "desc": "Flexible frame splitter for horizontal or vertical layouts.",
                "type": "Layout",
                "example": [
                    "var frame = Q.Container().Frame({ direction: 'horizontal' });\nframe.frames([{ name: 'left' }, { name: 'right' }]);\ndocument.body.appendChild(frame);",
                    "var frame = Q.Container().Frame({ direction: 'vertical', id: 'mainFrame' });\nframe.frames([{ name: 'top', size: '30%' }, { name: 'bottom', size: '70%' }]);\ndocument.body.appendChild(frame);"
                ],
                "dependencies": [
                    "Q",
                    "Container"
                ],
                "script": "Container.prototype.Frame = function(options = {}) {\n    const self = this;\n    const defaultOptions = {\n        direction: 'horizontal', // 'horizontal' or 'vertical'\n        id: \"ok\",                // unique id for saving/restoring positions\n        savePosition: true,      // save/restore frame sizes in localStorage\n        minSize: 20,             // minimum size in px for a frame section\n        responsive: true,\n        responsivesMaxCount: 5, // maximum number of responsive frames\n        responsiveAnimation: 250,\n        responsiveAnimationEasing: 'ease-in-out',\n        storageKey: \"settings.frames\"\n    };\n    options = Object.assign({}, defaultOptions, options);\n    if (!Container.frameClassesInitialized) {\n        Container.frameClasses = Q.style('', `\n            .frame_root {\n                display: flex;\n                width: 100%;\n                height: 100%;\n                min-height: 100px;\n                min-width: 100px;\n                border-radius: 6px;\n                overflow: hidden;\n                position: relative;\n            }\n            .frame_horizontal {\n                flex-direction: row;\n            }\n            .frame_vertical {\n                flex-direction: column;\n            }\n            .frame_section {\n                position: relative;\n                overflow: auto;\n                min-width: 20px;\n                min-height: 20px;\n            }\n            .frame_resizer {\n                background: var(--form-default-accent-color, #444);\n                opacity: 0.2;\n                z-index: 10;\n                position: relative;\n                user-select: none;\n            }\n            .frame_resizer_horizontal {\n                width: 3px;\n                cursor: col-resize;\n            }\n            .frame_resizer_vertical {\n                height: 3px;\n                cursor: row-resize;\n            }\n            .frame_resizer:hover {\n                opacity: 0.5;\n            }\n        `, null, {\n            'frame_root': 'frame_root',\n            'frame_horizontal': 'frame_horizontal',\n            'frame_vertical': 'frame_vertical',\n            'frame_section': 'frame_section',\n            'frame_resizer': 'frame_resizer',\n            'frame_resizer_horizontal': 'frame_resizer_horizontal',\n            'frame_resizer_vertical': 'frame_resizer_vertical'\n        },false);\n        Container.frameClassesInitialized = true;\n    }\n    let direction = options.direction === 'vertical' ? 'vertical' : 'horizontal';\n    const root = Q('<div>', { class: Container.frameClasses.frame_root });\n    root.addClass(direction === 'horizontal' ? Container.frameClasses.frame_horizontal : Container.frameClasses.frame_vertical);\n    const frameId = options.id || null;\n    const savePosition = !!options.savePosition;\n    const storageKey = options.storageKey;\n    const minSize = options.minSize;\n    const responsive = !!options.responsive;\n    const responsivesMaxCount = options.responsivesMaxCount || 5;\n    function getSavedFrames() {\n        return Q.Storage(storageKey) || {};\n    }\n    function saveFrames(framesObj) {\n        console.log('Saving frames:', framesObj);\n        Q.Storage(storageKey, framesObj);\n    }\n    function clearFramePos(id) {\n        const all = getSavedFrames();\n        if (all[id]) {\n            delete all[id];\n            saveFrames(all);\n        }\n    }\n    function getScreenSizeBucket() {\n        const px = direction === 'horizontal'\n            ? window.innerWidth\n            : window.innerHeight;\n        return Math.floor(px / 100); // pl. 1842 -> 18\n    }\n    function findSavedSizeByBucket(saved, bucket) {\n        if (!saved || !Array.isArray(saved) || saved.length === 0) return null;\n        for (let i = 0; i < saved.length; ++i) {\n            const entry = saved[i];\n            if (entry && typeof entry.screenSizeBucket === 'number' && entry.screenSizeBucket === bucket) {\n                return entry;\n            }\n        }\n        return null;\n    }\n    root.direction = function(dir) {\n        direction = dir === 'vertical' ? 'vertical' : 'horizontal';\n        root.removeClass(Container.frameClasses.frame_horizontal + ' ' + Container.frameClasses.frame_vertical);\n        root.addClass(direction === 'horizontal' ? Container.frameClasses.frame_horizontal : Container.frameClasses.frame_vertical);\n        return this;\n    };\n    root.clearPos = function() {\n        if (frameId) clearFramePos(frameId);\n        return this;\n    };\n    root.frames = function(frameDefs) {\n        root.empty();\n        const frameMap = {};\n        let totalFlex = 0;\n        root._frameDefs = frameDefs;\n        frameDefs.forEach(def => {\n            if (def.size && typeof def.size === 'string' && def.size.endsWith('%')) {\n                totalFlex += parseFloat(def.size);\n            }\n        });\n        const defaultSize = frameDefs.length > 0 ? (100 - totalFlex) / frameDefs.filter(f => !f.size).length : 100;\n        let savedSizes = null;\n        let savedResponsiveList = null;\n        let currentScreenSizeBucket = getScreenSizeBucket();\n        if (savePosition && frameId) {\n            const all = getSavedFrames();\n            if (all[frameId]) {\n                if (responsive && Array.isArray(all[frameId].responsive)) {\n                    savedResponsiveList = all[frameId].responsive;\n                    const found = findSavedSizeByBucket(savedResponsiveList, currentScreenSizeBucket);\n                    if (found && Array.isArray(found.sizes) && found.sizes.length === frameDefs.length) {\n                        savedSizes = found.sizes;\n                    }\n                } else if (Array.isArray(all[frameId].sizes) && all[frameId].sizes.length === frameDefs.length) {\n                    savedSizes = all[frameId].sizes;\n                }\n            }\n        }\n        const sections = [];\n        const resizers = [];\n        frameDefs.forEach((def, idx) => {\n            const section = Q('<div>', { class: Container.frameClasses.frame_section });\n            let sizeVal = null;\n            if (savedSizes && savedSizes[idx]) {\n                sizeVal = savedSizes[idx];\n            } else if (def.size) {\n                sizeVal = def.size;\n            } else {\n                sizeVal = defaultSize + '%';\n            }\n            if (direction === 'horizontal') section.css('width', sizeVal);\n            else section.css('height', sizeVal);\n            frameMap[def.name] = section;\n            sections.push(section);\n            root.append(section);\n            if (def.resize && idx < frameDefs.length - 1) {\n                const resizer = Q('<div>', { class: Container.frameClasses.frame_resizer });\n                resizer.addClass(direction === 'horizontal' ? Container.frameClasses.frame_resizer_horizontal : Container.frameClasses.frame_resizer_vertical);\n                resizer.on('mousedown', function(e) {\n                    e.preventDefault();\n                    const prev = section;\n                    const next = sections[idx + 1];\n                    if (!prev || !next) return;\n                    const parent = root.nodes[0];\n                    const isHorizontal = direction === 'horizontal';\n                    const prevRect = prev.nodes[0].getBoundingClientRect();\n                    const nextRect = next.nodes[0].getBoundingClientRect();\n                    const parentPx = isHorizontal ? parent.clientWidth : parent.clientHeight;\n                    const prevPercent = (isHorizontal ? prevRect.width : prevRect.height) / parentPx * 100;\n                    const nextPercent = (isHorizontal ? nextRect.width : nextRect.height) / parentPx * 100;\n                    const startX = e.clientX, startY = e.clientY;\n                    function onMove(ev) {\n                        let deltaPx = isHorizontal ? ev.clientX - startX : ev.clientY - startY;\n                        let newPrevPercent = prevPercent + (deltaPx / parentPx) * 100;\n                        let newNextPercent = nextPercent - (deltaPx / parentPx) * 100;\n                        const minPercent = minSize / parentPx * 100;\n                        if (newPrevPercent < minPercent) {\n                            newNextPercent -= (minPercent - newPrevPercent);\n                            newPrevPercent = minPercent;\n                        }\n                        if (newNextPercent < minPercent) {\n                            newPrevPercent -= (minPercent - newNextPercent);\n                            newNextPercent = minPercent;\n                        }\n                        if (isHorizontal) {\n                            prev.css('width', newPrevPercent + '%');\n                            next.css('width', newNextPercent + '%');\n                        } else {\n                            prev.css('height', newPrevPercent + '%');\n                            next.css('height', newNextPercent + '%');\n                        }\n                    }\n                    function onUp() {\n                        document.removeEventListener('mousemove', onMove);\n                        document.removeEventListener('mouseup', onUp);\n                        saveCurrentSizes();\n                    }\n                    document.addEventListener('mousemove', onMove);\n                    document.addEventListener('mouseup', onUp);\n                });\n                root.append(resizer);\n                resizers.push(resizer); // Store reference\n            }\n        });\n        if (responsive && frameId) {\n            let lastScreenSizeBucket = currentScreenSizeBucket;\n            let lastFrameDefs = frameDefs;\n            Q.Resize(function handleResize() {\n                Q.Debounce('frame-resize-' + frameId, 250, function () {\n                    const newScreenSizeBucket = getScreenSizeBucket();\n                    if (newScreenSizeBucket !== lastScreenSizeBucket) {\n                        const all = getSavedFrames();\n                        let responsiveArr = (all[frameId] && Array.isArray(all[frameId].responsive)) ? all[frameId].responsive : [];\n                        const found = findSavedSizeByBucket(responsiveArr, newScreenSizeBucket);\n                        if (found && Array.isArray(found.sizes) && found.sizes.length === lastFrameDefs.length) {\n                            for (let i = 0; i < sections.length; ++i) {\n                                const sec = sections[i];\n                                const sizeVal = found.sizes[i];\n                                if (direction === 'horizontal') {\n                                    sec.css({\n                                        transition: `width ${options.responsiveAnimation}ms ${options.responsiveAnimationEasing}`\n                                    });\n                                    sec.css('width', sizeVal);\n                                } else {\n                                    sec.css({\n                                        transition: `height ${options.responsiveAnimation}ms ${options.responsiveAnimationEasing}`\n                                    });\n                                    sec.css('height', sizeVal);\n                                }\n                                setTimeout(() => {\n                                    if (direction === 'horizontal') {\n                                        sec.css('transition', '');\n                                    } else {\n                                        sec.css('transition', '');\n                                    }\n                                }, options.responsiveAnimation + 10);\n                            }\n                        } else {\n                            let totalFlex = 0;\n                            lastFrameDefs.forEach(def => {\n                                if (def.size && typeof def.size === 'string' && def.size.endsWith('%')) {\n                                    totalFlex += parseFloat(def.size);\n                                }\n                            });\n                            const defaultSize = lastFrameDefs.length > 0 ? (100 - totalFlex) / lastFrameDefs.filter(f => !f.size).length : 100;\n                            for (let i = 0; i < sections.length; ++i) {\n                                let sizeVal = lastFrameDefs[i].size ? lastFrameDefs[i].size : (defaultSize + '%');\n                                const sec = sections[i];\n                                if (direction === 'horizontal') {\n                                    sec.css({\n                                        transition: `width ${options.responsiveAnimation}ms ${options.responsiveAnimationEasing}`\n                                    });\n                                    sec.css('width', sizeVal);\n                                } else {\n                                    sec.css({\n                                        transition: `height ${options.responsiveAnimation}ms ${options.responsiveAnimationEasing}`\n                                    });\n                                    sec.css('height', sizeVal);\n                                }\n                                setTimeout(() => {\n                                    if (direction === 'horizontal') {\n                                        sec.css('transition', '');\n                                    } else {\n                                        sec.css('transition', '');\n                                    }\n                                }, options.responsiveAnimation + 10);\n                            }\n                        }\n                        lastScreenSizeBucket = newScreenSizeBucket;\n                    }\n                });\n            });\n        }\n        function saveCurrentSizes() {\n            if (savePosition && frameId) {\n                const sizes = sections.map(sec => {\n                    if (direction === 'horizontal') {\n                        const px = sec.nodes[0].getBoundingClientRect().width;\n                        const parentPx = root.nodes[0].clientWidth;\n                        return (px / parentPx * 100) + '%';\n                    } else {\n                        const px = sec.nodes[0].getBoundingClientRect().height;\n                        const parentPx = root.nodes[0].clientHeight;\n                        return (px / parentPx * 100) + '%';\n                    }\n                });\n                const all = getSavedFrames();\n                if (responsive) {\n                    let responsiveArr = (all[frameId] && Array.isArray(all[frameId].responsive)) ? all[frameId].responsive : [];\n                    const screenSizeBucket = getScreenSizeBucket();\n                    responsiveArr = responsiveArr.filter(entry => entry.screenSizeBucket !== screenSizeBucket);\n                    if (responsiveArr.length >= responsivesMaxCount) {\n                        responsiveArr.shift();\n                    }\n                    responsiveArr.push({ screenSizeBucket, sizes });\n                    all[frameId] = { responsive: responsiveArr };\n                } else {\n                    all[frameId] = { sizes };\n                }\n                saveFrames(all);\n            }\n        }\n        root._frameSections = sections;\n        root._frameMap = frameMap;\n        root.resize = function(name, size) {\n            if (root._frameMap && root._frameMap[name]) {\n                const section = root._frameMap[name].nodes[0];\n                const isHorizontal = root.hasClass(Container.frameClasses.frame_horizontal);\n                if (isHorizontal) {\n                    section.style.width = typeof size === 'number' ? size + 'px' : size;\n                } else {\n                    section.style.height = typeof size === 'number' ? size + 'px' : size;\n                }\n            }\n            return this;\n        };\n        return frameMap;\n    };\n    this.elements.push(root);\n    return root;\n};"
            },
            "Container": {
                "uuid": "3e5e793a-6b6b-423b-a20f-60f67de5ef68",
                "name": "Container",
                "method": "Constructor",
                "desc": "Core container and layout manager for VulpiniQ UI components.",
                "type": "Constructor",
                "example": [
                    "var container = new Container();\ndocument.body.appendChild(container.elements[0]);",
                    "var container = Q.Container();\ncontainer.elements[0].appendChild(document.createElement('div'));"
                ],
                "dependencies": [
                    "Q"
                ],
                "script": "function Container(options = {}) {\n    if (!(this instanceof Container)) {\n        return new Container(options);\n    }\n    this.elements = [];\n    this.options = options;\n    if (!Container.initialized) {\n        Container.classes = Q.style('', `\n            .container_icon {\n                width: 100%;\n                height: 100%;\n                color: #777; /* Default color */\n                pointer-events: none;\n                z-index: 1;\n            }\n        `, null, {\n            'container_icon': 'container_icon'\n        });\n        Q.Icons();\n        Container.initialized = true;\n        console.log('Container core initialized');\n    }\n}\nContainer.prototype.Icon = function(icon) {\n    const iconInstance = Q.Icons();\n    return iconInstance.get(icon, 'container_icon');\n};\nQ.Container = Container;"
            },
            "Container.Tab": {
                "uuid": "43078fe9-7e65-49e5-bd8d-666d41ab753a",
                "name": "Container.Tab",
                "method": "Prototype",
                "desc": "Tabbed navigation component for organizing content.",
                "type": "UI Component",
                "example": [
                    "var tab = Q.Container().Tab([{ title: 'Tab 1', value: 't1', content: 'Content 1' }, { title: 'Tab 2', value: 't2', content: 'Content 2' }]);\ndocument.body.appendChild(tab);",
                    "var tab = Q.Container().Tab([{ title: 'A', value: 'a', content: '<b>A</b>' }], false);\ntab.addTab({ title: 'B', value: 'b', content: 'B content' });\ntab.select('b');\ndocument.body.appendChild(tab);"
                ],
                "dependencies": [
                    "Q",
                    "Container"
                ],
                "script": "Container.prototype.Tab = function(data, horizontal = true) {\n    if (!Container.tabClassesInitialized) {\n        Container.tabClasses = Q.style('', `\n            .tab_navigation_buttons {\n                box-sizing: border-box;\n                width: 30px;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                user-select: none;\n            }\n            .tab_navigation_buttons_vertical {\n                width: auto;\n                height: 20px;\n            }\n            .tab_navigation_buttons:hover {\n                background-color: var(--form-default-background-hover);\n            }\n            .tab_container {\n                width: 100%;\n                min-height: 300px;\n            }\n            .tab_container_vertical {\n                display: flex;\n            }\n            .tab_navigation_header {\n                background-color: var(--form-default-background);\n                display: flex;\n            }\n            .tab_navigation_header_vertical {\n                flex-direction: column;\n                width: auto;\n            }\n            .tab_navigation_tabs {\n                user-select: none;\n                display: flex;\n                flex-direction: row;\n                width: 100%;\n                overflow: hidden;\n            }\n            .tab_navigation_tabs_vertical {\n                flex-direction: column;\n            }\n            .tab_active {\n                background-color: var(--form-default-accent-color);\n                color: var(--form-default-accent-text-color);\n                color: #fff;\n            }\n            .tab {\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                cursor: default;\n                padding: var(--form-default-padding);\n                font-size: var(--form-default-font-size);\n                white-space: nowrap;     /* prevent text wrap */\n            }\n            .tab_disabled {\n                background-color: var(--form-default-background-disabled);\n                color: var(--form-default-text-color-disabled);\n            }\n            .tab_content {\n                display: none;\n                width: 100%;\n                height: 100%;\n                overflow: auto;\n            }\n            .tab_content_active {\n                display: block;\n            }\n            .tab_content_container {\n                width: 100%;\n                height: 100%;\n                overflow: auto;\n                position: relative;\n            }\n        `, null, {\n            'tab_navigation_buttons': 'tab_navigation_buttons',\n            'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n            'tab_container': 'tab_container',\n            'tab_container_vertical': 'tab_container_vertical',\n            'tab_navigation_header': 'tab_navigation_header',\n            'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n            'tab_navigation_tabs': 'tab_navigation_tabs',\n            'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n            'tab_active': 'tab_active',\n            'tab': 'tab',\n            'tab_disabled': 'tab_disabled',\n            'tab_content_container': 'tab_content_container'\n        });\n        Container.tabClassesInitialized = true;\n    }\n    const wrapper = Q('<div>', { class: Container.tabClasses.tab_container });\n    const header = Q('<div>', { class: Container.tabClasses.tab_navigation_header });\n    const prevBtn = Q('<div>', { class: Container.tabClasses.tab_navigation_buttons });\n    const nextBtn = Q('<div>', { class: Container.tabClasses.tab_navigation_buttons });\n    const tabs = Q('<div>', { class: Container.tabClasses.tab_navigation_tabs });\n    const contentContainer = Q('<div>', { class: Container.tabClasses.tab_content_container });\n    if (!horizontal) {\n        wrapper.addClass(Container.tabClasses.tab_container_vertical);\n        header.addClass(Container.tabClasses.tab_navigation_header_vertical);\n        tabs.addClass(Container.tabClasses.tab_navigation_tabs_vertical);\n        prevBtn.addClass(Container.tabClasses.tab_navigation_buttons_vertical);\n        nextBtn.addClass(Container.tabClasses.tab_navigation_buttons_vertical);\n        prevBtn.html('\u25b2');\n        nextBtn.html('\u25bc');\n    } else {\n        prevBtn.html('\u25c0');\n        nextBtn.html('\u25b6');\n    }\n    header.append(prevBtn, tabs, nextBtn);\n    wrapper.append(header, contentContainer);\n    function updateNavButtons() {\n        const el = tabs.nodes[0];\n        const hasOverflow = horizontal\n            ? el.scrollWidth > el.clientWidth\n            : el.scrollHeight > el.clientHeight;\n        const disp = hasOverflow ? 'flex' : 'none';\n        prevBtn.css('display', disp);\n        nextBtn.css('display', disp);\n    }\n    const data_tabs = {};\n    const data_contents = {};\n    let activeTab = null;\n    prevBtn.off('click').on('click', () => {\n        const scrollAmount = horizontal ? tabs.width() : tabs.height();\n        const el = tabs.nodes[0];\n        if (el && el.scrollBy) {\n            el.scrollBy({\n                left: horizontal ? -scrollAmount : 0,\n                top:  horizontal ? 0 : -scrollAmount,\n                behavior: 'smooth'\n            });\n        } else {\n            horizontal ? tabs.scrollLeft(-scrollAmount, true)\n                       : tabs.scrollTop(-scrollAmount, true);\n        }\n    });\n    nextBtn.off('click').on('click', () => {\n        const scrollAmount = horizontal ? tabs.width() : tabs.height();\n        const el = tabs.nodes[0];\n        if (el && el.scrollBy) {\n            el.scrollBy({\n                left: horizontal ?  scrollAmount : 0,\n                top:  horizontal ?  0 :  scrollAmount,\n                behavior: 'smooth'\n            });\n        } else {\n            horizontal ? tabs.scrollLeft( scrollAmount, true)\n                       : tabs.scrollTop( scrollAmount, true);\n        }\n    });\n    data.forEach(item => {\n        const tab = Q('<div>', { class: Container.tabClasses.tab })\n            .attr('data-value', item.value)\n            .text(item.title);\n        if (item.disabled) {\n            tab.addClass(Container.tabClasses.tab_disabled);\n        }\n        let content;\n        if (typeof item.content === 'string') {\n            content = Q('<div>').html(item.content);\n        } else if (item.content instanceof Element) {\n            content = Q(item.content);\n        } else if (item.content instanceof Q) {\n            content = item.content;\n        } else {\n            content = Q('<div>');\n        }\n        data_tabs[item.value] = tab;\n        data_contents[item.value] = content;\n        tab.on('click', function() {\n            if (tab.hasClass(Container.tabClasses.tab_disabled)) return;\n            const activeTabs = tabs.find('.' + Container.tabClasses.tab_active);\n            if (activeTabs) activeTabs.removeClass(Container.tabClasses.tab_active);\n            tab.addClass(Container.tabClasses.tab_active);\n            showContent(item.value);\n        });\n        tabs.append(tab);\n    });\n    updateNavButtons();\n    function showContent(value) {\n        if (!data_contents[value]) return;\n        if (activeTab && data_contents[activeTab]) {\n            data_contents[activeTab].detach();\n        }\n        activeTab = value;\n        contentContainer.append(data_contents[value]);\n    }\n    wrapper.select = function(value) {\n        const tab = data_tabs[value];\n        if (tab) tab.click();\n        return this;\n    };\n    wrapper.disabled = function(value, state) {\n        const tab = data_tabs[value];\n        if (tab) {\n            state ? tab.addClass(Container.tabClasses.tab_disabled) : \n                  tab.removeClass(Container.tabClasses.tab_disabled);\n        }\n        return this;\n    };\n    wrapper.addTab = function(tabData) {\n        if (!tabData) return null;\n        const tab = Q('<div>', { class: Container.tabClasses.tab })\n            .attr('data-value', tabData.value)\n            .text(tabData.title);\n        if (tabData.disabled) {\n            tab.addClass(Container.tabClasses.tab_disabled);\n        }\n        let content;\n        if (typeof tabData.content === 'string') {\n            content = Q('<div>').html(tabData.content);\n        } else if (tabData.content instanceof Element) {\n            content = Q(tabData.content);\n        } else if (tabData.content instanceof Q) {\n            content = tabData.content;\n        } else {\n            content = Q('<div>');\n        }\n        data_tabs[tabData.value] = tab;\n        data_contents[tabData.value] = content;\n        tab.on('click', function() {\n            if (tab.hasClass(Container.tabClasses.tab_disabled)) return;\n            const activeTabs = tabs.find('.' + Container.tabClasses.tab_active);\n            if (activeTabs) activeTabs.removeClass(Container.tabClasses.tab_active);\n            tab.addClass(Container.tabClasses.tab_active);\n            showContent(tabData.value);\n        });\n        tabs.append(tab);\n        updateNavButtons();\n        return tab;\n    };\n    wrapper.removeTab = function(value) {\n        if (data_tabs[value]) {\n            data_tabs[value].remove();\n            if (activeTab === value) {\n                const availableTab = Object.keys(data_tabs).find(key => key !== value);\n                if (availableTab) {\n                    this.select(availableTab);\n                } else {\n                    contentContainer.empty();\n                    activeTab = null;\n                }\n            }\n            if (data_contents[value]) {\n                data_contents[value].remove();\n            }\n            delete data_tabs[value];\n            delete data_contents[value];\n        }\n        updateNavButtons();\n        return this;\n    };\n    wrapper.getContent = function(value) {\n        return data_contents[value] || null;\n    };\n    wrapper.updateContent = function(value, newContent) {\n        if (!data_contents[value]) return this;\n        if (typeof newContent === 'string') {\n            data_contents[value].html(newContent);\n        } else if (newContent instanceof Element || newContent instanceof Q) {\n            data_contents[value].empty().append(newContent);\n        }\n        return this;\n    };\n    this.elements.push(wrapper);\n    return wrapper;\n};"
            },
            "Container.Table": {
                "uuid": "ab1cb797-efea-4d04-963b-6a3f48a94fac",
                "name": "Container.Table",
                "method": "Prototype",
                "desc": "Dynamic data table with sorting, filtering, and pagination.",
                "type": "UI Component",
                "example": [
                    "var table = Q.Container().Table([{ name: 'Alice', age: 30 }, { name: 'Bob', age: 25 }]);\ndocument.body.appendChild(table);",
                    "var table = Q.Container().Table([{ id: 1, value: 'A' }, { id: 2, value: 'B' }], { pageSize: 1 });\ntable.select(0);\ndocument.body.appendChild(table);"
                ],
                "dependencies": [
                    "Q",
                    "Container"
                ],
                "script": "Container.prototype.Table = function (data = [], options = {}) {\n  if (!Array.isArray(data)) throw new Error('Container.Table: data must be an array of objects');\n  const defaultOptions = {\n    pageSize: 10,\n    sizes: [],\n    pageButtonLimit: 5,\n    debounce: 250,\n    search: true,\n    sort: true,\n    filter: true,\n    page: true,\n    info: true,\n    language: ['Search...', 'No results found.', 'Showing [PAGE] to [ALL_PAGES] of [TOTAL] entries','First', 'Prev', 'Next', 'Last'],\n  };\n  options = Object.assign({}, defaultOptions, options);\n  const {\n    debounce: debounceTime,\n    search: enableSearch,\n    sort: enableSort,\n    filter: enableFilter,\n    page: enablePage,\n    info: enableInfo\n  } = options;\n  if (!Container.tableClassesInitialized) {\n    Container.tableClasses = Q.style('', `\n      .tbl_wrapper { display: flex; flex-direction: column; }\n      .tbl_top { display: flex; justify-content: space-between; margin-bottom: 5px; }\n      .tbl_table { width:100%; border-collapse: collapse; \n      border-radius: var(--form-default-border-radius);\n      overflow: hidden;\n      }\n      .tbl_table th, .tbl_table td {\n      border: var(--form-default-dataset-border);\n      padding:6px;\n      text-align:left;\n      cursor: default;\n      }\n      .tbl_row.selected { background: var(--form-default-accent-color); color: var(--form-default-accent-text-color); }\n            .tbl_table th\n      {\n        background: var(--form-default-dataset-header-background);\n        color: var(--form-default-dataset-header-text-color);\n        font-weight: var(--form-default-dataset-header-font-weight);\n        font-size: var(--form-default-dataset-header-font-size);\n        padding-right: 25px;\n}\n        .tbl_table td\n      {\n        font-size: var(--form-default-dataset-header-data-font-size);\n        color: var(--form-default-dataset-data-text-color);\n    }\n      .tbl_bottom {\n      display: flex;\n      justify-content: space-between;\n      margin-top:5px; \n      font-size: var(--form-default-dataset-header-data-font-size);\n      color: var(--form-default-dataset-data-text-color);\n      }\n      .tbl_pagination {\n      display:flex;\n      gap:2px;\n      }\n      .tbl_page_btn {\n      padding: 5px 15px;\n      cursor: default;\n      user-select: none;\n      }\n      .tbl_page_btn.active { \n      background: var(--form-default-accent-color);\n        color: var(--form-default-text-color-active);\n    }\n      .tbl_table th { position: relative; }\n      .tbl_table th .sort-icons {\n        position: absolute; right: 8px; top: 50%;\n        transform: translateY(-50%);\n        display: flex; flex-direction: column;\n        font-size: 8px; line-height: 1.3;\n      }\n      .sort_active {\n      color: var(--form-default-accent-color);\n    }\n    `, null, {\n      'tbl_wrapper': 'tbl_wrapper',\n      'tbl_top': 'tbl_top',\n      'tbl_search': 'tbl_search',\n      'tbl_page_size': 'tbl_page_size',\n      'tbl_table': 'tbl_table',\n      'tbl_row': 'tbl_row',\n      'tbl_bottom': 'tbl_bottom',\n      'tbl_pagination': 'tbl_pagination',\n      'tbl_page_btn': 'tbl_page_btn',\n      'sort-icons': 'sort-icons',\n      'asc': 'asc', 'desc': 'desc',\n      'sort_active': 'sort_active',\n      'active': 'active',\n      'selected': 'selected',\n    }, true);\n    Container.tableClassesInitialized = true;\n  }\n  const wrapper = Q('<div>', { class: Container.tableClasses.tbl_wrapper });\n  const top = Q('<div>', { class: Container.tableClasses.tbl_top });\n  let allData = [...data],\n    currentPage = 1,\n    sortKey = null,\n    sortOrder = 'off',\n    selectedIdx = null,\n    onChange = null,\n    filteredIndices = [];\n  const columnSizes = options.sizes;\n  const form = new Q.Form();\n  const searchInput = form.TextBox('text', '', options.language[0]);\n  const search = Q('<div>', { class: Container.tableClasses.tbl_search })\n    .append(searchInput.nodes[0]);\n  if (enableSearch) top.append(search);\n  const searchDebounceId = Q.ID('tbl_search_');\n  const table = Q('<table>', { class: Container.tableClasses.tbl_table });\n  const bottom = Q('<div>', { class: Container.tableClasses.tbl_bottom });\n  const status = Q('<div>');\n  const pagination = Q('<div>', { class: Container.tableClasses.tbl_pagination });\n  bottom.append(status, pagination);\n  wrapper.append(top, table, bottom);\n  let pageSizeVal = options.pageSize;\n  const pageSizeDropdown = form.Dropdown({\n    values: [10, 25, 50, 100].map(n => ({ value: n, text: '' + n, default: n === pageSizeVal }))\n  });\n  const pageSize = Q('<div>', { class: Container.tableClasses.tbl_page_size })\n    .append(pageSizeDropdown.nodes[0]);\n  if (enablePage) top.append(pageSize);\n  pageSizeDropdown.change(v => {\n    pageSizeVal = +v;\n    currentPage = 1;\n    render();\n  });\n  pageSizeVal = +pageSizeDropdown.val().value;\n  function render() {\n    const rawVal = searchInput.val() || '';\n    const term = rawVal.trim();\n    if (enableFilter) {\n      filteredIndices = allData.map((row, i) => i);\n      if (term.includes(':')) {\n        const clauses = term.split(',').map(c => {\n          const [field, ...rest] = c.split(':');\n          return [field.trim(), rest.join(':').trim()];\n        });\n        filteredIndices = filteredIndices.filter(i => {\n          const row = allData[i];\n          return clauses.every(([field, val]) => {\n            const fv = row[field];\n            if (fv == null) return false;\n            const str = typeof fv === 'object' ? JSON.stringify(fv) : String(fv);\n            return str.toLowerCase().includes(val.toLowerCase());\n          });\n        });\n      } else {\n        const lower = term.toLowerCase();\n        filteredIndices = filteredIndices.filter(i =>\n          JSON.stringify(allData[i]).toLowerCase().includes(lower)\n        );\n      }\n    } else {\n      filteredIndices = allData.map((_, i) => i);\n    }\n    if (enableSort && sortKey && sortOrder !== 'off') {\n      filteredIndices.sort((a, b) => {\n        const aVal = allData[a][sortKey];\n        const bVal = allData[b][sortKey];\n        if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;\n        if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;\n        return 0;\n      });\n    }\n    const total = filteredIndices.length;\n    const totalPages = Math.ceil(total / pageSizeVal) || 1;\n    currentPage = Math.min(currentPage, totalPages);\n    const start = (currentPage - 1) * pageSizeVal,\n      end = start + pageSizeVal;\n    const pageIndices = enablePage\n      ? filteredIndices.slice(start, end)\n      : filteredIndices;\n    const keys = Object.keys(allData[0] || {});\n    const thead = `<thead><tr>${keys.map((k, i) => {\n      const icons = enableSort\n        ? `<span class=\"${Container.tableClasses['sort-icons']}\">\n               <span class=\"${Container.tableClasses.asc}\">\u25b2</span>\n               <span class=\"${Container.tableClasses.desc}\">\u25bc</span>\n             </span>`\n        : '';\n      return `<th data-key=\"${k}\"${columnSizes[i] ? ` style=\"width:${columnSizes[i]}\"` : ''}>${k}${icons}</th>`;\n    }).join('')\n      }</tr></thead>`;\n    const tbody = pageIndices.map(idx => {\n      const row = allData[idx];\n      return `<tr data-idx=\"${idx}\" class=\"${Container.tableClasses.tbl_row}${idx === selectedIdx ? ' '+ Container.tableClasses.selected : ''}\">${Object.values(row).map(v => {\n        if (Array.isArray(v)) return `<td>${v.join(', ')}</td>`;\n        if (typeof v === 'object') return `<td>${JSON.stringify(v)}</td>`;\n        return `<td>${v}</td>`;\n      }).join('')\n        }</tr>`;\n    }).join('');\n    table.html('');\n    table.append(thead + `<tbody>${tbody}</tbody>`);\n    if (enableInfo) {\n      if (total === 0) {\n        status.html(options.language[1]);\n      } else{\n      const pageInfo = options.language[2]\n        .replace('[PAGE]', currentPage)\n        .replace('[ALL_PAGES]', totalPages)\n        .replace('[TOTAL]', total);\n      status.html(pageInfo);\n      }\n    }\n    if (enablePage) {\n      pagination.html('');\n      [options.language[3], options.language[4]].forEach(t => {\n        const btn = `<span class=\"${Container.tableClasses.tbl_page_btn}\" data-action=\"${t.toLowerCase()}\">${t}</span>`;\n        pagination.append(btn);\n      });\n      const limit = options.pageButtonLimit;\n      const half = Math.floor(limit / 2);\n      let startPage = Math.max(1, currentPage - half);\n      let endPage = Math.min(totalPages, startPage + limit - 1);\n      if (endPage - startPage + 1 < limit) {\n        startPage = Math.max(1, endPage - limit + 1);\n      }\n      for (let p = startPage; p <= endPage; p++) {\n        const cls = p === currentPage ? ' '+ Container.tableClasses.active : '';\n        pagination.append(`<span class=\"${Container.tableClasses.tbl_page_btn + cls}\" data-page=\"${p}\">${p}</span>`);\n      }\n      [options.language[5], options.language[6]].forEach(t => {\n        const btn = `<span class=\"${Container.tableClasses.tbl_page_btn}\" data-action=\"${t.toLowerCase()}\">${t}</span>`;\n        pagination.append(btn);\n      });\n    }\n  }\n  if (enableSearch) {\n    searchInput.change(() => {\n      Q.Debounce(searchDebounceId, debounceTime, () => {\n        currentPage = 1;\n        render();\n      });\n    });\n  }\n  table.on('click', evt => {\n    const th = evt.target.closest('th');\n    const tr = evt.target.closest('tr[data-idx]');\n    if (enableSort && th) {\n      const key = th.dataset.key;\n      if (sortKey === key) {\n        if (sortOrder === 'off') sortOrder = 'asc';\n        else if (sortOrder === 'asc') sortOrder = 'desc';\n        else { sortOrder = 'off'; sortKey = null; }\n      } else {\n        sortKey = key;\n        sortOrder = 'asc';\n      }\n      render();\n      Q('.' + Container.tableClasses.sort_active).removeClass(Container.tableClasses.sort_active);\n      if (sortOrder != 'off') {\n        const arrowKey = sortOrder === 'asc' ? Container.tableClasses.asc : Container.tableClasses.desc;\n        const head = Q(`[data-key=\"${key}\"] .${arrowKey}`);\n        head.addClass(Container.tableClasses.sort_active);\n      }\n    } else if (tr) {\n      const idx = +tr.dataset.idx;\n      wrapper.select(idx);\n    }\n  });\n  if (enablePage) {\n    pagination.on('click', evt => {\n      const tgt = evt.target;\n      if (tgt.dataset.page) currentPage = +tgt.dataset.page;\n      else if (tgt.dataset.action === 'first') currentPage = 1;\n      else if (tgt.dataset.action === 'prev') currentPage = Math.max(1, currentPage - 1);\n      else if (tgt.dataset.action === 'next') currentPage = Math.min(Math.ceil(filteredIndices.length / pageSizeVal), currentPage + 1);\n      else if (tgt.dataset.action === 'last') currentPage = Math.ceil(filteredIndices.length / pageSizeVal);\n      render();\n    });\n  }\n  wrapper.load = function (newData, stayOn = false) {\n    allData = [...newData];\n    if (!stayOn) { sortKey = null; sortOrder = 'off'; currentPage = 1; }\n    wrapper; render(); return this;\n  };\n  wrapper.select = function (idx, key, val) {\n    if (key != null) {\n      const found = allData.findIndex(o => o[key] === val);\n      if (found >= 0) idx = found;\n    }\n    selectedIdx = idx;\n    table.find('tr').removeClass(Container.tableClasses.selected);\n    table.find(`tr[data-idx=\"${idx}\"]`).addClass(Container.tableClasses.selected);\n    if (onChange) onChange(idx, allData[idx]);\n    return this;\n  };\n  wrapper.change = function (cb) { onChange = cb; return this; };\n  wrapper.index = function (idx) { return wrapper.select(idx); };\n  wrapper.clear = function () { allData = []; render(); return this; };\n  this.elements.push(wrapper);\n  render();\n  return wrapper;\n};"
            },
            "Container.Window": {
                "uuid": "baee54e4-3b09-453d-8a63-1cd4ae5eb006",
                "name": "Container.Window",
                "method": "Prototype",
                "desc": "Movable, resizable window component with taskbar integration.",
                "type": "UI Component",
                "example": [
                    "var win = Q.Container().Window({ title: 'My Window', content: '<b>Hello</b>' });\nwin.Open();",
                    "var win = Q.Container().Window({ width: 500, height: 400 });\nwin.Content('Dynamic content');\nwin.Position(100, 100);\nwin.Open();"
                ],
                "dependencies": [
                    "Q",
                    "Container"
                ],
                "script": "Container.prototype.Window = function (options = {}) {\n    const defaultOptions = {\n        title: 'Window',\n        content: '',\n        resizable: true,\n        minimizable: true,\n        maximizable: true,\n        closable: true,\n        draggable: true,\n        x: 50,\n        y: 50,\n        width: 400,\n        height: 300,\n        minWidth: 200,\n        minHeight: 150,\n        zIndex: 1000,\n        minimizePosition: 'bottom-left',\n        minimizeContainer: null,\n        minimizeOffset: 10,\n        animate: 150,\n        shadow: true,\n        shadowColor: 'rgba(0, 0, 0, 0.5)',\n        shadowBlur: 10,\n        shadowOffsetX: 0,\n        shadowOffsetY: 5,\n        shadowSpread: 0,\n        blur: false,\n        blurInactive: false,\n        blurRadius: 10,\n        blurGradientOpacity: 0.3,\n    };\n    if (!Container.windowClassesInitialized) {\n        Container.windowClasses = Q.style(`\n            --window-bg-color:rgb(37, 37, 37);\n            --window-shadow-color: rgba(0, 0, 0, 0.1);\n            --window-titlebar-bg:rgb(17, 17, 17);\n            --window-titlebar-text: #ffffff;\n            --window-button-bg:rgb(17, 17, 17);\n            --window-button-hover-bg: #777777;\n            --window-button-text: #ffffff;\n            --window-close-color: #e74c3c;\n            --window-titlebar-height: 28px; /* Add fixed titlebar height */\n        `, `\n            .window_container {\n                position: fixed; /* Change from absolute to fixed */\n                min-width: 200px;\n                border-radius: 4px;\n                display: flex;\n                flex-direction: column;\n                overflow: hidden;\n                z-index: 1000;\n                transition-property: opacity, transform, width, height, top, left;\n                transition-timing-function: ease-out;\n            }\n            .window_titlebar {\n                color: var(--window-titlebar-text);\n                background-color: var(--window-titlebar-bg);\n                font-size: 12px;\n                cursor: default;\n                user-select: none;\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n                box-sizing: border-box;\n                height: var(--window-titlebar-height); /* Fixed height for titlebar */\n            }\n            .window_title {\n                white-space: nowrap;\n                overflow: hidden;\n                text-overflow: ellipsis;\n                flex: 1;\n                margin: 0 10px;\n                text-shadow: 0px 1px 5px rgba(0, 0, 0, 1.0);\n            }\n            .window_controls {\n                display: flex;\n                height:100%;\n            }\n            .window_button {\n                background-color: var(--window-button-bg);\n                cursor: default;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                position: relative;\n                height: 100%;\n                width: 30px;\n            }\n            .window_button:hover {\n                background-color: var(--window-button-hover-bg);\n            }\n            .window_close:hover {\n                background-color: var(--window-close-color);\n            }\n            .window_content {\n                flex: 1;\n                overflow: auto;\n                padding: 10px;\n                position: relative;\n                background-color: var(--window-bg-color);\n                box-sizing: border-box;\n            }\n            .window_content:empty {\n            padding: 0;\n            }\n            .window_resize_handle {\n                position: absolute;\n                z-index: 1;\n            }\n            .window_resize_n {\n                top: 0;\n                left: 0;\n                right: 0;\n                height: 5px;\n                cursor: n-resize;\n            }\n            .window_resize_e {\n                top: 0;\n                right: 0;\n                bottom: 0;\n                width: 5px;\n                cursor: e-resize;\n            }\n            .window_resize_s {\n                bottom: 0;\n                left: 0;\n                right: 0;\n                height: 5px;\n                cursor: s-resize;\n            }\n            .window_resize_w {\n                top: 0;\n                left: 0;\n                bottom: 0;\n                width: 5px;\n                cursor: w-resize;\n            }\n            .window_resize_nw {\n                top: 0;\n                left: 0;\n                width: 10px;\n                height: 10px;\n                cursor: nw-resize;\n            }\n            .window_resize_ne {\n                top: 0;\n                right: 0;\n                width: 10px;\n                height: 10px;\n                cursor: ne-resize;\n            }\n            .window_resize_se {\n                bottom: 0;\n                right: 0;\n                width: 10px;\n                height: 10px;\n                cursor: se-resize;\n            }\n            .window_resize_sw {\n                bottom: 0;\n                left: 0;\n                width: 10px;\n                height: 10px;\n                cursor: sw-resize;\n            }\n            .window_minimized {\n                height: var(--window-titlebar-height) !important; /* Fixed to titlebar height */\n                width: auto !important;\n                min-width: 200px;\n                position: fixed !important;\n                bottom: 10px;\n                left: 10px;\n                overflow: hidden;\n            }\n            .window_minimized .window_content {\n                display: none !important; /* Biztos\u00edtjuk, hogy val\u00f3ban ne jelenjen meg */\n                height: 0 !important;\n            }\n            .window_minimized .window_resize_handle {\n                display: none;\n            }\n            .window_maximized {\n                top: 0 !important;\n                left: 0 !important;\n                width: 100% !important;\n                height: 100% !important;\n                border-radius: 0;\n                position: fixed !important;\n            }\n            .window_maximized .window_resize_handle {\n                display: none;\n            }\n            .window_button_icon {\n                width: 10px;\n                height: 10px;\n                color: var(--window-button-text);\n                pointer-events: none;\n            }\n            .window_taskbar_btn {\n                min-width: 100px;\n                max-width: 220px;\n                overflow: hidden;\n                text-overflow: ellipsis;\n                white-space: nowrap;\n                background: #222;\n                color: #fff;\n                border: 1px solid #444;\n                border-radius: 4px;\n                padding: 0 12px;\n                height: 28px;\n                display: flex;\n                align-items: center;\n                cursor: pointer;\n                font-size: 13px;\n                box-sizing: border-box;\n            }\n        `, null, {\n            'window_container': 'window_container',\n            'window_titlebar': 'window_titlebar',\n            'window_title': 'window_title',\n            'window_controls': 'window_controls',\n            'window_button': 'window_button',\n            'window_minimize': 'window_minimize',\n            'window_maximize': 'window_maximize',\n            'window_restore': 'window_restore',\n            'window_close': 'window_close',\n            'window_content': 'window_content',\n            'window_resize_handle': 'window_resize_handle',\n            'window_resize_n': 'window_resize_n',\n            'window_resize_e': 'window_resize_e',\n            'window_resize_s': 'window_resize_s',\n            'window_resize_w': 'window_resize_w',\n            'window_resize_nw': 'window_resize_nw',\n            'window_resize_ne': 'window_resize_ne',\n            'window_resize_se': 'window_resize_se',\n            'window_resize_sw': 'window_resize_sw',\n            'window_minimized': 'window_minimized',\n            'window_maximized': 'window_maximized',\n            'window_button_icon': 'window_button_icon',\n            'window_taskbar_btn': 'window_taskbar_btn'\n        }, false);\n        Container.windowClassesInitialized = true;\n    }\n    if (!Container.taskbar) {\n        let taskbarStyle = {\n            position: 'fixed',\n            height: '32px',\n            zIndex: 1000,\n            display: 'flex',\n            alignItems: 'center',\n            maxWidth: '100vw',\n            minHeight: '0',\n            minWidth: '0'\n        };\n        switch (defaultOptions.minimizePosition || 'bottom-left') {\n            case 'bottom-right':\n                taskbarStyle.right = defaultOptions.minimizeOffset + 'px';\n                taskbarStyle.bottom = defaultOptions.minimizeOffset + 'px';\n                break;\n            case 'top-left':\n                taskbarStyle.left = defaultOptions.minimizeOffset + 'px';\n                taskbarStyle.top = defaultOptions.minimizeOffset + 'px';\n                break;\n            case 'top-right':\n                taskbarStyle.right = defaultOptions.minimizeOffset + 'px';\n                taskbarStyle.top = defaultOptions.minimizeOffset + 'px';\n                break;\n            case 'bottom-left':\n            default:\n                taskbarStyle.left = defaultOptions.minimizeOffset + 'px';\n                taskbarStyle.bottom = defaultOptions.minimizeOffset + 'px';\n                break;\n        }\n        Container.taskbar = Q('<div>', { class: Container.windowClasses.window_taskbar || 'window_taskbar' }).css(taskbarStyle);\n        Q('body').append(Container.taskbar);\n    }\n    const settings = Object.assign({}, defaultOptions, options);\n    const windowElement = Q('<div>', { class: Container.windowClasses.window_container });\n    if (settings.shadow) {\n        windowElement.css({\n            boxShadow: `${settings.shadowOffsetX}px ${settings.shadowOffsetY}px ${settings.shadowBlur}px ${settings.shadowSpread}px ${settings.shadowColor}`\n        });\n    } else {\n        windowElement.css({ boxShadow: 'none' });\n    }\n    const titlebar = Q('<div>', { class: Container.windowClasses.window_titlebar });\n    function setTitlebarBlurElement(titlebarElem, active, blurRadius, gradientOpacity, animateMs) {\n        if (!titlebarElem) return;\n        if (typeof animateMs === 'number' && animateMs > 0) {\n            titlebarElem.style.transition = `backdrop-filter ${animateMs}ms, -webkit-backdrop-filter ${animateMs}ms, background-image ${animateMs}ms`;\n        } else {\n            titlebarElem.style.transition = '';\n        }\n        if (active) {\n            titlebarElem.style.backdropFilter = `blur(${blurRadius}px)`;\n            titlebarElem.style.WebkitBackdropFilter = `blur(${blurRadius}px)`;\n            titlebarElem.style.backgroundColor = 'transparent';\n            const buttonBg = getComputedStyle(document.documentElement)\n                .getPropertyValue('--window-button-bg') || '#111';\n            const leftAlpha = Math.max(0, Math.min(1, gradientOpacity));\n            titlebarElem.style.backgroundImage =\n                `linear-gradient(to right, rgba(17,17,17,${leftAlpha}), ${buttonBg.trim()} 80%)`;\n        } else {\n            titlebarElem.style.backdropFilter = 'blur(0px)';\n            titlebarElem.style.WebkitBackdropFilter = 'blur(0px)';\n            titlebarElem.style.backgroundColor = '';\n            titlebarElem.style.backgroundImage = '';\n        }\n    }\n    function updateAllTitlebarBlur() {\n        const allWindows = document.querySelectorAll('.' + Container.windowClasses.window_container);\n        let maxZ = -Infinity, activeWindow = null;\n        allWindows.forEach(win => {\n            const z = parseInt(win.style.zIndex || window.getComputedStyle(win).zIndex, 10) || 0;\n            if (z > maxZ) {\n                maxZ = z;\n                activeWindow = win;\n            }\n        });\n        allWindows.forEach(win => {\n            const tb = win.querySelector('.' + Container.windowClasses.window_titlebar);\n            if (!tb) return;\n            if (settings.blurInactive) {\n                setTitlebarBlurElement(\n                    tb,\n                    win !== activeWindow,\n                    settings.blurRadius,\n                    settings.blurGradientOpacity,\n                    settings.animate\n                );\n            } else if (settings.blur) {\n                setTitlebarBlurElement(tb, true, settings.blurRadius, settings.blurGradientOpacity, 0);\n            } else {\n                setTitlebarBlurElement(tb, false, settings.blurRadius, settings.blurGradientOpacity, 0);\n            }\n        });\n    }\n    if (settings.blurInactive) {\n        setTimeout(updateAllTitlebarBlur, 0);\n        windowElement.on('mousedown', function () {\n            setTimeout(updateAllTitlebarBlur, 0);\n        });\n    } else if (settings.blur) {\n        setTitlebarBlurElement(titlebar.nodes[0], true, settings.blurRadius, settings.blurGradientOpacity, 0);\n    } else {\n        setTitlebarBlurElement(titlebar.nodes[0], false, settings.blurRadius, settings.blurGradientOpacity, 0);\n    }\n    const titleElement = Q('<div>', { class: Container.windowClasses.window_title }).text(settings.title);\n    const controls = Q('<div>', { class: Container.windowClasses.window_controls });\n    const contentContainer = Q('<div>', { class: Container.windowClasses.window_content });\n    if (settings.minimizable) {\n        const minimizeButton = Q('<div>', {\n            class: Container.windowClasses.window_button + ' ' + Container.windowClasses.window_minimize\n        });\n        minimizeButton.append(this.Icon('window-minimize').addClass(Container.windowClasses.window_button_icon));\n        controls.append(minimizeButton);\n    }\n    if (settings.maximizable) {\n        const maximizeButton = Q('<div>', {\n            class: Container.windowClasses.window_button + ' ' + Container.windowClasses.window_maximize\n        });\n        maximizeButton.append(this.Icon('window-full').addClass(Container.windowClasses.window_button_icon));\n        controls.append(maximizeButton);\n    }\n    if (settings.closable) {\n        const closeButton = Q('<div>', {\n            class: Container.windowClasses.window_button + ' ' + Container.windowClasses.window_close\n        });\n        closeButton.append(this.Icon('window-close').addClass(Container.windowClasses.window_button_icon));\n        controls.append(closeButton);\n    }\n    titlebar.append(titleElement, controls);\n    windowElement.append(titlebar, contentContainer);\n    if (settings.resizable) {\n        const resizeHandles = [\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_n, 'data-resize': 'n' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_e, 'data-resize': 'e' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_s, 'data-resize': 's' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_w, 'data-resize': 'w' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_nw, 'data-resize': 'nw' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_ne, 'data-resize': 'ne' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_se, 'data-resize': 'se' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_sw, 'data-resize': 'sw' })\n        ];\n        for (let i = 0; i < resizeHandles.length; i++) {\n            windowElement.append(resizeHandles[i]);\n        }\n    }\n    if (settings.content) {\n        if (typeof settings.content === 'string') {\n            contentContainer.html(settings.content);\n        } else if (settings.content instanceof Element || settings.content instanceof Q) {\n            contentContainer.append(settings.content);\n        }\n    }\n    let isMinimized = false;\n    let isMaximized = false;\n    let previousState = {\n        width: settings.width,\n        height: settings.height,\n        x: 0,\n        y: 0\n    };\n    let isOpen = false;\n    let isAnimating = false;\n    let taskbarButton = null;\n    function setTransitionDuration(duration) {\n        if (!settings.animate) return;\n        windowElement.css('transition-duration', duration + 'ms');\n    }\n    function resetTransition() {\n        setTimeout(() => {\n            windowElement.css('transition-duration', '');\n            isAnimating = false;\n        }, settings.animate);\n    }\n    function calculateInitialPosition() {\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const windowWidth = settings.width;\n        const windowHeight = settings.height;\n        let left = (viewportWidth * settings.x / 100) - (windowWidth / 2);\n        let top = (viewportHeight * settings.y / 100) - (windowHeight / 2);\n        left = Math.max(0, Math.min(left, viewportWidth - windowWidth));\n        top = Math.max(0, Math.min(top, viewportHeight - windowHeight));\n        return { left, top };\n    }\n    function setInitialPositionAndSize() {\n        const position = calculateInitialPosition();\n        windowElement.css({\n            position: 'fixed',\n            width: settings.width + 'px',\n            height: settings.height + 'px',\n            left: position.left + 'px',\n            top: position.top + 'px',\n            zIndex: settings.zIndex\n        });\n        previousState.x = position.left;\n        previousState.y = position.top;\n    }\n    function bringToFront() {\n        const windowIndex = Container.openWindows.indexOf(windowElement.nodes[0]);\n        if (windowIndex !== -1) {\n            Container.openWindows.splice(windowIndex, 1);\n        }\n        Container.openWindows.push(windowElement.nodes[0]);\n        updateZIndices();\n        if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n    }\n    function updateZIndices() {\n        const baseZIndex = settings.zIndex;\n        for (let i = 0; i < Container.openWindows.length; i++) {\n            const windowNode = Container.openWindows[i];\n            windowNode.style.zIndex = baseZIndex + i;\n        }\n        Container.highestZIndex = baseZIndex + Container.openWindows.length - 1;\n    }\n    function setupDraggable() {\n        if (!settings.draggable) return;\n        let isDragging = false;\n        let startX, startY, startLeft, startTop;\n        function onMouseMove(e) {\n            if (!isDragging) return;\n            const dx = e.clientX - startX;\n            const dy = e.clientY - startY;\n            const newLeft = startLeft + dx;\n            const newTop = startTop + dy;\n            if (isMinimized) {\n                const viewportWidth = window.innerWidth;\n                const viewportHeight = window.innerHeight;\n                const minWidth = windowElement.width();\n                const minHeight = windowElement.height();\n                const constrainedLeft = Math.max(0, Math.min(newLeft, viewportWidth - minWidth));\n                const constrainedTop = Math.max(0, Math.min(newTop, viewportHeight - minHeight));\n                windowElement.css({\n                    left: constrainedLeft + 'px',\n                    top: constrainedTop + 'px',\n                    right: 'auto',\n                    bottom: 'auto'\n                });\n                return;\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            const windowWidth = windowElement.width();\n            const windowHeight = windowElement.height();\n            const constrainedLeft = Math.max(0, Math.min(newLeft, viewportWidth - windowWidth));\n            const constrainedTop = Math.max(0, Math.min(newTop, viewportHeight - windowHeight));\n            windowElement.css({\n                left: constrainedLeft + 'px',\n                top: constrainedTop + 'px',\n                right: 'auto',\n                bottom: 'auto'\n            });\n            previousState.x = constrainedLeft;\n            previousState.y = constrainedTop;\n        }\n        function onMouseUp() {\n            isDragging = false;\n            Q(document).off('mousemove', onMouseMove);\n            Q(document).off('mouseup', onMouseUp);\n        }\n        Q(titlebar).on('mousedown', function (e) {\n            if (isMaximized || isMinimized) return;\n            isDragging = true;\n            startX = e.clientX;\n            startY = e.clientY;\n            startLeft = parseInt(windowElement.css('left'), 10);\n            startTop = parseInt(windowElement.css('top'), 10);\n            bringToFront();\n            Q(document).on('mousemove', onMouseMove);\n            Q(document).on('mouseup', onMouseUp);\n            e.preventDefault();\n        });\n        Q(titlebar).on('dblclick', function (e) {\n            if (settings.maximizable) {\n                toggleMaximize();\n            }\n        });\n    }\n    function setupResizable() {\n        if (!settings.resizable) return;\n        let isResizing = false;\n        let resizeDirection = '';\n        let startX, startY, startWidth, startHeight, startLeft, startTop;\n        const resizeHandles = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_resize_handle);\n        function onMouseMove(e) {\n            if (!isResizing) return;\n            const dx = e.clientX - startX;\n            const dy = e.clientY - startY;\n            let newWidth = startWidth;\n            let newHeight = startHeight;\n            let newLeft = startLeft;\n            let newTop = startTop;\n            if (resizeDirection.includes('e')) {\n                newWidth = startWidth + dx;\n            }\n            if (resizeDirection.includes('s')) {\n                newHeight = startHeight + dy;\n            }\n            if (resizeDirection.includes('w')) {\n                newWidth = startWidth - dx;\n                newLeft = startLeft + dx;\n            }\n            if (resizeDirection.includes('n')) {\n                newHeight = startHeight - dy;\n                newTop = startTop + dy;\n            }\n            if (newWidth < settings.minWidth) {\n                if (resizeDirection.includes('w')) {\n                    newLeft = startLeft + startWidth - settings.minWidth;\n                }\n                newWidth = settings.minWidth;\n            }\n            if (newHeight < settings.minHeight) {\n                if (resizeDirection.includes('n')) {\n                    newTop = startTop + startHeight - settings.minHeight;\n                }\n                newHeight = settings.minHeight;\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            if (newLeft + newWidth > viewportWidth) {\n                if (resizeDirection.includes('e')) {\n                    newWidth = viewportWidth - newLeft;\n                }\n            }\n            if (newTop + newHeight > viewportHeight) {\n                if (resizeDirection.includes('s')) {\n                    newHeight = viewportHeight - newTop;\n                }\n            }\n            if (newLeft < 0) {\n                if (resizeDirection.includes('w')) {\n                    const adjustment = -newLeft;\n                    newLeft = 0;\n                    newWidth -= adjustment;\n                }\n            }\n            if (newTop < 0) {\n                if (resizeDirection.includes('n')) {\n                    const adjustment = -newTop;\n                    newTop = 0;\n                    newHeight -= adjustment;\n                }\n            }\n            windowElement.css({\n                width: newWidth + 'px',\n                height: newHeight + 'px',\n                left: newLeft + 'px',\n                top: newTop + 'px'\n            });\n            previousState.width = newWidth;\n            previousState.height = newHeight;\n            previousState.x = newLeft;\n            previousState.y = newTop;\n        }\n        function onMouseUp() {\n            isResizing = false;\n            Q(document).off('mousemove', onMouseMove);\n            Q(document).off('mouseup', onMouseUp);\n        }\n        for (let i = 0; i < resizeHandles.length; i++) {\n            const handle = resizeHandles[i];\n            Q(handle).on('mousedown', function (e) {\n                if (isMaximized || isMinimized) return;\n                isResizing = true;\n                resizeDirection = this.getAttribute('data-resize');\n                startX = e.clientX;\n                startY = e.clientY;\n                startWidth = windowElement.width();\n                startHeight = windowElement.height();\n                startLeft = parseInt(windowElement.css('left'), 10);\n                startTop = parseInt(windowElement.css('top'), 10);\n                windowElement.css('zIndex', settings.zIndex + 10);\n                Q(document).on('mousemove', onMouseMove);\n                Q(document).on('mouseup', onMouseUp);\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n    }\n    function setupControls() {\n        const minimizeButtons = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_minimize);\n        if (minimizeButtons.length) {\n            for (let i = 0; i < minimizeButtons.length; i++) {\n                Q(minimizeButtons[i]).on('click', function () {\n                    bringToFront();\n                    toggleMinimize();\n                });\n            }\n        }\n        const maximizeButtons = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_maximize);\n        if (maximizeButtons.length) {\n            for (let i = 0; i < maximizeButtons.length; i++) {\n                Q(maximizeButtons[i]).on('click', function () {\n                    bringToFront();\n                    toggleMaximize();\n                });\n            }\n        }\n        const closeButtons = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_close);\n        if (closeButtons.length) {\n            for (let i = 0; i < closeButtons.length; i++) {\n                Q(closeButtons[i]).on('click', function () {\n                    closeWindow();\n                });\n            }\n        }\n        Q(contentContainer).on('mousedown', function () {\n            bringToFront();\n        });\n    }\n    if (!Container.highestZIndex) {\n        Container.highestZIndex = settings.zIndex;\n        Container.openWindows = [];\n    }\n    function toggleMinimize() {\n        if (isAnimating) return;\n        isAnimating = true;\n        if (!isMinimized) {\n            const rect = windowElement.nodes[0].getBoundingClientRect();\n            const start = {\n                width: rect.width,\n                height: rect.height,\n                left: rect.left,\n                top: rect.top,\n                opacity: 1\n            };\n            let taskbarRect = { left: 0, top: window.innerHeight, width: 160, height: 28 };\n            if (Container.taskbar && taskbarButton) {\n                const btnRect = taskbarButton.nodes[0].getBoundingClientRect();\n                taskbarRect = {\n                    left: btnRect.left,\n                    top: btnRect.top,\n                    width: btnRect.width,\n                    height: btnRect.height\n                };\n            } else if (Container.taskbar) {\n                const barRect = Container.taskbar.nodes[0].getBoundingClientRect();\n                taskbarRect.left = barRect.left;\n                taskbarRect.top = barRect.top;\n            }\n            windowElement.css({\n                willChange: 'width,height,left,top,opacity',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`\n            });\n            windowElement.css({\n                width: start.width + 'px',\n                height: start.height + 'px',\n                left: start.left + 'px',\n                top: start.top + 'px',\n                opacity: 1\n            });\n            setTimeout(() => {\n                windowElement.css({\n                    width: taskbarRect.width + 'px',\n                    height: taskbarRect.height + 'px',\n                    left: taskbarRect.left + 'px',\n                    top: taskbarRect.top + 'px',\n                    opacity: 0.2\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                if (!taskbarButton) {\n                    let shortTitle = settings.title;\n                    if (shortTitle.length > 18) {\n                        shortTitle = shortTitle.slice(0, 15) + '...';\n                    }\n                    taskbarButton = Q('<div>', { class: Container.windowClasses.window_taskbar_btn, text: shortTitle });\n                    taskbarButton.on('click', function () {\n                        toggleMinimize();\n                    });\n                    if (settings.minimizePosition === 'bottom-left' || settings.minimizePosition === 'top-left') {\n                        Q(Container.taskbar).prepend(taskbarButton);\n                    } else {\n                        Q(Container.taskbar).append(taskbarButton);\n                    }\n                }\n                windowElement.detach();\n                isMinimized = true;\n                isAnimating = false;\n            }, settings.animate + 10);\n        } else {\n            Q('body').append(windowElement);\n            let btnRect = { left: 0, top: window.innerHeight, width: 160, height: 28 };\n            if (taskbarButton) {\n                const rect = taskbarButton.nodes[0].getBoundingClientRect();\n                btnRect = {\n                    left: rect.left,\n                    top: rect.top,\n                    width: rect.width,\n                    height: rect.height\n                };\n            }\n            const end = {\n                width: previousState.width,\n                height: previousState.height,\n                left: previousState.x,\n                top: previousState.y,\n                opacity: 1\n            };\n            windowElement.css({\n                willChange: 'width,height,left,top,opacity',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`,\n                width: btnRect.width + 'px',\n                height: btnRect.height + 'px',\n                left: btnRect.left + 'px',\n                top: btnRect.top + 'px',\n                opacity: 0.2,\n                display: ''\n            });\n            setTimeout(() => {\n                windowElement.css({\n                    width: end.width + 'px',\n                    height: end.height + 'px',\n                    left: end.left + 'px',\n                    top: end.top + 'px',\n                    opacity: 1\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                if (taskbarButton) {\n                    taskbarButton.remove();\n                    taskbarButton = null;\n                }\n                isMinimized = false;\n                bringToFront();\n                isAnimating = false;\n            }, settings.animate + 10);\n        }\n    }\n    function toggleMaximize() {\n        if (isAnimating) return;\n        isAnimating = true;\n        if (!isMaximized) {\n            const rect = windowElement.nodes[0].getBoundingClientRect();\n            const start = {\n                width: rect.width,\n                height: rect.height,\n                left: rect.left,\n                top: rect.top\n            };\n            windowElement.css({\n                willChange: 'width,height,left,top',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`,\n                width: start.width + 'px',\n                height: start.height + 'px',\n                left: start.left + 'px',\n                top: start.top + 'px'\n            });\n            setTimeout(() => {\n                windowElement.addClass(Container.windowClasses.window_maximized);\n                windowElement.css({\n                    left: 0,\n                    top: 0,\n                    width: '100vw',\n                    height: '100vh',\n                    borderRadius: 0\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                isMaximized = true;\n                previousState.width = start.width;\n                previousState.height = start.height;\n                previousState.x = start.left;\n                previousState.y = start.top;\n                isAnimating = false;\n            }, settings.animate + 10);\n        } else {\n            const end = {\n                width: previousState.width,\n                height: previousState.height,\n                left: previousState.x,\n                top: previousState.y\n            };\n            windowElement.removeClass(Container.windowClasses.window_maximized);\n            windowElement.css({\n                willChange: 'width,height,left,top',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`,\n                width: '100vw',\n                height: '100vh',\n                left: 0,\n                top: 0,\n                borderRadius: '0'\n            });\n            setTimeout(() => {\n                windowElement.css({\n                    width: end.width + 'px',\n                    height: end.height + 'px',\n                    left: end.left + 'px',\n                    top: end.top + 'px',\n                    borderRadius: '4px'\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                isMaximized = false;\n                isAnimating = false;\n            }, settings.animate + 10);\n        }\n    }\n    function closeWindow() {\n        if (isAnimating) return;\n        if (taskbarButton) {\n            taskbarButton.remove();\n            taskbarButton = null;\n        }\n        const savedContent = windowElement.data('detached-content');\n        if (savedContent) {\n            windowElement.removeData('detached-content');\n        }\n        if (settings.animate) {\n            isAnimating = true;\n            setTransitionDuration(settings.animate);\n            windowElement.css({\n                opacity: '0',\n                transform: 'scale(0.90)'\n            });\n            setTimeout(() => {\n                if (windowElement.nodes[0]._resizeHandler) {\n                    window.removeEventListener('resize', windowElement.nodes[0]._resizeHandler);\n                    windowElement.nodes[0]._resizeHandler = null;\n                }\n                const windowIndex = Container.openWindows.indexOf(windowElement.nodes[0]);\n                if (windowIndex !== -1) {\n                    Container.openWindows.splice(windowIndex, 1);\n                    updateZIndices();\n                }\n                windowElement.remove();\n                isOpen = false;\n            }, settings.animate);\n        } else {\n            if (windowElement.nodes[0]._resizeHandler) {\n                window.removeEventListener('resize', windowElement.nodes[0]._resizeHandler);\n                windowElement.nodes[0]._resizeHandler = null;\n            }\n            const windowIndex = Container.openWindows.indexOf(windowElement.nodes[0]);\n            if (windowIndex !== -1) {\n                Container.openWindows.splice(windowIndex, 1);\n                updateZIndices();\n            }\n            windowElement.remove();\n            isOpen = false;\n        }\n        setTimeout(function () {\n            const selector = '.' + (Container.windowClasses.window_container || 'window_container');\n            if (!Q(selector).nodes.length) {\n                if (Container.taskbar) {\n                    Q(Container.taskbar).remove();\n                    Container.taskbar = null;\n                }\n            }\n        }, 0);\n        if (settings.blurInactive) {\n            setTimeout(updateAllTitlebarBlur, 0);\n        }\n    }\n    function handleWindowResize() {\n        if (isMaximized) {\n            return;\n        }\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const currentWidth = windowElement.width();\n        const currentHeight = windowElement.height();\n        let currentLeft = parseInt(windowElement.css('left'), 10);\n        let currentTop = parseInt(windowElement.css('top'), 10);\n        let needsUpdate = false;\n        if (currentWidth > viewportWidth) {\n            windowElement.css('width', viewportWidth + 'px');\n            previousState.width = viewportWidth;\n            needsUpdate = true;\n        }\n        if (currentHeight > viewportHeight) {\n            windowElement.css('height', viewportHeight + 'px');\n            previousState.height = viewportHeight;\n            needsUpdate = true;\n        }\n        if (currentLeft + currentWidth > viewportWidth) {\n            currentLeft = Math.max(0, viewportWidth - currentWidth);\n            needsUpdate = true;\n        }\n        if (currentTop + currentHeight > viewportHeight) {\n            currentTop = Math.max(0, viewportHeight - currentHeight);\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            windowElement.css({\n                left: currentLeft + 'px',\n                top: currentTop + 'px'\n            });\n            previousState.x = currentLeft;\n            previousState.y = currentTop;\n        }\n    }\n    function setupWindowResizeHandler() {\n        function resizeHandler() {\n            handleWindowResize();\n        }\n        windowElement.nodes[0]._resizeHandler = resizeHandler;\n        window.addEventListener('resize', resizeHandler);\n    }\n    const windowAPI = {\n        Open: function () {\n            if (!isOpen) {\n                Q('body').append(windowElement);\n                setInitialPositionAndSize();\n                if (settings.animate) {\n                    windowElement.css({\n                        opacity: '0',\n                        transform: 'scale(0.90)'\n                    });\n                    void windowElement.nodes[0].offsetWidth;\n                    isAnimating = true;\n                    setTransitionDuration(settings.animate);\n                    windowElement.css({\n                        opacity: '1',\n                        transform: 'scale(1)'\n                    });\n                    resetTransition();\n                }\n                setupDraggable();\n                setupResizable();\n                setupControls();\n                setupWindowResizeHandler();\n                isOpen = true;\n                bringToFront();\n                if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n            } else {\n                windowElement.show();\n                bringToFront();\n            }\n            return this;\n        },\n        Close: function () {\n            closeWindow();\n            if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n            return this;\n        },\n        Content: function (content) {\n            if (content === undefined) {\n                return contentContainer.html();\n            }\n            contentContainer.empty();\n            if (typeof content === 'string') {\n                contentContainer.html(content);\n            } else if (content instanceof Element || content instanceof Q) {\n                contentContainer.append(content);\n            }\n            return this;\n        },\n        Title: function (title) {\n            if (title === undefined) {\n                return titleElement.text();\n            }\n            titleElement.text(title);\n            return this;\n        },\n        Position: function (x, y) {\n            if (x === undefined || y === undefined) {\n                return {\n                    x: parseInt(windowElement.css('left'), 10),\n                    y: parseInt(windowElement.css('top'), 10)\n                };\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            const windowWidth = windowElement.width();\n            const windowHeight = windowElement.height();\n            let left = typeof x === 'string' && x.endsWith('%')\n                ? (viewportWidth * parseInt(x, 10) / 100) - (windowWidth / 2)\n                : x;\n            let top = typeof y === 'string' && y.endsWith('%')\n                ? (viewportHeight * parseInt(y, 10) / 100) - (windowHeight / 2)\n                : y;\n            left = Math.max(0, Math.min(left, viewportWidth - windowWidth));\n            top = Math.max(0, Math.min(top, viewportHeight - windowHeight));\n            windowElement.css({\n                left: left + 'px',\n                top: top + 'px'\n            });\n            previousState.x = left;\n            previousState.y = top;\n            return this;\n        },\n        Size: function (width, height) {\n            if (width === undefined || height === undefined) {\n                return {\n                    width: windowElement.width(),\n                    height: windowElement.height()\n                };\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            let currentLeft = parseInt(windowElement.css('left'), 10);\n            let currentTop = parseInt(windowElement.css('top'), 10);\n            width = Math.max(settings.minWidth, width);\n            height = Math.max(settings.minHeight, height);\n            if (currentLeft + width > viewportWidth) {\n                currentLeft = Math.max(0, viewportWidth - width);\n                windowElement.css('left', currentLeft + 'px');\n                previousState.x = currentLeft;\n            }\n            if (currentTop + height > viewportHeight) {\n                currentTop = Math.max(0, viewportHeight - height);\n                windowElement.css('top', currentTop + 'px');\n                previousState.y = currentTop;\n            }\n            windowElement.css({\n                width: width + 'px',\n                height: height + 'px'\n            });\n            previousState.width = width;\n            previousState.height = height;\n            return this;\n        },\n        Minimize: function () {\n            if (!isMinimized) {\n                toggleMinimize();\n            }\n            return this;\n        },\n        Maximize: function () {\n            if (!isMaximized) {\n                toggleMaximize();\n            }\n            return this;\n        },\n        Restore: function () {\n            if (isMinimized) {\n                toggleMinimize();\n            } else if (isMaximized) {\n                toggleMaximize();\n            }\n            return this;\n        },\n        IsMinimized: function () {\n            return isMinimized;\n        },\n        IsMaximized: function () {\n            return isMaximized;\n        },\n        IsOpen: function () {\n            return isOpen;\n        },\n        Element: function () {\n            return windowElement;\n        },\n        BringToFront: function () {\n            bringToFront();\n            return this;\n        },\n        MinimizePosition: function (position, container, offset) {\n            if (position === undefined) {\n                return {\n                    position: settings.minimizePosition,\n                    container: settings.minimizeContainer,\n                    offset: settings.minimizeOffset\n                };\n            }\n            if (position) {\n                settings.minimizePosition = position;\n            }\n            if (container !== undefined) {\n                settings.minimizeContainer = container;\n            }\n            if (offset !== undefined) {\n                settings.minimizeOffset = offset;\n            }\n            if (isMinimized) {\n                toggleMinimize();\n                toggleMinimize();\n            }\n            return this;\n        },\n        Animation: function (duration) {\n            if (duration === undefined) {\n                return settings.animate;\n            }\n            settings.animate = parseInt(duration) || 0;\n            return this;\n        }\n    };\n    this.elements.push(windowAPI);\n    return windowAPI;\n};"
            },
            "Form.Button": {
                "uuid": "40dc8d61-fec4-425c-8c84-0f1fc01893ba",
                "name": "Form.Button",
                "method": "Component",
                "desc": "Button component for Form plugin",
                "type": "Component",
                "example": [
                    "var btn = Q.Form.Button('Click me');",
                    "var btn = Q.Form.Button('Save').click(function(){ alert('Saved!'); });",
                    "var btn = Q.Form.Button('Disabled'); btn.disabled(true);",
                    "var btn = Q.Form.Button('Text'); btn.setText('New text');"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "text",
                    "click"
                ],
                "script": "Form.prototype.Button = function(text = '') {\n    if (!Form.buttonClassesInitialized) {\n        Form.buttonClasses = Q.style(null, `\n            .button {\n                user-select: none;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n                border-radius: var(--form-default-border-radius);\n                padding: var(--form-default-padding);\n            }\n            .button:hover {\n                background-color: var(--form-default-background-hover);\n                color: var(--form-default-text-color-hover);\n            }\n            .button:active {\n                background-color: var(--form-default-background-active);\n                color: var(--form-default-text-color-active);\n            }\n            .button_disabled {\n                opacity: 0.6;\n                cursor: not-allowed;\n            }\n        `, null, {\n            'button_disabled': 'button_disabled',\n            'button': 'button'\n        });\n        Form.buttonClassesInitialized = true;\n    }\n    const button = Q(`<div class=\"${Form.buttonClasses.button}\">${text}</div>`);\n    button.click = function(callback) {\n        button.on('click', callback);\n        return button;\n    };\n    button.disabled = function(state) {\n        if (state) {\n            button.addClass(Form.buttonClasses.button_disabled);\n        } else {\n            button.removeClass(Form.buttonClasses.button_disabled);\n        }\n        return button;\n    };\n    button.setText = function(newText) {\n        button.text(newText);\n        return button;\n    };\n    button.remove = function() {\n        button.remove();\n        return button;\n    };\n    this.elements.push(button);\n    this.FX_Ripple(button);\n    return button;\n};"
            },
            "Form.CheckBox": {
                "uuid": "b9261896-ef34-4096-b552-730ccd6df4be",
                "name": "Form.CheckBox",
                "method": "Component",
                "desc": "CheckBox component for Form plugin",
                "type": "Component",
                "example": [
                    "var cb = Q.Form.CheckBox();",
                    "var cb = Q.Form.CheckBox(true, 'I accept the terms');",
                    "var cb = Q.Form.CheckBox(false, 'Newsletter').change(function(checked){ console.log('State:', checked); });",
                    "var cb = Q.Form.CheckBox(); cb.checked(true);",
                    "var cb = Q.Form.CheckBox(); cb.disabled(true);",
                    "var cb = Q.Form.CheckBox(); cb.text('New label');"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "append",
                    "prop",
                    "trigger",
                    "text"
                ],
                "script": "Form.prototype.CheckBox = function(checked = false, text = '') {\n    if (!Form.checkBoxClassesInitialized) {\n        Form.checkBoxClasses = Q.style('', `\n            .form_checkbox {\n                display: flex;\n                width: fit-content;\n                align-items: center;\n            }\n            .form_checkbox .form_label:empty {\n                display: none;\n            }\n            .form_checkbox .form_label {\n                padding-left: 5px;\n                user-select: none;\n            }\n            .form_checkbox_element {\n                position: relative;\n                width: 20px;\n                height: 20px;\n                background-color: var(--form-default-background);\n                border-radius: var(--form-default-border-radius);\n                cursor: pointer;\n            }\n            .form_checkbox_element.checked:before {\n                content: \"\";\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background-color: var(--form-default-accent-color);\n                border-radius: var(--form-default-border-radius);\n            }\n            .form_label {\n                padding-left: 5px;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n            .form_checkbox_element.disabled {\n                opacity: 0.5;\n                pointer-events: none;\n            }\n        `, null, {\n            'form_checkbox': 'form_checkbox',\n            'form_checkbox_element': 'form_checkbox_element',\n            'form_label': 'form_label',\n            'disabled': 'disabled',\n            'checked': 'checked'\n        });\n        Form.checkBoxClassesInitialized = true;\n    }\n    let ID = '_' + Q.ID();\n    const container = Q('<div class=\"' + Form.checkBoxClasses.form_checkbox + '\">');\n    const checkbox_container = Q('<div class=\"' + Form.checkBoxClasses.form_checkbox_element + '\">');\n    const labeltext = Q('<div class=\"' + Form.checkBoxClasses.form_label + '\">' + text + '</div>');\n    if (checked) {\n        checkbox_container.addClass(Form.checkBoxClasses['checked']);\n    }\n    checkbox_container.on('click', function(){\n        if (!checkbox_container.hasClass(Form.checkBoxClasses['disabled'])) {\n            const newState = !checkbox_container.hasClass(Form.checkBoxClasses['checked']);\n            checkbox_container.toggleClass(Form.checkBoxClasses['checked'], newState);\n            if (container._changeCallback) {\n                container._changeCallback(newState);\n            }\n        }\n    });\n    container.append(checkbox_container, labeltext);\n    container.checked = function(state) {\n        checkbox_container.toggleClass(Form.checkBoxClasses['checked'], state);\n        if (state && container._changeCallback) {\n            container._changeCallback(state);\n        }\n    };\n    container.change = function(callback) {\n        container._changeCallback = callback;\n    };\n    container.disabled = function(state) {\n        if (state) {\n            checkbox_container.addClass(Form.checkBoxClasses['disabled']);\n            container.addClass(Form.classes.form_disabled);\n        } else {\n            checkbox_container.removeClass(Form.checkBoxClasses['disabled']);\n            container.removeClass(Form.classes.form_disabled);\n        }\n    };\n    container.text = function(newText) {\n        labeltext.text(newText);\n    };\n    this.elements.push(container);\n    return container;\n};"
            },
            "Form.ColorPicker": {
                "uuid": "c3d9ebf6-fdd4-400a-ac5a-ba6aadff5099",
                "name": "Form.ColorPicker",
                "method": "Component",
                "desc": "Photoshop-like Color Picker component for Form plugin. Renders a canvas with an outer detail (24\u2013color) ring, a full\u2013rainbow middle ring, and an inner triangle for selecting saturation and brightness by mixing the selected hue with white and black.",
                "type": "Component",
                "example": [
                    "var cp = Q.Form.ColorPicker();",
                    "var cp = Q.Form.ColorPicker({ color: '#00FF00' });",
                    "var cp = Q.Form.ColorPicker({ width: 400, height: 400 });",
                    "var cp = Q.Form.ColorPicker().change(function(color){ console.log('Color changed:', color); });",
                    "var cp = Q.Form.ColorPicker(); cp.val('#123456');"
                ],
                "dependencies": [
                    "Form",
                    "canvas",
                    "on",
                    "attr",
                    "val",
                    "Debounce"
                ],
                "script": "Form.prototype.ColorPicker = function (options = {}) {\n    if (!Form.ColorPickerClassesInitialized) {\n        Form.colorPickerClasses = Q.style('', `\n            .q_form_color_picker_wrapper {\n                display: flex;\n                width: 100%;\n                height: 100%;\n                align-items: stretch;\n                justify-content: space-between;\n            }\n            .left_wrapper {\n                flex: 1;\n                width: 100%;\n                height: 100%;\n                display: flex;\n            }\n            .right_wrapper {\n                display: flex;\n                flex-direction: column;\n                flex: 1;\n                padding: 5px;\n            }\n            .section_snatches, .section_second, .section_third, .section_fourth {\n                flex: 1;\n                display: flex;\n                flex-direction: column;\n            }\n            .sections {\n                display: grid;\n                grid-template-columns: repeat(2, 1fr);\n                gap: 2px;\n                flex: 1;\n            }\n            .color_picker_input {\n                background-color: var(--form-default-background);\n                border-radius: var(--form-default-border-radius);\n                padding: 2px;\n                margin: 2px;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                outline: var(--form-default-outline);\n                border: 0;\n                width: 45px;\n                text-align: center;\n            }\n            .input_rgb888, .input_rgb565, .input_hsl\n            {\n            width: 100%;\n            }\n            .color_picker_input:focus {\n                outline: none;\n                background-color: var(--form-default-background-focus);\n                outline: var(--form-default-outline-focus);\n            }\n            /* Hide spinner buttons for number inputs */\n            .color_picker_input[type=\"number\"]::-webkit-inner-spin-button,\n            .color_picker_input[type=\"number\"]::-webkit-outer-spin-button {\n                -webkit-appearance: none;\n                margin: 0;\n            }\n            /* Firefox */\n            .color_picker_input[type=\"number\"] {\n                -moz-appearance: textfield;\n            }\n            .input_wrapper {\n                display: flex;\n                align-items: center;\n            }\n            .half_snatch {\n                height: 50%;\n                width: 100%;\n        }\n        .picker_blocks {\n        background: rgba(0, 0, 0, 0.1);\n        border-radius: var(--form-default-border-radius);\n        padding: 5px;\n        margin: 2px;\n        }\n            .input_snatches {\n            width:40px;\n            height:40px;\n            border-radius: 10px;\n            background-color: var(--form-default-background);\n            color: var(--form-default-text-color);\n            font-family: var(--form-default-font-family);\n            font-size: var(--form-default-font-size);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .snatches_wrapper {\n    display: grid;\n    grid-template-columns: repeat(6, 1fr);\n    justify-items: center;\n        }\n        .input_snatch_wrapper {\n            display: flex;\n            flex-direction: column;\n            width: 40px;\n            height: 40px;\n            border-radius: 10px;\n            overflow: hidden;\n        }\n            .input_prefix {\n            user-select: none;\n                width: 20px;\n                font-size: var(--form-default-font-size);\n                color: var(--form-default-text-color);\n                display:block;\n            }\n            .input_suffix {\n            user-select: none;\n                margin-left: 5px;\n                font-size: var(--form-default-font-size);\n                color: var(--form-default-text-color);\n                display:block;\n            }\n            .block_header {\n            user-select: none;\n                font-weight: bold;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                text-align: center;\n                grid-column: 1 / -1;\n            }\n            .snatches_add {\n            cursor: pointer;\n            user-select: none;\n            }\n            `, null, {\n            'sections': 'sections',\n            'q_form_color_picker_wrapper': 'q_form_color_picker_wrapper',\n            'left_wrapper': 'left_wrapper',\n            'right_wrapper': 'right_wrapper',\n            'color_picker_input': 'color_picker_input',\n            'input_wrapper': 'input_wrapper',\n            'input_prefix': 'input_prefix',\n            'input_suffix': 'input_suffix',\n            'section_snatches': 'section_snatches',\n            'section_first': 'section_first',\n            'section_second': 'section_second',\n            'section_third': 'section_third',\n            'section_fourth': 'section_fourth',\n            'input_snatches': 'input_snatches',\n            'input_snatch_wrapper': 'input_snatch_wrapper',\n            'half_snatch': 'half_snatch',\n            'block_hsb': 'block_hsb',\n            'block_rgb': 'block_rgb',\n            'block_lab': 'block_lab',\n            'block_cmyk': 'block_cmyk',\n            'block_rgb888': 'block_rgb888',\n            'block_rgb565': 'block_rgb565',\n            'block_rgb': 'block_rgb',\n            'block_hex': 'block_hex',\n            'block_hsl': 'block_hsl',\n            'input_h': 'input_h',\n            'input_s': 'input_s',\n            'input_b': 'input_b',\n            'input_r': 'input_r',\n            'input_g': 'input_g',\n            'input_b2': 'input_b2',\n            'input_l': 'input_l',\n            'input_a': 'input_a',\n            'input_b3': 'input_b3',\n            'input_c': 'input_c',\n            'input_m': 'input_m',\n            'input_y': 'input_y',\n            'input_k': 'input_k',\n            'input_rgb888': 'input_rgb888',\n            'input_rgb565': 'input_rgb565',\n            'input_rgb': 'input_rgb',\n            'input_hex': 'input_hex',\n            'input_hsl': 'input_hsl',\n            'input_lab': 'input_lab',\n            'input_cmyk': 'input_cmyk',\n            'block_header': 'block_header',\n            'snatches_wrapper': 'snatches_wrapper',\n            'picker_blocks': 'picker_blocks',\n            'snatches_add': 'snatches_add'\n        }, false);\n        Form.ColorPickerClassesInitialized = true;\n    }\n    const width = options.width || 300;\n    const height = options.height || 300;\n    const showDetails = options.showDetails !== undefined ? options.showDetails : true;\n    const initialColor = options.color || '#FF0000';\n    const wrapper = Q('<div>');\n    const canvas = Q(`<canvas width=\"${width}\" height=\"${height}\"></canvas>`);\n    let current_color, previous_color, input_h, input_s, input_b, input_r, input_g, input_b2, input_l, input_a, input_b3, input_c, input_m, input_y, input_k, input_rgb888, input_rgb565, input_rgb, input_hex, input_hsl, input_lab, input_cmyk;\n    let snatches = [];\n    if (showDetails) {\n        canvas.css({\n            'width': '100%',\n            'height': '100%',\n        });\n        wrapper.addClass(Form.colorPickerClasses.q_form_color_picker_wrapper);\n        const left_wrapper = Q('<div>', { class: Form.colorPickerClasses.left_wrapper });\n        const right_wrapper = Q('<div>', { class: Form.colorPickerClasses.right_wrapper });\n        const snatches_wrapper = Q('<div>', { class: Form.colorPickerClasses.snatches_wrapper + ' ' + Form.colorPickerClasses.picker_blocks });\n        const section_snatches = Q('<div>', { class: Form.colorPickerClasses.section_snatches });\n        const section_first = Q('<div>', { class: Form.colorPickerClasses.section_first });\n        const section_second = Q('<div>', { class: Form.colorPickerClasses.section_second + ' ' + Form.colorPickerClasses.sections });\n        const section_third = Q('<div>', { class: Form.colorPickerClasses.section_third + ' ' + Form.colorPickerClasses.sections });\n        const section_fourth = Q('<div>', { class: Form.colorPickerClasses.section_fourth + ' ' + Form.colorPickerClasses.sections });\n        const block_hsb = Q('<div>', { class: Form.colorPickerClasses.block_hsb + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_rgb = Q('<div>', { class: Form.colorPickerClasses.block_rgb + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_lab = Q('<div>', { class: Form.colorPickerClasses.block_lab + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_cmyk = Q('<div>', { class: Form.colorPickerClasses.block_cmyk + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_rgb888 = Q('<div>', { class: Form.colorPickerClasses.block_rgb888 + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_rgb565 = Q('<div>', { class: Form.colorPickerClasses.block_rgb565 + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_hsl = Q('<div>', { class: Form.colorPickerClasses.block_hsl + ' ' + Form.colorPickerClasses.picker_blocks });\n        const header_hsb = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'HSB Color'\n        });\n        const header_rgb = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'RGB Color'\n        });\n        const header_lab = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'LAB Color'\n        });\n        const header_cmyk = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'CMYK Color'\n        });\n        const header_rgb888 = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'RGB888'\n        });\n        const header_rgb565 = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'RGB565'\n        });\n        const header_hsl = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'HSL Color'\n        });\n        const createInputWithLabel = (type, className, value, min, max, prefix, suffix) => {\n            const wrapper = Q('<div>', { class: Form.colorPickerClasses.input_wrapper });\n            const prefixElement = Q('<span>', { class: Form.colorPickerClasses.input_prefix, text: prefix });\n            const input = Q('<input>', {\n                type: type,\n                class: Form.colorPickerClasses.color_picker_input + ' ' + className,\n                value: value\n            });\n            if (type === 'number') {\n                input.attr('min', min);\n                input.attr('max', max);\n            } else if (type === 'text') {\n                input.attr('maxlength', max || 20);\n            }\n            wrapper.append(prefixElement, input);\n            if (suffix) {\n                const suffixElement = Q('<span>', { class: Form.colorPickerClasses.input_suffix, text: suffix });\n                wrapper.append(suffixElement);\n            }\n            return { wrapper, input };\n        };\n        const snatch_add = Q('<div>', { class: Form.colorPickerClasses.input_snatches + ' ' + Form.colorPickerClasses.snatches_add, text: '+' });\n        const snatch_1 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_2 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_3 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_4 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_prev_current_wrapper = Q('<div>', { class: Form.colorPickerClasses.input_snatch_wrapper });\n        current_color = Q('<div>', { class: Form.colorPickerClasses.half_snatch });\n        previous_color = Q('<div>', { class: Form.colorPickerClasses.half_snatch });\n        snatch_prev_current_wrapper.append(current_color,previous_color);\n        snatches = [snatch_1, snatch_2, snatch_3, snatch_4];\n        snatches.forEach(slot => slot.on('click', () => {\n            const col = slot.css('background-color');\n            if (col) wrapper.val(col);\n        }));\n        snatch_add.on('click', () => {\n            for (let i = snatches.length - 1; i > 0; i--) {\n                snatches[i].css('background-color', snatches[i - 1].css('background-color'));\n            }\n            snatches[0].css('background-color', current_color.css('background-color'));\n        });\n        const input_h_obj = createInputWithLabel('number', Form.colorPickerClasses.input_h, 0, 0, 360, 'H:', '\u00b0');\n        const input_s_obj = createInputWithLabel('number', Form.colorPickerClasses.input_s, 0, 0, 100, 'S:', '%');\n        const input_b_obj = createInputWithLabel('number', Form.colorPickerClasses.input_b, 0, 0, 100, 'B:', '%');\n        const input_r_obj = createInputWithLabel('number', Form.colorPickerClasses.input_r, 0, 0, 255, 'R:');\n        const input_g_obj = createInputWithLabel('number', Form.colorPickerClasses.input_g, 0, 0, 255, 'G:');\n        const input_b2_obj = createInputWithLabel('number', Form.colorPickerClasses.input_b2, 0, 0, 255, 'B:');\n        const input_l_obj = createInputWithLabel('number', Form.colorPickerClasses.input_l, 0, 0, 100, 'L:');\n        const input_a_obj = createInputWithLabel('number', Form.colorPickerClasses.input_a, 0, -128, 127, 'a:');\n        const input_b3_obj = createInputWithLabel('number', Form.colorPickerClasses.input_b3, 0, -128, 127, 'b:');\n        const input_c_obj = createInputWithLabel('number', Form.colorPickerClasses.input_c, 0, 0, 100, 'C:', '%');\n        const input_m_obj = createInputWithLabel('number', Form.colorPickerClasses.input_m, 0, 0, 100, 'M:', '%');\n        const input_y_obj = createInputWithLabel('number', Form.colorPickerClasses.input_y, 0, 0, 100, 'Y:', '%');\n        const input_k_obj = createInputWithLabel('number', Form.colorPickerClasses.input_k, 0, 0, 100, 'K:', '%');\n        const input_rgb888_obj = createInputWithLabel('text', Form.colorPickerClasses.input_rgb888, '0x000000', null, 8, '888:');\n        const input_rgb565_obj = createInputWithLabel('text', Form.colorPickerClasses.input_rgb565, '0x0000', null, 6, '565:');\n        const input_rgb_obj = createInputWithLabel('text', Form.colorPickerClasses.input_rgb, 'rgb(0,0,0)', null, 20, 'RGB:');\n        const input_hex_obj = createInputWithLabel('text', Form.colorPickerClasses.input_hex, '#000000', null, 7, 'Hex:');\n        const input_hsl_obj = createInputWithLabel('text', Form.colorPickerClasses.input_hsl, 'hsl(0,0%,0%)', null, 20, 'HSL:');\n        const input_lab_obj = createInputWithLabel('text', Form.colorPickerClasses.input_lab, 'lab(0,0,0)', null, 20, 'LAB:');\n        const input_cmyk_obj = createInputWithLabel('text', Form.colorPickerClasses.input_cmyk, 'cmyk(0%,0%,0%,0%)', null, 20, 'CMYK:');\n        input_h = input_h_obj.input;\n        input_s = input_s_obj.input;\n        input_b = input_b_obj.input;\n        input_r = input_r_obj.input;\n        input_g = input_g_obj.input;\n        input_b2 = input_b2_obj.input;\n        input_l = input_l_obj.input;\n        input_a = input_a_obj.input;\n        input_b3 = input_b3_obj.input;\n        input_c = input_c_obj.input;\n        input_m = input_m_obj.input;\n        input_y = input_y_obj.input;\n        input_k = input_k_obj.input;\n        input_rgb888 = input_rgb888_obj.input;\n        input_rgb565 = input_rgb565_obj.input;\n        input_rgb = input_rgb_obj.input;\n        input_hex = input_hex_obj.input;\n        input_hsl = input_hsl_obj.input;\n        input_lab = input_lab_obj.input;\n        input_cmyk = input_cmyk_obj.input;\n        function setupInputListeners() {\n            input_h.on('input', updateFromHSB);\n            input_s.on('input', updateFromHSB);\n            input_b.on('input', updateFromHSB);\n            input_r.on('input', updateFromRGB);\n            input_g.on('input', updateFromRGB);\n            input_b2.on('input', updateFromRGB);\n            input_l.on('input', updateFromLAB);\n            input_a.on('input', updateFromLAB);\n            input_b3.on('input', updateFromLAB);\n            input_c.on('input', updateFromCMYK);\n            input_m.on('input', updateFromCMYK);\n            input_y.on('input', updateFromCMYK);\n            input_k.on('input', updateFromCMYK);\n            input_hex.on('input', updateFromHex);\n            input_rgb.on('input', updateFromRGBString);\n            input_hsl.on('input', updateFromHSLString);\n        }\n        function updateFromHSB() {\n            const h = parseInt(input_h.val()) / 360;\n            const s = parseInt(input_s.val()) / 100;\n            const b = parseInt(input_b.val()) / 100;\n            const [r, g, b2] = Q.HSL2RGB(h, s, (2 * b - b * s) / 2); // Convert HSB to RGB\n            updatePickerFromRGB(Math.round(r), Math.round(g), Math.round(b2));\n        }\n        function updateFromRGB() {\n            const r = parseInt(input_r.val());\n            const g = parseInt(input_g.val());\n            const b = parseInt(input_b2.val());\n            updatePickerFromRGB(r, g, b);\n        }\n        function updateFromLAB() {\n            const l = parseFloat(input_l.val());\n            const a = parseFloat(input_a.val());\n            const b = parseFloat(input_b3.val());\n            const [r, g, b2] = labToRGB(l, a, b);\n            updatePickerFromRGB(r, g, b2);\n        }\n        function updateFromCMYK() {\n            const c = parseInt(input_c.val()) / 100;\n            const m = parseInt(input_m.val()) / 100;\n            const y = parseInt(input_y.val()) / 100;\n            const k = parseInt(input_k.val()) / 100;\n            const r = Math.round(255 * (1 - c) * (1 - k));\n            const g = Math.round(255 * (1 - m) * (1 - k));\n            const b = Math.round(255 * (1 - y) * (1 - k));\n            updatePickerFromRGB(r, g, b);\n        }\n        function updateFromHex() {\n            const hex = input_hex.val();\n            if (hex.match(/^#[0-9A-Fa-f]{6}$/)) {\n                const r = parseInt(hex.slice(1, 3), 16);\n                const g = parseInt(hex.slice(3, 5), 16);\n                const b = parseInt(hex.slice(5, 7), 16);\n                updatePickerFromRGB(r, g, b);\n            }\n        }\n        function updateFromRGBString() {\n            const rgbStr = input_rgb.val();\n            const match = rgbStr.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n            if (match) {\n                const r = parseInt(match[1]);\n                const g = parseInt(match[2]);\n                const b = parseInt(match[3]);\n                updatePickerFromRGB(r, g, b);\n            }\n        }\n        function updateFromHSLString() {\n            const hslStr = input_hsl.val();\n            const match = hslStr.match(/hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/);\n            if (match) {\n                const h = parseInt(match[1]) / 360;\n                const s = parseInt(match[2]) / 100;\n                const l = parseInt(match[3]) / 100;\n                const [r, g, b] = Q.HSL2RGB(h, s, l);\n                updatePickerFromRGB(Math.round(r), Math.round(g), Math.round(b));\n            }\n        }\n        function updatePickerFromRGB(r, g, b) {\n            const [h, s, l] = Q.RGB2HSL(r, g, b);\n            selectedHue = h; // Store just the hue\n            positionHueMarker(h);\n            positionTriangleMarker(s, l);\n            drawPicker();\n            return `rgb(${r},${g},${b})`;\n        }\n        function positionHueMarker(hue) {\n            const angle = hue * 2 * Math.PI;\n            const innerRingMiddleRadius = innerRadius - innerRingThickness / 2;\n            markers.outer = {\n                x: centerX + innerRingMiddleRadius * Math.cos(angle),\n                y: ringCenterY + innerRingMiddleRadius * Math.sin(angle)\n            };\n            if (outerSegments > 0) {\n                const segmentIndex = Math.floor(hue * outerSegments) % outerSegments;\n                selectedOuterSegment = (angle >= 0) ? segmentIndex : null;\n            }\n        }\n        function positionTriangleMarker(s, l) {\n            const totalHeight = bottomLeftVertex.y - topVertex.y;\n            const relativeY = 1 - s;\n            const y = topVertex.y + relativeY * totalHeight;\n            const triangleWidthAtY = (bottomRightVertex.x - bottomLeftVertex.x) * relativeY;\n            let relativeX;\n            if (relativeY === 0) {\n                relativeX = 0.5;\n            } else {\n                if (l <= 0.5) {\n                    relativeX = 1 - (l / 0.5);\n                } else {\n                    relativeX = (1 - l) / 0.5;\n                }\n            }\n            const leftX = centerX - triangleWidthAtY / 2;\n            const x = leftX + relativeX * triangleWidthAtY;\n            markers.triangle = { x, y };\n        }\n        function updateInputsFromColor(color) {\n            if (!color) return;\n            let r, g, b;\n            if (color.startsWith('rgb')) {\n                const match = color.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n                if (match) {\n                    r = parseInt(match[1]);\n                    g = parseInt(match[2]);\n                    b = parseInt(match[3]);\n                }\n            } else if (color.startsWith('#')) {\n                r = parseInt(color.slice(1, 3), 16);\n                g = parseInt(color.slice(3, 5), 16);\n                b = parseInt(color.slice(5, 7), 16);\n            }\n            if (r === undefined || g === undefined || b === undefined) return;\n            input_r.val(r);\n            input_g.val(g);\n            input_b2.val(b);\n            const hex = '#' +\n                r.toString(16).padStart(2, '0') +\n                g.toString(16).padStart(2, '0') +\n                b.toString(16).padStart(2, '0');\n            input_hex.val(hex);\n            input_rgb.val(`rgb(${r},${g},${b})`);\n            const [h, s, l] = Q.RGB2HSL(r, g, b);\n            input_h.val(Math.round(h * 360));\n            input_s.val(Math.round(s * 100));\n            input_b.val(Math.round((l * 2 / (2 - s)) * 100)); // Convert L to B (brightness)\n            input_hsl.val(`hsl(${Math.round(h * 360)},${Math.round(s * 100)}%,${Math.round(l * 100)}%)`);\n            const [l_val, a_val, b_val] = rgbToLab(r, g, b);\n            input_l.val(Math.round(l_val));\n            input_a.val(Math.round(a_val));\n            input_b3.val(Math.round(b_val));\n            input_lab.val(`lab(${Math.round(l_val)},${Math.round(a_val)},${Math.round(b_val)})`);\n            const [c, m, y, k] = rgbToCmyk(r, g, b);\n            input_c.val(Math.round(c * 100));\n            input_m.val(Math.round(m * 100));\n            input_y.val(Math.round(y * 100));\n            input_k.val(Math.round(k * 100));\n            input_cmyk.val(`cmyk(${Math.round(c * 100)}%,${Math.round(m * 100)}%,${Math.round(y * 100)}%,${Math.round(k * 100)}%)`);\n            input_rgb888.val('0x' +\n                r.toString(16).padStart(2, '0') +\n                g.toString(16).padStart(2, '0') +\n                b.toString(16).padStart(2, '0'));\n            const r5 = Math.round(r * 31 / 255) & 0x1F;\n            const g6 = Math.round(g * 63 / 255) & 0x3F;\n            const b5 = Math.round(b * 31 / 255) & 0x1F;\n            const rgb565 = (r5 << 11) | (g6 << 5) | b5;\n            input_rgb565.val('0x' + rgb565.toString(16).padStart(4, '0'));\n        }\n        function rgbToCmyk(r, g, b) {\n            return Q.RGB2CMYK(r, g, b);\n        }\n        function rgbToLab(r, g, b) {\n            return Q.RGB2LAB(r, g, b);\n        }\n        function labToRGB(l, a, b) {\n            return Q.LAB2RGB(l, a, b);\n        }\n        setupInputListeners();\n        block_hsb.append(header_hsb, input_h_obj.wrapper, input_s_obj.wrapper, input_b_obj.wrapper);\n        block_rgb.append(header_rgb, input_r_obj.wrapper, input_g_obj.wrapper, input_b2_obj.wrapper);\n        block_lab.append(header_lab, input_l_obj.wrapper, input_a_obj.wrapper, input_b3_obj.wrapper);\n        block_cmyk.append(header_cmyk, input_c_obj.wrapper, input_m_obj.wrapper, input_y_obj.wrapper, input_k_obj.wrapper);\n        block_rgb888.append(header_rgb888, input_rgb888_obj.wrapper);\n        block_rgb565.append(header_rgb565, input_rgb565_obj.wrapper);\n        block_hsl.append(header_hsl, input_hsl_obj.wrapper);\n        snatches_wrapper.append(snatch_prev_current_wrapper, snatch_1, snatch_2, snatch_3, snatch_4, snatch_add);\n        section_first.append(snatches_wrapper);\n        section_second.append(block_hsb, block_rgb, block_lab, block_cmyk);\n        section_third.append(block_rgb888, block_rgb565, block_hsl);\n        left_wrapper.append(canvas);\n        right_wrapper.append(section_snatches, section_first, section_second, section_third, section_fourth);\n        wrapper.append(left_wrapper, right_wrapper);\n    }\n    else {\n        canvas.css({\n            'width': width + 'px',\n            'height': height + 'px',\n        });\n        wrapper.append(canvas);\n    }\n    const ctx = canvas.nodes[0].getContext('2d');\n    const centerX = width / 2;\n    const ringCenterY = height / 2;\n    const minDimension = Math.min(width, height);\n    const globalRadius = options.globalRadius || (minDimension * 0.46);\n    const outerRingThickness = options.outerRingThickness || (globalRadius * 0.05);\n    const innerRingThickness = options.innerRingThickness || (globalRadius * 0.15);\n    const ringPadding = options.ringPadding || (globalRadius * 0.02);\n    const outerRadius = globalRadius;\n    const innerRadius = outerRadius - outerRingThickness - ringPadding;\n    const innerMostRadius = innerRadius - innerRingThickness - ringPadding;\n    const triangleVertexRadius = innerMostRadius - (globalRadius * 0.07);\n    const topVertex = {\n        x: centerX,\n        y: ringCenterY - triangleVertexRadius\n    };\n    const bottomLeftVertex = {\n        x: centerX - triangleVertexRadius * Math.sin(Math.PI / 3),\n        y: ringCenterY + triangleVertexRadius * Math.cos(Math.PI / 3)\n    };\n    const bottomRightVertex = {\n        x: centerX + triangleVertexRadius * Math.sin(Math.PI / 3),\n        y: ringCenterY + triangleVertexRadius * Math.cos(Math.PI / 3)\n    };\n    let selectedHue = 0; // Store hue as a number (0-1) instead of a color string\n    let selectedOuterSegment = null;\n    let activeArea = 'inner';\n    let markers = {\n        outer: { x: centerX, y: ringCenterY },\n        triangle: { x: centerX, y: ringCenterY }\n    };\n    const outerSegments = options.outerSegments || 18;\n    const outerColors = Array.from({ length: outerSegments }, (_, i) => {\n        const hue = i * (1 / outerSegments);\n        const [r, g, b] = Q.HSL2RGB(hue, 1, 0.5);\n        return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n    });\n    const defaultHue = 0;\n    const defaultSaturation = 1;\n    const defaultLightness = 0.5;\n    const middleRingAngle = (defaultHue / 360) * 2 * Math.PI;\n    const middleRingRadius = innerRadius - innerRingThickness / 2;\n    markers.outer = {\n        x: centerX + middleRingRadius * Math.cos(middleRingAngle),\n        y: ringCenterY + middleRingRadius * Math.sin(middleRingAngle)\n    };\n    markers.triangle = {\n        x: topVertex.x,\n        y: topVertex.y\n    };\n    function drawPicker() {\n        current_color.css({\n            'background-color': `rgb(${input_r.val()},${input_g.val()},${input_b2.val()})`\n        });\n        ctx.clearRect(0, 0, width, height);\n        drawOuterRing();\n        drawMiddleRing();\n        drawTriangle();\n        drawMarkers();\n    }\n    function drawOuterRing() {\n        const segAngle = (2 * Math.PI) / outerSegments;\n        for (let i = 0; i < outerSegments; i++) {\n            const startAngle = i * segAngle;\n            const endAngle = startAngle + segAngle;\n            ctx.beginPath();\n            ctx.arc(centerX, ringCenterY, outerRadius, startAngle, endAngle);\n            ctx.arc(centerX, ringCenterY, outerRadius - outerRingThickness, endAngle, startAngle, true);\n            ctx.closePath();\n            ctx.fillStyle = outerColors[i];\n            ctx.fill();\n        }\n    }\n    function drawMiddleRing() {\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(centerX, ringCenterY, innerRadius, 0, 2 * Math.PI);\n        ctx.closePath();\n        if (ctx.createConicGradient) {\n            const grad = ctx.createConicGradient(0, centerX, ringCenterY);\n            grad.addColorStop(0, \"hsl(0, 100%, 50%)\");\n            grad.addColorStop(0.17, \"hsl(60, 100%, 50%)\");\n            grad.addColorStop(0.33, \"hsl(120, 100%, 50%)\");\n            grad.addColorStop(0.5, \"hsl(180, 100%, 50%)\");\n            grad.addColorStop(0.67, \"hsl(240, 100%, 50%)\");\n            grad.addColorStop(0.83, \"hsl(300, 100%, 50%)\");\n            grad.addColorStop(1, \"hsl(360, 100%, 50%)\");\n            ctx.fillStyle = grad;\n        } else {\n            const grad = ctx.createLinearGradient(0, 0, width, 0);\n            grad.addColorStop(0, \"#FF0000\");\n            grad.addColorStop(0.17, \"#FFFF00\");\n            grad.addColorStop(0.33, \"#00FF00\");\n            grad.addColorStop(0.5, \"#00FFFF\");\n            grad.addColorStop(0.67, \"#0000FF\");\n            grad.addColorStop(0.83, \"#FF00FF\");\n            grad.addColorStop(1, \"#FF0000\");\n            ctx.fillStyle = grad;\n        }\n        ctx.fill();\n        ctx.globalCompositeOperation = 'destination-out';\n        ctx.beginPath();\n        ctx.arc(centerX, ringCenterY, innerRadius - innerRingThickness, 0, 2 * Math.PI);\n        ctx.closePath();\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawTriangle() {\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(centerX, ringCenterY, innerMostRadius * 0.8, 0, 2 * Math.PI);\n        ctx.closePath();\n        ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n        ctx.fill();\n        ctx.restore();\n        ctx.save();\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.6)\";\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 5;\n        ctx.shadowBlur = 10;\n        ctx.beginPath();\n        ctx.moveTo(topVertex.x, topVertex.y);\n        ctx.lineTo(bottomLeftVertex.x, bottomLeftVertex.y);\n        ctx.lineTo(bottomRightVertex.x, bottomRightVertex.y);\n        ctx.closePath();\n        ctx.fillStyle = \"#000\";\n        ctx.fill();\n        ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.beginPath();\n        ctx.moveTo(topVertex.x, topVertex.y);\n        ctx.lineTo(bottomLeftVertex.x, bottomLeftVertex.y);\n        ctx.lineTo(bottomRightVertex.x, bottomRightVertex.y);\n        ctx.closePath();\n        ctx.clip();\n        const gradHoriz = ctx.createLinearGradient(bottomLeftVertex.x, bottomLeftVertex.y, bottomRightVertex.x, bottomRightVertex.y);\n        gradHoriz.addColorStop(0, \"rgba(255,255,255,1)\");\n        gradHoriz.addColorStop(1, \"rgba(255,255,255,0)\");\n        ctx.fillStyle = gradHoriz;\n        ctx.globalCompositeOperation = 'normal';\n        ctx.fillRect(bottomLeftVertex.x, topVertex.y, bottomRightVertex.x - bottomLeftVertex.x, bottomLeftVertex.y - topVertex.y);\n        const [r, g, b] = Q.HSL2RGB(selectedHue, 1, 0.5);\n        const pureHueColor = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n        const gradVert = ctx.createLinearGradient(topVertex.x, topVertex.y, topVertex.x, bottomLeftVertex.y);\n        gradVert.addColorStop(0, pureHueColor); // Use pure hue color instead of selectedHue\n        gradVert.addColorStop(1, \"#000\");\n        ctx.fillStyle = gradVert;\n        ctx.globalCompositeOperation = 'color';\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawMarkers() {\n        ctx.save();\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 4;\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.5)\";\n        ctx.shadowBlur = 5;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 2;\n        if (activeArea === 'inner') {\n            const markerSize = innerRingThickness / 3; // Half the thickness for better visibility\n            ctx.beginPath();\n            ctx.arc(markers.outer.x, markers.outer.y, markerSize, 0, 2 * Math.PI);\n            ctx.stroke();\n        } else if (activeArea === 'outer' && selectedOuterSegment !== null) {\n            const segAngle = (2 * Math.PI) / outerSegments;\n            const startAngle = selectedOuterSegment * segAngle;\n            const endAngle = startAngle + segAngle;\n            ctx.strokeStyle = \"#FFFFFF\";\n            ctx.lineWidth = 5;\n            ctx.beginPath();\n            ctx.arc(centerX, ringCenterY, outerRadius, startAngle, endAngle);\n            ctx.arc(centerX, ringCenterY, outerRadius - outerRingThickness, endAngle, startAngle, true);\n            ctx.closePath();\n            ctx.stroke();\n        }\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(markers.triangle.x, markers.triangle.y, 5, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.restore();\n    }\n    function computeColor() {\n        let hue = 0;\n        if (typeof selectedHue === 'string') {\n            if (selectedHue.startsWith('rgb')) {\n                const rgbMatch = selectedHue.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n                if (rgbMatch) {\n                    const [r, g, b] = [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];\n                    const [h] = Q.RGB2HSL(r, g, b);\n                    hue = h;\n                }\n            } else if (selectedHue.startsWith('#')) {\n                hue = 0;\n            }\n        }\n        const triangleMarker = markers.triangle;\n        const totalHeight = bottomLeftVertex.y - topVertex.y;\n        const totalWidth = bottomRightVertex.x - bottomLeftVertex.x;\n        const relativeY = (triangleMarker.y - topVertex.y) / totalHeight;\n        const triangleWidthAtY = totalWidth * relativeY;\n        const leftBoundAtY = centerX - (triangleWidthAtY / 2);\n        const relativeX = triangleWidthAtY === 0 ? 0.5 :\n            (triangleMarker.x - leftBoundAtY) / triangleWidthAtY;\n        let saturation = 1 - (1 - relativeX) * relativeY;\n        let lightness = 1 - relativeY * relativeX;\n        saturation = Math.max(0, Math.min(1, saturation));\n        lightness = Math.max(0, Math.min(1, lightness));\n        return `hsl(${Math.round(hue * 360)}, ${Math.round(saturation * 100)}%, ${Math.round(lightness * 100)}%)`;\n    }\n    let dragging = null;\n    function handleEvent(e) {\n        const rect = canvas.nodes[0].getBoundingClientRect();\n        const scaleX = width / rect.width;\n        const scaleY = height / rect.height;\n        const canvasX = (e.clientX - rect.left) * scaleX;\n        const canvasY = (e.clientY - rect.top) * scaleY;\n        if (dragging === 'triangle') {\n            const constrained = constrainToTriangle(canvasX, canvasY, topVertex, bottomLeftVertex, bottomRightVertex);\n            markers.triangle = constrained;\n            const triangleColor = computeTriangleColor(constrained.x, constrained.y);\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(triangleColor);\n            }\n            drawPicker();\n            return; // Exit early as we've handled the drag event\n        }\n        if (dragging === 'inner_ring') {\n            const constrained = constrainToHueRing(canvasX, canvasY);\n            markers.outer = constrained;\n            const angle = Math.atan2(constrained.y - ringCenterY, constrained.x - centerX);\n            const hue = (angle >= 0 ? angle : angle + 2 * Math.PI) / (2 * Math.PI);\n            selectedHue = hue;\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(computeTriangleColor(markers.triangle.x, markers.triangle.y));\n            }\n            drawPicker();\n            return; // Exit early as we've handled the drag event\n        }\n        const distFromCenter = Math.sqrt(Math.pow(canvasX - centerX, 2) + Math.pow(canvasY - ringCenterY, 2));\n        if (distFromCenter <= outerRadius && distFromCenter >= outerRadius - outerRingThickness) {\n            const angle = Math.atan2(canvasY - ringCenterY, canvasX - centerX);\n            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;\n            const segmentIndex = Math.floor(normalizedAngle / ((2 * Math.PI) / outerSegments));\n            selectedOuterSegment = segmentIndex;\n            selectedHue = segmentIndex / outerSegments;\n            activeArea = 'outer';\n            if (e.type === 'mousedown') {\n                dragging = false;\n            }\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(computeTriangleColor(markers.triangle.x, markers.triangle.y));\n            }\n        }\n        else if (distFromCenter <= innerRadius && distFromCenter >= innerRadius - innerRingThickness) {\n            const angle = Math.atan2(canvasY - ringCenterY, canvasX - centerX);\n            const innerRingMiddleRadius = innerRadius - innerRingThickness / 2;\n            markers.outer = {\n                x: centerX + innerRingMiddleRadius * Math.cos(angle),\n                y: ringCenterY + innerRingMiddleRadius * Math.sin(angle)\n            };\n            const hue = (angle >= 0 ? angle : angle + 2 * Math.PI) / (2 * Math.PI);\n            selectedHue = hue;\n            selectedOuterSegment = null;\n            activeArea = 'inner';\n            if (e.type === 'mousedown') {\n                dragging = 'inner_ring';\n            }\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(computeTriangleColor(markers.triangle.x, markers.triangle.y));\n            }\n        }\n        else if (isPointInTriangle(canvasX, canvasY, topVertex, bottomLeftVertex, bottomRightVertex)) {\n            markers.triangle = { x: canvasX, y: canvasY };\n            const triangleColor = computeTriangleColor(canvasX, canvasY);\n            if (e.type === 'mousedown') {\n                dragging = 'triangle';\n            }\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(triangleColor);\n            }\n        }\n        drawPicker();\n    }\n    function constrainToHueRing(x, y) {\n        const angle = Math.atan2(y - ringCenterY, x - centerX);\n        const innerRingMiddleRadius = innerRadius - innerRingThickness / 2;\n        return {\n            x: centerX + innerRingMiddleRadius * Math.cos(angle),\n            y: ringCenterY + innerRingMiddleRadius * Math.sin(angle)\n        };\n    }\n    function computeTriangleColor(x, y) {\n        const totalHeight = bottomLeftVertex.y - topVertex.y;\n        const relativeY = Math.max(0, Math.min(1, (y - topVertex.y) / totalHeight));\n        const triangleWidthAtY = (bottomRightVertex.x - bottomLeftVertex.x) * relativeY;\n        const leftX = centerX - triangleWidthAtY / 2;\n        const rightX = centerX + triangleWidthAtY / 2;\n        const relativeX = Math.max(0, Math.min(1, (x - leftX) / (rightX - leftX)));\n        const saturation = 1 - relativeY;\n        let lightness = 0.5;\n        if (relativeY > 0) {\n            lightness = 0.5 * (1 - relativeY) + relativeY * (1 - relativeX);\n        }\n        const clampedSaturation = Math.max(0, Math.min(1, saturation));\n        const clampedLightness = Math.max(0, Math.min(1, lightness));\n        const [r, g, b] = Q.HSL2RGB(selectedHue, clampedSaturation, clampedLightness);\n        return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n    }\n    function isPointInTriangle(px, py, v1, v2, v3) {\n        const d1 = sign(px, py, v1.x, v1.y, v2.x, v2.y);\n        const d2 = sign(px, py, v2.x, v2.y, v3.x, v3.y);\n        const d3 = sign(px, py, v3.x, v3.y, v1.x, v1.y);\n        const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n        const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n        return !(has_neg && has_pos);\n    }\n    function sign(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return (p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y);\n    }\n    let onMouseMoveHandler, onMouseUpHandler;\n    function attachGlobalListeners() {\n        onMouseMoveHandler = handleMouseMove.bind(this);\n        onMouseUpHandler = handleMouseUp.bind(this);\n        Q(document).on('mousemove', onMouseMoveHandler);\n        Q(document).on('mouseup', onMouseUpHandler);\n    }\n    function removeGlobalListeners() {\n        Q(document).off('mousemove', onMouseMoveHandler);\n        Q(document).off('mouseup', onMouseUpHandler);\n    }\n    function handleMouseDown(e) {\n        handleEvent(e);\n        if (dragging) {\n            previous_color.css({\n                'background-color': `rgb(${input_r.val()},${input_g.val()},${input_b2.val()})`\n            });\n            attachGlobalListeners();\n        }\n    }\n    function handleMouseMove(e) {\n        if (dragging === 'inner_ring' || dragging === 'hue_stripe' || dragging === 'triangle') {\n            handleEvent(e);\n        }\n    }\n    function handleMouseUp(e) {\n        dragging = false;\n        removeGlobalListeners();\n    }\n    canvas.on('mousedown', handleMouseDown);\n    function constrainToTriangle(x, y, v1, v2, v3) {\n        if (isPointInTriangle(x, y, v1, v2, v3)) {\n            return { x, y };\n        }\n        const denominator = ((v2.y - v3.y) * (v1.x - v3.x) + (v3.x - v2.x) * (v1.y - v3.y));\n        let a = ((v2.y - v3.y) * (x - v3.x) + (v3.x - v2.x) * (y - v3.y)) / denominator;\n        let b = ((v3.y - v1.y) * (x - v3.x) + (v1.x - v3.x) * (y - v3.y)) / denominator;\n        let c = 1 - a - b;\n        if (a < 0) a = 0;\n        if (b < 0) b = 0;\n        if (c < 0) c = 0;\n        const sum = a + b + c;\n        if (sum > 0) {\n            a /= sum;\n            b /= sum;\n            c /= sum;\n        } else {\n            a = b = c = 1 / 3;\n        }\n        return {\n            x: a * v1.x + b * v2.x + c * v3.x,\n            y: a * v1.y + b * v2.y + c * v3.y\n        };\n    }\n    wrapper.change = function (callback) {\n        const originalCallback = callback;\n        wrapper.changeCallback = function (color) {\n            Q.Debounce('colorpicker_change', 10, function () {\n                if (showDetails && input_h) {\n                    updateInputsFromColor(color);\n                }\n                originalCallback(color);\n            });\n        };\n        return this;\n    };\n    wrapper.val = function (color) {\n        if (!color) {\n            return computeColor();\n        }\n        if (color.startsWith('#') || color.startsWith('rgb')) {\n            let r, g, b;\n            if (color.startsWith('rgb')) {\n                const rgbMatch = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n                if (rgbMatch) {\n                    r = parseInt(rgbMatch[1]);\n                    g = parseInt(rgbMatch[2]);\n                    b = parseInt(rgbMatch[3]);\n                }\n            } else if (color.startsWith('#')) {\n                const hex = color.slice(1);\n                if (hex.length === 3) {\n                    r = parseInt(hex[0] + hex[0], 16);\n                    g = parseInt(hex[1] + hex[1], 16);\n                    b = parseInt(hex[2] + hex[2], 16);\n                } else if (hex.length === 6) {\n                    r = parseInt(hex.slice(0, 2), 16);\n                    g = parseInt(hex.slice(2, 4), 16);\n                    b = parseInt(hex.slice(4, 6), 16);\n                }\n            }\n            const [h, s, l] = Q.RGB2HSL(r, g, b);\n            selectedHue = h;\n            positionHueMarker(h);\n            positionTriangleMarker(s, l);\n            drawPicker();\n            current_color.css('background-color', color);\n            previous_color.css('background-color', color);\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(color);\n            }\n        }\n        return this;\n    };\n    wrapper.destroy = function () {\n        canvas.off('mousedown', handleMouseDown);\n        removeGlobalListeners();\n        dragging = false;\n        return this;\n    };\n    wrapper.Snatch = function (index) {\n        return snatches[index]\n            ? snatches[index].css('background-color')\n            : null;\n    };\n    drawPicker();\n    console.log('ColorPicker drawn on canvas');\n    if (showDetails) {\n        updateInputsFromColor(initialColor);\n        current_color.css('background-color', initialColor);\n        previous_color.css('background-color', initialColor);\n    }\n    this.elements.push(wrapper);\n    return wrapper;\n};"
            },
            "Form.Dropdown": {
                "uuid": "861acb53-db56-4822-b99d-01b07f28b6c8",
                "name": "Form.Dropdown",
                "method": "Component",
                "desc": "A customizable dropdown list component for selecting options from a list.",
                "type": "Component",
                "example": [
                    "var dd = Q.Form.Dropdown({ values: [ { value: 1, text: 'One' }, { value: 2, text: 'Two' } ] });",
                    "var dd = Q.Form.Dropdown(); dd.val([ { value: 'a', text: 'A' }, { value: 'b', text: 'B' } ]);",
                    "var dd = Q.Form.Dropdown(); dd.add('c', 'C'); dd.select(0);",
                    "var dd = Q.Form.Dropdown({ disabled: true });"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "attr",
                    "css",
                    "append",
                    "find",
                    "text"
                ],
                "script": "Form.prototype.Dropdown = function(options = {}) {\n    if (!Form.dropdownStyles) {\n        Form.dropdownStyles = Q.style('', `\n            .form_dropdown {\n                position: relative;\n                width: 100%;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                cursor: pointer;\n                user-select: none;\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n            }\n            .selected_text {\n            padding-right: 10px;\n        }\n            .form_dropdown.disabled {\n                opacity: 0.6;\n                cursor: not-allowed;\n                pointer-events: none;\n            }\n            .form_dropdown_selected {\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n                padding: var(--form-default-padding);\n                line-height: normal;\n                cursor: pointer;\n                user-select: none;\n                width: 100%;\n                box-sizing: border-box;\n            }\n            .form_dropdown_items {\n                position: absolute;\n                top: 100%;\n                left: 0;\n                right: 0;\n                margin-top: 3px;\n                z-index: 1000;\n                max-height: 200px;\n                overflow-y: auto;\n                background-color: var(--form-default-background);\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                box-shadow: var(--form-default-shadow);\n                display: none;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n            }\n            .form_dropdown_item {\n                padding: var(--form-default-padding);\n                cursor: pointer;\n            }\n            .form_dropdown_item:hover {\n                background-color: var(--form-default-accent-color);\n                color: var(--form-default-accent-text-color);\n            }\n            .form_dropdown_item.selected {\n                background-color: var(--form-default-selected-background-color);\n                color: var(--form-default-selected-text-color);\n                font-weight: 500;\n            }\n            .form_dropdown_items {\n                display: none;\n            }\n            .form_dropdown_arrow {\n                transition: transform 0.2s ease-in-out;\n                transform: scale(2.0);\n            }\n            .form_dropdown.open .form_dropdown_arrow {\n                transform: rotate(180deg) scale(2.0);\n            }\n            .form_dropdown.open .form_dropdown_items {\n                display: block;\n                position: absolute;\n                width: 100%;\n                z-index: 1000;\n                overflow-y: auto;\n                top: 100%;\n            }\n            .form_dropdown.up .form_dropdown_items {\n                top: auto;\n                bottom: 100%;\n                margin-top: 0;\n                margin-bottom: 3px;\n            }\n        `, null, {\n            'selected_text': 'selected_text',\n            'form_dropdown': 'form_dropdown',\n            'open': 'open',\n            'disabled': 'disabled',\n            'selected': 'selected',\n            'form_dropdown_selected': 'form_dropdown_selected', \n            'form_dropdown_items': 'form_dropdown_items',\n            'form_dropdown_item': 'form_dropdown_item',\n            'form_dropdown_arrow': 'form_dropdown_arrow',\n            'up': 'up'\n        },true);\n    }\n    const container = Q('<div>').addClass(Form.dropdownStyles['form_dropdown']);\n    const header = Q('<div>').addClass(Form.dropdownStyles['form_dropdown_selected']);\n    const label = Q('<div>').text('Select an option').addClass(Form.dropdownStyles['selected_text']);\n    const arrow = Q('<div>').addClass(Form.dropdownStyles['form_dropdown_arrow']).html('&#9662;');\n    header.append(label, arrow);\n    const listContainer = Q('<div>')\n        .addClass(Form.dropdownStyles['form_dropdown_items'])\n        .addClass(Form.classes['scrollbar']);\n    container.append(header, listContainer);\n    if (!Form.dropdownCloseListenerInitialized) {\n        Q(document).on('click', () => {\n            Q('.' + Form.dropdownStyles['form_dropdown'])\n              .removeClass(Form.dropdownStyles['open']);\n        });\n        Form.dropdownCloseListenerInitialized = true;\n    }\n    if (options['max-height']) {\n        listContainer.css('maxHeight', options['max-height'] + 'px');\n    }\n    let selectedValue = null;\n    let selectedText = '';\n    let selectedIndex = -1;\n    let isDisabled = options.disabled || false;\n    let changeCallback = options.change || null;\n    if (isDisabled) { container.addClass(Form.dropdownStyles['disabled']); }\n    header.on('click', function(e) {\n        e.stopPropagation();\n        if (isDisabled) return;\n        const openCl = Form.dropdownStyles['open'];\n        const upCl = Form.dropdownStyles['up'];\n        if (container.hasClass(openCl)) {\n            container.removeClass(upCl);\n        } else {\n            const rect = container.nodes[0].getBoundingClientRect();\n            const itemsH = listContainer.nodes[0].scrollHeight;\n            if (rect.bottom + itemsH > window.innerHeight) {\n                container.addClass(upCl);\n            } else {\n                container.removeClass(upCl);\n            }\n        }\n        container.toggleClass(openCl);\n    });\n    function selectItem(index) {\n        const items = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n        if (!items) return;\n        items.removeClass(Form.dropdownStyles['selected']);\n        const item = items.eq(index);\n        if (item.hasClass(Form.dropdownStyles['disabled'])) return;\n        item.addClass(Form.dropdownStyles['selected']);\n        selectedValue = item.attr('data-value');\n        selectedText  = item.text();\n        selectedIndex = index;\n        label.text(selectedText);\n        container.removeClass(Form.dropdownStyles['open']);\n        if (typeof changeCallback === 'function') {\n            changeCallback(selectedValue, selectedText, selectedIndex);\n        }\n    }\n    if (options.values && Array.isArray(options.values)) {\n        setValues(options.values);\n    }\n    function setValues(values) {\n        listContainer.html('');\n        let defaultIndex = -1;\n        if (!Array.isArray(values) || values.length === 0) { return; }\n        values.forEach((item, index) => {\n            if (!item || typeof item !== 'object' || item.value === undefined || item.text === undefined) { return; }\n            const dropdownItem = Q('<div>')\n                .addClass(Form.dropdownStyles['form_dropdown_item'])\n                .attr('data-value', item.value)\n                .text(item.text);\n            if (item.disabled) { dropdownItem.addClass(Form.dropdownStyles['disabled']); }\n            if (item.default) { defaultIndex = index; }\n            dropdownItem.on('click', function(e) {\n                e.stopPropagation();\n                if (!dropdownItem.hasClass(Form.dropdownStyles['disabled'])) {\n                    selectItem(index);\n                }\n            });\n            listContainer.append(dropdownItem);\n        });\n        if (defaultIndex < 0) defaultIndex = 0;\n        selectItem(defaultIndex);\n    }\n    const dropdownAPI = {\n        val: function(values) {\n            if (values === undefined) {\n                return { value: selectedValue, text: selectedText, index: selectedIndex };\n            }\n            setValues(values);\n            return this;\n        },\n        change: function(callback) {\n            changeCallback = callback;\n            return this;\n        },\n        disabled: function(state) {\n            isDisabled = !!state;\n            if (isDisabled) { container.addClass(Form.dropdownStyles['disabled']); }\n            else { container.removeClass(Form.dropdownStyles['disabled']); }\n            return this;\n        },\n        select: function(index) {\n            selectItem(index);\n            return this;\n        },\n        index: function(index) {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            if (index >= 0 && index < items.length) {\n                const item = Q(items[index]);\n                return { value: item.attr('data-value'), text: item.text() };\n            }\n            return null;\n        },\n        disable: function(indexes) {\n            if (!Array.isArray(indexes)) return this;\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            indexes.forEach(idx => {\n                if (idx >= 0 && idx < items.length) {\n                    Q(items[idx]).addClass(Form.dropdownStyles['disabled']);\n                }\n            });\n            return this;\n        },\n        enable: function(indexes) {\n            if (!Array.isArray(indexes)) return this;\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            indexes.forEach(idx => {\n                if (idx >= 0 && idx < items.length) {\n                    Q(items[idx]).removeClass(Form.dropdownStyles['disabled']);\n                }\n            });\n            return this;\n        },\n        text: function(index, newText) {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            if (index >= 0 && index < items.length) {\n                const item = Q(items[index]);\n                item.text(newText);\n                if (index === selectedIndex) {\n                    selectedText = newText;\n                    label.text(newText);\n                }\n            }\n            return this;\n        },\n        add: function(value, text) {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            const newIndex = items.length;\n            const dropdownItem = Q('<div>')\n                .addClass(Form.dropdownStyles['form_dropdown_item'])\n                .attr('data-value', value)\n                .text(text);\n            dropdownItem.on('click', function(e) {\n                e.stopPropagation();\n                if (!dropdownItem.hasClass(Form.dropdownStyles['disabled'])) {\n                    selectItem(newIndex);\n                }\n            });\n            listContainer.append(dropdownItem);\n            return newIndex;\n        },\n        remove: function(index) {\n            if (index !== undefined) {\n                const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n                const items = found ? found.nodes : [];\n                if (index >= 0 && index < items.length) {\n                    Q(items[index]).remove();\n                    if (index === selectedIndex) {\n                        selectedValue = null;\n                        selectedText = '';\n                        selectedIndex = -1;\n                        label.text('Select an option');\n                    }\n                }\n                return this;\n            } else {\n                container.remove();\n                return null;\n            }\n        },\n        getCount: function() {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            return items.length;\n        }\n    };\n    for (const key in dropdownAPI) {\n        if (dropdownAPI.hasOwnProperty(key)) {\n            container[key] = dropdownAPI[key];\n        }\n    }\n    this.elements.push(container);\n    return container;\n};"
            },
            "Form": {
                "uuid": "7fc6cfe0-f8e3-4e59-ba96-c3b8d0794fd7",
                "name": "Form",
                "method": "Constructor",
                "desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
                "type": "Constructor",
                "example": "var containers = Q.Form()",
                "dependencies": [
                    "Style",
                    "addClass",
                    "removeClass",
                    "on",
                    "append",
                    "each",
                    "find",
                    "scrollTop",
                    "scrollLeft",
                    "hasClass",
                    "text",
                    "html",
                    "val",
                    "click",
                    "closest",
                    "empty",
                    "show",
                    "hide",
                    "css",
                    "attr",
                    "prop",
                    "remove",
                    "add"
                ],
                "script": "function Form(options = {}) {\n    if (!(this instanceof Form)) {\n        return new Form(options);\n    }\n    this.elements = [];\n    this.options = options;\n    if (!Form.initialized) {\n        Form.classes = Q.style(`\n            --form-default-accent-color: rgb(100, 60, 240);\n            --form-default-accent-text-color: #fff;\n            --form-default-font-size: 12px;\n            --form-default-font-family: Arial, sans-serif;\n            --form-default-dataset-header-font-weight: 600;\n            --form-default-dataset-header-font-size: 12px;\n            --form-default-dataset-header-data-font-size: 12px;\n            --form-default-dataset-header-background: rgba(127, 127, 127, 0.10);\n            --form-default-dataset-header-text-color: #fff;\n            --form-default-dataset-border: 1px solid rgba(127, 127, 127, 0.24);\n            --form-default-shadow: 0px 0px 5px rgba(0, 0, 0, 0.5);\n            --form-default-shadow-active: 0px 0px 5px rgba(100, 60, 240, 0.5);\n            --form-default-shadow-focus: 0px 0px 5px rgba(100, 60, 240, 0.5);\n            --form-default-shadow-hover: 0px 0px 5px rgba(100, 60, 240, 0.5);\n            --form-default-background-active: rgb(46, 46, 46);\n            --form-default-background-focus: rgb(46, 46, 46);\n            --form-default-background-hover: rgb(46, 46, 46);\n            --form-default-background-disabled: rgb(46, 46, 46);\n            --form-default-background: rgb(46, 46, 46);\n            --form-default-border-active: 1px solid var(--form-default-accent-color);\n            --form-default-border-focus: 1px solid var(--form-default-accent-color);\n            --form-default-border-hover: 1px solid var(--form-default-accent-color);\n            --form-default-border: 1px solid rgba(255, 255, 255, 0.03);\n            --form-default-outline-active: var(--form-default-border-active);\n            --form-default-outline-focus: var(--form-default-border-focus);\n            --form-default-outline-hover: var(--form-default-border-hover);\n            --form-default-outline: var(--form-default-border);\n            --form-default-border-radius: 5px;\n            --form-default-margin: 0px 0px 0px 0px;\n            --form-default-padding: 5px 10px 5px 10px;\n            --form-default-text-color-active: #fff;\n            --form-default-text-color-focus: #fff;\n            --form-default-text-color-hover: #fff;\n            --form-default-text-color-disabled: #999;\n            --form-default-text-color: #999;\n            --form-default-text-active: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-text-focus: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-text-hover: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-text: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-width: 100%;\n        `, `\n            .form_icon {\n                width: 100%;\n                height: 100%;\n                color: #fff;\n                pointer-events: none;\n            }\n            .form_close_button {\n                user-select: none;\n                -webkit-user-select: none;\n                position: absolute;\n                top: 0px;\n                right: 0px;\n                width: 18px;\n                height: 18px;\n                background-color: rgba(0, 0, 0, 0.5);\n                color: #fff;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                font-size: 12px;\n                cursor: pointer;\n            }\n            .form_close_button:hover {\n                background-color: rgba(220, 53, 69, 0.8);\n            }\n            /* New scrollbar customization class */\n            .scrollbar::-webkit-scrollbar {\n                width: 12px;\n            }\n            .scrollbar::-webkit-scrollbar-track {\n                background:transparent;\n            }\n            .scrollbar::-webkit-scrollbar-thumb {\n                background-color: #888;\n                border-radius: 10px;\n                border: 3px solid rgb(37, 37, 37);\n            }\n            .scrollbar {\n                scrollbar-color: #888 rgb(48, 48, 48);\n            }\n            /* ripple effect container */\n            .form_ripple_container {\n                position: relative;\n                overflow: hidden;\n            }\n            .form_ripple_container::after {\n                content: '';\n                position: absolute;\n                border-radius: 50%;\n                background: rgba(255,255,255,0.2);\n                width: var(--ripple-size);\n                height: var(--ripple-size);\n                top: var(--ripple-y);\n                left: var(--ripple-x);\n                transform: scale(0);\n            }\n            .form_ripple_container.rippleing::after {\n                animation: form_ripple 0.4s linear;\n            }\n            @keyframes form_ripple {\n                to {\n                    transform: scale(4);\n                    opacity: 0;\n                }\n            }\n        `, null, {\n            'form_icon': 'form_icon',\n            'form_close_button': 'form_close_button',\n            'scrollbar': 'scrollbar',\n            'form_ripple_container': 'form_ripple_container',\n            'rippleing': 'rippleing'\n        });\n        Form.initialized = true;\n        console.log('Form core initialized');\n    }\n}\nForm.prototype.Icon = function (icon) {\n    let iconElement = Q('<div>');\n    iconElement.addClass('svg_' + icon + ' form_icon');\n    return iconElement;\n};\n/* FX_Ripple: pseudo\u2011element approach */\nForm.prototype.FX_Ripple = function(el) {\n    const element = el instanceof Q ? el.nodes[0] : el;\n    if (!element) return this;\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    element.classList.add(Form.classes.form_ripple_container);\n    element.addEventListener('click', function(e) {\n        const rect = element.getBoundingClientRect();\n        const size = Math.max(rect.width, rect.height);\n        element.style.setProperty('--ripple-size', size + 'px');\n        element.style.setProperty(\n            '--ripple-x',\n            (e.clientX - rect.left - size/2) + 'px'\n        );\n        element.style.setProperty(\n            '--ripple-y',\n            (e.clientY - rect.top  - size/2) + 'px'\n        );\n        element.classList.add(Form.classes.rippleing);\n        setTimeout(() => {\n            element.classList.remove(Form.classes.rippleing);\n        }, 400);\n    });\n    return this;\n};\nQ.Form = Form;"
            },
            "Form.ProgressBar": {
                "uuid": "64129130-91e5-4a36-b3d7-0c6e893a8123",
                "name": "Form.ProgressBar",
                "method": "Component",
                "desc": "Progress bar component with min, max, val methods",
                "type": "Component",
                "example": [
                    "var pb = Q.Form.ProgressBar(0, 100, 30);",
                    "pb.max(200).min(10).val(50);"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "find",
                    "css"
                ],
                "script": "Form.prototype.ProgressBar = function(min = 0, max = 100, value = 0) {\n    if (!Form.progressClassesInitialized) {\n        Form.progressClasses = Q.style(null, `\n            .progress_bar {\n                width: 100%;\n                background-color: var(--form-default-background);\n                border-radius: var(--form-default-border-radius);\n                overflow: hidden;\n            }\n            .progress_fill {\n            position: relative;\n                height: var(--form-default-font-size);\n                background-color: var(--form-default-accent-color);\n                width: 0%;\n                border-radius: var(--form-default-border-radius);\n            }\n            .progress_fill:before {\n                content: \"\";\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: linear-gradient(90deg,rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.10) 95%, rgba(255, 255, 255, 0.20) 100%);\n                background-size: 200% 100%;\n                animation: gradient 2s linear infinite;\n            }\n            @keyframes gradient {\n                0% { background-position: 100% 100%; }\n                100% { background-position: -100% 100%; }\n            }\n        `, null, {\n            'progress_bar': 'progress_bar',\n            'progress_fill': 'progress_fill'\n        });\n        Form.progressClassesInitialized = true;\n    }\n    const bar = Q(\n        `<div class=\"${Form.progressClasses.progress_bar}\">\n            <div class=\"${Form.progressClasses.progress_fill}\"></div>\n        </div>`\n    );\n    let _min = min, _max = max, _val = value;\n    const fill = bar.find(`.${Form.progressClasses.progress_fill}`);\n    const update = () => {\n        const pct = _max > _min\n            ? ((_val - _min) / (_max - _min)) * 100\n            : 0;\n        fill.css('width', Math.min(Math.max(pct, 0), 100) + '%');\n    };\n    bar.min = function(v) { _min = v; update(); return bar; };\n    bar.max = function(v) { _max = v; update(); return bar; };\n    bar.val = function(v) {\n        if (v === undefined) return _val;\n        _val = v; update(); return bar;\n    };\n    update();\n    this.elements.push(bar);\n    return bar;\n};"
            },
            "Form.Radio": {
                "uuid": "a1eebdd5-d136-485d-9713-6a42c809d668",
                "name": "Form.Radio",
                "method": "Component",
                "desc": "Radio component using only HTML elements with val, selected, disable, select methods",
                "type": "Component",
                "example": [
                    "var rg = Q.Form.Radio([{value:'a',text:'A'}]); rg.change((i,v,t)=>{}); rg.disable(0); rg.select(0);"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "empty",
                    "append",
                    "on",
                    "addClass",
                    "removeClass"
                ],
                "script": "Form.prototype.Radio = function(options = []) {\n    if (!Form.radioClassesInitialized) {\n        Form.radioClasses = Q.style(null, `\n            .form_radio { display: flex; flex-direction: column; gap: 5px; }\n            .form_radio_item { display: flex; align-items: center; cursor: pointer;\n            color: var(--form-default-text-color);\n            font: var(--form-default-text); font-size: var(--form-default-font-size);\n            }\n            .form_radio_item::before {\n                content: \"\";\n                display: inline-block;\n                width: 16px;\n                height: 16px;\n                margin-right: 8px;\n                background-color: var(--form-default-background);\n                border-radius: 50%;\n            }\n            .form_radio_item:hover::before {\n                outline: 2px solid var(--form-default-accent-color);\n            }\n            .form_radio_item.selected::before {\n                background-color: var(--form-default-accent-color);\n            }\n            .form_radio_item.disabled {\n                opacity: 0.5;\n                pointer-events: none;\n            }\n        `, null, {\n            'form_radio': 'form_radio',\n            'form_radio_item': 'form_radio_item',\n            'selected': 'selected',\n            'disabled': 'disabled'\n        },false);\n        Form.radioClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.radioClasses.form_radio}\"></div>`);\n    let _options = options.map(o => ({\n        value: o.value,\n        text: o.text,\n        enabled: o.enabled !== false,\n        selected: !!o.selected,\n        disabled: !!o.disabled\n    }));\n    let _changeCallback;\n    function render() {\n        container.empty();\n        _options.forEach((opt, idx) => {\n            const item = Q(`<div class=\"${Form.radioClasses.form_radio_item}\">${opt.text}</div>`);\n            if (opt.selected) item.addClass(Form.radioClasses.selected);\n            if (opt.disabled) item.addClass(Form.radioClasses.disabled);\n            item.on('click', () => {\n                if (opt.disabled) return;\n                select(idx);\n            });\n            opt._el = item;\n            container.append(item);\n        });\n    }\n    function select(idx) {\n        _options.forEach((o, i) => {\n            const sel = i === idx;\n            o.selected = sel;\n            if (sel) {\n                o._el.addClass(Form.radioClasses.selected);\n            } else {\n                o._el.removeClass(Form.radioClasses.selected);\n            }\n        });\n        if (_changeCallback) {\n            const o = _options[idx];\n            _changeCallback(idx, o.value, o.text);\n        }\n    }\n    container.val = function(vals) {\n        if (vals === undefined) {\n            return _options.map(({_el,...o}) => o);\n        }\n        _options = vals.map(o => ({\n            value: o.value,\n            text: o.text,\n            enabled: o.enabled !== false,\n            selected: !!o.selected,\n            disabled: !!o.disabled\n        }));\n        render();\n        return container;\n    };\n    container.selected = function() {\n        const idx = _options.findIndex(o => o.selected);\n        const o = _options[idx] || {};\n        return { index: idx, value: o.value, text: o.text };\n    };\n    container.disable = function(idx) {\n        const o = _options[idx];\n        if (o) { o.disabled = true; o._el.addClass(Form.radioClasses.disabled); }\n        return container;\n    };\n    container.select = function(idx) {\n        select(idx);\n        return container;\n    };\n    container.change = function(cb) { _changeCallback = cb; return container; };\n    render();\n    this.elements.push(container);\n    return container;\n};"
            },
            "Form.Slider": {
                "uuid": "377281ef-30a6-41cb-9145-58c75aceeed6",
                "name": "Form.Slider",
                "method": "Component",
                "desc": "Slider input component implemented with divs (no native <input>)",
                "type": "Component",
                "example": [
                    "var slider = Q.Form.Slider(10, {min:0, max:100}); slider.change(v=>console.log(v));"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "on",
                    "css"
                ],
                "script": "Form.prototype.Slider = function(initial = 0, options = {}) {\n    if (!Form.sliderClassesInitialized) {\n        Form.sliderClasses = Q.style(null, `\n            .slider { position: relative; width: 100%; height: 8px; background: var(--form-default-background); border-radius: 4px; cursor: pointer; }\n            .slider_track { position: absolute; height:100%; background: var(--form-default-accent-color); border-radius: 4px; }\n            .slider_thumb { position: absolute; top:50%; transform:translate(-50%,-50%); width:5px; height:100%; background: var('--form-default-accent-color'); border-radius: 4px; cursor: pointer; }\n        `, null, {\n            'slider': 'slider',\n            'slider_track': 'slider_track',\n            'slider_thumb': 'slider_thumb'\n        });\n        Form.sliderClassesInitialized = true;\n    }\n    const min = options.min ?? 0, max = options.max ?? 100;\n    let val = Math.min(max, Math.max(min, initial)), callbacks = [];\n    const slider = Q(`<div class=\"${Form.sliderClasses.slider}\">\n        <div class=\"${Form.sliderClasses.slider_track}\"></div>\n        <div class=\"${Form.sliderClasses.slider_thumb}\"></div>\n    </div>`);\n    const containerEl = slider.nodes[0],\n          trackEl     = containerEl.children[0],\n          thumbEl     = containerEl.children[1];\n    function updateThumb() {\n        const pct = (val-min)/(max-min)*100;\n        trackEl.style.width = pct+'%';\n        thumbEl.style.left = pct+'%';\n    }\n    updateThumb();\n    slider.on('mousedown', e => {\n        const rect = containerEl.getBoundingClientRect();\n        const setFromX = x => {\n            let rel = (x - rect.left)/rect.width;\n            rel = Math.max(0,Math.min(1,rel));\n            val = min + rel*(max-min);\n            updateThumb();\n            callbacks.forEach(cb=>cb(val));\n        };\n        setFromX(e.clientX);\n        const move = me=> setFromX(me.clientX),\n              up   = ()=>{ document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };\n        document.addEventListener('mousemove', move);\n        document.addEventListener('mouseup', up);\n    });\n    slider.min = v => v===undefined ? min : (null, slider);\n    slider.max = v => v===undefined ? max : (null, slider);\n    slider.val = v => {\n        if (v===undefined) return val;\n        val = Math.min(max, Math.max(min, v));\n        updateThumb();\n        callbacks.forEach(cb=>cb(val));\n        return slider;\n    };\n    slider.change = cb => { callbacks.push(cb); return slider; };\n    this.elements.push(slider);\n    return slider;\n};"
            },
            "Form.Switch": {
                "uuid": "afc15c0e-3a74-4e35-955b-7de4884071b2",
                "name": "Form.Switch",
                "method": "Component",
                "desc": "Switch component for Form plugin",
                "type": "Component",
                "example": [
                    "var sw = Q.Form.Switch(3, 0); sw.change(function(pos) { console.log('Switch position:', pos); }); sw.disabled(true);"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "attr",
                    "css",
                    "append"
                ],
                "script": "Form.prototype.Switch = function (positions = 2, initial = 0) {\n    if (!Form.switchClassesInitialized) {\n        Form.switchClasses = Q.style(null, `\n            .switch {\n                display: inline-block;\n                position: relative;\n                width: 48px;\n                height: 24px;\n                background: var(--form-default-background, #333);\n                border-radius: 12px;\n                box-shadow: var(--form-default-shadow, 0 0 4px #0004);\n                transition: background 0.2s;\n                cursor: pointer;\n                user-select: none;\n            }\n            .switch_disabled {\n                opacity: 0.5;\n                cursor: not-allowed;\n            }\n            .switch_track {\n                position: absolute;\n                top: 50%;\n                left: 8px;\n                right: 8px;\n                height: 4px;\n                background: #666;\n                border-radius: 2px;\n                transform: translateY(-50%);\n            }\n            .switch_knob {\n                position: absolute;\n                top: 2px;\n                width: 20px;\n                height: 20px;\n                background: var(--form-default-accent-color, #643cf0);\n                border-radius: 50%;\n                box-shadow: 0 1px 4px #0004;\n                transition: left 0.2s;\n                left: 2px;\n                z-index: 2;\n            }\n            .switch_active .switch_knob {\n                background: var(--form-default-accent-color, #643cf0);\n            }\n        `, null, {\n            'switch': 'switch',\n            'switch_disabled': 'switch_disabled',\n            'switch_track': 'switch_track',\n            'switch_knob': 'switch_knob',\n            'switch_active': 'switch_active'\n        });\n        Form.switchClassesInitialized = true;\n    }\n    function clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    }\n    const sw = Q(`<div class=\"${Form.switchClasses.switch}\"></div>`);\n    const knob = Q(`<div class=\"${Form.switchClasses.switch_knob}\"></div>`);\n    sw.append(knob);\n    let _positions = clamp(parseInt(positions) || 2, 2, 10);\n    let _val = clamp(parseInt(initial) || 0, 0, _positions - 1);\n    let _disabled = false;\n    let _changeHandler = null;\n    function updateKnob() {\n        const percent = _positions === 1 ? 0 : _val / (_positions - 1);\n        const minLeft = 2, maxLeft = 24;\n        const left = minLeft + percent * (maxLeft - minLeft);\n        knob.css('left', `${left}px`);\n        if (_val > 0) sw.addClass(Form.switchClasses.switch_active);\n        else sw.removeClass(Form.switchClasses.switch_active);\n    }\n    function setVal(val, fire = true) {\n        const newVal = clamp(parseInt(val) || 0, 0, _positions - 1);\n        if (_val !== newVal) {\n            _val = newVal;\n            updateKnob();\n            if (fire && typeof _changeHandler === 'function') {\n                _changeHandler(_val);\n            }\n        } else {\n            updateKnob();\n        }\n    }\n    sw.on('click', function (e) {\n        if (_disabled) return;\n        let next = _val + 1;\n        if (next >= _positions) next = 0;\n        setVal(next, true);\n    });\n    sw.attr('tabindex', 0);\n    sw.change = function (cb) {\n        _changeHandler = cb;\n        return sw;\n    };\n    sw.positions = function (n) {\n        if (n === undefined) return _positions;\n        _positions = clamp(parseInt(n) || 2, 2, 10);\n        if (_val >= _positions) _val = 0;\n        updateKnob();\n        return sw;\n    };\n    sw.val = function (v) {\n        if (v === undefined) return _val;\n        setVal(v, true);\n        return sw;\n    };\n    sw.disabled = function (state) {\n        if (typeof state === 'undefined') return _disabled;\n        _disabled = !!state;\n        if (_disabled) sw.addClass(Form.switchClasses.switch_disabled);\n        else sw.removeClass(Form.switchClasses.switch_disabled);\n        return sw;\n    };\n    sw.remove = function () {\n        sw.remove();\n        return null;\n    };\n    updateKnob();\n    this.elements.push(sw);\n    return sw;\n};"
            },
            "Form.Tags": {
                "uuid": "8c4353c1-c200-49ef-9fc0-928aa4de79b5",
                "name": "Form.Tags",
                "method": "Component",
                "desc": "Tags component for Form plugin",
                "type": "Component",
                "example": [
                    "var tags = Q.Form.Tags('tag1,tag2,tag3', 'Add tags...'); tags.change(function(value) { console.log(value); });"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "attr",
                    "val",
                    "prop",
                    "html",
                    "before",
                    "after",
                    "css",
                    "find",
                    "focus",
                    "children"
                ],
                "script": "Form.prototype.Tags = function(value = '', placeholder = '', options = {}) {\n    const defaultOptions = {\n        separator: ',',\n        maxTags: null,\n        minChars: 1\n    };\n    options = Object.assign({}, defaultOptions, options);\n    if (!Form.tagsClassesInitialized) {\n        Form.tagsClasses = Q.style('', `\n            .form_tags_container {\n                display: flex;\n                flex-wrap: wrap;\n                gap: 5px;\n                width: 100%;\n                min-height: 36px;\n                padding: 3px;\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-input-background-color);\n                cursor: text;\n            }\n            .form_tags_container:focus-within {\n                border-color: var(--form-default-outline-focus);\n                outline: none;\n            }\n            .form_tag {\n            position:relative;\n            overflow: hidden;\n                display: inline-flex;\n                align-items: center;\n                padding: 0 30px 0 5px;\n                background: var(--form-default-background);\n                color: var(--form-default-text-color);\n                border-radius: var(--form-default-border-radius);\n                font-size: var(--form-default-font-size);\n                font-family: var(--form-default-font-family);\n                user-select: none;\n            }\n            .form_tag_editable {\n                background-color: var(--form-default-background-hover);\n            }\n            .form_tag_remove {\n                display: flex;\n                position: absolute;\n                right: 0;\n                cursor: pointer;\n                width: 20px;\n                height: 100%;\n                align-items: center;\n                justify-content: center;\n                font-size: 12px;\n            }\n            .form_tag_input {\n                flex-grow: 1;\n                min-width: 60px;\n                border: none;\n                outline: none;\n                padding: 5px;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                background: transparent;\n                color: var(--form-default-text-color);\n            }\n            .form_tag.dragging {\n                opacity: 0.2;\n            }\n            .form_tag[draggable=true] {\n                cursor: move;\n            }\n        `, null, {\n            'form_tags_container': 'form_tags_container',\n            'form_tag': 'form_tag',\n            'form_tag_editable': 'form_tag_editable',\n            'form_tag_remove': 'form_tag_remove',\n            'form_tag_input': 'form_tag_input'\n        });\n        Form.tagsClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.tagsClasses.form_tags_container}\"></div>`);\n    const input = Q(`<input class=\"${Form.tagsClasses.form_tag_input}\" placeholder=\"${placeholder}\" type=\"text\">`);\n    const state = {\n        tags: [],\n        draggedTag: null,\n        currentEditTag: null\n    };\n    container.append(input);\n    if (value && typeof value === 'string' && value.trim() !== '') {\n        const initialTags = value.split(options.separator)\n                               .map(tag => tag.trim())\n                               .filter(Boolean);\n        initialTags.forEach(tag => addTag(tag));\n    }\n    function addTag(text) {\n        if (!text || text.length < options.minChars) return;\n        if (options.maxTags !== null && state.tags.length >= options.maxTags) return;\n        if (state.tags.includes(text)) return;\n        const tag = Q(`<div class=\"${Form.tagsClasses.form_tag}\" draggable=\"true\"></div>`);\n        const tagText = Q(`<span>${text}</span>`);\n        const removeBtn = Q(`<span class=\"${Form.tagsClasses.form_tag_remove}\">\u00d7</span>`);\n        tag.append(tagText, removeBtn);\n        state.tags.push(text);\n        input.before(tag);\n        setupDragAndDrop(tag);\n        tag.on('click', function(e) {\n            if (e.target.classList.contains(Form.tagsClasses.form_tag_remove.split(' ')[0])) return;\n            tag.html('');\n            tag.addClass(Form.tagsClasses.form_tag_editable);\n            const editInput = Q(`<input type=\"text\" value=\"${text}\" style=\"border:none; background:transparent; color:inherit; outline:none; width:auto;\">`);\n            tag.append(editInput);\n            editInput.focus();\n            state.currentEditTag = { tag, originalText: text };\n            editInput.on('blur', function() {\n                finishEditing(editInput.val());\n            });\n            editInput.on('keydown', function(e) {\n                if (e.key === 'Enter') {\n                    finishEditing(editInput.val());\n                    e.preventDefault();\n                } else if (e.key === 'Escape') {\n                    finishEditing(text); \n                    e.preventDefault();\n                }\n            });\n        });\n        removeBtn.on('click', function() {\n            removeTag(tag, text);\n        });\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function finishEditing(newText) {\n        if (!state.currentEditTag) return;\n        const { tag, originalText } = state.currentEditTag;\n        const index = state.tags.indexOf(originalText);\n        if (index !== -1) {\n            state.tags.splice(index, 1);\n        }\n        if (newText && newText.trim() && newText.length >= options.minChars) {\n            tag.removeClass(Form.tagsClasses.form_tag_editable);\n            tag.html(`<span>${newText}</span><span class=\"${Form.tagsClasses.form_tag_remove}\">\u00d7</span>`);\n            tag.find(`.${Form.tagsClasses.form_tag_remove.split(' ')[0]}`).on('click', function() {\n                removeTag(tag, newText);\n            });\n            state.tags.push(newText);\n        } else {\n            tag.remove();\n        }\n        state.currentEditTag = null;\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function removeTag(tagElement, text) {\n        tagElement.remove();\n        const index = state.tags.indexOf(text);\n        if (index !== -1) {\n            state.tags.splice(index, 1);\n        }\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function setupDragAndDrop(tag) {\n        tag.on('dragstart', function(e) {\n            state.draggedTag = tag;\n            tag.addClass('dragging');\n            if (e.dataTransfer) {\n                e.dataTransfer.setData('text/plain', '');\n                e.dataTransfer.effectAllowed = 'move';\n            }\n        });\n        tag.on('dragend', function() {\n            state.draggedTag = null;\n            tag.removeClass('dragging');\n        });\n        tag.on('dragover', function(e) {\n            if (e.preventDefault) {\n                e.preventDefault(); \n            }\n            return false;\n        });\n        tag.on('dragenter', function(e) {\n            e.preventDefault();\n        });\n        tag.on('drop', function(e) {\n            e.stopPropagation();\n            if (!state.draggedTag || state.draggedTag === tag) {\n                return;\n            }\n            const allTags = Array.from(container.children()).filter(\n                el => el.classList.contains(Form.tagsClasses.form_tag.split(' ')[0])\n            );\n            const fromIndex = allTags.indexOf(state.draggedTag);\n            const toIndex = allTags.indexOf(tag);\n            if (fromIndex < toIndex) {\n                tag.after(state.draggedTag);\n            } else {\n                tag.before(state.draggedTag);\n            }\n            const movedTag = state.tags.splice(fromIndex, 1)[0];\n            state.tags.splice(toIndex, 0, movedTag);\n            if (typeof container.changeCallback === 'function') {\n                container.changeCallback(state.tags.join(options.separator));\n            }\n            return false;\n        });\n    }\n    container.on('click', function(e) {\n        if (e.target === container.element) {\n            input.focus();\n        }\n    });\n    input.on('keydown', function(e) {\n        if (e.key === 'Enter' || e.key === ',' || e.key === ';' || (options.separator === ' ' && e.key === ' ')) {\n            const value = input.val().trim();\n            if (value) {\n                addTag(value);\n                input.val('');\n                e.preventDefault();\n            }\n        }\n        else if (e.key === 'Backspace' && input.val() === '' && state.tags.length > 0) {\n            const tagElements = container.nodes[0].querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n            if (tagElements.length > 0) {\n                const lastTag = Q(tagElements[tagElements.length - 1]);\n                lastTag.click(); \n            }\n        }\n    });\n    input.on('paste', function(e) {\n        let pastedText;\n        if (window.clipboardData && window.clipboardData.getData) {\n            pastedText = window.clipboardData.getData('Text');\n        } else if (e.clipboardData && e.clipboardData.getData) {\n            pastedText = e.clipboardData.getData('text/plain');\n        }\n        if (pastedText) {\n            e.preventDefault();\n            const tags = pastedText.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n            tags.forEach(tag => addTag(tag));\n            input.val('');\n        }\n    });\n    input.on('blur', function() {\n        const inputValue = input.val();\n        const value = inputValue ? inputValue.trim() : '';\n        if (value) {\n            addTag(value);\n            input.val('');\n        }\n    });\n    container.val = function(value) {\n        if (value === undefined) {\n            return state.tags.join(options.separator);\n        }\n        if (value === '') {\n            if (container.nodes && container.nodes.length > 0) {\n                const tagElements = container.nodes[0].querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n                for (let i = 0; i < tagElements.length; i++) {\n                    if (tagElements[i].parentNode) {\n                        tagElements[i].parentNode.removeChild(tagElements[i]);\n                    }\n                }\n            }\n            state.tags = [];\n        } else {\n            if (container.nodes && container.nodes.length > 0) {\n                const tagElements = container.nodes[0].querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n                for (let i = 0; i < tagElements.length; i++) {\n                    if (tagElements[i].parentNode) {\n                        tagElements[i].parentNode.removeChild(tagElements[i]);\n                    }\n                }\n            }\n            state.tags = [];\n            const newTags = value.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n            newTags.forEach(tag => addTag(tag));\n        }\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n        return container;\n    };\n    container.placeholder = function(text) {\n        input.attr('placeholder', text);\n        return container;\n    };\n    container.disabled = function(state) {\n        input.prop('disabled', state);\n        container.css('pointer-events', state ? 'none' : 'auto');\n        if (state) {\n            container.addClass(Form.classes.q_form_disabled);\n        } else {\n            container.removeClass(Form.classes.q_form_disabled);\n        }\n        return container;\n    };\n    container.setSeparator = function(separator) {\n        options.separator = separator;\n        return container;\n    };\n    container.reset = function() {\n        return container.val('');\n    };\n    container.change = function(callback) {\n        container.changeCallback = callback;\n        return container;\n    };\n    this.elements.push(container);\n    return container;\n};"
            },
            "Form.TextArea": {
                "uuid": "b3144a11-778b-4cc2-9bb6-6122845ba895",
                "name": "Form.TextArea",
                "method": "Component",
                "desc": "TextArea component for Form plugin",
                "type": "Component",
                "example": [
                    "var textarea = Q.Form.TextArea('Initial content', 'Enter text...'); textarea.change(function(value) { console.log(value); });"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "attr",
                    "val",
                    "prop"
                ],
                "script": "Form.prototype.TextArea = function(value = '', placeholder = '') {\n    if (!Form.textAreaClassesInitialized) {\n        Form.textAreaClasses = Q.style('', `\n            .form_textarea {\n                width: 100%;\n                padding: var(--form-default-padding);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n                outline: var(--form-default-outline);\n                border: 0;\n                resize: none;\n                min-height: 100px;\n            }\n            .form_textarea:focus {\n                outline: var(--form-default-outline-focus);\n            }\n        `, null, {\n            'form_textarea': 'form_textarea'\n        });\n        Form.textAreaClassesInitialized = true;\n    }\n    const textarea = Q('<textarea>')\n        .addClass(Form.textAreaClasses.form_textarea)\n        .attr('placeholder', placeholder)\n        .val(value);\n    textarea.disabled = function(state) {\n        textarea.prop('disabled', state);\n        return textarea;\n    };\n    textarea.reset = function() {\n        textarea.val('');\n        return textarea;\n    };\n    textarea.resizeable = function(x = true, y = true) {\n        textarea.css('resize', (x ? 'horizontal' : 'none') + ' ' + (y ? 'vertical' : 'none'));\n        return textarea;\n    }\n    textarea.change = function(callback) {\n        textarea.on('input', function() {\n            callback(this.value);\n        });\n        return textarea;\n    };\n    this.elements.push(textarea);\n    return textarea;\n};"
            },
            "Form.TextBox": {
                "uuid": "efa573b4-3311-4b97-b709-cebae89975e9",
                "name": "Form.TextBox",
                "method": "Component",
                "desc": "TextBox component for Form plugin",
                "type": "Component",
                "example": [
                    "var textbox = Q.Form.TextBox('text', 'Initial value', 'Enter text...'); textbox.change(function(value) { console.log(value); });"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "attr",
                    "val",
                    "prop"
                ],
                "script": "Form.prototype.TextBox = function(type = 'text', value = '', placeholder = '') {\n    if (!Form.textBoxClassesInitialized) {\n        Form.textBoxClasses = Q.style('', `\n            .q_form_input {\n                width: 100%;\n                font-family: var(--form-default-font-family);\n                padding: var(--form-default-padding);\n                font-size: var(--form-default-font-size);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n                border: 0;\n                resize: none;\n                transition: background-color 0s ease, color 0s ease, outline 0s ease;\n            }\n            /* Fix for autofill background color */\n            .q_form_input:-webkit-autofill,\n            .q_form_input:-webkit-autofill:hover,\n            .q_form_input:-webkit-autofill:focus,\n            .q_form_input:-webkit-autofill:active {\n                -webkit-box-shadow: 0 0 0 30px var(--form-default-background) inset !important;\n                -webkit-text-fill-color: var(--form-default-text-color) !important;\n                transition: background-color 5000s ease-in-out 0s;\n                background-color: var(--form-default-background) !important;\n            }\n            .q_form_input:hover {\n                outline: var(--form-default-outline-hover);\n                background-color: var(--form-default-background-hover);\n            }\n            .q_form_input:hover:-webkit-autofill {\n                -webkit-box-shadow: 0 0 0 30px var(--form-default-background-hover) inset !important;\n                background-color: var(--form-default-background-hover) !important;\n            }\n            .q_form_input:focus {\n                outline: var(--form-default-outline-focus);\n                background-color: var(--form-default-background-focus);\n            }\n            .q_form_input:focus:-webkit-autofill {\n                -webkit-box-shadow: 0 0 0 30px var(--form-default-background-focus) inset !important;\n                background-color: var(--form-default-background-focus) !important;\n            }\n            .q_form_input:active {\n                outline: var(--form-default-outline-active);\n                background-color: var(--form-default-background-active);\n            }\n            .q_form_input:disabled {\n                background-color: var(--form-default-background-disabled);\n                color: var(--form-default-text-color-disabled);\n                cursor: not-allowed;\n            }\n        `, null, {\n            'q_form_input': 'q_form_input'\n        });\n        Form.textBoxClassesInitialized = true;\n    }\n    const input = Q(`<input class=\"${Form.textBoxClasses.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n    input.placeholder = function(text) {\n        input.attr('placeholder', text);\n    };\n    input.disabled = function(state) {\n        input.prop('disabled', state);\n        if (state) {\n            input.addClass(Form.classes.q_form_disabled);\n        } else {\n            input.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    input.reset = function() {\n        input.val('');\n    };\n    input.change = function(callback) {\n        input.on('change input', function() {\n            callback(this.value);\n        });\n    };\n    this.elements.push(input);\n    return input;\n};"
            },
            "Form.Uploader": {
                "uuid": "4c158b2f-56c0-45ef-9edc-2cc693aa64e7",
                "name": "Form.Uploader",
                "method": "Component",
                "desc": "File upload component with drag and drop functionality",
                "type": "Component",
                "example": [
                    "var uploader = Q.Form.Uploader({ fileTypes: '.jpg,.png', preview: true }); uploader.change(function(files) { console.log(files); });"
                ],
                "dependencies": [
                    "Form",
                    "style",
                    "addClass",
                    "removeClass",
                    "on",
                    "attr",
                    "val",
                    "prop",
                    "html",
                    "append",
                    "css",
                    "text",
                    "remove"
                ],
                "script": "Form.prototype.Uploader = function (options = {}) {\n    const defaultOptions = {\n        fileTypes: '*', // Accepted file types: 'image/jpeg,image/png' or '.jpg,.png'\n        preview: true,  // Show previews for images/videos\n        thumbSize: 100, // Thumbnail size (px)\n        allowDrop: true, // Allow drag and drop\n        multiple: false, // Allow multiple file selection\n        placeholder: 'Drop files here or click to select'\n    };\n    options = Object.assign({}, defaultOptions, options);\n    if (!Form.uploaderClassesInitialized) {\n        Form.uploaderClasses = Q.style('', `\n            .form_uploader_container {\n            user-select: none;\n                -webkit-user-select: none;\n                display: flex;\n                flex-direction: column;\n                width: 100%;\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                padding: 10px;\n                color: var(--form-default-text-color);\n            }\n            .form_uploader_container.drag_over {\n                outline: var(--form-default-outline-active);\n                background-color: var(--form-default-background-hover);\n            }\n            .form_uploader_drop_area {\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                justify-content: center;\n                padding: 20px;\n                text-align: center;\n                cursor: pointer;\n                color: var(--form-default-text-color);\n                min-height: 120px;\n            }\n            .form_uploader_icon {\n                font-size: 32px;\n                margin-bottom: 10px;\n                opacity: 0.7;\n            }\n            .form_uploader_text {\n                margin-bottom: 10px;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n            .form_uploader_button {\n                padding: var(--form-default-padding);\n                background-color: var(--form-default-button-background-color);\n                color: var(--form-default-button-text-color);\n                border: none;\n                border-radius: var(--form-default-border-radius);\n                cursor: pointer;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n            .form_uploader_button:hover {\n                background-color: var(--form-default-background-hover);\n                color: var(--form-default-text-color-hover);\n            }\n            .form_uploader_input {\n                display: none;\n            }\n            .form_uploader_preview_container {\n                display: flex;\n                flex-wrap: wrap;\n                gap: 5px;\n                margin-top: 5px;\n            }\n            .form_uploader_preview_item {\n                position: relative;\n                border-radius: var(--form-default-border-radius);\n                overflow: hidden;\n                outline: var(--form-default-outline);\n            }\n            .form_uploader_preview_image {\n                object-fit: cover;\n                display: block;\n            }\n            .form_uploader_preview_video {\n                object-fit: cover;\n                display: block;\n            }\n            .form_uploader_preview_icon {\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                color: var(--form-default-input-text-color);\n                background-color: rgba(37, 37, 37, 0.8);\n                font-size: 24px;\n            }\n            .form_uploader_preview_info {\n                position: absolute;\n                bottom: 0;\n                left: 0;\n                right: 0;\n                padding: 4px 6px;\n                background: rgba(0, 0, 0, 0.7);\n                color: #fff;\n                font-size: 10px;\n                text-overflow: ellipsis;\n                white-space: nowrap;\n                overflow: hidden;\n            }\n        `, null, {\n            'form_uploader_container': 'form_uploader_container',\n            'drag_over': 'drag_over',\n            'form_uploader_drop_area': 'form_uploader_drop_area',\n            'form_uploader_icon': 'form_uploader_icon',\n            'form_uploader_text': 'form_uploader_text',\n            'form_uploader_button': 'form_uploader_button',\n            'form_uploader_input': 'form_uploader_input',\n            'form_uploader_preview_container': 'form_uploader_preview_container',\n            'form_uploader_preview_item': 'form_uploader_preview_item',\n            'form_uploader_preview_image': 'form_uploader_preview_image',\n            'form_uploader_preview_video': 'form_uploader_preview_video',\n            'form_uploader_preview_icon': 'form_uploader_preview_icon',\n            'form_uploader_preview_info': 'form_uploader_preview_info'\n        });\n        Form.uploaderClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.classes.q_form} ${Form.uploaderClasses.form_uploader_container}\"></div>`);\n    const dropArea = Q(`<div class=\"${Form.uploaderClasses.form_uploader_drop_area}\"></div>`);\n    const uploadIcon = Q(`<div class=\"${Form.uploaderClasses.form_uploader_icon}\">\ud83d\udcc2</div>`);\n    const text = Q(`<div class=\"${Form.uploaderClasses.form_uploader_text}\">${options.placeholder}</div>`);\n    const browseButton = Q(`<button type=\"button\" class=\"${Form.uploaderClasses.form_uploader_button}\">Browse Files</button>`);\n    const fileInput = Q(`<input type=\"file\" class=\"${Form.uploaderClasses.form_uploader_input}\">`);\n    if (options.multiple) {\n        fileInput.attr('multiple', true);\n    }\n    if (options.fileTypes && options.fileTypes !== '*') {\n        fileInput.attr('accept', options.fileTypes);\n    }\n    dropArea.append(uploadIcon, text, browseButton);\n    container.append(dropArea, fileInput);\n    let previewContainer = null;\n    if (options.preview) {\n        previewContainer = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_container}\"></div>`);\n        container.append(previewContainer);\n    }\n    const state = {\n        files: [],\n        fileObjects: []\n    };\n    function formatFileSize(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n    function getFileExtension(filename) {\n        return filename.split('.').pop().toUpperCase();\n    }\n    function handleFiles(files) {\n        if (!files || files.length === 0) return;\n        Array.from(files).forEach(file => {\n            const fileInfo = {\n                name: file.name,\n                size: file.size,\n                formattedSize: formatFileSize(file.size),\n                type: file.type,\n                extension: getFileExtension(file.name)\n            };\n            state.files.push(fileInfo);\n            state.fileObjects.push(file);\n            if (options.preview) {\n                generatePreview(file, fileInfo);\n            }\n        });\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.files);\n        }\n    }\n    function generatePreview(file, fileInfo) {\n        const previewItem = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_item}\"></div>`);\n        const fileInfoElement = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_info}\">${file.name} (${fileInfo.formattedSize})</div>`);\n        const removeButton = Q(`<div class=\"${Form.classes.form_close_button}\">\u00d7</div>`);\n        previewItem.css({\n            width: options.thumbSize + 'px',\n            height: options.thumbSize + 'px'\n        });\n        const titleInfo = `Name: ${file.name}\\nSize: ${fileInfo.formattedSize}\\nType: ${file.type}`;\n        previewItem.attr('title', titleInfo);\n        if (file.type.startsWith('image/')) {\n            const img = Q(`<img class=\"${Form.uploaderClasses.form_uploader_preview_image}\" alt=\"${file.name}\">`);\n            img.css({\n                width: '100%',\n                height: '100%'\n            });\n            img.attr('title', titleInfo);\n            const reader = new FileReader();\n            reader.onload = function (e) {\n                img.attr('src', e.target.result);\n                fileInfo.preview = e.target.result;\n            };\n            reader.readAsDataURL(file);\n            previewItem.append(img);\n        }\n        else if (file.type.startsWith('video/')) {\n            const video = Q(`<video class=\"${Form.uploaderClasses.form_uploader_preview_video}\" controls muted>`);\n            video.css({\n                width: '100%',\n                height: '100%'\n            });\n            video.attr('title', titleInfo);\n            const reader = new FileReader();\n            reader.onload = function (e) {\n                video.attr('src', e.target.result);\n                fileInfo.preview = e.target.result;\n            };\n            reader.readAsDataURL(file);\n            previewItem.append(video);\n        }\n        else {\n            const fileIcon = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_icon}\"></div>`);\n            fileIcon.css({\n                width: '100%',\n                height: '100%'\n            });\n            fileIcon.attr('title', titleInfo);\n            fileIcon.text(fileInfo.extension);\n            previewItem.append(fileIcon);\n        }\n        previewItem.append(fileInfoElement, removeButton);\n        fileInfo.element = previewItem;\n        if (previewContainer) {\n            previewContainer.append(previewItem);\n        }\n        removeButton.on('click', () => {\n            removeFile(fileInfo);\n        });\n    }\n    function removeFile(fileInfo) {\n        const index = state.files.indexOf(fileInfo);\n        if (index !== -1) {\n            state.files.splice(index, 1);\n            state.fileObjects.splice(index, 1);\n            if (fileInfo.element) {\n                fileInfo.element.remove();\n            }\n            if (typeof container.changeCallback === 'function') {\n                container.changeCallback(state.files);\n            }\n        }\n    }\n    function resetUploader() {\n        state.files = [];\n        state.fileObjects = [];\n        if (previewContainer) {\n            previewContainer.html('');\n        }\n        fileInput.val('');\n    }\n    if (options.allowDrop) {\n        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n            dropArea.on(eventName, (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        });\n        ['dragenter', 'dragover'].forEach(eventName => {\n            dropArea.on(eventName, () => {\n                container.addClass(Form.uploaderClasses.drag_over);\n            });\n        });\n        ['dragleave', 'drop'].forEach(eventName => {\n            dropArea.on(eventName, () => {\n                container.removeClass(Form.uploaderClasses.drag_over);\n            });\n        });\n        dropArea.on('drop', (e) => {\n            const files = e.dataTransfer.files;\n            if (!options.multiple && files.length > 1) {\n                handleFiles([files[0]]);\n            } else {\n                handleFiles(files);\n            }\n        });\n    }\n    browseButton.on('click', function () {\n        fileInput.nodes[0].click();\n    });\n    dropArea.on('click', function (e) {\n        if (e.target !== browseButton.nodes[0]) {\n            fileInput.nodes[0].click();\n        }\n    });\n    fileInput.on('change', function () {\n        if (!options.multiple) {\n            resetUploader(); // Clear previous files if not multiple\n        }\n        handleFiles(this.files);\n    });\n    container.val = function (value) {\n        if (value === undefined) {\n            return {\n                files: state.files,\n                fileObjects: state.fileObjects\n            };\n        }\n        if (value === '' || value === null) {\n            resetUploader();\n            return container;\n        }\n        return container;\n    };\n    container.reset = function () {\n        resetUploader();\n        return container;\n    };\n    container.disabled = function (state) {\n        if (state) {\n            container.css('opacity', '0.5');\n            container.css('pointer-events', 'none');\n            fileInput.prop('disabled', true);\n        } else {\n            container.css('opacity', '1');\n            container.css('pointer-events', 'auto');\n            fileInput.prop('disabled', false);\n        }\n        return container;\n    };\n    container.change = function (callback) {\n        container.changeCallback = callback;\n        return container;\n    };\n    this.elements.push(container);\n    return container;\n};"
            },
            "Graph": {
                "uuid": "4eae8c71-3161-4fde-a736-d2e645ce7603",
                "name": "Graph",
                "method": "Constructor",
                "desc": "Core graph plotting and visualization provider for VulpiniQ.",
                "type": "Constructor",
                "example": [
                    "// Create a new Graph and append to body\nvar graph = new Graph();\ndocument.body.appendChild(graph);",
                    "// Create a Graph and set data\nvar graph = new Graph();\ngraph.data([1,2,3,4,5]);\ndocument.body.appendChild(graph);",
                    "// Using Q helper to create and show a Graph\nQ.Graph().data([10, 20, 30]).appendTo(document.body);"
                ],
                "dependencies": [],
                "script": "function Graph(options = {}) {\n    if (!(this instanceof Graph)) {\n        return new Graph(options);\n    }\n    if (!Graph.initialized) {\n        Q.style(`\n        `);\n        Graph.initialized = true;\n    }\n    return this;\n};\nGraph.deepMerge = function(target, src) {\n    for (const k in src) {\n        if (src[k] && typeof src[k] === 'object' && !Array.isArray(src[k])) {\n            if (!target[k]) target[k] = {};\n            Graph.deepMerge(target[k], src[k]);\n        } else {\n            target[k] = src[k];\n        }\n    }\n    return target;\n};\nGraph.getPadding = function(pad) {\n    if (Array.isArray(pad)) {\n        if (pad.length === 2) return [pad[0], pad[1], pad[0], pad[1]];\n        if (pad.length === 3) return [pad[0], pad[1], pad[2], pad[1]];\n        if (pad.length === 4) return pad;\n    }\n    return [pad, pad, pad, pad];\n};\nGraph.catmullRom2bezier = function(points) {\n    let d = '';\n    for (let i = 0; i < points.length - 1; i++) {\n        const p0 = points[i - 1] || points[i];\n        const p1 = points[i];\n        const p2 = points[i + 1];\n        const p3 = points[i + 2] || p2;\n        if (i === 0) d += `M${p1[0]},${p1[1]}`;\n        const c1x = p1[0] + (p2[0] - p0[0]) / 6;\n        const c1y = p1[1] + (p2[1] - p0[1]) / 6;\n        const c2x = p2[0] - (p3[0] - p1[0]) / 6;\n        const c2y = p2[1] - (p3[1] - p1[1]) / 6;\n        d += ` C${c1x},${c1y} ${c2x},${c2y} ${p2[0]},${p2[1]}`;\n    }\n    return d;\n};\nQ.Graph = Graph;"
            },
            "Graph.Line": {
                "uuid": "212f060b-1711-45f6-b165-945c3d325fcc",
                "name": "Graph.Line",
                "method": "Constructor",
                "desc": "Line graph plotting and visualization for VulpiniQ.",
                "type": "Constructor",
                "example": [
                    "// Create a new Line graph and append to body\nvar line = new Graph.Line();\ndocument.body.appendChild(line);",
                    "// Create a Line graph, set data, and append\nvar line = new Graph.Line();\nline.data([1, 3, 2, 5, 4]);\ndocument.body.appendChild(line);",
                    "// Using Q helper to create and show a Line graph\nQ.Graph.Line().data([5, 10, 7, 12]).appendTo(document.body);"
                ],
                "dependencies": [
                    "Graph"
                ],
                "script": "Graph.prototype.Line = function (options = {}) {\n    const defaults = {\n        size: {\n            width: 600,\n            height: 300,\n            padding: 40\n        },\n        background: '#181818',\n        range: {\n            min: 0,\n            max: 100,\n            autoscaleX: true,\n            autoscaleY: true\n        },\n        line: {\n            type: 'line',\n            color: 'rgb(100, 60, 240)',\n            thickness: 2,\n            fill: null,\n            triangle: {\n                size: 8,\n                fill: null,\n                stroke: null,\n                strokeWidth: null,\n                opacity: null\n            }\n        },\n        dot: {\n            radius: 2,\n            stroke: '#222',\n            strokeWidth: 0\n        },\n        zeroLine: {\n            enabled: false,\n            color: '#607d8b',\n            thickness: 2,\n            dasharray: '',\n            point: undefined,\n            points: undefined\n        },\n        grid: {\n            resolutionX: 0,\n            resolutionY: 0,\n            color: '#333',\n            thickness: 1,\n            dasharray: '2,2',\n            showValuesX: false,\n            showValuesY: false\n        },\n        text: {\n            value: {\n                color: '#bbb',\n                fontSize: 14,\n                fontFamily: 'monospace',\n                fontWeight: 'normal',\n                shadow: '',\n            },\n            axis: {\n                color: '#aaa',\n                fontSize: 14,\n                fontFamily: 'monospace',\n                fontWeight: 'bold',\n                shadow: '',\n            },\n            label: {\n                color: '#fff',\n                fontSize: 12,\n                fontFamily: 'monospace',\n                fontWeight: 'bold',\n                shadow: '',\n            }\n        },\n        current: {\n            show: false\n        },\n        average: {\n            enabled: true,\n            dasharray: '2,2',\n            color: '#ff9800',\n            thickness: 3,\n            label: {\n                color: '#ff9800',\n                fontSize: 12,\n                fontFamily: 'monospace',\n                fontWeight: 'bold',\n                shadow: '',\n            }\n        },\n        hover: {\n            value: false,\n            onlyPoints: false,\n            digits: 5,\n            distance: 20,\n            wrap: false,\n            show: 'both',\n            xDigits: 5,\n            yDigits: 5,\n            dot: {\n                radius: 10,\n                fill: 'rgb(100, 60, 240)',\n                stroke: '#fff',\n                strokeWidth: 0\n            },\n            margin: [0, 20],\n            cursor: false,\n            padding: [8, 8, 8, 8],\n            background: '#111',\n            opacity: 1,\n            shadow: '',\n            text: {\n                color: '#fff',\n                fontSize: 14,\n                fontFamily: 'monospace',\n                fontWeight: 'normal',\n                shadow: ''\n            }\n        },\n        valueDigits: 2\n    };\n    const opts = Graph.deepMerge(JSON.parse(JSON.stringify(defaults)), options);\n    let dataX = [], dataY = [];\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttribute('width', opts.size.width);\n    svg.setAttribute('height', opts.size.height);\n    svg.style.background = opts.background;\n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    svg.appendChild(g);\n    function render() {\n        g.innerHTML = '';\n        if (!dataY.length) return;\n        let xArr = dataX.length ? dataX : dataY.map((_, i) => i);\n        let minY = opts.range.autoscaleY ? Math.min(...dataY) : opts.range.min;\n        let maxY = opts.range.autoscaleY ? Math.max(...dataY) : opts.range.max;\n        let minX = opts.range.autoscaleX ? Math.min(...xArr) : 0;\n        let maxX = opts.range.autoscaleX ? Math.max(...xArr) : xArr.length - 1;\n        const pad = Graph.getPadding(opts.size.padding);\n        const [padT, padR, padB, padL] = pad;\n        const w = opts.size.width - padL - padR;\n        const h = opts.size.height - padT - padB;\n        const scaleX = v => padL + (w) * (v - minX) / (maxX - minX);\n        const scaleY = v => opts.size.height - padB - (h) * (v - minY) / (maxY - minY);\n        if (opts.grid.resolutionX > 0) {\n            let xVal = Math.ceil(minX / opts.grid.resolutionX) * opts.grid.resolutionX;\n            for (; xVal <= maxX; xVal += opts.grid.resolutionX) {\n                const x = scaleX(xVal);\n                const grid = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                Q(grid).attr({\n                    x1: x,\n                    y1: padT,\n                    x2: x,\n                    y2: opts.size.height - padB,\n                    stroke: opts.grid.color,\n                    'stroke-width': opts.grid.thickness,\n                    'stroke-dasharray': opts.grid.dasharray\n                });\n                g.appendChild(grid);\n                if (opts.grid.showValuesX) {\n                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    Q(label).attr({\n                        x: x,\n                        y: opts.size.height - padB + 18,\n                        fill: opts.text.value.color,\n                        'font-size': opts.text.value.fontSize,\n                        'font-family': opts.text.value.fontFamily,\n                        'font-weight': opts.text.value.fontWeight\n                    });\n                    label.textContent = xVal.toFixed(opts.valueDigits);\n                    g.appendChild(label);\n                }\n            }\n        }\n        if (opts.grid.resolutionY > 0) {\n            let yVal = Math.ceil(minY / opts.grid.resolutionY) * opts.grid.resolutionY;\n            for (; yVal <= maxY; yVal += opts.grid.resolutionY) {\n                const y = scaleY(yVal);\n                const grid = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                Q(grid).attr({\n                    x1: padL,\n                    y1: y,\n                    x2: opts.size.width - padR,\n                    y2: y,\n                    stroke: opts.grid.color,\n                    'stroke-width': opts.grid.thickness,\n                    'stroke-dasharray': opts.grid.dasharray\n                });\n                g.appendChild(grid);\n                if (opts.grid.showValuesY) {\n                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                    Q(label).attr({\n                        x: padL - 8,\n                        y: y + 4,\n                        fill: opts.text.value.color,\n                        'font-size': opts.text.value.fontSize,\n                        'font-family': opts.text.value.fontFamily,\n                        'font-weight': opts.text.value.fontWeight,\n                        'text-anchor': 'end'\n                    });\n                    label.textContent = yVal.toFixed(opts.valueDigits);\n                    g.appendChild(label);\n                }\n            }\n        }\n        let d = '';\n        if (opts.line.type === 'curve' && dataY.length > 2) {\n            const points = dataY.map((y, i) => [scaleX(xArr[i]), scaleY(y)]);\n            d = Graph.catmullRom2bezier(points);\n        } else if (opts.line.type === 'dots') {\n            for (let i = 0; i < dataY.length; i++) {\n                const x = scaleX(xArr[i]);\n                const y = scaleY(dataY[i]);\n                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n                Q(dot).attr({\n                    cx: x,\n                    cy: y,\n                    r: opts.dot.radius,\n                    fill: opts.line.color,\n                    stroke: opts.dot.stroke,\n                    'stroke-width': opts.dot.strokeWidth\n                });\n                g.appendChild(dot);\n            }\n            d = '';\n        } else {\n            for (let i = 0; i < dataY.length; i++) {\n                const x = scaleX(xArr[i]);\n                const y = scaleY(dataY[i]);\n                d += (i === 0 ? 'M' : 'L') + x + ',' + y;\n            }\n        }\n        if (opts.line.fill && d && dataY.length > 1) {\n            let areaPath = '';\n            let fillColor = typeof opts.line.fill === 'object' ? opts.line.fill.color : opts.line.fill;\n            let lowerY = [];\n            if (opts.zeroLine && opts.zeroLine.enabled) {\n                if (Array.isArray(opts.zeroLine.points) && opts.zeroLine.points.length === dataY.length) {\n                    lowerY = opts.zeroLine.points;\n                } else if (Array.isArray(opts.zeroLine.point) && opts.zeroLine.point.length === 2) {\n                    lowerY = Array(dataY.length).fill(opts.zeroLine.point[1]);\n                } else {\n                    lowerY = Array(dataY.length).fill(opts.range.min);\n                }\n            } else {\n                lowerY = Array(dataY.length).fill(opts.range.min);\n            }\n            if (opts.line.type === 'curve' && dataY.length > 2) {\n                const points = dataY.map((y, i) => [scaleX(xArr[i]), scaleY(y)]);\n                areaPath = Graph.catmullRom2bezier(points);\n                for (let i = dataY.length - 1; i >= 0; i--) {\n                    areaPath += 'L' + scaleX(xArr[i]) + ',' + scaleY(lowerY[i]);\n                }\n                areaPath += 'Z';\n            } else {\n                areaPath = '';\n                for (let i = 0; i < dataY.length; i++) {\n                    const x = scaleX(xArr[i]);\n                    const y = scaleY(dataY[i]);\n                    areaPath += (i === 0 ? 'M' : 'L') + x + ',' + y;\n                }\n                for (let i = dataY.length - 1; i >= 0; i--) {\n                    areaPath += 'L' + scaleX(xArr[i]) + ',' + scaleY(lowerY[i]);\n                }\n                areaPath += 'Z';\n            }\n            const fillPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n            Q(fillPath).attr({\n                d: areaPath,\n                fill: fillColor\n            });\n            g.appendChild(fillPath);\n        }\n        if (d) {\n            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n            Q(path).attr({\n                d: d,\n                stroke: opts.line.color,\n                'stroke-width': opts.line.thickness,\n                fill: 'none'\n            });\n            g.appendChild(path);\n        }\n        if (opts.zeroLine && opts.zeroLine.enabled) {\n            let nullD = '';\n            let started = false;\n            for (let i = 0; i < dataY.length; i++) {\n                if (dataY[i] === 0) {\n                    const x = scaleX(xArr[i]);\n                    const y = scaleY(dataY[i]);\n                    nullD += (started ? 'L' : 'M') + x + ',' + y;\n                    started = true;\n                }\n            }\n            if (nullD) {\n                const nullPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n                Q(nullPath).attr({\n                    d: nullD,\n                    stroke: opts.zeroLine.color,\n                    'stroke-width': opts.zeroLine.thickness,\n                    fill: 'none'\n                });\n                g.appendChild(nullPath);\n            }\n            if (Array.isArray(opts.zeroLine.point) && opts.zeroLine.point.length === 2) {\n                const [nullX, nullY] = opts.zeroLine.point;\n                if (typeof nullX === 'number' && typeof nullY === 'number') {\n                    const x = scaleX(nullX);\n                    const nullLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                    Q(nullLine).attr({\n                        x1: x,\n                        y1: padT,\n                        x2: x,\n                        y2: opts.size.height - padB,\n                        stroke: opts.zeroLine.color,\n                        'stroke-width': opts.zeroLine.thickness,\n                        'stroke-dasharray': opts.zeroLine.dasharray\n                    });\n                    g.appendChild(nullLine);\n                    const y = scaleY(nullY);\n                    const nullLineH = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                    Q(nullLineH).attr({\n                        x1: padL,\n                        y1: y,\n                        x2: opts.size.width - padR,\n                        y2: y,\n                        stroke: opts.zeroLine.color,\n                        'stroke-width': opts.zeroLine.thickness,\n                        'stroke-dasharray': opts.zeroLine.dasharray\n                    });\n                    g.appendChild(nullLineH);\n                }\n            }\n            if (Array.isArray(opts.zeroLine.points) && opts.zeroLine.points.length > 0) {\n                const n = opts.zeroLine.points.length;\n                if (n === 1) {\n                    const y = scaleY(opts.zeroLine.points[0]);\n                    const nullLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n                    Q(nullLine).attr({\n                        x1: padL,\n                        y1: y,\n                        x2: opts.size.width - padR,\n                        y2: y,\n                        stroke: opts.zeroLine.color,\n                        'stroke-width': opts.zeroLine.thickness,\n                        'stroke-dasharray': opts.zeroLine.dasharray\n                    });\n                    g.appendChild(nullLine);\n                } else {\n                    let points = [];\n                    for (let i = 0; i < n; i++) {\n                        const x = padL + (w) * (n === 1 ? 0.5 : i / (n - 1));\n                        const y = scaleY(opts.zeroLine.points[i]);\n                        points.push([x, y]);\n                    }\n                    let d = '';\n                    for (let i = 0; i < points.length; i++) {\n                        d += (i === 0 ? 'M' : 'L') + points[i][0] + ',' + points[i][1];\n                    }\n                    const nullPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    Q(nullPath).attr({\n                        d: d,\n                        stroke: opts.zeroLine.color,\n                        'stroke-width': opts.zeroLine.thickness,\n                        fill: 'none',\n                        'stroke-dasharray': opts.zeroLine.dasharray\n                    });\n                    g.appendChild(nullPath);\n                }\n            }\n        }\n        if (opts.current.show && dataX.length && dataY.length) {\n            const lastX = dataX[dataX.length - 1];\n            const lastY = dataY[dataX.length - 1];\n            const x = scaleX(lastX);\n            const y = scaleY(lastY);\n            const triOpts = opts.line.triangle;\n            const triXSize = triOpts.size;\n            const triYSize = triOpts.size;\n            const triX = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n            Q(triX).attr({\n                points: `${x - triXSize},${opts.size.height - padB} ${x + triXSize},${opts.size.height - padB} ${x},${opts.size.height - padB + triXSize}`,\n                fill: triOpts.fill || opts.line.color,\n                stroke: triOpts.stroke,\n                'stroke-width': triOpts.strokeWidth,\n                opacity: triOpts.opacity\n            });\n            g.appendChild(triX);\n            const xValStr = lastX.toFixed(opts.valueDigits);\n            const xFont = opts.text.value.fontFamily;\n            const xFontSize = opts.text.value.fontSize;\n            const xLabelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n            Q(xLabelBg).attr({\n                x: x - 22,\n                y: opts.size.height - padB + triXSize + 2,\n                width: 44,\n                height: 22,\n                fill: '#111',\n                rx: 4\n            });\n            g.appendChild(xLabelBg);\n            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n            Q(xLabel).attr({\n                x: x,\n                y: opts.size.height - padB + triXSize + 18,\n                'text-anchor': 'middle',\n                fill: opts.text.value.color,\n                'font-size': xFontSize,\n                'font-family': xFont\n            });\n            xLabel.textContent = xValStr;\n            g.appendChild(xLabel);\n            const triY = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n            Q(triY).attr({\n                points: `${padL},${y - triYSize} ${padL},${y + triYSize} ${padL - triYSize},${y}`,\n                fill: triOpts.fill || opts.line.color,\n                stroke: triOpts.stroke,\n                'stroke-width': triOpts.strokeWidth,\n                opacity: triOpts.opacity\n            });\n            g.appendChild(triY);\n            const yValStr = lastY.toFixed(opts.valueDigits);\n            const yFont = opts.text.value.fontFamily;\n            const yFontSize = opts.text.value.fontSize;\n            const yLabelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n            Q(yLabelBg).attr({\n                x: padL - triYSize - 46,\n                y: y - 11,\n                width: 44,\n                height: 22,\n                fill: '#111',\n                rx: 4\n            });\n            g.appendChild(yLabelBg);\n            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n            Q(yLabel).attr({\n                x: padL - triYSize - 24,\n                y: y + 6,\n                'text-anchor': 'middle',\n                fill: opts.text.value.color,\n                'font-size': yFontSize,\n                'font-family': yFont\n            });\n            yLabel.textContent = yValStr;\n            g.appendChild(yLabel);\n        }\n        if (opts.average && opts.average.enabled && dataY.length > 0) {\n            const avgY = dataY.reduce((a, b) => a + b, 0) / dataY.length;\n            const pad = Graph.getPadding(opts.size.padding);\n            const [padT, padR, padB, padL] = pad;\n            const w = opts.size.width - padL - padR;\n            const h = opts.size.height - padT - padB;\n            let minY = opts.range.autoscaleY ? Math.min(...dataY) : opts.range.min;\n            let maxY = opts.range.autoscaleY ? Math.max(...dataY) : opts.range.max;\n            const scaleY = v => opts.size.height - padB - (h) * (v - minY) / (maxY - minY);\n            const y = scaleY(avgY);\n            const avgLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n            Q(avgLine).attr({\n                x1: padL,\n                y1: y,\n                x2: opts.size.width - padR,\n                y2: y,\n                stroke: opts.average.color,\n                'stroke-width': opts.average.thickness,\n                'stroke-dasharray': opts.average.dasharray\n            });\n            g.appendChild(avgLine);\n            const avgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n            Q(avgLabel).attr({\n                x: padL - 8,\n                y: y + 4,\n                fill: opts.average.label.color,\n                'font-size': opts.average.label.fontSize,\n                'font-family': opts.average.label.fontFamily,\n                'font-weight': opts.average.label.fontWeight,\n                'text-anchor': 'end',\n                opacity: 1\n            });\n            avgLabel.textContent = avgY.toFixed(typeof opts.valueDigits === 'number' ? opts.valueDigits : 2);\n            g.appendChild(avgLabel);\n        }\n        if (opts.hover.value) {\n            svg.onmousemove = function (e) {\n                const rect = svg.getBoundingClientRect();\n                const pad = Graph.getPadding(opts.size.padding);\n                const [padT, padR, padB, padL] = pad;\n                const w = opts.size.width - padL - padR;\n                const h = opts.size.height - padT - padB;\n                const mouseX = e.clientX - rect.left;\n                const mouseY = e.clientY - rect.top;\n                let minX = opts.range.autoscaleX ? Math.min(...dataX) : opts.range.min;\n                let maxX = opts.range.autoscaleX ? Math.max(...dataX) : dataX.length - 1;\n                let minY = opts.range.autoscaleY ? Math.min(...dataY) : opts.range.min;\n                let maxY = opts.range.autoscaleY ? Math.max(...dataY) : opts.range.max;\n                let xVal = minX + (mouseX - padL) * (maxX - minX) / (w);\n                let yVal = maxY - (mouseY - padT) * (maxY - minY) / (h);\n                let showX = xVal, showY = yVal, dist = 0;\n                if (opts.hover.onlyPoints && dataX.length) {\n                    let minDist = Infinity, idx = 0;\n                    for (let i = 0; i < dataX.length; i++) {\n                        const px = padL + (w) * (dataX[i] - minX) / (maxX - minX);\n                        const py = opts.size.height - padB - (h) * (dataY[i] - minY) / (maxY - minY);\n                        const d = Math.hypot(mouseX - px, mouseY - py);\n                        if (d < minDist) { minDist = d; idx = i; }\n                    }\n                    showX = dataX[idx];\n                    showY = dataY[idx];\n                    dist = minDist;\n                } else if (dataX.length > 1) {\n                    let minDist = Infinity;\n                    for (let i = 0; i < dataX.length - 1; i++) {\n                        const x1 = padL + (w) * (dataX[i] - minX) / (maxX - minX);\n                        const y1 = opts.size.height - padB - (h) * (dataY[i] - minY) / (maxY - minY);\n                        const x2 = padL + (w) * (dataX[i + 1] - minX) / (maxX - minX);\n                        const y2 = opts.size.height - padB - (h) * (dataY[i + 1] - minY) / (maxY - minY);\n                        const t = Math.max(0, Math.min(1, ((mouseX - x1) * (x2 - x1) + (mouseY - y1) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2)));\n                        const projX = x1 + t * (x2 - x1);\n                        const projY = y1 + t * (x2 - x1);\n                        const d = Math.hypot(mouseX - projX, mouseY - projY);\n                        if (d < minDist) {\n                            minDist = d;\n                            showX = dataX[i] + t * (dataX[i + 1] - dataX[i]);\n                            showY = dataY[i] + t * (dataY[i + 1] - dataY[i]);\n                            dist = d;\n                        }\n                    }\n                }\n                if (dist > (opts.hover.distance)) {\n                    let old = svg.querySelector('.q-graph-hover-label');\n                    if (old) old.remove();\n                    svg.style.cursor = opts.hover.cursor === false ? '' : (opts.hover.cursor === true ? 'pointer' : 'auto');\n                    return;\n                }\n                if (opts.hover.cursor === false) {\n                    svg.style.cursor = 'none';\n                } else if (opts.hover.cursor === true) {\n                    svg.style.cursor = 'pointer';\n                } else {\n                    svg.style.cursor = '';\n                }\n                const hoverShow = opts.hover.show;\n                const xDigits = typeof opts.hover.xDigits === 'number' ? opts.hover.xDigits : (typeof opts.hover.digits === 'number' ? opts.hover.digits : 5);\n                const yDigits = typeof opts.hover.yDigits === 'number' ? opts.hover.yDigits : (typeof opts.hover.digits === 'number' ? opts.hover.digits : 5);\n                const showXVal = +showX.toFixed(xDigits);\n                const showYVal = +showY.toFixed(yDigits);\n                let old = svg.querySelector('.q-graph-hover-label');\n                if (old) old.remove();\n                const gHover = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n                gHover.classList.add('q-graph-hover-label');\n                const cx = padL + (w) * (showX - minX) / (maxX - minX);\n                const cy = opts.size.height - padB - (h) * (showY - minY) / (maxY - minY);\n                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n                const hoverDot = opts.hover.dot;\n                Q(dot).attr({\n                    cx: cx,\n                    cy: cy,\n                    r: hoverDot.radius,\n                    fill: hoverDot.fill,\n                    stroke: hoverDot.stroke,\n                    'stroke-width': hoverDot.strokeWidth\n                });\n                gHover.appendChild(dot);\n                const hoverText = opts.hover.text;\n                let labelText = '';\n                if (hoverShow === 'both') {\n                    labelText = opts.hover.wrap ? `x: ${showXVal}\\ny: ${showYVal}` : `x: ${showXVal}, y: ${showYVal}`;\n                } else if (hoverShow === 'x') {\n                    labelText = `x: ${showXVal}`;\n                } else if (hoverShow === 'y') {\n                    labelText = `y: ${showYVal}`;\n                }\n                const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                Q(tempText).attr({\n                    'font-size': hoverText.fontSize,\n                    'font-family': hoverText.fontFamily,\n                    'font-weight': hoverText.fontWeight\n                });\n                if (opts.hover.wrap && labelText.includes('\\n')) {\n                    const lines = labelText.split('\\n');\n                    lines.forEach((line, i) => {\n                        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                        Q(tspan).attr({\n                            x: 0,\n                            dy: i === 0 ? '0' : (hoverText.fontSize) * 1.2\n                        });\n                        tspan.textContent = line;\n                        tempText.appendChild(tspan);\n                    });\n                } else {\n                    tempText.textContent = labelText;\n                }\n                svg.appendChild(tempText);\n                const bbox = tempText.getBBox();\n                svg.removeChild(tempText);\n                function getBox(box, def, count) {\n                    if (Array.isArray(box)) {\n                        if (box.length === 2 && count === 2) return box;\n                        if (box.length === 2 && count === 4) return [box[0], box[1], box[0], box[1]];\n                        if (box.length === 3) return [box[0], box[1], box[2], box[1]];\n                        if (box.length === 4) return box;\n                    }\n                    return Array(count).fill(def);\n                }\n                const hoverPadArr = getBox(opts.hover.padding, 8, 4);\n                const hoverMarginArr = getBox(opts.hover.margin, 8, 2);\n                const labelW = bbox.width + hoverPadArr[1] + hoverPadArr[3];\n                const labelH = bbox.height + hoverPadArr[0] + hoverPadArr[2];\n                const labelX = cx + hoverMarginArr[1];\n                const labelY = cy - labelH / 2 + hoverMarginArr[0];\n                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n                Q(labelBg).attr({\n                    x: labelX,\n                    y: labelY,\n                    width: labelW,\n                    height: labelH,\n                    fill: opts.hover.background,\n                    rx: 5,\n                    opacity: opts.hover.opacity\n                });\n                if (opts.hover.shadow) labelBg.setAttribute('filter', `drop-shadow(${opts.hover.shadow})`);\n                gHover.appendChild(labelBg);\n                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n                Q(label).attr({\n                    fill: hoverText.color,\n                    'font-size': hoverText.fontSize,\n                    'font-family': hoverText.fontFamily,\n                    'font-weight': hoverText.fontWeight,\n                    'alignment-baseline': 'middle',\n                    'text-anchor': 'middle'\n                });\n                if (hoverText.shadow) label.setAttribute('filter', `drop-shadow(${hoverText.shadow})`);\n                if (opts.hover.wrap && labelText.includes('\\n')) {\n                    const lines = labelText.split('\\n');\n                    for (let i = 0; i < lines.length; i++) {\n                        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                        Q(tspan).attr({\n                            x: labelX + labelW / 2,\n                            dy: i === 0 ? '0' : (hoverText.fontSize) * 1.2\n                        });\n                        tspan.textContent = lines[i];\n                        label.appendChild(tspan);\n                    }\n                    label.setAttribute('y', labelY + hoverPadArr[0] + (hoverText.fontSize));\n                } else {\n                    label.setAttribute('x', labelX + labelW / 2);\n                    label.setAttribute('y', labelY + labelH / 2 + (hoverText.fontSize ? hoverText.fontSize / 3 - 2 : 6));\n                    label.textContent = labelText;\n                }\n                gHover.appendChild(label);\n                svg.appendChild(gHover);\n                svg.style.cursor = 'none';\n            };\n            svg.onmouseleave = function () {\n                let old = svg.querySelector('.q-graph-hover-label');\n                if (old) old.remove();\n                svg.style.cursor = opts.hover.cursor === false ? '' : (opts.hover.cursor === true ? 'pointer' : 'auto');\n            };\n        } else {\n            svg.style.cursor = '';\n            svg.onmousemove = null;\n            svg.onmouseleave = null;\n        }\n    }\n    const qsvg = Q(svg);\n    qsvg.data = function (arr) {\n        if (Array.isArray(arr)) {\n            dataY = arr;\n            dataX = arr.map((_, i) => i);\n        } else if (arr && typeof arr === 'object' && arr.x && arr.y) {\n            dataX = arr.x;\n            dataY = arr.y;\n        }\n        render();\n        return qsvg;\n    };\n    qsvg.add = function (val) {\n        if (typeof val === 'object' && val.x !== undefined && val.y !== undefined) {\n            dataX.push(val.x);\n            dataY.push(val.y);\n        } else if (typeof val === 'number') {\n            dataX.push(dataX.length);\n            dataY.push(val);\n        }\n        render();\n        return qsvg;\n    };\n    render();\n    return qsvg;\n};"
            },
            "Image.AutoAdjust": {
                "uuid": "f6ad1bef-9334-4f8d-9116-c9a891eaf5df",
                "name": "Image.AutoAdjust",
                "method": "Prototype",
                "desc": "Automatically adjusts tone, contrast, brightness, or color. Chainable. If the selection is empty, no action is taken and the chain continues.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.AutoAdjust({ mode: 'autoTone' }); });",
                    "Q.Image().Load('img.png').AutoAdjust({ mode: 'autoContrast', clipPercentage: 1 });",
                    "Q.Image().Load('img.png').AutoAdjust({ mode: 'autoTone' }).AutoAdjust({ mode: 'autoColor' }); // chaining",
                    "Q.Image([]).AutoAdjust({ mode: 'autoTone' }).AutoAdjust({ mode: 'autoContrast' }); // empty selection, no error, chain continues"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.AutoAdjust = function(autoAdjustOptions = {}) {\n    const defaultOptions = {\n        mode: 'autoTone',\n        clipPercentage: 0.5,\n        targetBrightness: 128,\n        neutralizeColors: true,\n        enhanceShadows: true,\n        enhanceHighlights: true,\n        preserveContrast: true,\n        strength: 1.0,\n        preserveHue: true,\n        clamp: true\n    };\n    const finalOptions = Object.assign({}, defaultOptions, autoAdjustOptions);\n    const canvas_node = this.node;\n    const ctx = canvas_node.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n    const pixels = imageData.data;\n    const pixelCount = pixels.length / 4;\n    const imageStats = analyzeImage(pixels, pixelCount);\n    switch (finalOptions.mode) {\n        case 'autoTone':\n            applyAutoTone(pixels, imageStats, finalOptions);\n            break;\n        case 'autoContrast':\n            applyAutoContrast(pixels, imageStats, finalOptions);\n            break;\n        case 'autoBrightness':\n            applyAutoBrightness(pixels, imageStats, finalOptions);\n            break;\n        case 'autoColor':\n            applyAutoColor(pixels, imageStats, finalOptions);\n            break;\n        default:\n            applyAutoTone(pixels, imageStats, finalOptions);\n    }\n    ctx.putImageData(imageData, 0, 0);\n    this.saveToHistory();\n    return this;\n};\nfunction applyAutoTone(pixels, imageStats, options) {\n    const { histogram, avgR, avgG, avgB } = imageStats;\n    const clipAmount = Math.floor(imageStats.pixelCount * (options.clipPercentage / 100));\n    const blackPoint = {\n        r: findBlackPoint(histogram.r, clipAmount, options.enhanceShadows),\n        g: findBlackPoint(histogram.g, clipAmount, options.enhanceShadows),\n        b: findBlackPoint(histogram.b, clipAmount, options.enhanceShadows)\n    };\n    const whitePoint = {\n        r: findWhitePoint(histogram.r, clipAmount, options.enhanceHighlights),\n        g: findWhitePoint(histogram.g, clipAmount, options.enhanceHighlights),\n        b: findWhitePoint(histogram.b, clipAmount, options.enhanceHighlights)\n    };\n    for (let i = 0; i < pixels.length; i += 4) {\n        let r = pixels[i];\n        let g = pixels[i + 1];\n        let b = pixels[i + 2];\n        const originalR = r;\n        const originalG = g;\n        const originalB = b;\n        const originalLuminance = 0.299 * r + 0.587 * g + 0.114 * b;\n        r = mapTone(r, blackPoint.r, whitePoint.r);\n        g = mapTone(g, blackPoint.g, whitePoint.g);\n        b = mapTone(b, blackPoint.b, whitePoint.b);\n        r = lerp(originalR, r, options.strength);\n        g = lerp(originalG, g, options.strength);\n        b = lerp(originalB, b, options.strength);\n        if (options.preserveHue && originalLuminance > 0) {\n            const newLuminance = 0.299 * r + 0.587 * g + 0.114 * b;\n            if (newLuminance > 0) {\n                const luminanceRatio = newLuminance / originalLuminance;\n                r = originalR * luminanceRatio;\n                g = originalG * luminanceRatio;\n                b = originalB * luminanceRatio;\n            }\n        }\n        if (options.clamp) {\n            r = Math.min(255, Math.max(0, r));\n            g = Math.min(255, Math.max(0, g));\n            b = Math.min(255, Math.max(0, b));\n        }\n        pixels[i] = r;\n        pixels[i + 1] = g;\n        pixels[i + 2] = b;\n    }\n}\nfunction applyAutoContrast(pixels, imageStats, options) {\n    const { histogram } = imageStats;\n    const clipAmount = Math.floor(imageStats.pixelCount * (options.clipPercentage / 100));\n    const blackPoint = findBlackPoint(histogram.luminance, clipAmount, true);\n    const whitePoint = findWhitePoint(histogram.luminance, clipAmount, true);\n    for (let i = 0; i < pixels.length; i += 4) {\n        let r = pixels[i];\n        let g = pixels[i + 1];\n        let b = pixels[i + 2];\n        const originalR = r;\n        const originalG = g;\n        const originalB = b;\n        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;\n        const newLuminance = mapTone(luminance, blackPoint, whitePoint);\n        if (luminance > 0) {\n            const luminanceRatio = newLuminance / luminance;\n            r = r * luminanceRatio;\n            g = g * luminanceRatio;\n            b = b * luminanceRatio;\n        }\n        r = lerp(originalR, r, options.strength);\n        g = lerp(originalG, g, options.strength);\n        b = lerp(originalB, b, options.strength);\n        if (options.clamp) {\n            r = Math.min(255, Math.max(0, r));\n            g = Math.min(255, Math.max(0, g));\n            b = Math.min(255, Math.max(0, b));\n        }\n        pixels[i] = r;\n        pixels[i + 1] = g;\n        pixels[i + 2] = b;\n    }\n}\nfunction applyAutoBrightness(pixels, imageStats, options) {\n    const { avgLuminance } = imageStats;\n    const targetBrightness = options.targetBrightness;\n    const brightnessAdjust = targetBrightness - avgLuminance;\n    const maxAdjustment = 80;\n    const actualAdjustment = Math.max(-maxAdjustment, Math.min(maxAdjustment, \n                             brightnessAdjust * options.strength));\n    for (let i = 0; i < pixels.length; i += 4) {\n        const r = pixels[i];\n        const g = pixels[i + 1];\n        const b = pixels[i + 2];\n        pixels[i] = Math.min(255, Math.max(0, r + actualAdjustment));\n        pixels[i + 1] = Math.min(255, Math.max(0, g + actualAdjustment));\n        pixels[i + 2] = Math.min(255, Math.max(0, b + actualAdjustment));\n    }\n}\nfunction applyAutoColor(pixels, imageStats, options) {\n    const { avgR, avgG, avgB } = imageStats;\n    const neutralGray = (avgR + avgG + avgB) / 3;\n    const rFactor = neutralGray / avgR;\n    const gFactor = neutralGray / avgG;\n    const bFactor = neutralGray / avgB;\n    const limitFactor = 2.0;\n    const rAdjust = Math.max(1/limitFactor, Math.min(limitFactor, rFactor));\n    const gAdjust = Math.max(1/limitFactor, Math.min(limitFactor, gFactor));\n    const bAdjust = Math.max(1/limitFactor, Math.min(limitFactor, bFactor));\n    for (let i = 0; i < pixels.length; i += 4) {\n        let r = pixels[i];\n        let g = pixels[i + 1];\n        let b = pixels[i + 2];\n        const originalR = r;\n        const originalG = g;\n        const originalB = b;\n        const originalLuminance = 0.299 * r + 0.587 * g + 0.114 * b;\n        r = r * rAdjust;\n        g = g * gAdjust;\n        b = b * bAdjust;\n        r = lerp(originalR, r, options.strength);\n        g = lerp(originalG, g, options.strength);\n        b = lerp(originalB, b, options.strength);\n        if (options.preserveHue && originalLuminance > 0) {\n            const newLuminance = 0.299 * r + 0.587 * g + 0.114 * b;\n            if (newLuminance > 0) {\n                const luminanceRatio = newLuminance / originalLuminance;\n                r = originalR * luminanceRatio;\n                g = originalG * luminanceRatio;\n                b = originalB * luminanceRatio;\n            }\n        }\n        if (options.clamp) {\n            r = Math.min(255, Math.max(0, r));\n            g = Math.min(255, Math.max(0, g));\n            b = Math.min(255, Math.max(0, b));\n        }\n        pixels[i] = r;\n        pixels[i + 1] = g;\n        pixels[i + 2] = b;\n    }\n}\nfunction analyzeImage(pixels, pixelCount) {\n    const histogram = {\n        r: new Array(256).fill(0),\n        g: new Array(256).fill(0),\n        b: new Array(256).fill(0),\n        luminance: new Array(256).fill(0)\n    };\n    let totalR = 0, totalG = 0, totalB = 0, totalLuminance = 0;\n    let minR = 255, minG = 255, minB = 255, minLuminance = 255;\n    let maxR = 0, maxG = 0, maxB = 0, maxLuminance = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n        const r = pixels[i];\n        const g = pixels[i + 1];\n        const b = pixels[i + 2];\n        histogram.r[r]++;\n        histogram.g[g]++;\n        histogram.b[b]++;\n        const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b);\n        histogram.luminance[luminance]++;\n        totalR += r;\n        totalG += g;\n        totalB += b;\n        totalLuminance += luminance;\n        minR = Math.min(minR, r);\n        minG = Math.min(minG, g);\n        minB = Math.min(minB, b);\n        minLuminance = Math.min(minLuminance, luminance);\n        maxR = Math.max(maxR, r);\n        maxG = Math.max(maxG, g);\n        maxB = Math.max(maxB, b);\n        maxLuminance = Math.max(maxLuminance, luminance);\n    }\n    const avgR = totalR / pixelCount;\n    const avgG = totalG / pixelCount;\n    const avgB = totalB / pixelCount;\n    const avgLuminance = totalLuminance / pixelCount;\n    return {\n        histogram,\n        pixelCount,\n        avgR, avgG, avgB, avgLuminance,\n        minR, minG, minB, minLuminance,\n        maxR, maxG, maxB, maxLuminance\n    };\n}\nfunction findBlackPoint(histogram, clipAmount, enhanceShadows) {\n    let count = 0;\n    let blackPoint = 0;\n    for (let i = 0; i < 256; i++) {\n        count += histogram[i];\n        if (count > clipAmount) {\n            blackPoint = i;\n            break;\n        }\n    }\n    if (enhanceShadows) {\n        blackPoint = Math.max(0, blackPoint - 5);\n    }\n    return blackPoint;\n}\nfunction findWhitePoint(histogram, clipAmount, enhanceHighlights) {\n    let count = 0;\n    let whitePoint = 255;\n    for (let i = 255; i >= 0; i--) {\n        count += histogram[i];\n        if (count > clipAmount) {\n            whitePoint = i;\n            break;\n        }\n    }\n    if (enhanceHighlights) {\n        whitePoint = Math.min(255, whitePoint + 5);\n    }\n    return whitePoint;\n}\nfunction mapTone(value, blackPoint, whitePoint) {\n    if (whitePoint <= blackPoint) {\n        whitePoint = blackPoint + 1;\n    }\n    return 255 * (value - blackPoint) / (whitePoint - blackPoint);\n}\nfunction lerp(a, b, t) {\n    return a + (b - a) * Math.max(0, Math.min(1, t));\n}\nQ.Image.prototype.AutoTone = function(options = {}) {\n    return this.AutoAdjust(Object.assign({}, options, { mode: 'autoTone' }));\n};\nQ.Image.prototype.AutoContrast = function(options = {}) {\n    return this.AutoAdjust(Object.assign({}, options, { mode: 'autoContrast' }));\n};\nQ.Image.prototype.AutoBrightness = function(options = {}) {\n    return this.AutoAdjust(Object.assign({}, options, { mode: 'autoBrightness' }));\n};\nQ.Image.prototype.AutoColor = function(options = {}) {\n    return this.AutoAdjust(Object.assign({}, options, { mode: 'autoColor' }));\n};"
            },
            "Image.Blur": {
                "uuid": "9afcf033-8312-41ba-a731-b9df43848a77",
                "name": "Image.Blur",
                "method": "Prototype",
                "desc": "Applies a blur effect to the image using various kernels.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Blur({ radius: 10, type: 'gaussian' }); });",
                    "Q.Image().Load('img.png').Blur({ type: 'motion', direction: 45, distance: 20 });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Blur = function (options = {}) {\n  const DEFAULTS = {\n    type: 'gaussian',\n    radius: 5,\n    quality: 1,\n    direction: 0,\n    distance: 10,\n    focalDistance: 0.5,\n    shape: 'circle',\n    blades: 6,\n    bladeCurvature: 0,\n    rotation: 0,\n    specularHighlights: 0,\n    noise: 0\n  };\n  const settings = Object.assign({}, DEFAULTS, options);\n  settings.radius = Math.max(1, Math.floor(settings.radius));\n  settings.quality = Math.max(1, Math.round(settings.quality));\n  settings.distance = Math.max(1, Math.round(settings.distance));\n  settings.blades = Math.min(8, Math.max(5, Math.floor(settings.blades)));\n  settings.bladeCurvature = clamp01(settings.bladeCurvature);\n  settings.focalDistance = clamp01(settings.focalDistance);\n  settings.specularHighlights = clamp01(settings.specularHighlights);\n  settings.noise = clamp01(settings.noise);\n  const ctx = this.node.getContext('2d', { willReadFrequently: true });\n  const { width, height } = this.node;\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const srcPixels = imageData.data;\n  const dstPixels = new Uint8ClampedArray(srcPixels);\n  const { kernel, size } = buildKernel(settings);\n  for (let i = 0; i < settings.quality; i++) {\n    convolve(srcPixels, dstPixels, width, height, kernel, size);\n    srcPixels.set(dstPixels);\n  }\n  imageData.data.set(dstPixels);\n  ctx.putImageData(imageData, 0, 0);\n  this.saveToHistory();\n  return this;\n};\nfunction clamp01(v) { return v < 0 ? 0 : v > 1 ? 1 : v; }\nfunction buildKernel(s) {\n  switch (s.type.toLowerCase()) {\n    case 'box':\n      return createBoxKernel(s.radius);\n    case 'motion':\n      return createMotionKernel(s.radius, s.distance, s.direction);\n    case 'lens':\n      return createLensKernel(s);\n    case 'gaussian':\n    default:\n      return createGaussianKernel(s.radius);\n  }\n}\nfunction createGaussianKernel(radius) {\n  radius = Math.max(0, Math.floor(radius));\n  const size = 2 * radius + 1;\n  if (size < 1 || !Number.isInteger(size)) {\n    console.warn(\"Gaussian kernel: Invalid size derived from radius, using fallback 1x1 kernel.\");\n    return { kernel: new Float32Array([1]), size: 1 };\n  }\n  if (radius === 0) {\n    return { kernel: new Float32Array([1]), size: 1 };\n  }\n  const kernel = new Float32Array(size * size);\n  const sigma = radius / 3; \n  const twoSigmaSquare = 2 * sigma * sigma;\n  let sum = 0;\n  const center = radius; \n  for (let y = 0; y < size; y++) {\n    for (let x = 0; x < size; x++) {\n      const dx = x - center;\n      const dy = y - center;\n      const weight = Math.exp(-(dx * dx + dy * dy) / twoSigmaSquare);\n      kernel[y * size + x] = weight;\n      sum += weight;\n    }\n  }\n  if (sum <= 0 || !isFinite(sum)) {\n    console.warn(\"Gaussian kernel: Sum is zero or non-finite (\" + sum + \"), using fallback 1x1 kernel.\");\n    kernel.fill(0);\n    const centerIndex = center * size + center;\n    if (centerIndex >= 0 && centerIndex < kernel.length) {\n      kernel[centerIndex] = 1;\n    } else {\n      return { kernel: new Float32Array([1]), size: 1 };\n    }\n    sum = 1; \n  } else {\n    for (let i = 0; i < kernel.length; i++) {\n      kernel[i] /= sum;\n      if (!isFinite(kernel[i])) {\n        console.warn(\"Gaussian kernel: Non-finite value after normalization, resetting to fallback 1x1 kernel.\");\n        kernel.fill(0);\n        kernel[center * size + center] = 1; \n        break; \n      }\n    }\n  }\n  return { kernel, size };\n}\nfunction createBoxKernel(radius) {\n  const size = 2 * radius + 1;\n  const kernel = new Float32Array(size * size).fill(1 / (size * size));\n  return { kernel, size };\n}\nfunction createMotionKernel(radius, distance, direction) {\n  const size = 2 * distance + 1;\n  const kernel = new Float32Array(size * size).fill(0);\n  const half = Math.floor(size / 2);\n  const angle = direction * Math.PI / 180; \n  let totalWeight = 0;\n  for (let t = -half; t <= half; t++) {\n    const x = Math.round(Math.cos(angle) * t) + half;\n    const y = Math.round(Math.sin(angle) * t) + half;\n    if (x >= 0 && x < size && y >= 0 && y < size) {\n      let weight = 1;\n      if (radius > 1) {\n        const dist = Math.abs(t) / half;\n        weight = Math.exp(-dist * dist / (2 * (radius / distance) * (radius / distance)));\n      }\n      kernel[y * size + x] = weight;\n      totalWeight += weight;\n    }\n  }\n  if (totalWeight > 0) {\n    for (let i = 0; i < kernel.length; i++) {\n      kernel[i] /= totalWeight;\n    }\n  }\n  return { kernel, size };\n}\nfunction createLensKernel({ radius, shape, blades, bladeCurvature, rotation, focalDistance, specularHighlights, noise }) {\n  const size = 2 * radius + 1;\n  const kernel = new Float32Array(size * size).fill(0);\n  const half = radius;\n  const rotationRad = rotation * Math.PI / 180; \n  const focalFactor = 1 - focalDistance;\n  let totalWeight = 0;\n  for (let y = 0; y < size; y++) {\n    for (let x = 0; x < size; x++) {\n      const dx = x - half;\n      const dy = y - half;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      if (distance <= radius) {\n        const angle = Math.atan2(dy, dx) + rotationRad;\n        let weight = 0;\n        switch (shape) {\n          case 'hexagon':\n          case 'pentagon':\n          case 'octagon':\n            const bladeAngle = 2 * Math.PI / blades;\n            const normalizedAngle = (angle % bladeAngle) / bladeAngle - 0.5;\n            const bladeDistance = radius * (1 - bladeCurvature * Math.abs(normalizedAngle));\n            weight = distance <= bladeDistance ? 1 : 0;\n            break;\n          case 'circle':\n          default:\n            weight = 1;\n            const normalizedDist = distance / radius;\n            if (normalizedDist > focalFactor) {\n              weight *= Math.max(0, 1 - (normalizedDist - focalFactor) / (1 - focalFactor));\n            }\n            break;\n        }\n        if (specularHighlights > 0) {\n          const highlightFactor = Math.max(0, 1 - distance / radius);\n          weight *= 1 + specularHighlights * highlightFactor * 2;\n        }\n        if (noise > 0) {\n          weight *= 1 + (Math.random() - 0.5) * noise;\n        }\n        kernel[y * size + x] = Math.max(0, weight);\n        totalWeight += kernel[y * size + x];\n      }\n    }\n  }\n  if (totalWeight > 0) {\n    for (let i = 0; i < kernel.length; i++) {\n      kernel[i] /= totalWeight;\n    }\n  }\n  return { kernel, size };\n}\nfunction convolve(src, dst, width, height, kernel, size) {\n  const half = Math.floor(size / 2);\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0, g = 0, b = 0, a = 0;\n      const dstOff = (y * width + x) * 4;\n      let weightSum = 0;\n      for (let ky = 0; ky < size; ky++) {\n        for (let kx = 0; kx < size; kx++) {\n          const ny = y + ky - half;\n          const nx = x + kx - half;\n          if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n            const srcOff = (ny * width + nx) * 4;\n            const weight = kernel[ky * size + kx];\n            if (isFinite(weight)) {\n              r += src[srcOff] * weight;\n              g += src[srcOff + 1] * weight;\n              b += src[srcOff + 2] * weight;\n              a += src[srcOff + 3] * weight;\n              weightSum += weight;\n            }\n          }\n        }\n      }\n      if (weightSum > 0 && isFinite(weightSum)) {\n        dst[dstOff] = r / weightSum;\n        dst[dstOff + 1] = g / weightSum;\n        dst[dstOff + 2] = b / weightSum;\n        dst[dstOff + 3] = a / weightSum;\n      } else {\n        dst[dstOff] = src[dstOff];\n        dst[dstOff + 1] = src[dstOff + 1];\n        dst[dstOff + 2] = src[dstOff + 2];\n        dst[dstOff + 3] = src[dstOff + 3];\n      }\n    }\n  }\n};"
            },
            "Image.Brightness": {
                "uuid": "94e5c80c-c89a-418f-81df-616eb2709c06",
                "name": "Image.Brightness",
                "method": "Prototype",
                "desc": "Adjusts the brightness of the image.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Brightness(40); });",
                    "Q.Image().Load('img.png').Brightness(-20, { clamp: false });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Brightness = function (value, brightOptions = {}) {\n    const defaultOptions = {\n        preserveAlpha: true,\n        clamp: true\n    };\n    const finalOptions = Object.assign({}, defaultOptions, brightOptions);\n    const canvas_node = this.node;\n    let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n    let pixels = data.data;\n    for (let i = 0; i < pixels.length; i += 4) {\n        pixels[i] += value;\n        pixels[i + 1] += value;\n        pixels[i + 2] += value;\n        if (finalOptions.clamp) {\n            pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n            pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n            pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n        }\n    }\n    canvas_node.getContext('2d').putImageData(data, 0, 0);\n    this.saveToHistory();\n    return this;\n};"
            },
            "Image.ComicEffect": {
                "uuid": "89ed7bf2-93b0-4911-929e-4aa7f21945a4",
                "name": "Image.ComicEffect",
                "method": "Prototype",
                "desc": "Applies a comic-style color quantization and optional edge detection. Chainable. If the selection is empty, no action is taken and the chain continues.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.ComicEffect(6, { edgeDetection: true }); });",
                    "Q.Image().Load('img.png').ComicEffect(4, { saturation: 1.5 });",
                    "Q.Image().Load('img.png').ComicEffect(8).ComicEffect(2, { edgeDetection: false }); // chaining",
                    "Q.Image([]).ComicEffect(6).ComicEffect(4); // empty selection, no error, chain continues"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.ComicEffect = function (colorSteps = 4, effectOptions = {}) {\n    const defaultOptions = {\n        redSteps: colorSteps,\n        greenSteps: colorSteps,\n        blueSteps: colorSteps,\n        edgeDetection: false,\n        edgeThickness: 1,\n        edgeThreshold: 20,\n        saturation: 1.2\n    };\n    const finalOptions = Object.assign({}, defaultOptions, effectOptions);\n    const canvas_node = this.node;\n    this.saveToHistory();\n    let temp = Q('<canvas>', {\n        width: canvas_node.width,\n        height: canvas_node.height\n    }).nodes[0];\n    let ctx = temp.getContext('2d', { willReadFrequently: true });\n    ctx.drawImage(canvas_node, 0, 0);\n    const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n    const pixels = imageData.data;\n    const redIntervalSize = 256 / finalOptions.redSteps;\n    const greenIntervalSize = 256 / finalOptions.greenSteps;\n    const blueIntervalSize = 256 / finalOptions.blueSteps;\n    for (let i = 0; i < pixels.length; i += 4) {\n        if (finalOptions.saturation !== 1.0) {\n            let r = pixels[i] / 255;\n            let g = pixels[i + 1] / 255;\n            let b = pixels[i + 2] / 255;\n            const max = Math.max(r, g, b);\n            const min = Math.min(r, g, b);\n            let h, s, l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0;\n            } else {\n                const d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch (max) {\n                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                    case g: h = (b - r) / d + 2; break;\n                    case b: h = (r - g) / d + 4; break;\n                }\n                h /= 6;\n            }\n            s = Math.min(1, s * finalOptions.saturation);\n            if (s === 0) {\n                r = g = b = l;\n            } else {\n                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                const p = 2 * l - q;\n                r = hue2rgb(p, q, h + 1 / 3);\n                g = hue2rgb(p, q, h);\n                b = hue2rgb(p, q, h - 1 / 3);\n            }\n            pixels[i] = Math.round(r * 255);\n            pixels[i + 1] = Math.round(g * 255);\n            pixels[i + 2] = Math.round(b * 255);\n        }\n        const redIndex = Math.floor(pixels[i] / redIntervalSize);\n        const greenIndex = Math.floor(pixels[i + 1] / greenIntervalSize);\n        const blueIndex = Math.floor(pixels[i + 2] / blueIntervalSize);\n        pixels[i] = redIndex * redIntervalSize;\n        pixels[i + 1] = greenIndex * greenIntervalSize;\n        pixels[i + 2] = blueIndex * blueIntervalSize;\n    }\n    if (finalOptions.edgeDetection) {\n        const edgeImageData = new ImageData(\n            new Uint8ClampedArray(pixels),\n            temp.width,\n            temp.height\n        );\n        for (let y = finalOptions.edgeThickness; y < temp.height - finalOptions.edgeThickness; y++) {\n            for (let x = finalOptions.edgeThickness; x < temp.width - finalOptions.edgeThickness; x++) {\n                const pos = (y * temp.width + x) * 4;\n                let edgeDetected = false;\n                const leftPos = (y * temp.width + (x - finalOptions.edgeThickness)) * 4;\n                const rightPos = (y * temp.width + (x + finalOptions.edgeThickness)) * 4;\n                const topPos = ((y - finalOptions.edgeThickness) * temp.width + x) * 4;\n                const bottomPos = ((y + finalOptions.edgeThickness) * temp.width + x) * 4;\n                const diffH = Math.abs(pixels[leftPos] - pixels[rightPos]) +\n                    Math.abs(pixels[leftPos + 1] - pixels[rightPos + 1]) +\n                    Math.abs(pixels[leftPos + 2] - pixels[rightPos + 2]);\n                const diffV = Math.abs(pixels[topPos] - pixels[bottomPos]) +\n                    Math.abs(pixels[topPos + 1] - pixels[bottomPos + 1]) +\n                    Math.abs(pixels[topPos + 2] - pixels[bottomPos + 2]);\n                if (diffH > finalOptions.edgeThreshold || diffV > finalOptions.edgeThreshold) {\n                    edgeImageData.data[pos] = 0;\n                    edgeImageData.data[pos + 1] = 0;\n                    edgeImageData.data[pos + 2] = 0;\n                }\n            }\n        }\n        ctx.putImageData(edgeImageData, 0, 0);\n    } else {\n        ctx.putImageData(imageData, 0, 0);\n    }\n    canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n    canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    return this;\n};\nfunction hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}"
            },
            "Image.Contrast": {
                "uuid": "cd4c39fc-7bfe-4608-913f-370ca6730696",
                "name": "Image.Contrast",
                "method": "Prototype",
                "desc": "Adjusts the contrast of the image. Chainable. If the selection is empty, no action is taken and the chain continues.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Contrast(50); });",
                    "Q.Image().Load('img.png').Contrast(-30, { preserveHue: false });",
                    "Q.Image().Load('img.png').Contrast(0).Contrast(100).Contrast(-100); // chaining",
                    "Q.Image([]).Contrast(50).Contrast(-50); // empty selection, no error, chain continues"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Contrast = function (value, contrastOptions = {}) {\n    const defaultOptions = {\n        preserveHue: true,\n        clamp: true\n    };\n    const finalOptions = Object.assign({}, defaultOptions, contrastOptions);\n    const canvas_node = this.node;\n    let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n    let pixels = data.data;\n    let factor = (259 * (value + 255)) / (255 * (259 - value));\n    for (let i = 0; i < pixels.length; i += 4) {\n        pixels[i] = factor * (pixels[i] - 128) + 128;\n        pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n        pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n        if (finalOptions.clamp) {\n            pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n            pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n            pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n        }\n    }\n    canvas_node.getContext('2d').putImageData(data, 0, 0);\n    this.saveToHistory();\n    return this;\n};"
            },
            "Image.Crop": {
                "uuid": "cb43df19-10e0-44d2-a23b-e112f9501a66",
                "name": "Image.Crop",
                "method": "Prototype",
                "desc": "Crops the image to a specified rectangle.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 400, height: 300 });\nimg.Load('photo.jpg', function() { img.Crop(50, 50, 200, 100); });",
                    "Q.Image().Load('img.png').Crop(10, 10, 100, 100, { preserveContext: false });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Crop = function (x, y, width, height, cropOptions = {}) {\n    const defaultOptions = {\n        preserveContext: true\n    };\n    this.saveToHistory();\n    const finalOptions = Object.assign({}, defaultOptions, cropOptions);\n    const canvas_node = this.node;\n    let temp = Q('<canvas>', { width: width, height: height }).nodes[0];\n    let tempCtx = temp.getContext('2d');\n    if (finalOptions.preserveContext) {\n        const ctx = canvas_node.getContext('2d');\n        tempCtx.globalAlpha = ctx.globalAlpha;\n        tempCtx.globalCompositeOperation = ctx.globalCompositeOperation;\n    }\n    tempCtx.drawImage(canvas_node, x, y, width, height, 0, 0, width, height);\n    canvas_node.width = width;\n    canvas_node.height = height;\n    canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    return this;\n};"
            },
            "Image.CRT": {
                "uuid": "1ac93ab5-816b-4e9c-9443-a2e6bfda9aa1",
                "name": "Image.CRT",
                "method": "Prototype",
                "desc": "Applies a CRT (cathode ray tube) simulation effect to the image. Chainable. If the selection is empty, no action is taken and the chain continues.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 320, height: 240 });\nimg.Load('photo.jpg', function() { img.CRT({ scanlineOpacity: 0.2, curvature: true }); });",
                    "Q.Image().Load('img.png').CRT({ vignette: true, noiseStrength: 20 });",
                    "Q.Image().Load('img.png').CRT({ curvature: true }).CRT({ scanlineOpacity: 0.5 }); // chaining",
                    "Q.Image([]).CRT({ scanlineOpacity: 0.2 }).CRT({ vignette: true }); // empty selection, no error, chain continues"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.CRT = function (crtOptions = {}) {\n    const defaultOptions = {\n        noiseStrength: 10,\n        strongNoiseStrength: 100,\n        strongNoiseCount: 5,\n        noiseMaxLength: 20000,\n        redShift: 3,\n        blueShift: 3,\n        scanlineHeight: 1,\n        scanlineMargin: 3,\n        scanlineOpacity: 0.1,\n        vignette: false,\n        vignetteStrength: 0.5,\n        scanlineBrightness: 0.5,\n        rgbOffset: 0,\n        curvature: true,\n        curvatureAmount: 0.1,\n        curvatureX: 50,\n        curvatureY: 50,\n        curvatureArc: 15,\n        curvatureType: \"convex\",\n        zoom: 0,\n        autoFill: false,\n        verticalWobble: 5,\n        horizontalWobble: 2,\n        wobbleSpeed: 10,\n        colorBleed: 0,\n        jitterChance: 0,\n    };\n    const finalOptions = Object.assign({}, defaultOptions, crtOptions);\n    finalOptions.curvatureArc = Math.max(0, Math.min(45, finalOptions.curvatureArc));\n    const curvatureAmountFromArc = finalOptions.curvatureArc / 45 * 0.3;\n    let curveAmount = Math.min(finalOptions.curvatureAmount, curvatureAmountFromArc);\n    if (finalOptions.curvatureType === \"concave\") {\n        curveAmount = -curveAmount;\n    }\n    finalOptions._effectiveCurvatureAmount = curveAmount;\n    let zoom = (typeof finalOptions.zoom === \"number\" ? finalOptions.zoom : 0) / 100;\n    if (finalOptions.autoFill && finalOptions.curvature && finalOptions.curvatureType === \"concave\") {\n        const maxDistSq = 1 * 1 + 1 * 1;\n        const absCurve = Math.abs(curveAmount);\n        const distortion = 1 + maxDistSq * absCurve;\n        zoom = Math.max(zoom, distortion - 1);\n    }\n    const canvas_node = this.node;\n    this.saveToHistory();\n    let temp = Q('<canvas>', {\n        width: canvas_node.width,\n        height: canvas_node.height\n    }).nodes[0];\n    let ctx = temp.getContext('2d', { willReadFrequently: true });\n    ctx.drawImage(canvas_node, 0, 0);\n    const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n    const data = imageData.data;\n    function clamp(value, min, max) {\n        return Math.min(Math.max(value, min), max);\n    }\n    function CRTRandomBetween(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    const noiseStrength = finalOptions.noiseStrength;\n    for (let i = 0; i < data.length; i += 4) {\n        const noise = (Math.random() - 0.5) * noiseStrength;\n        data[i] = clamp(data[i] + noise, 0, 255);\n        data[i + 1] = clamp(data[i + 1] + noise, 0, 255);\n        data[i + 2] = clamp(data[i + 2] + noise, 0, 255);\n    }\n    const strongNoiseStrength = finalOptions.strongNoiseStrength;\n    const strongNoiseCount = finalOptions.strongNoiseCount;\n    const noiseMaxLength = finalOptions.noiseMaxLength;\n    for (let i0 = 0; i0 < strongNoiseCount; i0++) {\n        const startPos = CRTRandomBetween(\n            CRTRandomBetween(0, data.length - noiseMaxLength),\n            data.length - noiseMaxLength\n        );\n        const endPos = startPos + CRTRandomBetween(0, noiseMaxLength);\n        for (let i = startPos; i < endPos; i += 4) {\n            if (i + 2 < data.length) {\n                const noise = (Math.random() - 0.4) * strongNoiseStrength;\n                data[i] = clamp(data[i] + noise, 0, 255);\n                data[i + 1] = clamp(data[i + 1] + noise, 0, 255);\n                data[i + 2] = clamp(data[i + 2] + noise, 0, 255);\n            }\n        }\n    }\n    let wobbleCanvas = Q('<canvas>', {\n        width: canvas_node.width,\n        height: canvas_node.height\n    }).nodes[0];\n    let wobbleCtx = wobbleCanvas.getContext('2d', { willReadFrequently: true });\n    const tempData = new Uint8ClampedArray(data);\n    const redShift = finalOptions.redShift;\n    const blueShift = finalOptions.blueShift;\n    const rgbOffset = finalOptions.rgbOffset;\n    if (finalOptions.colorBleed > 0) {\n        const bleed = Math.floor(finalOptions.colorBleed);\n        for (let y = 0; y < temp.height; y++) {\n            for (let x = 0; x < temp.width; x++) {\n                const currentIndex = (y * temp.width + x) * 4;\n                if (x + bleed < temp.width) {\n                    const bleedIndex = (y * temp.width + (x + bleed)) * 4;\n                    data[bleedIndex] = Math.max(data[bleedIndex], data[currentIndex] * 0.7);\n                }\n                if (y > bleed) {\n                    const bleedIndex = ((y - bleed) * temp.width + x) * 4 + 2;\n                    data[bleedIndex] = Math.max(data[bleedIndex], data[currentIndex + 2] * 0.7);\n                }\n            }\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    wobbleCtx.drawImage(temp, 0, 0);\n    const resultCtx = canvas_node.getContext('2d', { willReadFrequently: true });\n    resultCtx.clearRect(0, 0, canvas_node.width, canvas_node.height);\n    let applyScanlines = !finalOptions.subpixelEmulation || !finalOptions.applyScanlineAfterSubpixel;\n    if (finalOptions.jitterChance > 0 && Math.random() * 100 < finalOptions.jitterChance) {\n        const jumpOffset = CRTRandomBetween(5, 20);\n        resultCtx.drawImage(wobbleCanvas, 0, jumpOffset, canvas_node.width, canvas_node.height - jumpOffset);\n        resultCtx.drawImage(wobbleCanvas, 0, 0, canvas_node.width, jumpOffset, 0, canvas_node.height - jumpOffset, canvas_node.width, jumpOffset);\n    } else {\n        const vWobbleAmp = finalOptions.verticalWobble;\n        const hWobbleAmp = finalOptions.horizontalWobble;\n        const wobbleSpeed = finalOptions.wobbleSpeed / 10;\n        const timePhase = Date.now() / 1000 * wobbleSpeed;\n        if (finalOptions.curvature) {\n            const curveAmount = finalOptions._effectiveCurvatureAmount;\n            const centerX = Math.round((finalOptions.curvatureX / 100) * canvas_node.width);\n            const centerY = Math.round((finalOptions.curvatureY / 100) * canvas_node.height);\n            for (let y = 0; y < canvas_node.height; y++) {\n                const ny = ((y - centerY) / canvas_node.height) * 2;\n                const vWobble = vWobbleAmp * Math.sin(y / 30 + timePhase);\n                for (let x = 0; x < canvas_node.width; x++) {\n                    const nx = ((x - centerX) / canvas_node.width) * 2;\n                    let zx = nx / (1 + zoom);\n                    let zy = ny / (1 + zoom);\n                    const hWobble = hWobbleAmp * Math.sin(x / 20 + timePhase * 0.7);\n                    const distSq = zx * zx + zy * zy;\n                    const distortion = 1 + distSq * curveAmount;\n                    const srcX = Math.round(centerX + (zx / distortion) * (canvas_node.width / 2) + hWobble);\n                    const srcY = Math.round(centerY + (zy / distortion) * (canvas_node.height / 2) + vWobble);\n                    if (srcX >= 0 && srcX < canvas_node.width && srcY >= 0 && srcY < canvas_node.height) {\n                        if (rgbOffset > 0) {\n                            const rOffset = Math.min(canvas_node.width - 1, srcX + Math.floor(rgbOffset));\n                            const gOffset = srcX;\n                            const bOffset = Math.max(0, srcX - Math.floor(rgbOffset));\n                            const rData = wobbleCtx.getImageData(rOffset, srcY, 1, 1).data;\n                            const gData = wobbleCtx.getImageData(gOffset, srcY, 1, 1).data;\n                            const bData = wobbleCtx.getImageData(bOffset, srcY, 1, 1).data;\n                            resultCtx.fillStyle = `rgb(${rData[0]}, ${gData[1]}, ${bData[2]})`;\n                            resultCtx.fillRect(x, y, 1, 1);\n                        } else {\n                            const pixelData = wobbleCtx.getImageData(srcX, srcY, 1, 1).data;\n                            resultCtx.fillStyle = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3] / 255})`;\n                            resultCtx.fillRect(x, y, 1, 1);\n                        }\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < canvas_node.height; y++) {\n                const vWobble = vWobbleAmp * Math.sin(y / 30 + timePhase);\n                for (let x = 0; x < canvas_node.width; x++) {\n                    const hWobble = hWobbleAmp * Math.sin(x / 20 + timePhase * 0.7);\n                    const srcX = Math.round(x + hWobble);\n                    const srcY = Math.round(y + vWobble);\n                    if (srcX >= 0 && srcX < canvas_node.width && srcY >= 0 && srcY < canvas_node.height) {\n                        if (rgbOffset > 0) {\n                            const rOffset = Math.min(canvas_node.width - 1, srcX + Math.floor(rgbOffset));\n                            const gOffset = srcX;\n                            const bOffset = Math.max(0, srcX - Math.floor(rgbOffset));\n                            const rData = wobbleCtx.getImageData(rOffset, srcY, 1, 1).data;\n                            const gData = wobbleCtx.getImageData(gOffset, srcY, 1, 1).data;\n                            const bData = wobbleCtx.getImageData(bOffset, srcY, 1, 1).data;\n                            resultCtx.fillStyle = `rgb(${rData[0]}, ${gData[1]}, ${bData[2]})`;\n                            resultCtx.fillRect(x, y, 1, 1);\n                        } else {\n                            const pixelData = wobbleCtx.getImageData(srcX, srcY, 1, 1).data;\n                            resultCtx.fillStyle = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3] / 255})`;\n                            resultCtx.fillRect(x, y, 1, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    function drawHorizontalLines(ctx, width, height, totalHeight, margin, color, brightnessFactor) {\n        ctx.fillStyle = color;\n        for (let i = 0; i < totalHeight; i += (height + margin)) {\n            ctx.fillRect(0, i, width, height);\n            if (brightnessFactor > 0 && i + height < totalHeight) {\n                const brightColor = `rgba(255, 255, 255, ${brightnessFactor * 0.1})`;\n                ctx.fillStyle = brightColor;\n                ctx.fillRect(0, i + height, width, margin);\n                ctx.fillStyle = color;\n            }\n        }\n    }\n    if (applyScanlines) {\n        drawHorizontalLines(\n            resultCtx,\n            canvas_node.width,\n            finalOptions.scanlineHeight,\n            canvas_node.height,\n            finalOptions.scanlineMargin,\n            `rgba(0, 0, 0, ${finalOptions.scanlineOpacity})`,\n            finalOptions.scanlineBrightness\n        );\n    }\n    if (finalOptions.subpixelEmulation && finalOptions.applyScanlineAfterSubpixel) {\n        drawHorizontalLines(\n            resultCtx,\n            canvas_node.width,\n            finalOptions.scanlineHeight,\n            canvas_node.height,\n            finalOptions.scanlineMargin,\n            `rgba(0, 0, 0, ${finalOptions.scanlineOpacity})`,\n            finalOptions.scanlineBrightness\n        );\n    }\n    if (finalOptions.vignette) {\n        const centerX = canvas_node.width / 2;\n        const centerY = canvas_node.height / 2;\n        const radius = Math.max(centerX, centerY);\n        const gradient = resultCtx.createRadialGradient(\n            centerX, centerY, radius * 0.5,\n            centerX, centerY, radius * 1.5\n        );\n        gradient.addColorStop(0, 'rgba(0,0,0,0)');\n        gradient.addColorStop(1, `rgba(0,0,0,${finalOptions.vignetteStrength})`);\n        resultCtx.fillStyle = gradient;\n        resultCtx.globalCompositeOperation = 'multiply';\n        resultCtx.fillRect(0, 0, canvas_node.width, canvas_node.height);\n        resultCtx.globalCompositeOperation = 'source-over';\n    }\n    return this;\n};"
            },
            "Image.Flip": {
                "uuid": "47509588-6b09-4ab3-b039-684e86bae999",
                "name": "Image.Flip",
                "method": "Prototype",
                "desc": "Flips the image horizontally, vertically, or both.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Flip('vertical'); });",
                    "Q.Image().Load('img.png').Flip('both', { quality: 'medium' });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Flip = function(direction = 'horizontal', flipOptions = {}) {\n        const defaultOptions = {\n            smoothing: true,    // Whether to use smoothing\n            quality: 'high'     // Smoothing quality: 'low', 'medium', 'high'\n        };\n        const finalOptions = Object.assign({}, defaultOptions, flipOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d');\n        this.saveToHistory(); // Save the current state to history\n        ctx.imageSmoothingEnabled = finalOptions.smoothing;\n        ctx.imageSmoothingQuality = finalOptions.quality;\n        if (direction === 'horizontal') {\n            ctx.translate(canvas_node.width, 0);\n            ctx.scale(-1, 1);\n        } else if (direction === 'vertical') {\n            ctx.translate(0, canvas_node.height);\n            ctx.scale(1, -1);\n        } else if (direction === 'both') {\n            ctx.translate(canvas_node.width, canvas_node.height);\n            ctx.scale(-1, -1);\n        }\n        ctx.drawImage(canvas_node, 0, 0);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
            },
            "Image.Glitch": {
                "uuid": "3efb9037-3bac-4535-9d26-c853d0040d7b",
                "name": "Image.Glitch",
                "method": "Prototype",
                "desc": "Applies a glitch effect to the image using various algorithms.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 320, height: 240 });\nimg.Load('photo.jpg', function() { img.Glitch({ type: 'datamosh', counts: 8 }); });",
                    "Q.Image().Load('img.png').Glitch({ type: 'pixelsort', pixelsortAxis: 'horizontal' });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Glitch = function (options = {}) {\n    const defaults = {\n        minDistance: 10,\n        maxDistance: 80,\n        type: \"datamosh\",\n        angle: 0,\n        counts: 12,\n        minWidth: 10,\n        maxWidth: 80,\n        minHeight: 2,\n        maxHeight: 30,\n        corruptedBlockSize: 16,\n        corruptedIntensity: 0.3,\n        corruptedChannelShift: 8,\n        macroblockBlockSize: 32,\n        macroblockIntensity: 0.5,\n        macroblockBlend: 0.3,\n        macroblockShift: 24,\n        macroblockNoise: 0.1,\n        pixelsortAxis: \"vertical\",\n        pixelsortSortBy: \"brightness\",\n        pixelsortStrength: 1,\n        pixelsortRandom: 0,\n        pixelsortEdge: false,\n        pixelsortEdgeThreshold: 0.2,\n        pixelsortMass: false,\n        pixelsortEdgeInside: true,\n        waveAmplitude: 24,\n        waveFrequency: 2,\n        wavePhase: 0,\n        waveDirection: \"horizontal\"\n    };\n    const opts = Object.assign({}, defaults, options);\n    const canvas = this.node;\n    const w = canvas.width, h = canvas.height;\n    if (w === 0 || h === 0) return this;\n    this.saveToHistory();\n    const angleRad = opts.angle * Math.PI / 180;\n    const diag = Math.ceil(Math.sqrt(w * w + h * h));\n    const temp1 = document.createElement('canvas');\n    temp1.width = diag;\n    temp1.height = diag;\n    const ctx1 = temp1.getContext('2d', { willReadFrequently: true });\n    ctx1.save();\n    ctx1.translate(diag / 2, diag / 2);\n    ctx1.rotate(angleRad);\n    ctx1.drawImage(canvas, -w / 2, -h / 2);\n    ctx1.restore();\n    {\n        const imgData = ctx1.getImageData(0, 0, diag, diag);\n        const data = imgData.data;\n        for (let y = 0; y < diag; y++) {\n            for (let x = 0; x < diag; x++) {\n                let cx = x - diag / 2;\n                let cy = y - diag / 2;\n                let rx = Math.cos(-angleRad) * cx - Math.sin(-angleRad) * cy + w / 2;\n                let ry = Math.sin(-angleRad) * cx + Math.cos(-angleRad) * cy + h / 2;\n                if (rx < 0 || rx >= w || ry < 0 || ry >= h) {\n                    const idx = (y * diag + x) * 4;\n                    data[idx + 3] = 0;\n                }\n            }\n        }\n        ctx1.putImageData(imgData, 0, 0);\n    }\n    if (opts.type === \"datamosh\") {\n        for (let i = 0; i < opts.counts; i++) {\n            const gw = Math.floor(Math.random() * (opts.maxWidth - opts.minWidth + 1)) + opts.minWidth;\n            const gh = Math.floor(Math.random() * (opts.maxHeight - opts.minHeight + 1)) + opts.minHeight;\n            const gx = Math.floor(Math.random() * (diag - gw));\n            const gy = Math.floor(Math.random() * (diag - gh));\n            let distance = Math.floor(Math.random() * (opts.maxDistance - opts.minDistance + 1)) + opts.minDistance;\n            if (Math.random() < 0.5) distance *= -1;\n            let nx = gx + distance;\n            if (nx < 0) nx = 0;\n            if (nx + gw > diag) nx = diag - gw;\n            const imageData = ctx1.getImageData(gx, gy, gw, gh);\n            ctx1.putImageData(imageData, nx, gy);\n        }\n    } else if (opts.type === \"corrupted\") {\n        const blockSize = opts.corruptedBlockSize;\n        const intensity = opts.corruptedIntensity;\n        const channelShift = opts.corruptedChannelShift;\n        const imgData = ctx1.getImageData(0, 0, diag, diag);\n        const data = imgData.data;\n        for (let i = 0; i < opts.counts; i++) {\n            const bx = Math.floor(Math.random() * (diag - blockSize));\n            const by = Math.floor(Math.random() * (diag - blockSize));\n            for (let y = 0; y < blockSize; y++) {\n                for (let x = 0; x < blockSize; x++) {\n                    const px = bx + x;\n                    const py = by + y;\n                    const idx = (py * diag + px) * 4;\n                    if (Math.random() < intensity) {\n                        const rx = bx + Math.floor(Math.random() * blockSize);\n                        const ry = by + Math.floor(Math.random() * blockSize);\n                        const ridx = (ry * diag + rx) * 4;\n                        for (let c = 0; c < 4; c++) {\n                            const tmp = data[idx + c];\n                            data[idx + c] = data[ridx + c];\n                            data[ridx + c] = tmp;\n                        }\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < opts.counts; i++) {\n            const bx = Math.floor(Math.random() * (diag - blockSize));\n            const by = Math.floor(Math.random() * (diag - blockSize));\n            const shiftR = Math.floor((Math.random() - 0.5) * 2 * channelShift);\n            const shiftG = Math.floor((Math.random() - 0.5) * 2 * channelShift);\n            const shiftB = Math.floor((Math.random() - 0.5) * 2 * channelShift);\n            for (let y = 0; y < blockSize; y++) {\n                for (let x = 0; x < blockSize; x++) {\n                    const px = bx + x;\n                    const py = by + y;\n                    const idx = (py * diag + px) * 4;\n                    let rIdx = ((py) * diag + Math.min(diag - 1, Math.max(0, px + shiftR))) * 4;\n                    let gIdx = ((py) * diag + Math.min(diag - 1, Math.max(0, px + shiftG))) * 4;\n                    let bIdx = ((py) * diag + Math.min(diag - 1, Math.max(0, px + shiftB))) * 4;\n                    data[idx] = data[rIdx];\n                    data[idx + 1] = data[gIdx + 1];\n                    data[idx + 2] = data[bIdx + 2];\n                }\n            }\n        }\n        ctx1.putImageData(imgData, 0, 0);\n    } else if (opts.type === \"macroblock\") {\n        const blockSize = opts.macroblockBlockSize;\n        const intensity = opts.macroblockIntensity;\n        const blend = opts.macroblockBlend;\n        const shift = opts.macroblockShift;\n        const noise = opts.macroblockNoise;\n        const imgData = ctx1.getImageData(0, 0, diag, diag);\n        const data = imgData.data;\n        for (let by = 0; by < diag; by += blockSize) {\n            for (let bx = 0; bx < diag; bx += blockSize) {\n                if (Math.random() < intensity) {\n                    let sx = bx + Math.floor((Math.random() - 0.5) * 2 * shift);\n                    let sy = by + Math.floor((Math.random() - 0.5) * 2 * shift);\n                    sx = Math.max(0, Math.min(diag - blockSize, sx));\n                    sy = Math.max(0, Math.min(diag - blockSize, sy));\n                    for (let y = 0; y < blockSize; y++) {\n                        for (let x = 0; x < blockSize; x++) {\n                            const dstX = bx + x;\n                            const dstY = by + y;\n                            const srcX = sx + x;\n                            const srcY = sy + y;\n                            if (dstX < diag && dstY < diag && srcX < diag && srcY < diag) {\n                                const dstIdx = (dstY * diag + dstX) * 4;\n                                const srcIdx = (srcY * diag + srcX) * 4;\n                                for (let c = 0; c < 3; c++) {\n                                    data[dstIdx + c] = Math.round(\n                                        data[srcIdx + c] * blend + data[dstIdx + c] * (1 - blend)\n                                    );\n                                }\n                                if (noise > 0) {\n                                    for (let c = 0; c < 3; c++) {\n                                        data[dstIdx + c] = Math.min(255, Math.max(0, data[dstIdx + c] + (Math.random() - 0.5) * 255 * noise));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        ctx1.putImageData(imgData, 0, 0);\n    } else if (opts.type === \"pixelsort\") {\n        const axis = opts.pixelsortAxis;\n        const sortBy = opts.pixelsortSortBy;\n        const strength = Math.max(0, Math.min(1, opts.pixelsortStrength));\n        const randomness = Math.max(0, Math.min(1, opts.pixelsortRandom));\n        const edgeEnabled = !!opts.pixelsortEdge;\n        const edgeThreshold = Math.max(0, Math.min(1, opts.pixelsortEdgeThreshold || 0.2));\n        const massMode = !!opts.pixelsortMass;\n        const edgeInside = opts.pixelsortEdgeInside !== undefined ? !!opts.pixelsortEdgeInside : true;\n        const imgData = ctx1.getImageData(0, 0, diag, diag);\n        const data = imgData.data;\n        function getSortValue(r, g, b) {\n            if (sortBy === \"brightness\") {\n                return 0.299 * r + 0.587 * g + 0.114 * b;\n            } else if (sortBy === \"intensity\") {\n                return (r + g + b) / 3;\n            } else if (sortBy === \"hue\") {\n                const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                let h = 0;\n                if (max === min) h = 0;\n                else if (max === r) h = (60 * ((g - b) / (max - min)) + 360) % 360;\n                else if (max === g) h = (60 * ((b - r) / (max - min)) + 120) % 360;\n                else if (max === b) h = (60 * ((r - g) / (max - min)) + 240) % 360;\n                return h;\n            }\n            return 0;\n        }\n        let edgeMap = null;\n        if (edgeEnabled) {\n            edgeMap = new Float32Array(diag * diag);\n            const gx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];\n            const gy = [-1, -2, -1, 0, 0, 0, 1, 2, 1];\n            for (let y = 1; y < diag - 1; y++) {\n                for (let x = 1; x < diag - 1; x++) {\n                    let sx = 0, sy = 0;\n                    for (let ky = -1; ky <= 1; ky++) {\n                        for (let kx = -1; kx <= 1; kx++) {\n                            const idx = ((y + ky) * diag + (x + kx)) * 4;\n                            let v;\n                            if (sortBy === \"brightness\") {\n                                v = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];\n                            } else if (sortBy === \"intensity\") {\n                                v = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;\n                            } else if (sortBy === \"hue\") {\n                                const r = data[idx], g = data[idx + 1], b = data[idx + 2];\n                                const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                                let h = 0;\n                                if (max === min) h = 0;\n                                else if (max === r) h = (60 * ((g - b) / (max - min)) + 360) % 360;\n                                else if (max === g) h = (60 * ((b - r) / (max - min)) + 120) % 360;\n                                else if (max === b) h = (60 * ((r - g) / (max - min)) + 240) % 360;\n                                v = h;\n                            } else {\n                                v = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];\n                            }\n                            const kIdx = (ky + 1) * 3 + (kx + 1);\n                            sx += gx[kIdx] * v;\n                            sy += gy[kIdx] * v;\n                        }\n                    }\n                    const mag = Math.sqrt(sx * sx + sy * sy) / 1448;\n                    edgeMap[y * diag + x] = mag;\n                }\n            }\n        }\n        function getEdgeMask(lineIdx, axis) {\n            const mask = [];\n            if (!edgeMap) return null;\n            for (let i = 0; i < diag; i++) {\n                let idx = axis === \"vertical\" ? (i * diag + lineIdx) : (lineIdx * diag + i);\n                mask.push(edgeMap[idx] > edgeThreshold);\n            }\n            return mask;\n        }\n        function countEdges(lineIdx, axis) {\n            if (!edgeMap) return 0;\n            let count = 0;\n            for (let i = 0; i < diag; i++) {\n                let idx = axis === \"vertical\" ? (i * diag + lineIdx) : (lineIdx * diag + i);\n                if (edgeMap[idx] > edgeThreshold) count++;\n            }\n            return count;\n        }\n        let massLine = -1;\n        if (edgeEnabled && massMode) {\n            let maxCount = -1;\n            for (let i = 0; i < diag; i++) {\n                const cnt = countEdges(i, axis);\n                if (cnt > maxCount) {\n                    maxCount = cnt;\n                    massLine = i;\n                }\n            }\n        }\n        if (axis === \"vertical\") {\n            for (let x = 0; x < diag; x++) {\n                if (Math.random() > strength) continue;\n                if (massMode && x !== massLine) continue;\n                let pixels = [];\n                let mask = edgeEnabled ? getEdgeMask(x, \"vertical\") : null;\n                for (let y = 0; y < diag; y++) {\n                    const idx = (y * diag + x) * 4;\n                    pixels.push({\n                        r: data[idx],\n                        g: data[idx + 1],\n                        b: data[idx + 2],\n                        a: data[idx + 3],\n                        sort: getSortValue(data[idx], data[idx + 1], data[idx + 2]) + (Math.random() - 0.5) * 255 * randomness,\n                        edge: mask ? mask[y] : false\n                    });\n                }\n                if (edgeEnabled) {\n                    let first = pixels.findIndex(p => p.edge);\n                    let last = -1;\n                    for (let i = diag - 1; i >= 0; i--) {\n                        if (pixels[i].edge) { last = i; break; }\n                    }\n                    if (first !== -1 && last !== -1 && last > first) {\n                        if (edgeInside) {\n                            let segment = pixels.slice(first, last + 1);\n                            segment.sort((a, b) => a.sort - b.sort);\n                            for (let i = first; i <= last; i++) {\n                                pixels[i] = segment[i - first];\n                            }\n                        } else {\n                            if (first > 0) {\n                                let segment = pixels.slice(0, first);\n                                segment.sort((a, b) => a.sort - b.sort);\n                                for (let i = 0; i < first; i++) {\n                                    pixels[i] = segment[i];\n                                }\n                            }\n                            if (last < diag - 1) {\n                                let segment = pixels.slice(last + 1);\n                                segment.sort((a, b) => a.sort - b.sort);\n                                for (let i = last + 1; i < diag; i++) {\n                                    pixels[i] = segment[i - (last + 1)];\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    pixels.sort((a, b) => a.sort - b.sort);\n                }\n                for (let y = 0; y < diag; y++) {\n                    let cx = x - diag / 2;\n                    let cy = y - diag / 2;\n                    let rx = Math.cos(-angleRad) * cx - Math.sin(-angleRad) * cy + w / 2;\n                    let ry = Math.sin(-angleRad) * cx + Math.cos(-angleRad) * cy + h / 2;\n                    if (rx >= 0 && rx < w && ry >= 0 && ry < h) {\n                        const idx = (y * diag + x) * 4;\n                        data[idx] = pixels[y].r;\n                        data[idx + 1] = pixels[y].g;\n                        data[idx + 2] = pixels[y].b;\n                        data[idx + 3] = pixels[y].a;\n                    }\n                }\n            }\n        } else {\n            for (let y = 0; y < diag; y++) {\n                if (Math.random() > strength) continue;\n                if (massMode && y !== massLine) continue;\n                let pixels = [];\n                let mask = edgeEnabled ? getEdgeMask(y, \"horizontal\") : null;\n                for (let x = 0; x < diag; x++) {\n                    const idx = (y * diag + x) * 4;\n                    pixels.push({\n                        r: data[idx],\n                        g: data[idx + 1],\n                        b: data[idx + 2],\n                        a: data[idx + 3],\n                        sort: getSortValue(data[idx], data[idx + 1], data[idx + 2]) + (Math.random() - 0.5) * 255 * randomness,\n                        edge: mask ? mask[x] : false\n                    });\n                }\n                if (edgeEnabled) {\n                    let first = pixels.findIndex(p => p.edge);\n                    let last = -1;\n                    for (let i = diag - 1; i >= 0; i--) {\n                        if (pixels[i].edge) { last = i; break; }\n                    }\n                    if (first !== -1 && last !== -1 && last > first) {\n                        if (edgeInside) {\n                            let segment = pixels.slice(first, last + 1);\n                            segment.sort((a, b) => a.sort - b.sort);\n                            for (let i = first; i <= last; i++) {\n                                pixels[i] = segment[i - first];\n                            }\n                        } else {\n                            if (first > 0) {\n                                let segment = pixels.slice(0, first);\n                                segment.sort((a, b) => a.sort - b.sort);\n                                for (let i = 0; i < first; i++) {\n                                    pixels[i] = segment[i];\n                                }\n                            }\n                            if (last < diag - 1) {\n                                let segment = pixels.slice(last + 1);\n                                segment.sort((a, b) => a.sort - b.sort);\n                                for (let i = last + 1; i < diag; i++) {\n                                    pixels[i] = segment[i - (last + 1)];\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    pixels.sort((a, b) => a.sort - b.sort);\n                }\n                for (let x = 0; x < diag; x++) {\n                    let cx = x - diag / 2;\n                    let cy = y - diag / 2;\n                    let rx = Math.cos(-angleRad) * cx - Math.sin(-angleRad) * cy + w / 2;\n                    let ry = Math.sin(-angleRad) * cx + Math.cos(-angleRad) * cy + h / 2;\n                    if (rx >= 0 && rx < w && ry >= 0 && ry < h) {\n                        const idx = (y * diag + x) * 4;\n                        data[idx] = pixels[x].r;\n                        data[idx + 1] = pixels[x].g;\n                        data[idx + 2] = pixels[x].b;\n                        data[idx + 3] = pixels[x].a;\n                    }\n                }\n            }\n        }\n        ctx1.putImageData(imgData, 0, 0);\n    } else if (opts.type === \"wave\") {\n        const amplitude = opts.waveAmplitude;\n        const frequency = opts.waveFrequency;\n        const phase = opts.wavePhase;\n        const direction = opts.waveDirection;\n        const imgData = ctx1.getImageData(0, 0, diag, diag);\n        const data = imgData.data;\n        const out = ctx1.createImageData(diag, diag);\n        const outData = out.data;\n        if (direction === \"horizontal\") {\n            for (let y = 0; y < diag; y++) {\n                const shift = Math.round(\n                    Math.sin(2 * Math.PI * frequency * y / diag + phase) * amplitude\n                );\n                for (let x = 0; x < diag; x++) {\n                    let sx = x + shift;\n                    if (sx < 0 || sx >= diag) continue;\n                    const srcIdx = (y * diag + sx) * 4;\n                    const dstIdx = (y * diag + x) * 4;\n                    outData[dstIdx] = data[srcIdx];\n                    outData[dstIdx + 1] = data[srcIdx + 1];\n                    outData[dstIdx + 2] = data[srcIdx + 2];\n                    outData[dstIdx + 3] = data[srcIdx + 3];\n                }\n            }\n        } else {\n            for (let x = 0; x < diag; x++) {\n                const shift = Math.round(\n                    Math.sin(2 * Math.PI * frequency * x / diag + phase) * amplitude\n                );\n                for (let y = 0; y < diag; y++) {\n                    let sy = y + shift;\n                    if (sy < 0 || sy >= diag) continue;\n                    const srcIdx = (sy * diag + x) * 4;\n                    const dstIdx = (y * diag + x) * 4;\n                    outData[dstIdx] = data[srcIdx];\n                    outData[dstIdx + 1] = data[srcIdx + 1];\n                    outData[dstIdx + 2] = data[srcIdx + 2];\n                    outData[dstIdx + 3] = data[srcIdx + 3];\n                }\n            }\n        }\n        ctx1.putImageData(out, 0, 0);\n    }\n    const temp2 = document.createElement('canvas');\n    temp2.width = w;\n    temp2.height = h;\n    const ctx2 = temp2.getContext('2d', { willReadFrequently: true });\n    ctx2.save();\n    ctx2.clearRect(0, 0, w, h);\n    ctx2.translate(w / 2, h / 2);\n    ctx2.rotate(-angleRad);\n    ctx2.drawImage(temp1, -diag / 2, -diag / 2);\n    ctx2.restore();\n    const ctx = canvas.getContext('2d', { willReadFrequently: true });\n    ctx.clearRect(0, 0, w, h);\n    ctx.drawImage(temp2, 0, 0);\n    return this;\n};"
            },
            "Image.Glow": {
                "uuid": "389d4ea0-1217-4242-b4f5-82b77bafa256",
                "name": "Image.Glow",
                "method": "Prototype",
                "desc": "Adds a glow effect to bright areas of the image.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Glow({ blurRadius: 20, intensity: 1.5 }); });",
                    "Q.Image().Load('img.png').Glow({ color: '#ff0', blendMode: 'screen' });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Glow = function (glowOptions = {}) {\n    const defaultOptions = {\n        illuminanceThreshold: 200,\n        blurRadius: 10,\n        intensity: 1.0,\n        color: null,\n        blendMode: 'lighter'\n    };\n    const finalOptions = Object.assign({}, defaultOptions, glowOptions);\n    const w = this.node.width, h = this.node.height;\n    if (w === 0 || h === 0) return this;\n    this.saveToHistory();\n    const src = document.createElement('canvas');\n    src.width = w; src.height = h;\n    const srcCtx = src.getContext('2d');\n    srcCtx.drawImage(this.node, 0, 0);\n    const thr = document.createElement('canvas');\n    thr.width = w; thr.height = h;\n    const thrCtx = thr.getContext('2d');\n    const img = srcCtx.getImageData(0, 0, w, h);\n    const data = img.data;\n    let tint = null;\n    if (finalOptions.color) {\n        const tmp = document.createElement('canvas');\n        tmp.width = tmp.height = 1;\n        const tctx = tmp.getContext('2d');\n        tctx.fillStyle = finalOptions.color;\n        tctx.fillRect(0, 0, 1, 1);\n        const pd = tctx.getImageData(0, 0, 1, 1).data;\n        tint = { r: pd[0], g: pd[1], b: pd[2] };\n    }\n    for (let i = 0; i < data.length; i += 4) {\n        const lum = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];\n        if (lum <= finalOptions.illuminanceThreshold) {\n            data[i + 3] = 0;\n        } else if (tint) {\n            data[i] = tint.r;\n            data[i + 1] = tint.g;\n            data[i + 2] = tint.b;\n        }\n    }\n    thrCtx.putImageData(img, 0, 0);\n    const glow = document.createElement('canvas');\n    glow.width = w; glow.height = h;\n    const gctx = glow.getContext('2d');\n    gctx.filter = `blur(${finalOptions.blurRadius}px)`;\n    gctx.globalAlpha = finalOptions.intensity;\n    gctx.drawImage(thr, 0, 0);\n    const dst = this.node.getContext('2d');\n    dst.drawImage(src, 0, 0);\n    dst.globalCompositeOperation = finalOptions.blendMode;\n    dst.drawImage(glow, 0, 0);\n    dst.globalCompositeOperation = 'source-over';\n    return this;\n};"
            },
            "Image.GodRay": {
                "uuid": "a4f983c1-7e6b-41dd-9bc0-99e2bdb668ad",
                "name": "Image.GodRay",
                "method": "Prototype",
                "desc": "Adds volumetric light rays (god rays) to the image.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 400, height: 300 });\nimg.Load('photo.jpg', function() { img.GodRay({ centerX: 60, centerY: 40, strength: 2 }); });",
                    "Q.Image().Load('img.png').GodRay({ angle: 45, tintColor: '#ff0' });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.GodRay = function (rayOptions = {}) {\n    const defaultOptions = {\n        centerX: 50,\n        centerY: 50,\n        threshold: 200,\n        length: 50,\n        samples: 20,\n        strength: 1.0,\n        decay: 0.95,\n        exposure: 0.3,\n        angle: null,\n        tintColor: null,\n        blendMode: 'screen',\n        fadeOut: 0.1,\n        fadeOutType: 'ease'\n    };\n    this.saveToHistory();\n    const finalOptions = Object.assign({}, defaultOptions, rayOptions);\n    const canvas_node = this.node;\n    const centerX = (finalOptions.centerX / 100) * canvas_node.width;\n    const centerY = (finalOptions.centerY / 100) * canvas_node.height;\n    const samples = Math.max(5, Math.min(50, finalOptions.samples));\n    const length = Math.max(1, Math.min(100, finalOptions.length)) / 100;\n    const maxScale = 1 + length;\n    const sourceCanvas = document.createElement('canvas');\n    sourceCanvas.width = canvas_node.width;\n    sourceCanvas.height = canvas_node.height;\n    const sourceCtx = sourceCanvas.getContext('2d');\n    sourceCtx.drawImage(canvas_node, 0, 0);\n    const brightCanvas = document.createElement('canvas');\n    brightCanvas.width = canvas_node.width;\n    brightCanvas.height = canvas_node.height;\n    const brightCtx = brightCanvas.getContext('2d');\n    const imageData = sourceCtx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n    const brightData = brightCtx.createImageData(canvas_node.width, canvas_node.height);\n    for (let i = 0; i < imageData.data.length; i += 4) {\n        const r = imageData.data[i];\n        const g = imageData.data[i + 1];\n        const b = imageData.data[i + 2];\n        const brightness = Math.max(r, g, b);\n        if (brightness >= finalOptions.threshold) {\n            const factor = finalOptions.exposure * (brightness - finalOptions.threshold) / (255 - finalOptions.threshold);\n            if (finalOptions.tintColor) {\n                const color = parseColor(finalOptions.tintColor);\n                brightData.data[i] = Math.min(255, r * color.r / 255 * factor);\n                brightData.data[i + 1] = Math.min(255, g * color.g / 255 * factor);\n                brightData.data[i + 2] = Math.min(255, b * color.b / 255 * factor);\n            } else {\n                brightData.data[i] = Math.min(255, r * factor);\n                brightData.data[i + 1] = Math.min(255, g * factor);\n                brightData.data[i + 2] = Math.min(255, b * factor);\n            }\n            brightData.data[i + 3] = 255;\n        } else {\n            brightData.data[i] = 0;\n            brightData.data[i + 1] = 0;\n            brightData.data[i + 2] = 0;\n            brightData.data[i + 3] = 0;\n        }\n    }\n    brightCtx.putImageData(brightData, 0, 0);\n    const rayCanvas = document.createElement('canvas');\n    rayCanvas.width = canvas_node.width;\n    rayCanvas.height = canvas_node.height;\n    const rayCtx = rayCanvas.getContext('2d');\n    switch (finalOptions.blendMode) {\n        case 'screen':\n            rayCtx.globalCompositeOperation = 'screen';\n            break;\n        case 'add':\n            rayCtx.globalCompositeOperation = 'lighter';\n            break;\n        case 'lighten':\n            rayCtx.globalCompositeOperation = 'lighten';\n            break;\n        default:\n            rayCtx.globalCompositeOperation = 'screen';\n    }\n    function getFade(progress) {\n        if (finalOptions.fadeOutType === 'linear') {\n            return Math.max(0, 1 - finalOptions.fadeOut * progress * samples);\n        } else if (finalOptions.fadeOutType === 'ease') {\n            return Math.max(0, 1 - finalOptions.fadeOut * Math.pow(progress, 0.5) * samples);\n        }\n        return Math.max(0, 1 - finalOptions.fadeOut * progress * samples);\n    }\n    for (let i = 0; i < samples; i++) {\n        const progress = i / (samples - 1);\n        const scale = 1 + progress * length;\n        const fade = getFade(progress);\n        const opacity = Math.pow(finalOptions.decay, i) * finalOptions.strength * fade;\n        let x, y, w, h;\n        if (finalOptions.angle !== null) {\n            const angleDeg = parseFloat(finalOptions.angle);\n            const angleRad = (angleDeg * Math.PI) / 180;\n            const distance = progress * length * 50;\n            x = centerX - (Math.cos(angleRad) * distance);\n            y = centerY - (Math.sin(angleRad) * distance);\n            w = canvas_node.width;\n            h = canvas_node.height;\n        } else {\n            w = canvas_node.width * scale;\n            h = canvas_node.height * scale;\n            x = centerX - (centerX * scale);\n            y = centerY - (centerY * scale);\n        }\n        rayCtx.globalAlpha = opacity;\n        rayCtx.drawImage(brightCanvas, 0, 0, brightCanvas.width, brightCanvas.height,\n            x, y, w, h);\n    }\n    const finalCanvas = document.createElement('canvas');\n    finalCanvas.width = canvas_node.width;\n    finalCanvas.height = canvas_node.height;\n    const finalCtx = finalCanvas.getContext('2d');\n    finalCtx.drawImage(sourceCanvas, 0, 0);\n    finalCtx.globalCompositeOperation = 'screen';\n    finalCtx.drawImage(rayCanvas, 0, 0);\n    const ctx = canvas_node.getContext('2d');\n    ctx.clearRect(0, 0, canvas_node.width, canvas_node.height);\n    ctx.drawImage(finalCanvas, 0, 0);\n    return this;\n    function parseColor(color) {\n        let r = 255, g = 255, b = 255;\n        if (typeof color === 'string') {\n            if (color.startsWith('#')) {\n                if (color.length === 4) {\n                    r = parseInt(color[1] + color[1], 16);\n                    g = parseInt(color[2] + color[2], 16);\n                    b = parseInt(color[3] + color[3], 16);\n                } else if (color.length === 7) {\n                    r = parseInt(color.substring(1, 3), 16);\n                    g = parseInt(color.substring(3, 5), 16);\n                    b = parseInt(color.substring(5, 7), 16);\n                }\n            }\n            else if (color.startsWith('rgb')) {\n                const parts = color.match(/\\d+/g);\n                if (parts && parts.length >= 3) {\n                    r = parseInt(parts[0]);\n                    g = parseInt(parts[1]);\n                    b = parseInt(parts[2]);\n                }\n            }\n        }\n        return { r, g, b };\n    }\n};"
            },
            "Image.Grayscale": {
                "uuid": "2c6562b3-b72f-4cc5-90eb-3d3b00e13771",
                "name": "Image.Grayscale",
                "method": "Prototype",
                "desc": "Converts the image to grayscale using various algorithms.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Grayscale({ algorithm: 'luminance' }); });",
                    "Q.Image().Load('img.png').Grayscale({ intensity: 0.5, threshold: 128 });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Grayscale = function(grayOptions = {}) {\n    const defaultGrayOptions = {\n        algorithm: 'average', // 'average', 'luminance', 'lightness', 'desaturation', 'red', 'green', 'blue'\n        intensity: 1.0,       // 0.0 to 1.0 for partial grayscale effect\n        threshold: null       // optional: 0-255, if set, output is black/white\n    };\n    const finalOptions = Object.assign({}, defaultGrayOptions, grayOptions);\n    finalOptions.intensity = Math.max(0, Math.min(1, finalOptions.intensity));\n    const ctx = this.node.getContext('2d');\n    this.saveToHistory(); // Save the current state to history\n    let data = ctx.getImageData(0, 0, this.node.width, this.node.height);\n    let pixels = data.data;\n    for (let i = 0; i < pixels.length; i += 4) {\n        let r = pixels[i];\n        let g = pixels[i + 1];\n        let b = pixels[i + 2];\n        let gray;\n        switch (finalOptions.algorithm) {\n            case 'luminance':\n                gray = 0.299 * r + 0.587 * g + 0.114 * b;\n                break;\n            case 'lightness':\n                gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n                break;\n            case 'desaturation':\n                gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n                break;\n            case 'red':\n                gray = r;\n                break;\n            case 'green':\n                gray = g;\n                break;\n            case 'blue':\n                gray = b;\n                break;\n            case 'average':\n            default:\n                gray = (r + g + b) / 3;\n                break;\n        }\n        if (finalOptions.threshold !== null && !isNaN(finalOptions.threshold)) {\n            gray = gray >= finalOptions.threshold ? 255 : 0;\n        }\n        if (finalOptions.intensity < 1.0) {\n            pixels[i]     = Math.round(r * (1 - finalOptions.intensity) + gray * finalOptions.intensity);\n            pixels[i + 1] = Math.round(g * (1 - finalOptions.intensity) + gray * finalOptions.intensity);\n            pixels[i + 2] = Math.round(b * (1 - finalOptions.intensity) + gray * finalOptions.intensity);\n        } else {\n            pixels[i] = pixels[i + 1] = pixels[i + 2] = Math.round(gray);\n        }\n    }\n    ctx.putImageData(data, 0, 0);\n    return this;\n};"
            },
            "Image.HDR": {
                "uuid": "c41a163c-6420-41f7-9a6d-f2857f0e5864",
                "name": "Image.HDR",
                "method": "Prototype",
                "desc": "Applies a high dynamic range (HDR) effect to the image.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 400, height: 300 });\nimg.Load('photo.jpg', function() { img.HDR({ shadowAdjust: 20, highlights: -15 }); });",
                    "Q.Image().Load('img.png').HDR({ vibrance: 0.5, clarity: 15 });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.HDR = function(hdrOptions = {}) {\n        const defaultOptions = {\n            shadowAdjust: 15,        // Shadow level adjustment\n            brightnessAdjust: 10,    // Brightness adjustment\n            contrastAdjust: 1.2,     // Contrast adjustment\n            vibrance: 0.2,           // Vibrance adjustment (saturation for less saturated colors)\n            highlights: -10,         // Highlight level adjustment\n            clarity: 10,             // Clarity/local contrast enhancement\n            tonal: true              // Apply tonal balancing\n        };\n        const finalOptions = Object.assign({}, defaultOptions, hdrOptions);\n        const canvas_node = this.node;\n        this.saveToHistory(); // Save the current state to history\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const data = imageData.data;\n        let minBrightness = 255;\n        let maxBrightness = 0;\n        let avgBrightness = 0;\n        if (finalOptions.tonal) {\n            for (let i = 0; i < data.length; i += 4) {\n                const r = data[i];\n                const g = data[i + 1];\n                const b = data[i + 2];\n                const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n                minBrightness = Math.min(minBrightness, brightness);\n                maxBrightness = Math.max(maxBrightness, brightness);\n                avgBrightness += brightness;\n            }\n            avgBrightness /= (data.length / 4);\n        }\n        for (let i = 0; i < data.length; i += 4) {\n            let r = data[i];\n            let g = data[i + 1];\n            let b = data[i + 2];\n            const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n            const shadowFactor = Math.max(0, 1 - brightness / 128);\n            r += finalOptions.shadowAdjust * shadowFactor;\n            g += finalOptions.shadowAdjust * shadowFactor;\n            b += finalOptions.shadowAdjust * shadowFactor;\n            const highlightFactor = Math.max(0, brightness / 128 - 1);\n            r += finalOptions.highlights * highlightFactor;\n            g += finalOptions.highlights * highlightFactor;\n            b += finalOptions.highlights * highlightFactor;\n            r += finalOptions.brightnessAdjust;\n            g += finalOptions.brightnessAdjust;\n            b += finalOptions.brightnessAdjust;\n            r = (r - 128) * finalOptions.contrastAdjust + 128;\n            g = (g - 128) * finalOptions.contrastAdjust + 128;\n            b = (b - 128) * finalOptions.contrastAdjust + 128;\n            if (finalOptions.vibrance !== 0) {\n                const max = Math.max(r, g, b);\n                const min = Math.min(r, g, b);\n                const lightness = (max + min) / 510; // Normalize to 0-1\n                if (max - min < 100) {  // Lower values = less saturated\n                    const satAdjust = finalOptions.vibrance * (1 - (max - min) / 100);\n                    if (max === r) {\n                        g = g - satAdjust * (g - min);\n                        b = b - satAdjust * (b - min);\n                    } else if (max === g) {\n                        r = r - satAdjust * (r - min);\n                        b = b - satAdjust * (b - min);\n                    } else {\n                        r = r - satAdjust * (r - min);\n                        g = g - satAdjust * (g - min);\n                    }\n                }\n            }\n            if (finalOptions.tonal && maxBrightness > minBrightness) {\n                const normalizedBrightness = (brightness - minBrightness) / (maxBrightness - minBrightness);\n                const tonalFactor = (normalizedBrightness < 0.5) ? \n                    2 * normalizedBrightness : 2 - 2 * normalizedBrightness;\n                const tonalAdjust = finalOptions.clarity * tonalFactor;\n                r += tonalAdjust;\n                g += tonalAdjust;\n                b += tonalAdjust;\n            }\n            data[i] = Math.min(255, Math.max(0, r));\n            data[i + 1] = Math.min(255, Math.max(0, g));\n            data[i + 2] = Math.min(255, Math.max(0, b));\n        }\n        ctx.putImageData(imageData, 0, 0);\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
            },
            "Image.Hue": {
                "uuid": "d2c5c464-da24-4f1e-9b48-54cb16e4d686",
                "name": "Image.Hue",
                "method": "Prototype",
                "desc": "Shifts the hue of the image by a specified angle.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Hue(90); });",
                    "Q.Image().Load('img.png').Hue(180, { clamp: false });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Hue = function (angle = 0, options = {}) {\n    const defaultOptions = {\n        clamp: true // Clamp RGB values to [0,255]\n    };\n    const finalOptions = Object.assign({}, defaultOptions, options);\n    const canvas_node = this.node;\n    this.saveToHistory();\n    const ctx = canvas_node.getContext('2d', { willReadFrequently: true });\n    const imageData = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n    const data = imageData.data;\n    const hueShift = ((angle % 360) + 360) % 360 / 360;\n    for (let i = 0; i < data.length; i += 4) {\n        let r = data[i] / 255, g = data[i + 1] / 255, b = data[i + 2] / 255;\n        let max = Math.max(r, g, b), min = Math.min(r, g, b);\n        let h, s, l = (max + min) / 2;\n        if (max === min) {\n            h = s = 0;\n        } else {\n            let d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2; break;\n                case b: h = (r - g) / d + 4; break;\n            }\n            h /= 6;\n        }\n        h = (h + hueShift) % 1;\n        if (h < 0) h += 1;\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        let p = 2 * l - q;\n        function hue2rgb(p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        }\n        let rr = hue2rgb(p, q, h + 1 / 3);\n        let gg = hue2rgb(p, q, h);\n        let bb = hue2rgb(p, q, h - 1 / 3);\n        data[i] = finalOptions.clamp ? Math.min(255, Math.max(0, Math.round(rr * 255))) : Math.round(rr * 255);\n        data[i + 1] = finalOptions.clamp ? Math.min(255, Math.max(0, Math.round(gg * 255))) : Math.round(gg * 255);\n        data[i + 2] = finalOptions.clamp ? Math.min(255, Math.max(0, Math.round(bb * 255))) : Math.round(bb * 255);\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return this;\n};"
            },
            "Image": {
                "uuid": "810fd947-3e56-4991-887e-ee9ecefc735d",
                "name": "Image",
                "method": "Constructor",
                "desc": "Canvas-based image manipulation and processing utility.",
                "type": "Constructor",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Render('#preview'); });",
                    "var img = Q.Image({ width: 100, height: 100, fill: '#fff' });\nimg.Clear('#eee').Save('output.png');"
                ],
                "dependencies": [
                    "Q"
                ],
                "script": "Q.Image = function (options) {\n    const defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        quality: 1,\n        historyLimit: 10,\n        autoSaveHistory: true\n    };\n    this.options = Object.assign({}, defaultOptions, options);\n    this.canvas = Q('<canvas>');\n    this.node = this.canvas.nodes[0];\n    if (this.options.width && this.options.height) {\n        this.node.width = this.options.width;\n        this.node.height = this.options.height;\n    }\n    this.history = {\n        states: [],\n        position: -1,\n        isUndoRedoing: false\n    };\n};\nQ.Image.prototype.Load = function (src, callback) {\n    const img = new Image();\n    img.crossOrigin = 'Anonymous';\n    img.onload = () => {\n        if (this.node.width === 0 || this.node.height === 0 ||\n            this.options.width === 0 || this.options.height === 0) {\n            this.node.width = img.width;\n            this.node.height = img.height;\n        }\n        const ctx = this.node.getContext('2d');\n        ctx.clearRect(0, 0, this.node.width, this.node.height);\n        ctx.drawImage(img, 0, 0, img.width, img.height,\n            0, 0, this.node.width, this.node.height);\n        this.history.states = [];\n        this.history.position = -1;\n        this.saveToHistory();\n        if (callback) callback.call(this, null);\n    };\n    img.onerror = (err) => {\n        console.error('Hiba a k\u00e9p bet\u00f6lt\u00e9sekor:', src, err);\n        if (callback) callback.call(this, new Error('Error loading image'));\n    };\n    img.src = typeof src === 'string' ? src : src.src;\n    return this;\n};\nQ.Image.prototype.Clear = function (fill = this.options.fill) {\n    let ctx = this.node.getContext('2d');\n    ctx.fillStyle = fill;\n    ctx.fillRect(0, 0, this.node.width, this.node.height);\n    this.saveToHistory();\n    return this;\n};\nQ.Image.prototype.Render = function (target) {\n    const targetNode = (typeof target === 'string')\n        ? document.querySelector(target)\n        : (target instanceof HTMLElement)\n            ? target\n            : (target.nodes ? target.nodes[0] : null);\n    if (!targetNode) {\n        console.error('Invalid render target');\n        return this;\n    }\n    let ctxTarget;\n    if (targetNode.tagName.toLowerCase() === 'canvas') {\n        targetNode.width = this.node.width;\n        targetNode.height = this.node.height;\n        ctxTarget = targetNode.getContext('2d');\n        ctxTarget.drawImage(this.node, 0, 0);\n    } else if (targetNode.tagName.toLowerCase() === 'img') {\n        targetNode.src = this.node.toDataURL(`image/${this.options.format}`, this.options.quality);\n    } else {\n        console.error('Unsupported element for rendering');\n    }\n    return this;\n};\nQ.Image.prototype.Save = function (filename) {\n    const dataUrl = this.node.toDataURL('image/' + this.options.format, this.options.quality);\n    const link = document.createElement('a');\n    link.download = filename;\n    link.href = dataUrl;\n    link.click();\n    link.remove();\n    return this;\n};\nQ.Image.prototype.saveToHistory = function () {\n    if (this.history.isUndoRedoing || !this.options.autoSaveHistory) return;\n    if (this.node.width === 0 || this.node.height === 0) return;\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const imageData = ctx.getImageData(0, 0, this.node.width, this.node.height);\n    if (this.history.position < this.history.states.length - 1) {\n        this.history.states.length = this.history.position + 1;\n    }\n    this.history.states.push(imageData);\n    if (this.history.states.length > this.options.historyLimit) {\n        this.history.states.shift();\n        if (this.history.position > 0) {\n            this.history.position--;\n        }\n    } else {\n        this.history.position++;\n    }\n};\n/* \n * IMPORTANT: Every image manipulation method should call saveToHistory() \n * after modifying the canvas to ensure proper history tracking.\n */\nQ.Image.prototype.Undo = function () {\n    return this.History(-1);\n};\nQ.Image.prototype.Redo = function () {\n    return this.History(1);\n};\nQ.Image.prototype.History = function (offset) {\n    if (this.history.states.length === 0) {\n        console.warn('No history states available.');\n        return this;\n    }\n    const target = this.history.position + offset;\n    if (target < 0 || target >= this.history.states.length) {\n        console.warn('Nem lehets\u00e9ges tov\u00e1bbi visszal\u00e9p\u00e9s vagy el\u0151reugr\u00e1s.');\n        return this;\n    }\n    this.history.isUndoRedoing = true;\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const historyState = this.history.states[target];\n    if (this.node.width !== historyState.width || this.node.height !== historyState.height) {\n        this.node.width = historyState.width;\n        this.node.height = historyState.height;\n    }\n    ctx.putImageData(historyState, 0, 0);\n    this.history.position = target;\n    this.history.isUndoRedoing = false;\n    return this;\n};"
            },
            "Image.LensFlare": {
                "uuid": "c99879e9-cd9f-47a4-8d3f-9029ad7ca4e1",
                "name": "Image.LensFlare",
                "method": "Prototype",
                "desc": "Adds a lens flare effect to the image using various presets.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 400, height: 300 });\nimg.Load('photo.jpg', function() { img.LensFlare({ preset: 'cinematic' }); });",
                    "Q.Image().Load('img.png').LensFlare({ type: 'starburst', points: 8 });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.LensFlare = function (flareOptions = {}) {\n    const presets = {\n        cinematic: {\n            type: \"anamorphic\",\n            widthModifier: 2.5,\n            heightThreshold: 8,\n            opacity: 0.18,\n            blur: 8,\n            falloff: 1.2,\n            intensity: 1.1,\n            blendMode: \"overlay\"\n        },\n        sciFi: {\n            type: \"starburst\",\n            points: 12,\n            radius: 60,\n            opacity: 0.22,\n            blur: 6,\n            falloff: 1.6,\n            intensity: 1.3,\n            blendMode: \"lighter\"\n        },\n        vintage: {\n            type: \"polygon\",\n            points: 6,\n            radius: 38,\n            opacity: 0.16,\n            blur: 4,\n            falloff: 1.0,\n            intensity: 0.9,\n            blendMode: \"lighter\"\n        },\n        photo: {\n            type: \"circular\",\n            radius: 32,\n            opacity: 0.12,\n            blur: 10,\n            falloff: 1.0,\n            intensity: 1.0,\n            blendMode: \"screen\"\n        },\n        blockbuster: {\n            type: \"anamorphic\",\n            widthModifier: 3.5,\n            heightThreshold: 12,\n            opacity: 0.22,\n            blur: 10,\n            falloff: 1.4,\n            intensity: 1.5,\n            blendMode: \"lighter\",\n            starSize: 320,\n            starIntensity: 1.2,\n            starPoints: 12,\n            starRotation: 15,\n            starOpacity: 1,\n            streakOpacity: 1,\n            centerOpacity: 1,\n            diagOpacity: 1\n        },\n        dreamy: {\n            type: \"circular\",\n            radius: 80,\n            opacity: 0.09,\n            blur: 18,\n            falloff: 0.7,\n            intensity: 0.7,\n            blendMode: \"screen\"\n        },\n        hardcore: {\n            type: \"starburst\",\n            points: 24,\n            radius: 120,\n            opacity: 0.35,\n            blur: 2,\n            falloff: 2.0,\n            intensity: 2.0,\n            blendMode: \"lighter\",\n            starSize: 400,\n            starIntensity: 2,\n            starPoints: 24,\n            starRotation: 0\n        },\n        minimal: {\n            type: \"polygon\",\n            points: 4,\n            radius: 20,\n            opacity: 0.08,\n            blur: 2,\n            falloff: 1.0,\n            intensity: 0.5,\n            blendMode: \"overlay\"\n        },\n        blueStreak: {\n            type: \"anamorphic\",\n            widthModifier: 4.0,\n            heightThreshold: 6,\n            opacity: 0.19,\n            blur: 12,\n            falloff: 1.1,\n            intensity: 1.0,\n            blendMode: \"lighter\",\n            starColor: \"#7cf\",\n            starSize: 220,\n            starIntensity: 1.1,\n            starPoints: 8,\n            starRotation: 0\n        },\n        rainbow: {\n            type: \"circular\",\n            radius: 60,\n            opacity: 0.18,\n            blur: 8,\n            falloff: 1.0,\n            intensity: 1.2,\n            blendMode: \"lighter\"\n        },\n        classic: {\n            type: \"starburst\",\n            points: 8,\n            radius: 48,\n            opacity: 0.18,\n            blur: 4,\n            falloff: 1.0,\n            intensity: 1.0,\n            blendMode: \"lighter\",\n            starSize: 180,\n            starIntensity: 1.0,\n            starPoints: 8,\n            starRotation: 0\n        },\n        crossStar: {\n            type: \"anamorphic\",\n            widthModifier: 1.5,\n            heightThreshold: 8,\n            opacity: 0.15,\n            blur: 6,\n            falloff: 1.0,\n            intensity: 1.0,\n            blendMode: \"lighter\",\n            starSize: 300,\n            starIntensity: 1.5,\n            starPoints: 4,\n            starRotation: 45\n        }\n    };\n    const defaultOptions = {\n        preset: null,\n        type: \"anamorphic\",\n        brightnessThreshold: 200,\n        widthModifier: 1.0,\n        heightThreshold: 10,\n        maxFlares: 20,\n        opacity: 0.2,\n        flareColor: null,\n        radius: 40,\n        points: 6,\n        rotation: 0,\n        blur: 0,\n        falloff: 1.0,\n        intensity: 1.0,\n        blendMode: \"lighter\",\n        directionX: 100,\n        directionY: 100,\n        starSize: 180,\n        starIntensity: 1.0,\n        starColor: null,\n        starPoints: 8,\n        starRotation: 0,\n        starOpacity: 1,\n        streakOpacity: 1,\n        centerOpacity: 1,\n        diagOpacity: 1\n    };\n    let finalOptions = Object.assign({}, defaultOptions);\n    if (flareOptions.preset && presets[flareOptions.preset]) {\n        Object.assign(finalOptions, presets[flareOptions.preset]);\n    }\n    Object.assign(finalOptions, flareOptions);\n    const canvas_node = this.node;\n    let temp = Q('<canvas>', {\n        width: canvas_node.width,\n        height: canvas_node.height\n    }).nodes[0];\n    let ctx = temp.getContext('2d', { willReadFrequently: true });\n    this.saveToHistory();\n    ctx.drawImage(canvas_node, 0, 0);\n    const sourceData = ctx.getImageData(0, 0, temp.width, temp.height).data;\n    let flareColor = finalOptions.flareColor;\n    if (!flareColor) {\n        const avgColor = { r: 0, g: 0, b: 0, count: 0 };\n        for (let y = 0; y < temp.height; y++) {\n            for (let x = 0; x < temp.width; x++) {\n                const index = (y * temp.width + x) * 4;\n                const brightness = (sourceData[index] + sourceData[index + 1] + sourceData[index + 2]) / 3;\n                if (brightness >= finalOptions.brightnessThreshold) {\n                    avgColor.r += sourceData[index];\n                    avgColor.g += sourceData[index + 1];\n                    avgColor.b += sourceData[index + 2];\n                    avgColor.count++;\n                }\n            }\n        }\n        if (avgColor.count > 0) {\n            flareColor = [\n                Math.round(avgColor.r / avgColor.count),\n                Math.round(avgColor.g / avgColor.count),\n                Math.round(avgColor.b / avgColor.count)\n            ];\n        } else {\n            flareColor = [255, 255, 255];\n        }\n    }\n    const flareColorR = flareColor[0];\n    const flareColorG = flareColor[1];\n    const flareColorB = flareColor[2];\n    const flares = [];\n    for (let y = 0; y < temp.height; y++) {\n        for (let x = 0; x < temp.width; x++) {\n            const index = (y * temp.width + x) * 4;\n            const brightness = (sourceData[index] + sourceData[index + 1] + sourceData[index + 2]) / 3;\n            if (brightness >= finalOptions.brightnessThreshold) {\n                flares.push({ x, y, brightness });\n            }\n        }\n    }\n    flares.sort((a, b) => b.brightness - a.brightness);\n    const targetCtx = canvas_node.getContext('2d');\n    function applyBlur(ctx, blur) {\n        if (blur > 0) {\n            ctx.filter = `blur(${blur}px)`;\n        } else {\n            ctx.filter = \"none\";\n        }\n    }\n    function getFinalAlpha(baseAlpha, partOpacity = 1) {\n        return Math.max(0, Math.min(1, baseAlpha * finalOptions.opacity * partOpacity));\n    }\n    function drawAnamorphic(flare) {\n        const starPoints = finalOptions.starPoints || 8;\n        const starSize = finalOptions.starSize || 180;\n        const starIntensity = finalOptions.starIntensity || 1.0;\n        const starRotation = (finalOptions.starRotation || 0) * Math.PI / 180;\n        let starColorStops = [\n            { stop: 0.0, color: 'rgba(255,255,255,1)' },\n            { stop: 0.5, color: 'rgba(120,180,255,0.7)' },\n            { stop: 1.0, color: 'rgba(120,80,255,0.0)' }\n        ];\n        if (finalOptions.starColor) {\n            starColorStops = [\n                { stop: 0.0, color: finalOptions.starColor },\n                { stop: 1.0, color: 'rgba(0,0,0,0)' }\n            ];\n        }\n        const baseAlpha = (flare.brightness / 255) * finalOptions.intensity * starIntensity;\n        const starAlpha = getFinalAlpha(baseAlpha, finalOptions.starOpacity);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        targetCtx.translate(flare.x, flare.y);\n        targetCtx.rotate(starRotation);\n        for (let i = 0; i < starPoints; i++) {\n            const angle = (i / starPoints) * Math.PI * 2;\n            targetCtx.save();\n            targetCtx.rotate(angle);\n            const grad = targetCtx.createLinearGradient(0, 0, 0, -starSize);\n            starColorStops.forEach(cs => grad.addColorStop(cs.stop, cs.color.replace(/[\\d\\.]+\\)$/g, starAlpha + ')')));\n            targetCtx.beginPath();\n            targetCtx.moveTo(-2, 0);\n            targetCtx.lineTo(-1, -starSize * 0.15);\n            targetCtx.lineTo(0, -starSize);\n            targetCtx.lineTo(1, -starSize * 0.15);\n            targetCtx.lineTo(2, 0);\n            targetCtx.closePath();\n            targetCtx.fillStyle = grad;\n            targetCtx.shadowColor = 'rgba(120,180,255,0.5)';\n            targetCtx.shadowBlur = starSize * 0.12;\n            targetCtx.globalAlpha = 1.0;\n            targetCtx.fill();\n            targetCtx.restore();\n        }\n        targetCtx.restore();\n        const centerRadius = Math.max(30, flare.brightness / finalOptions.brightnessThreshold * 60);\n        const centerAlpha = getFinalAlpha(baseAlpha, finalOptions.centerOpacity);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 6);\n        let grad = targetCtx.createRadialGradient(flare.x, flare.y, 0, flare.x, flare.y, centerRadius);\n        grad.addColorStop(0, `rgba(120,180,255,${centerAlpha})`);\n        grad.addColorStop(0.5, `rgba(120,180,255,${centerAlpha * 0.5})`);\n        grad.addColorStop(1, `rgba(120,180,255,0)`);\n        targetCtx.beginPath();\n        targetCtx.arc(flare.x, flare.y, centerRadius, 0, 2 * Math.PI);\n        targetCtx.fillStyle = grad;\n        targetCtx.fill();\n        targetCtx.restore();\n        const size = flare.brightness / finalOptions.brightnessThreshold * (400 * (finalOptions.widthModifier || 2.5));\n        const height = finalOptions.heightThreshold || 8;\n        const streakBaseAlpha = (flare.brightness / 255) * finalOptions.intensity * 0.7;\n        const streakAlpha = getFinalAlpha(streakBaseAlpha, finalOptions.streakOpacity);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 2);\n        let streakGrad = targetCtx.createLinearGradient(\n            flare.x - size / 2, flare.y,\n            flare.x + size / 2, flare.y\n        );\n        streakGrad.addColorStop(0, `rgba(120,180,255,0)`);\n        streakGrad.addColorStop(0.45, `rgba(120,180,255,${streakAlpha * 0.2})`);\n        streakGrad.addColorStop(0.5, `rgba(120,180,255,${streakAlpha})`);\n        streakGrad.addColorStop(0.55, `rgba(120,180,255,${streakAlpha * 0.2})`);\n        streakGrad.addColorStop(1, `rgba(120,180,255,0)`);\n        targetCtx.beginPath();\n        targetCtx.fillStyle = streakGrad;\n        targetCtx.fillRect(flare.x - size / 2, flare.y - height / 2, size, height);\n        targetCtx.restore();\n        const vStreakAlpha = streakAlpha * 0.25 * (finalOptions.streakOpacity || 1);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 1);\n        let vStreakGrad = targetCtx.createLinearGradient(\n            flare.x, flare.y - size / 2,\n            flare.x, flare.y + size / 2\n        );\n        vStreakGrad.addColorStop(0, `rgba(120,180,255,0)`);\n        vStreakGrad.addColorStop(0.45, `rgba(120,180,255,${vStreakAlpha})`);\n        vStreakGrad.addColorStop(0.5, `rgba(120,180,255,${vStreakAlpha * 2})`);\n        vStreakGrad.addColorStop(0.55, `rgba(120,180,255,${vStreakAlpha})`);\n        vStreakGrad.addColorStop(1, `rgba(120,180,255,0)`);\n        targetCtx.beginPath();\n        targetCtx.fillStyle = vStreakGrad;\n        targetCtx.fillRect(flare.x - height / 2, flare.y - size / 2, height, size);\n        targetCtx.restore();\n        const streakCount = 4;\n        const diagAlpha = getFinalAlpha(streakBaseAlpha * 0.12, finalOptions.diagOpacity);\n        for (let i = 0; i < streakCount; i++) {\n            const angle = (Math.PI / 2) * i + Math.PI / 4;\n            targetCtx.save();\n            targetCtx.globalCompositeOperation = finalOptions.blendMode;\n            targetCtx.translate(flare.x, flare.y);\n            targetCtx.rotate(angle);\n            applyBlur(targetCtx, finalOptions.blur);\n            let diagGrad = targetCtx.createLinearGradient(\n                -size / 2, 0,\n                size / 2, 0\n            );\n            diagGrad.addColorStop(0, `rgba(120,180,255,0)`);\n            diagGrad.addColorStop(0.5, `rgba(120,180,255,${diagAlpha})`);\n            diagGrad.addColorStop(1, `rgba(120,180,255,0)`);\n            targetCtx.beginPath();\n            targetCtx.fillStyle = diagGrad;\n            targetCtx.fillRect(-size / 2, -height / 2, size, height);\n            targetCtx.restore();\n        }\n    }\n    function drawCircular(flare) {\n        const w = temp.width, h = temp.height;\n        const cx = flare.x, cy = flare.y;\n        const centerX = w / 2, centerY = h / 2;\n        const dx = centerX - cx, dy = centerY - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const mainBaseAlpha = (flare.brightness / 255) * finalOptions.intensity;\n        const mainAlpha = getFinalAlpha(mainBaseAlpha);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 8);\n        let grad = targetCtx.createRadialGradient(cx, cy, 0, cx, cy, finalOptions.radius * 1.2);\n        grad.addColorStop(0, `rgba(255,255,255,${mainAlpha})`);\n        grad.addColorStop(0.5, `rgba(255,255,255,${mainAlpha * 0.5})`);\n        grad.addColorStop(1, `rgba(255,255,255,0)`);\n        targetCtx.beginPath();\n        targetCtx.arc(cx, cy, finalOptions.radius * 1.2, 0, 2 * Math.PI);\n        targetCtx.fillStyle = grad;\n        targetCtx.fill();\n        targetCtx.restore();\n        const haloRadii = [finalOptions.radius * 2.2, finalOptions.radius * 1.7, finalOptions.radius * 1.3];\n        const haloColors = [\n            [180, 220, 255],\n            [255, 220, 180],\n            [200, 180, 255]\n        ];\n        for (let i = 0; i < haloRadii.length; i++) {\n            targetCtx.save();\n            targetCtx.globalCompositeOperation = finalOptions.blendMode;\n            applyBlur(targetCtx, finalOptions.blur + 2 + i);\n            let haloGrad = targetCtx.createRadialGradient(cx, cy, haloRadii[i] * 0.7, cx, cy, haloRadii[i]);\n            haloGrad.addColorStop(0, `rgba(${haloColors[i][0]},${haloColors[i][1]},${haloColors[i][2]},${mainAlpha * 0.08})`);\n            haloGrad.addColorStop(1, `rgba(${haloColors[i][0]},${haloColors[i][1]},${haloColors[i][2]},0)`);\n            targetCtx.beginPath();\n            targetCtx.arc(cx, cy, haloRadii[i], 0, 2 * Math.PI);\n            targetCtx.fillStyle = haloGrad;\n            targetCtx.fill();\n            targetCtx.restore();\n        }\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 1);\n        let arcRadius = finalOptions.radius * 2.1;\n        let arcCenter = { x: cx, y: cy };\n        let arcStart = Math.PI * 0.15, arcEnd = Math.PI * 1.85;\n        let arcGrad = targetCtx.createLinearGradient(\n            arcCenter.x - arcRadius, arcCenter.y,\n            arcCenter.x + arcRadius, arcCenter.y\n        );\n        arcGrad.addColorStop(0.0, \"rgba(255,0,0,0.13)\");\n        arcGrad.addColorStop(0.2, \"rgba(255,255,0,0.13)\");\n        arcGrad.addColorStop(0.4, \"rgba(0,255,0,0.13)\");\n        arcGrad.addColorStop(0.6, \"rgba(0,255,255,0.13)\");\n        arcGrad.addColorStop(0.8, \"rgba(0,0,255,0.13)\");\n        arcGrad.addColorStop(1.0, \"rgba(255,0,255,0.13)\");\n        targetCtx.beginPath();\n        targetCtx.arc(arcCenter.x, arcCenter.y, arcRadius, arcStart, arcEnd, false);\n        targetCtx.lineWidth = Math.max(2, finalOptions.radius * 0.08);\n        targetCtx.strokeStyle = arcGrad;\n        targetCtx.shadowColor = \"rgba(255,255,255,0.08)\";\n        targetCtx.shadowBlur = arcRadius * 0.08;\n        targetCtx.stroke();\n        targetCtx.shadowBlur = 0;\n        targetCtx.restore();\n        const ghostCount = 4;\n        for (let i = 1; i <= ghostCount; i++) {\n            const t = i / (ghostCount + 1);\n            const gx = cx + dx * t;\n            const gy = cy + dy * t;\n            const ghostRadius = finalOptions.radius * (0.5 + 0.3 * Math.sin(i));\n            const ghostAlpha = mainAlpha * (0.18 + 0.12 * Math.cos(i));\n            const ghostColors = [\n                [180, 220, 255],\n                [255, 180, 220],\n                [220, 180, 255],\n                [200, 255, 255]\n            ];\n            const gc = ghostColors[i % ghostColors.length];\n            targetCtx.save();\n            targetCtx.globalCompositeOperation = finalOptions.blendMode;\n            applyBlur(targetCtx, finalOptions.blur + 1);\n            let ghostGrad = targetCtx.createRadialGradient(gx, gy, 0, gx, gy, ghostRadius);\n            ghostGrad.addColorStop(0, `rgba(${gc[0]},${gc[1]},${gc[2]},${ghostAlpha * 0.7})`);\n            ghostGrad.addColorStop(1, `rgba(${gc[0]},${gc[1]},${gc[2]},0)`);\n            targetCtx.beginPath();\n            targetCtx.arc(gx, gy, ghostRadius, 0, 2 * Math.PI);\n            targetCtx.fillStyle = ghostGrad;\n            targetCtx.fill();\n            targetCtx.restore();\n        }\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, 0);\n        let dotArcRadius = finalOptions.radius * 2.3;\n        let dotCount = 32;\n        for (let i = 0; i < dotCount; i++) {\n            const theta = Math.PI * 0.2 + (Math.PI * 1.6) * (i / dotCount);\n            const x = cx + Math.cos(theta) * dotArcRadius;\n            const y = cy + Math.sin(theta) * dotArcRadius;\n            targetCtx.beginPath();\n            targetCtx.arc(x, y, 1.2 + Math.sin(i) * 0.7, 0, 2 * Math.PI);\n            targetCtx.fillStyle = `rgba(255,255,255,0.13)`;\n            targetCtx.fill();\n        }\n        targetCtx.restore();\n    }\n    function drawStarburst(flare) {\n        const w = temp.width, h = temp.height;\n        const dirX = (finalOptions.directionX !== undefined ? finalOptions.directionX : 100) / 100 * w;\n        const dirY = (finalOptions.directionY !== undefined ? finalOptions.directionY : 100) / 100 * h;\n        const cx = flare.x, cy = flare.y;\n        const dx = dirX - cx, dy = dirY - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx);\n        let color = flareColor;\n        if (!finalOptions.flareColor) color = [255, 200, 120];\n        const [r, g, b] = color;\n        const points = Math.max(4, finalOptions.points || 12);\n        const outerRadius = (flare.brightness / finalOptions.brightnessThreshold) * (finalOptions.radius * 1.2);\n        const innerRadius = outerRadius * 0.3;\n        const angleStep = Math.PI / points;\n        const rotation = finalOptions.rotation || 0;\n        const baseAlpha = (flare.brightness / 255) * finalOptions.intensity;\n        const alpha = getFinalAlpha(baseAlpha);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur);\n        targetCtx.translate(cx, cy);\n        targetCtx.rotate(rotation * Math.PI / 180 + angle);\n        targetCtx.beginPath();\n        for (let i = 0; i < points * 2; i++) {\n            const r0 = (i % 2 === 0) ? outerRadius : innerRadius;\n            const a = i * angleStep;\n            targetCtx.lineTo(Math.cos(a) * r0, Math.sin(a) * r0);\n        }\n        targetCtx.closePath();\n        targetCtx.fillStyle = `rgba(${r},${g},${b},${alpha})`;\n        targetCtx.shadowColor = `rgba(${r},${g},${b},0.7)`;\n        targetCtx.shadowBlur = outerRadius * 0.5 * finalOptions.falloff;\n        targetCtx.fill();\n        targetCtx.shadowBlur = 0;\n        targetCtx.restore();\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 2);\n        targetCtx.beginPath();\n        const arcRadius = dist * 0.7;\n        const arcStart = angle - Math.PI / 3;\n        const arcEnd = angle + Math.PI / 1.5;\n        targetCtx.arc(cx, cy, arcRadius, arcStart, arcEnd, false);\n        targetCtx.lineWidth = Math.max(2, outerRadius * 0.08);\n        targetCtx.strokeStyle = `rgba(${r},${g},${b},${alpha * 0.25})`;\n        targetCtx.shadowColor = `rgba(${r},${g},${b},0.2)`;\n        targetCtx.shadowBlur = arcRadius * 0.08;\n        targetCtx.stroke();\n        targetCtx.shadowBlur = 0;\n        targetCtx.restore();\n        const ghostCount = 5;\n        for (let i = 1; i <= ghostCount; i++) {\n            const t = i / (ghostCount + 1);\n            const gx = cx + dx * t;\n            const gy = cy + dy * t;\n            const ghostRadius = outerRadius * (0.18 + 0.12 * Math.sin(i));\n            const ghostAlpha = alpha * (0.18 + 0.12 * Math.cos(i));\n            targetCtx.save();\n            targetCtx.globalCompositeOperation = finalOptions.blendMode;\n            applyBlur(targetCtx, finalOptions.blur + 1);\n            targetCtx.translate(gx, gy);\n            targetCtx.rotate(angle + Math.PI / 6 * i);\n            targetCtx.beginPath();\n            for (let j = 0; j < 6; j++) {\n                const a = (j / 6) * 2 * Math.PI;\n                const x = Math.cos(a) * ghostRadius;\n                const y = Math.sin(a) * ghostRadius;\n                if (j === 0) targetCtx.moveTo(x, y);\n                else targetCtx.lineTo(x, y);\n            }\n            targetCtx.closePath();\n            targetCtx.fillStyle = `rgba(${r},${g},${b},${ghostAlpha})`;\n            targetCtx.shadowColor = `rgba(${r},${g},${b},0.18)`;\n            targetCtx.shadowBlur = ghostRadius * 0.7;\n            targetCtx.fill();\n            targetCtx.shadowBlur = 0;\n            targetCtx.restore();\n        }\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur + 3);\n        let grad = targetCtx.createRadialGradient(cx, cy, 0, cx, cy, outerRadius * 0.7);\n        grad.addColorStop(0, `rgba(${r},${g},${b},${alpha * 0.8})`);\n        grad.addColorStop(1, `rgba(${r},${g},${b},0)`);\n        targetCtx.beginPath();\n        targetCtx.arc(cx, cy, outerRadius * 0.7, 0, 2 * Math.PI);\n        targetCtx.fillStyle = grad;\n        targetCtx.fill();\n        targetCtx.restore();\n    }\n    function drawPolygon(flare) {\n        const sides = Math.max(3, finalOptions.points || 6);\n        const radius = (flare.brightness / finalOptions.brightnessThreshold) * finalOptions.radius;\n        const rotation = finalOptions.rotation || 0;\n        const baseAlpha = (flare.brightness / 255) * finalOptions.intensity;\n        const alpha = getFinalAlpha(baseAlpha);\n        targetCtx.save();\n        targetCtx.globalCompositeOperation = finalOptions.blendMode;\n        applyBlur(targetCtx, finalOptions.blur);\n        targetCtx.translate(flare.x, flare.y);\n        targetCtx.rotate(rotation * Math.PI / 180);\n        targetCtx.beginPath();\n        for (let i = 0; i < sides; i++) {\n            const angle = (i / sides) * 2 * Math.PI;\n            const x = Math.cos(angle) * radius;\n            const y = Math.sin(angle) * radius;\n            if (i === 0) targetCtx.moveTo(x, y);\n            else targetCtx.lineTo(x, y);\n        }\n        targetCtx.closePath();\n        targetCtx.fillStyle = `rgba(${flareColorR}, ${flareColorG}, ${flareColorB}, ${alpha})`;\n        targetCtx.shadowColor = `rgba(${flareColorR}, ${flareColorG}, ${flareColorB}, 0.5)`;\n        targetCtx.shadowBlur = radius * 0.3 * finalOptions.falloff;\n        targetCtx.fill();\n        targetCtx.shadowBlur = 0;\n        targetCtx.restore();\n    }\n    for (let i = 0; i < Math.min(finalOptions.maxFlares, flares.length); i++) {\n        const flare = flares[i];\n        switch (finalOptions.type) {\n            case \"anamorphic\":\n                drawAnamorphic(flare);\n                break;\n            case \"circular\":\n                drawCircular(flare);\n                break;\n            case \"starburst\":\n                drawStarburst(flare);\n                break;\n            case \"polygon\":\n                drawPolygon(flare);\n                break;\n            default:\n                drawAnamorphic(flare);\n        }\n    }\n    targetCtx.globalCompositeOperation = \"source-over\";\n    targetCtx.filter = \"none\";\n    return this;\n};"
            },
            "Image.RGBSubpixel": {
                "uuid": "718b900c-171a-4e5f-927c-33767bc1f501",
                "name": "Image.RGBSubpixel",
                "method": "Prototype",
                "desc": "Simulates RGB subpixel rendering on the image.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 320, height: 240 });\nimg.Load('photo.jpg', function() { img.RGBSubpixel({ subpixelLayout: 'rgb', subpixelGlow: true }); });",
                    "Q.Image().Load('img.png').RGBSubpixel({ subpixelLayout: 'quad', screenBleed: true });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.RGBSubpixel = function (subpixelOptions = {}) {\n    const defaultOptions = {\n        subpixelSizeX: 2,\n        subpixelSizeY: 3,\n        padding: 1,\n        subpixelLayout: 'rgb',\n        subpixelGlow: false,\n        glowStrength: 0.4,\n        glowRadius: 2,\n        screenBleed: false,\n        bleedOpacity: 0.15,\n        bleedSize: 24\n    };\n    const opts = Object.assign({}, defaultOptions, subpixelOptions);\n    const canvas_node = this.node;\n    const w = canvas_node.width, h = canvas_node.height;\n    if (w === 0 || h === 0) return this;\n    this.saveToHistory();\n    let subpixelCountX = 3, subpixelCountY = 1;\n    if (opts.subpixelLayout === 'quad') { subpixelCountX = 2; subpixelCountY = 2; }\n    else if (opts.subpixelLayout === 'vrgb' || opts.subpixelLayout === 'vbgr') { subpixelCountX = 1; subpixelCountY = 3; }\n    const blockSizeX = opts.subpixelSizeX * subpixelCountX + opts.padding;\n    const blockSizeY = opts.subpixelSizeY * subpixelCountY + opts.padding;\n    const ctx = canvas_node.getContext('2d', { willReadFrequently: true });\n    const srcData = ctx.getImageData(0, 0, w, h).data;\n    const blocksX = Math.ceil(w / blockSizeX);\n    const blocksY = Math.ceil(h / blockSizeY);\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = blocksX * blockSizeX;\n    tempCanvas.height = blocksY * blockSizeY;\n    const tempCtx = tempCanvas.getContext('2d');\n    const tempImg = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);\n    const tempData = tempImg.data;\n    function getSubpixelColor(sx, sy, r, g, b, a, layout) {\n        if (layout === 'rgb') {\n            const idx = Math.floor(sx / opts.subpixelSizeX);\n            if (idx === 0) return [r, 0, 0, a];\n            if (idx === 1) return [0, g, 0, a];\n            if (idx === 2) return [0, 0, b, a];\n        } else if (layout === 'bgr') {\n            const idx = Math.floor(sx / opts.subpixelSizeX);\n            if (idx === 0) return [0, 0, b, a];\n            if (idx === 1) return [0, g, 0, a];\n            if (idx === 2) return [r, 0, 0, a];\n        } else if (layout === 'vrgb') {\n            const idx = Math.floor(sy / opts.subpixelSizeY);\n            if (idx === 0) return [r, 0, 0, a];\n            if (idx === 1) return [0, g, 0, a];\n            if (idx === 2) return [0, 0, b, a];\n        } else if (layout === 'vbgr') {\n            const idx = Math.floor(sy / opts.subpixelSizeY);\n            if (idx === 0) return [0, 0, b, a];\n            if (idx === 1) return [0, g, 0, a];\n            if (idx === 2) return [r, 0, 0, a];\n        } else if (layout === 'quad') {\n            const qx = Math.floor(sx / opts.subpixelSizeX);\n            const qy = Math.floor(sy / opts.subpixelSizeY);\n            if (qx === 0 && qy === 0) return [r, 0, 0, a];\n            if (qx === 1 && qy === 0) return [0, g, 0, a];\n            if (qx === 0 && qy === 1) return [0, 0, b, a];\n            return [0, 0, 0, a];\n        }\n        return [r, g, b, a];\n    }\n    for (let by = 0; by < blocksY; ++by) {\n        for (let bx = 0; bx < blocksX; ++bx) {\n            let r = 0, g = 0, b = 0, a = 0, count = 0;\n            for (let dy = 0; dy < blockSizeY; ++dy) {\n                for (let dx = 0; dx < blockSizeX; ++dx) {\n                    const sx = bx * blockSizeX + dx;\n                    const sy = by * blockSizeY + dy;\n                    if (sx < w && sy < h) {\n                        const idx = (sy * w + sx) * 4;\n                        r += srcData[idx];\n                        g += srcData[idx + 1];\n                        b += srcData[idx + 2];\n                        a += srcData[idx + 3];\n                        count++;\n                    }\n                }\n            }\n            r = Math.round(r / count);\n            g = Math.round(g / count);\n            b = Math.round(b / count);\n            a = Math.round(a / count);\n            for (let sy = 0; sy < blockSizeY; ++sy) {\n                for (let sx = 0; sx < blockSizeX; ++sx) {\n                    const tx = bx * blockSizeX + sx;\n                    const ty = by * blockSizeY + sy;\n                    const tidx = (ty * tempCanvas.width + tx) * 4;\n                    if (sx >= blockSizeX - opts.padding || sy >= blockSizeY - opts.padding) {\n                        tempData[tidx] = 0;\n                        tempData[tidx + 1] = 0;\n                        tempData[tidx + 2] = 0;\n                        tempData[tidx + 3] = 255;\n                    } else {\n                        const [cr, cg, cb, ca] = getSubpixelColor(sx, sy, r, g, b, a, opts.subpixelLayout);\n                        tempData[tidx] = cr;\n                        tempData[tidx + 1] = cg;\n                        tempData[tidx + 2] = cb;\n                        tempData[tidx + 3] = ca;\n                    }\n                }\n            }\n        }\n    }\n    tempCtx.putImageData(tempImg, 0, 0);\n    if (opts.subpixelGlow) {\n        const glowCanvas = document.createElement('canvas');\n        glowCanvas.width = tempCanvas.width;\n        glowCanvas.height = tempCanvas.height;\n        const glowCtx = glowCanvas.getContext('2d');\n        const glowImg = glowCtx.createImageData(tempCanvas.width, tempCanvas.height);\n        const glowData = glowImg.data;\n        for (let by = 0; by < blocksY; ++by) {\n            for (let bx = 0; bx < blocksX; ++bx) {\n                for (let sy = 0; sy < blockSizeY - opts.padding; ++sy) {\n                    for (let sx = 0; sx < blockSizeX - opts.padding; ++sx) {\n                        const tx = bx * blockSizeX + sx;\n                        const ty = by * blockSizeY + sy;\n                        const tidx = (ty * tempCanvas.width + tx) * 4;\n                        glowData[tidx] = tempData[tidx];\n                        glowData[tidx + 1] = tempData[tidx + 1];\n                        glowData[tidx + 2] = tempData[tidx + 2];\n                        glowData[tidx + 3] = tempData[tidx + 3];\n                    }\n                }\n            }\n        }\n        glowCtx.putImageData(glowImg, 0, 0);\n        tempCtx.save();\n        tempCtx.globalAlpha = opts.glowStrength;\n        tempCtx.globalCompositeOperation = \"lighten\";\n        tempCtx.filter = `blur(${opts.glowRadius}px)`;\n        tempCtx.drawImage(glowCanvas, 0, 0);\n        tempCtx.filter = \"none\";\n        tempCtx.globalAlpha = 1.0;\n        tempCtx.globalCompositeOperation = \"source-over\";\n        tempCtx.restore();\n    }\n    if (opts.screenBleed) {\n        tempCtx.save();\n        tempCtx.globalAlpha = opts.bleedOpacity;\n        let grad = tempCtx.createLinearGradient(0, 0, 0, opts.bleedSize);\n        grad.addColorStop(0, \"#fff\");\n        grad.addColorStop(1, \"rgba(255,255,255,0)\");\n        tempCtx.fillStyle = grad;\n        tempCtx.fillRect(0, 0, tempCanvas.width, opts.bleedSize);\n        grad = tempCtx.createLinearGradient(0, tempCanvas.height - opts.bleedSize, 0, tempCanvas.height);\n        grad.addColorStop(0, \"rgba(255,255,255,0)\");\n        grad.addColorStop(1, \"#fff\");\n        tempCtx.fillStyle = grad;\n        tempCtx.fillRect(0, tempCanvas.height - opts.bleedSize, tempCanvas.width, opts.bleedSize);\n        grad = tempCtx.createLinearGradient(0, 0, opts.bleedSize, 0);\n        grad.addColorStop(0, \"#fff\");\n        grad.addColorStop(1, \"rgba(255,255,255,0)\");\n        tempCtx.fillStyle = grad;\n        tempCtx.fillRect(0, 0, opts.bleedSize, tempCanvas.height);\n        grad = tempCtx.createLinearGradient(tempCanvas.width - opts.bleedSize, 0, tempCanvas.width, 0);\n        grad.addColorStop(0, \"rgba(255,255,255,0)\");\n        grad.addColorStop(1, \"#fff\");\n        tempCtx.fillStyle = grad;\n        tempCtx.fillRect(tempCanvas.width - opts.bleedSize, 0, opts.bleedSize, tempCanvas.height);\n        tempCtx.globalAlpha = 1.0;\n        tempCtx.restore();\n    }\n    ctx.clearRect(0, 0, w, h);\n    ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, w, h);\n    return this;\n};"
            },
            "Image.Sharpen": {
                "uuid": "a299ca54-8c77-4162-bd18-7818532bc920",
                "name": "Image.Sharpen",
                "method": "Prototype",
                "desc": "Sharpens the image using an unsharp mask technique.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.Sharpen({ amount: 1.5, radius: 2 }); });",
                    "Q.Image().Load('img.png').Sharpen({ threshold: 10, details: 0.8 });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Sharpen = function (options = {}) {\n    const DEFAULTS = {\n        amount: 1.0,\n        radius: 1.0,\n        threshold: 0,\n        details: 0.5\n    };\n    const s = Object.assign({}, DEFAULTS, options);\n    s.amount = Math.min(4, Math.max(0, s.amount));\n    s.radius = Math.max(0, s.radius);\n    s.threshold = Math.max(0, s.threshold);\n    s.details = Math.min(1, Math.max(0, s.details));\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const { width, height } = this.node;\n    const imgData = ctx.getImageData(0, 0, width, height);\n    const src = imgData.data;\n    const blurred = new Uint8ClampedArray(src);\n    const { kernel, size } = createGaussianKernel(s.radius);\n    convolve(src, blurred, width, height, kernel, size);\n    const amountFactor = s.amount * 0.75;\n    const detailFactor = s.details * 2;\n    for (let i = 0; i < src.length; i += 4) {\n        const r = src[i], g = src[i + 1], b = src[i + 2];\n        const rB = blurred[i], gB = blurred[i + 1], bB = blurred[i + 2];\n        const Y = 0.299 * r + 0.587 * g + 0.114 * b;\n        const Yb = 0.299 * rB + 0.587 * gB + 0.114 * bB;\n        const diff = Y - Yb;\n        if (Math.abs(diff) > s.threshold) {\n            const f = amountFactor + detailFactor * (Math.abs(diff) / 255);\n            const Ynew = Y + diff * f;\n            const ratio = Y > 0 ? Ynew / Y : 1;\n            imgData.data[i] = clamp255(r * ratio);\n            imgData.data[i + 1] = clamp255(g * ratio);\n            imgData.data[i + 2] = clamp255(b * ratio);\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    this.saveToHistory();\n    return this;\n};\nfunction clamp255(v) {\n    return v < 0 ? 0 : v > 255 ? 255 : v;\n}\nfunction createGaussianKernel(radius) {\n    radius = Math.floor(Math.max(0, radius));\n    const size = 2 * radius + 1;\n    if (size < 1) return { kernel: new Float32Array([1]), size: 1 };\n    if (radius === 0) return { kernel: new Float32Array([1]), size: 1 };\n    const kernel = new Float32Array(size * size);\n    const sigma = radius / 3;\n    const twoSigma2 = 2 * sigma * sigma;\n    let sum = 0, idx = 0, center = radius;\n    for (let y = 0; y < size; y++) {\n        for (let x = 0; x < size; x++, idx++) {\n            const dx = x - center, dy = y - center;\n            const w = Math.exp(-(dx * dx + dy * dy) / twoSigma2);\n            kernel[idx] = w;\n            sum += w;\n        }\n    }\n    if (sum <= 0 || !isFinite(sum)) {\n        kernel.fill(0);\n        kernel[center * size + center] = 1;\n        return { kernel, size: 1 };\n    }\n    for (let i = 0; i < kernel.length; i++) {\n        kernel[i] = isFinite(kernel[i] / sum) ? kernel[i] / sum : 0;\n    }\n    return { kernel, size };\n}\nfunction convolve(src, dst, width, height, kernel, size) {\n    const half = Math.floor(size / 2);\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            let r = 0, g = 0, b = 0, a = 0, wsum = 0;\n            const off = (y * width + x) * 4;\n            for (let ky = 0; ky < size; ky++) {\n                for (let kx = 0; kx < size; kx++) {\n                    const ny = y + ky - half;\n                    const nx = x + kx - half;\n                    if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                        const w = kernel[ky * size + kx];\n                        const i = (ny * width + nx) * 4;\n                        if (isFinite(w)) {\n                            r += src[i] * w;\n                            g += src[i + 1] * w;\n                            b += src[i + 2] * w;\n                            a += src[i + 3] * w;\n                            wsum += w;\n                        }\n                    }\n                }\n            }\n            if (wsum > 0) {\n                dst[off] = r / wsum;\n                dst[off + 1] = g / wsum;\n                dst[off + 2] = b / wsum;\n                dst[off + 3] = a / wsum;\n            } else {\n                dst[off] = src[off];\n                dst[off + 1] = src[off + 1];\n                dst[off + 2] = src[off + 2];\n                dst[off + 3] = src[off + 3];\n            }\n        }\n    }\n};"
            },
            "Image.Zoom": {
                "uuid": "62a7c827-23c9-4c00-b963-2aab7e696ce6",
                "name": "Image.Zoom",
                "method": "Prototype",
                "desc": "Zooms the image in or out around a center point.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 200, height: 200 });\nimg.Load('photo.jpg', function() { img.Zoom(2); });",
                    "Q.Image().Load('img.png').Zoom(0.5, { background: '#fff' });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.Zoom = function(factor = 1.5, zoomOptions = {}) {\n        const defaultOptions = {\n            centerX: this.node.width / 2,   // Default center point X\n            centerY: this.node.height / 2,  // Default center point Y\n            smoothing: true,                // Whether to use smoothing\n            quality: 'high',                // Smoothing quality: 'low', 'medium', 'high'\n            background: 'transparent'       // Background for areas outside the image when zooming out\n        };\n        const finalOptions = Object.assign({}, defaultOptions, zoomOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d');\n        this.saveToHistory(); // Save the current state to history\n        ctx.imageSmoothingEnabled = finalOptions.smoothing;\n        ctx.imageSmoothingQuality = finalOptions.quality;\n        ctx.fillStyle = finalOptions.background;\n        ctx.fillRect(0, 0, temp.width, temp.height);\n        if (factor >= 1) {\n            const sWidth = canvas_node.width / factor;\n            const sHeight = canvas_node.height / factor;\n            const sx = finalOptions.centerX - (sWidth / 2);\n            const sy = finalOptions.centerY - (sHeight / 2);\n            const boundedSx = Math.max(0, Math.min(canvas_node.width - sWidth, sx));\n            const boundedSy = Math.max(0, Math.min(canvas_node.height - sHeight, sy));\n            ctx.drawImage(\n                canvas_node,\n                boundedSx, boundedSy, sWidth, sHeight,\n                0, 0, canvas_node.width, canvas_node.height\n            );\n        } else {\n            const scaledWidth = canvas_node.width * factor;\n            const scaledHeight = canvas_node.height * factor;\n            const dx = (canvas_node.width - scaledWidth) / 2;\n            const dy = (canvas_node.height - scaledHeight) / 2;\n            ctx.drawImage(\n                canvas_node,\n                0, 0, canvas_node.width, canvas_node.height,\n                dx, dy, scaledWidth, scaledHeight\n            );\n        }\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
            },
            "Image.ZoomBlur": {
                "uuid": "cde1ba2f-bdb4-4018-acae-71355b960f91",
                "name": "Image.ZoomBlur",
                "method": "Prototype",
                "desc": "Applies a zoom blur effect to the image.",
                "type": "Image Effect",
                "example": [
                    "var img = new Q.Image({ width: 300, height: 200 });\nimg.Load('photo.jpg', function() { img.ZoomBlur({ centerX: 50, centerY: 50, strength: 30 }); });",
                    "Q.Image().Load('img.png').ZoomBlur({ strength: 10, steps: 20, opacityStart: 1, opacityEnd: 0.2 });"
                ],
                "dependencies": [
                    "Q.Image"
                ],
                "script": "Q.Image.prototype.ZoomBlur = function (zoomOptions = {}) {\n    const defaultOptions = {\n        centerX: 50,\n        centerY: 50,\n        strength: 20,\n        steps: 15,\n        easing: 'linear',\n        opacityStart: 0.7,\n        opacityEnd: 0.1,\n        baseLayerOpacity: 1.0,\n        progressive: true\n    };\n    this.saveToHistory();\n    const finalOptions = Object.assign({}, defaultOptions, zoomOptions);\n    const canvas_node = this.node;\n    const centerX = (finalOptions.centerX / 100) * canvas_node.width;\n    const centerY = (finalOptions.centerY / 100) * canvas_node.height;\n    const strength = Math.max(1, Math.min(100, finalOptions.strength));\n    const steps = Math.max(3, Math.min(30, finalOptions.steps));\n    const sourceCanvas = document.createElement('canvas');\n    sourceCanvas.width = canvas_node.width;\n    sourceCanvas.height = canvas_node.height;\n    const sourceCtx = sourceCanvas.getContext('2d');\n    sourceCtx.drawImage(canvas_node, 0, 0);\n    const destCanvas = document.createElement('canvas');\n    destCanvas.width = canvas_node.width;\n    destCanvas.height = canvas_node.height;\n    const destCtx = destCanvas.getContext('2d');\n    destCtx.clearRect(0, 0, destCanvas.width, destCanvas.height);\n    if (finalOptions.progressive) {\n        destCtx.globalAlpha = finalOptions.baseLayerOpacity;\n        destCtx.drawImage(sourceCanvas, 0, 0);\n        for (let i = 0; i < steps; i++) {\n            const t = i / (steps - 1);\n            let scale;\n            switch (finalOptions.easing) {\n                case 'easeIn':\n                    scale = 1 + (strength / 100) * (t * t);\n                    break;\n                case 'easeOut':\n                    scale = 1 + (strength / 100) * (1 - (1 - t) * (1 - t));\n                    break;\n                default:\n                    scale = 1 + (strength / 100) * t;\n            }\n            const w = canvas_node.width * scale;\n            const h = canvas_node.height * scale;\n            const x = centerX - (centerX * scale);\n            const y = centerY - (centerY * scale);\n            const layerOpacity = finalOptions.opacityStart +\n                (finalOptions.opacityEnd - finalOptions.opacityStart) * t;\n            destCtx.globalAlpha = layerOpacity;\n            destCtx.drawImage(sourceCanvas, 0, 0, canvas_node.width, canvas_node.height,\n                x, y, w, h);\n        }\n    } else {\n        destCtx.globalAlpha = 1.0;\n        destCtx.drawImage(sourceCanvas, 0, 0);\n        for (let i = 0; i < steps; i++) {\n            const t = i / (steps - 1);\n            let scale;\n            switch (finalOptions.easing) {\n                case 'easeIn':\n                    scale = 1 + (strength / 100) * (t * t);\n                    break;\n                case 'easeOut':\n                    scale = 1 + (strength / 100) * (1 - (1 - t) * (1 - t));\n                    break;\n                default:\n                    scale = 1 + (strength / 100) * t;\n            }\n            const w = canvas_node.width * scale;\n            const h = canvas_node.height * scale;\n            const x = centerX - (centerX * scale);\n            const y = centerY - (centerY * scale);\n            destCtx.globalAlpha = 1 / steps;\n            destCtx.drawImage(sourceCanvas, 0, 0, canvas_node.width, canvas_node.height,\n                x, y, w, h);\n        }\n    }\n    const ctx = canvas_node.getContext('2d');\n    ctx.clearRect(0, 0, canvas_node.width, canvas_node.height);\n    ctx.drawImage(destCanvas, 0, 0);\n    return this;\n};"
            },
            "Media": {
                "uuid": "e77a89c5-ad02-4b8f-9cdb-2e7d97e5dd70",
                "name": "Media",
                "method": "Constructor",
                "desc": "Core media functionality provider for VulpiniQ",
                "type": "Constructor",
                "example": [
                    "var media = new Media();",
                    "var media = Media();",
                    "Q.Media();"
                ],
                "dependencies": [
                    "style"
                ],
                "script": "function Media(options = {}) {\n    if (!(this instanceof Media)) {\n        return new Media(options);\n    }\n    if (!Media.initialized) {\n        Q.style(`\n            --media-timeline-bg: #232323;\n            --media-timeline-track-border: #3338;\n            --media-timeline-segment-normal: #4caf50;\n            --media-timeline-segment-alert: #ff9800;\n            --media-timeline-segment-warning: #f44336;\n            --media-timeline-handle-bg:rgba(255, 255, 255, 0.21);\n        `);\n        Media.initialized = true;\n        console.log('Media core initialized');\n    }\n    return this;\n};\nQ.Media = Media;"
            },
            "Media.Selector": {
                "uuid": "eb061296-d057-4476-b5fa-9407e94f0ca2",
                "name": "Media.Selector",
                "method": "Component",
                "desc": "Region selection tool for images and videos",
                "type": "Component",
                "example": [
                    "var selector = Media.Selector(document.getElementById('video-container'));",
                    "var selector = Media.Selector('#image-container', {default: {x: 10, y: 10, w: 30, h: 30}});",
                    "var selector = Media.Selector('#media').add(20, 20, 40, 40);",
                    "var selector = Media.Selector('#media').aspectRatio('16:9');",
                    "var selector = Media.Selector('#media').set(10, 10, 50, 50);",
                    "var coords = Media.Selector('#media').get();"
                ],
                "dependencies": [
                    "style"
                ],
                "script": "Media.prototype.Selector = function(container, options = {}) {\n    if (!Media.selectorClassesInitialized) {\n        Media.selectorClasses = Q.style(`\n            --media-selector-bg: rgba(0,0,0,0.15);\n            --media-selector-rect: #4caf50;\n            --media-selector-rect-active: #ff9800;\n            --media-selector-dot: #fff;\n            --media-selector-dot-border: #333;\n        `, `\n            .media-selector-canvas {\n                position: absolute;\n                left: 0; top: 0; width: 100%; height: 100%;\n                pointer-events: auto;\n                z-index: 20;\n                background: var(--media-selector-bg, rgba(0,0,0,0.15));\n                cursor: crosshair;\n                user-select: none;\n            }\n            .media-selector-rect {\n                position: absolute;\n                border: 2px solid var(--media-selector-rect, #4caf50);\n                background: rgba(76,175,80,0.08);\n                box-sizing: border-box;\n                pointer-events: auto;\n            }\n            .media-selector-rect.active {\n                border-color: var(--media-selector-rect-active, #ff9800);\n                background: rgba(255,152,0,0.08);\n            }\n            .media-selector-dot {\n                position: absolute;\n                width: 12px; height: 12px;\n                border-radius: 50%;\n                background: var(--media-selector-dot, #fff);\n                border: 2px solid var(--media-selector-dot-border, #333);\n                right: -8px; bottom: -8px;\n                cursor: nwse-resize;\n                z-index: 2;\n            }\n        `, null, {\n            'media-selector-canvas': 'media-selector-canvas',\n            'media-selector-rect': 'media-selector-rect',\n            'media-selector-dot': 'media-selector-dot'\n        }, false);\n        Media.selectorClassesInitialized = true;\n    }\n    const classes = Media.selectorClasses;\n    const wrapper = Q(container);\n    if (window.getComputedStyle(wrapper.nodes[0]).position === 'static') {\n        wrapper.css('position', 'relative');\n    }\n    const canvas = Q('<canvas class=\"' + classes['media-selector-canvas'] + '\"></canvas>');\n    wrapper.append(canvas);\n    let selection = null;\n    let defaultDims = { x: 10, y: 10, w: 30, h: 30 }; // percent\n    function getMediaRect() {\n        const media = wrapper.find('video') || wrapper.find('img');\n        if (!media || !media.nodes[0]) {\n            const rect = wrapper.nodes[0].getBoundingClientRect();\n            return { left: 0, top: 0, width: rect.width, height: rect.height };\n        }\n        const mediaRect = media.nodes[0].getBoundingClientRect();\n        const wrapperRect = wrapper.nodes[0].getBoundingClientRect();\n        return {\n            left: mediaRect.left - wrapperRect.left,\n            top: mediaRect.top - wrapperRect.top,\n            width: mediaRect.width,\n            height: mediaRect.height\n        };\n    }\n    function percentToPx({x, y, w, h}) {\n        const mediaRect = getMediaRect();\n        return {\n            x: mediaRect.left + mediaRect.width * x / 100,\n            y: mediaRect.top + mediaRect.height * y / 100,\n            w: mediaRect.width * w / 100,\n            h: mediaRect.height * h / 100\n        };\n    }\n    function pxToPercent({x, y, w, h}) {\n        const mediaRect = getMediaRect();\n        return {\n            x: mediaRect.width ? ((x - mediaRect.left) / mediaRect.width * 100) : 0,\n            y: mediaRect.height ? ((y - mediaRect.top) / mediaRect.height * 100) : 0,\n            w: mediaRect.width ? (w / mediaRect.width * 100) : 0,\n            h: mediaRect.height ? (h / mediaRect.height * 100) : 0\n        };\n    }\n    function renderSelections() {\n        const el = canvas.nodes[0];\n        const rect = wrapper.nodes[0].getBoundingClientRect();\n        el.width = rect.width;\n        el.height = rect.height;\n        el.style.width = rect.width + \"px\";\n        el.style.height = rect.height + \"px\";\n        const ctx = el.getContext('2d');\n        ctx.clearRect(0, 0, el.width, el.height);\n        if (!selection) {\n            return;\n        }\n        const dimsPx = percentToPx(selection);\n        ctx.save();\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, el.width, el.height);\n        ctx.clearRect(dimsPx.x, dimsPx.y, dimsPx.w, dimsPx.h);\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'rgba(255,255,255,0.1)';\n        ctx.lineWidth = 1;\n        ctx.strokeRect(dimsPx.x, dimsPx.y, dimsPx.w, dimsPx.h);\n        ctx.restore();\n        ctx.save();\n        ctx.clearRect(dimsPx.x + dimsPx.w - 3, dimsPx.y + dimsPx.h - 3, 6, 6);\n        ctx.strokeStyle = '#333';\n        ctx.lineWidth = 0.8;\n        ctx.fillStyle = 'rgba(255,255,255,0.1)';\n        ctx.beginPath();\n        ctx.rect(dimsPx.x + dimsPx.w - 3, dimsPx.y + dimsPx.h - 3, 6, 6);\n        ctx.fill();\n        ctx.stroke();\n        ctx.restore();\n    }\n    let drawing = null;\n    let drag = null;\n    canvas.on('mousedown', function(e) {\n        const rect = wrapper.nodes[0].getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        if (selection) {\n            const dimsPx = percentToPx(selection);\n            const dx = x - (dimsPx.x + dimsPx.w);\n            const dy = y - (dimsPx.y + dimsPx.h);\n            if (dx*dx + dy*dy <= 64) {\n                drag = {\n                    type: 'resize',\n                    startX: e.clientX,\n                    startY: e.clientY,\n                    orig: {...selection}\n                };\n                document.body.style.userSelect = 'none';\n                e.stopPropagation();\n                return;\n            }\n            if (\n                x >= dimsPx.x && x <= dimsPx.x + dimsPx.w &&\n                y >= dimsPx.y && y <= dimsPx.y + dimsPx.h\n            ) {\n                drag = {\n                    type: 'move',\n                    startX: e.clientX,\n                    startY: e.clientY,\n                    orig: {...selection}\n                };\n                document.body.style.userSelect = 'none';\n                e.stopPropagation();\n                return;\n            }\n        }\n        drawing = { startX: x, startY: y, endX: x, endY: y };\n    });\n    document.addEventListener('mousemove', function(e) {\n        if (drawing) {\n            const rect = wrapper.nodes[0].getBoundingClientRect();\n            drawing.endX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));\n            drawing.endY = Math.max(0, Math.min(e.clientY - rect.top, rect.height));\n            renderSelections();\n            const x = Math.min(drawing.startX, drawing.endX);\n            const y = Math.min(drawing.startY, drawing.endY);\n            const w = Math.abs(drawing.endX - drawing.startX);\n            const h = Math.abs(drawing.endY - drawing.startY);\n            const el = canvas.nodes[0];\n            const ctx = el.getContext('2d');\n            ctx.save();\n            ctx.strokeStyle = '#ff9800';\n            ctx.lineWidth = 1;\n            ctx.strokeRect(x, y, w, h);\n            ctx.restore();\n        }\n        if (drag && selection) {\n            const sel = selection;\n            const mediaRect = getMediaRect();\n            if (drag.type === 'resize') {\n                let dx = (e.clientX - drag.startX) / mediaRect.width * 100;\n                let dy = (e.clientY - drag.startY) / mediaRect.height * 100;\n                let newW = Math.max(2, drag.orig.w + dx);\n                let newH = Math.max(2, drag.orig.h + dy);\n                newW = Math.min(newW, 100 - drag.orig.x);\n                newH = Math.min(newH, 100 - drag.orig.y);\n                selection = {\n                    x: drag.orig.x,\n                    y: drag.orig.y,\n                    w: newW,\n                    h: newH\n                };\n                renderSelections();\n            } else if (drag.type === 'move') {\n                let dx = (e.clientX - drag.startX) / mediaRect.width * 100;\n                let dy = (e.clientY - drag.startY) / mediaRect.height * 100;\n                selection = {\n                    x: Math.max(0, Math.min(100 - sel.w, drag.orig.x + dx)),\n                    y: Math.max(0, Math.min(100 - sel.h, drag.orig.y + dy)),\n                    w: sel.w,\n                    h: sel.h\n                };\n                renderSelections();\n            }\n        }\n    });\n    document.addEventListener('mouseup', function(e) {\n        if (drawing) {\n            const rect = wrapper.nodes[0].getBoundingClientRect();\n            const x = Math.min(drawing.startX, drawing.endX);\n            const y = Math.min(drawing.startY, drawing.endY);\n            const w = Math.abs(drawing.endX - drawing.startX);\n            const h = Math.abs(drawing.endY - drawing.startY);\n            if (w > 10 && h > 10) {\n                const perc = pxToPercent({x, y, w, h});\n                add(perc.x, perc.y, perc.w, perc.h);\n            }\n            drawing = null;\n            renderSelections();\n        }\n        if (drag) {\n            drag = null;\n        }\n        document.body.style.userSelect = '';\n    });\n    function handleResize() {\n        renderSelections();\n    }\n    window.addEventListener('resize', handleResize);\n    if (window.ResizeObserver) {\n        const ro = new ResizeObserver(handleResize);\n        ro.observe(wrapper.nodes[0]);\n        const media = wrapper.find('video') || wrapper.find('img');\n        if (media && media.nodes[0]) {\n            ro.observe(media.nodes[0]);\n        }\n    }\n    function add(x, y, w, h) {\n        selection = {\n            x: Math.max(0, Math.min(100, x)),\n            y: Math.max(0, Math.min(100, y)),\n            w: Math.max(2, Math.min(100, w)),\n            h: Math.max(2, Math.min(100, h))\n        };\n        renderSelections();\n        return true;\n    }\n    function remove() {\n        if (selection) {\n            selection = null;\n            renderSelections();\n        }\n    }\n    function get() {\n        if (!selection) return null;\n        return {...selection};\n    }\n    function dimensions(x, y, w, h) {\n        if (x === undefined) return {...defaultDims};\n        defaultDims = {\n            x: Math.max(0, Math.min(100, x)),\n            y: Math.max(0, Math.min(100, y)),\n            w: Math.max(2, Math.min(100, w)),\n            h: Math.max(2, Math.min(100, h))\n        };\n        renderSelections();\n        return instance;\n    }\n    function set(x, y, w, h) {\n        selection = {\n            x: Math.max(0, Math.min(100, x)),\n            y: Math.max(0, Math.min(100, y)),\n            w: Math.max(2, Math.min(100, w)),\n            h: Math.max(2, Math.min(100, h))\n        };\n        renderSelections();\n        return instance;\n    }\n    function aspectRatio(ratio) {\n        if (!ratio) {\n            if (!selection) return null;\n            return (selection.w / selection.h).toFixed(4);\n        }\n        let [rw, rh] = ratio.split(':').map(Number);\n        if (!rw || !rh) return instance;\n        const mediaRect = getMediaRect();\n        const mediaW = mediaRect.width;\n        const mediaH = mediaRect.height;\n        if (!mediaW || !mediaH) return instance;\n        let targetW = mediaW, targetH = mediaW * rh / rw;\n        if (targetH > mediaH) {\n            targetH = mediaH;\n            targetW = mediaH * rw / rh;\n        }\n        const wPerc = (targetW / mediaW) * 100;\n        const hPerc = (targetH / mediaH) * 100;\n        const xPerc = (100 - wPerc) / 2;\n        const yPerc = (100 - hPerc) / 2;\n        set(xPerc, yPerc, wPerc, hPerc);\n        return instance;\n    }\n    const instance = canvas;\n    instance.add = add;\n    instance.remove = remove;\n    instance.get = get;\n    instance.dimensions = dimensions;\n    instance.set = set; // <-- new method\n    instance.aspectRatio = aspectRatio; // <-- new method\n    if (options.default) {\n        dimensions(options.default.x, options.default.y, options.default.w, options.default.h);\n    }\n    if (options.init) {\n        add(options.init.x, options.init.y, options.init.w, options.init.h);\n    }\n    renderSelections();\n    return instance;\n};"
            },
            "Media.Timeline": {
                "uuid": "9e469739-8437-4b11-8def-480334b18de6",
                "name": "Media.Timeline",
                "method": "Component",
                "desc": "Interactive timeline component for media annotation and navigation",
                "type": "Component",
                "example": [
                    "var timeline = Media.Timeline(document.getElementById('container'));",
                    "var timeline = Media.Timeline('#timeline-container').length(60000);",
                    "var timeline = Media.Timeline('#timeline-container').add(1000, 5000, 'normal');",
                    "var timeline = Media.Timeline('#timeline-container').track(3);",
                    "var timeline = Media.Timeline('#timeline-container').select(function(id, from, to, type){ console.log('Selected segment:', id); });",
                    "var timeline = Media.Timeline('#timeline-container').seek(15000);"
                ],
                "dependencies": [
                    "style"
                ],
                "script": "Media.prototype.Timeline = function (container, options = {}) {\n    if (!Media.timelineClassesInitialized) {\n        Media.timelineClasses = Q.style(`\n            --media-timeline-segment-height: 8px;\n            --media-timeline-segment-margin: 2px;\n            --media-timeline-track-gap: 0px;\n        `, `\n            .media-timeline-wrapper {\n                width: 100%;\n                background: var(--media-timeline-bg, #232323);\n                position: relative;\n                user-select: none;\n                display: block;\n            }\n            .media-timeline-bar {\n                width: 100%; height: 100%; position: relative; z-index: 2;\n            }\n            .media-timeline-tracks {\n                position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 1;\n                pointer-events: none;\n            }\n            .media-timeline-track-row {\n                position: absolute; left: 0; width: 100%;\n                border-bottom: 1px solid var(--media-timeline-track-border, #3338);\n                box-sizing: border-box;\n            }\n            .media-timeline-track-label {\n                position: absolute; left: 4px; top: 0; font-size: 10px; color: #888; z-index: 3;\n                pointer-events: none;\n            }\n            .media-timeline-segment {\n                position: absolute;\n                border-radius: 5px;\n                min-width: 1px;\n                cursor: pointer;\n                box-sizing: border-box;\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n                transition: box-shadow 0.1s;\n                margin-top: var(--media-timeline-segment-margin, 2px);\n                margin-bottom: var(--media-timeline-segment-margin, 2px);\n                background: var(--media-timeline-segment-normal, #4caf50);\n                overflow: hidden;\n                height: var(--media-timeline-segment-height, 8px);\n                opacity: 0.5;\n            }\n            .media-timeline-segment.normal { background: var(--media-timeline-segment-normal, #4caf50); }\n            .media-timeline-segment.alert { background: var(--media-timeline-segment-alert, #ff9800); }\n            .media-timeline-segment.warning { background: var(--media-timeline-segment-warning, #f44336); }\n            .media-timeline-segment.selected {z-index: 2; opacity: 1; }\n            .media-timeline-handle {\n                width: 5px; height: 100%; background: var(--media-timeline-handle-bg, #fff4); cursor: ew-resize; z-index: 3;\n            }\n            /* Seek line style */\n            .media-timeline-seek-line {\n                position: absolute;\n                top: 0;\n                bottom: 0;\n                width: 2px;\n                background: #fff;\n                opacity: 0.3;\n                z-index: 10;\n                pointer-events: none;\n            }\n        `, null, {\n            'media-timeline-wrapper': 'media-timeline-wrapper',\n            'media-timeline-bar': 'media-timeline-bar',\n            'media-timeline-tracks': 'media-timeline-tracks',\n            'media-timeline-track-row': 'media-timeline-track-row',\n            'media-timeline-track-label': 'media-timeline-track-label',\n            'media-timeline-segment': 'media-timeline-segment',\n            'media-timeline-handle': 'media-timeline-handle',\n            'selected': 'selected',\n            'normal': 'normal',\n            'alert': 'alert',\n            'warning': 'warning',\n            'left': 'left',\n            'right': 'right',\n            'media-timeline-seek-line': 'media-timeline-seek-line'\n        });\n        Media.timelineClassesInitialized = true;\n    }\n    const classes = Media.timelineClasses;\n    const timeline = Q(`<div class=\"${classes['media-timeline-wrapper']}\"></div>`);\n    const bar = Q(`<div class=\"${classes['media-timeline-bar']}\"></div>`);\n    const tracksBar = Q(`<div class=\"${classes['media-timeline-tracks']}\"></div>`);\n    const seekLine = Q(`<div class=\"${classes['media-timeline-seek-line']}\" style=\"display:none;height:100%;\"></div>`);\n    bar.append(seekLine);\n    timeline.append(bar, tracksBar);\n    timeline._length = 10000;\n    timeline._segments = [];\n    timeline._selected = null;\n    timeline._changeCb = null;\n    timeline._idCounter = 1;\n    timeline._maxTracks = null;\n    timeline._seekPos = null; // ms value or null\n    timeline.seek = function (ms) {\n        if (typeof ms !== \"number\" || isNaN(ms)) {\n            this._seekPos = null;\n        } else {\n            this._seekPos = Math.max(0, Math.min(ms, this._length));\n        }\n        this._render();\n        return this;\n    };\n    timeline.length = function (ms) {\n        if (typeof ms === 'undefined') return this._length;\n        this._length = Math.max(1, ms);\n        this._render();\n        return this;\n    };\n    timeline.add = function (from, to, type = 'normal', trackIndex) {\n        from = Math.max(0, Math.min(from, this._length));\n        to = Math.max(from, Math.min(to, this._length));\n        const id = 'seg_' + (this._idCounter++);\n        const seg = { id, from, to, type };\n        if (typeof trackIndex === 'number' && trackIndex >= 0) {\n            seg._forceTrack = trackIndex;\n        }\n        this._segments.push(seg);\n        this._render();\n        this._triggerChange();\n        return id;\n    };\n    timeline.modify = function (id, from, to, direction) {\n        const seg = this._segments.find(s => s.id === id);\n        if (!seg) return false;\n        seg.from = Math.max(0, Math.min(from, this._length));\n        seg.to = Math.max(seg.from, Math.min(to, this._length));\n        this._render();\n        this._triggerChange(direction);\n        return true;\n    };\n    timeline.remove = function (id) {\n        this._segments = this._segments.filter(s => s.id !== id);\n        if (this._selected === id) this._selected = null;\n        this._render();\n        this._triggerChange();\n        return this;\n    };\n    timeline.clear = function () {\n        this._segments = [];\n        this._selected = null;\n        this._render();\n        this._triggerChange();\n        return this;\n    };\n    timeline.clone = function (id, from) {\n        const seg = this._segments.find(s => s.id === id);\n        if (!seg) return null;\n        const len = seg.to - seg.from;\n        let newFrom = Math.max(0, Math.min(from, this._length - len));\n        let newTo = newFrom + len;\n        return this.add(newFrom, newTo, seg.type);\n    };\n    timeline.change = function (cb) {\n        this._changeCb = cb;\n        return this;\n    };\n    timeline._selectCb = null;\n    timeline._deselectCb = null;\n    timeline.select = function (arg) {\n        if (typeof arg === \"function\") {\n            this._selectCb = arg;\n            const seg = this._segments.find(s => s.id === this._selected);\n            if (seg) arg(seg.id, seg.from, seg.to, seg.type);\n            return this;\n        }\n        this._selected = arg;\n        this._render();\n        this._triggerChange(\"select\");\n        if (typeof this._selectCb === \"function\") {\n            const seg = this._segments.find(s => s.id === this._selected);\n            if (seg) this._selectCb(seg.id, seg.from, seg.to, seg.type);\n        }\n        return this;\n    };\n    timeline.deselect = function (arg) {\n        if (typeof arg === \"function\") {\n            this._deselectCb = arg;\n            return this;\n        }\n        const wasSelected = this._selected;\n        this._selected = null;\n        this._render();\n        this._triggerChange(\"deselect\");\n        if (wasSelected && typeof this._deselectCb === \"function\") {\n            this._deselectCb();\n        }\n        return this;\n    };\n    timeline.selected = function (cb) {\n        const seg = this._segments.find(s => s.id === this._selected);\n        if (seg && typeof cb === 'function') {\n            cb(seg.id, seg.from, seg.to, seg.type);\n        }\n        return seg;\n    };\n    timeline.track = function (number) {\n        if (typeof number === 'undefined') return this._maxTracks;\n        this._maxTracks = Math.max(1, parseInt(number, 10));\n        this._render();\n        return this;\n    };\n    timeline._triggerChange = function (event) {\n        if (typeof this._changeCb === 'function') {\n            const seg = this._segments.find(s => s.id === this._selected);\n            this._changeCb({\n                event: event,\n                segment: seg ? { id: seg.id, from: seg.from, to: seg.to, type: seg.type } : null\n            });\n        }\n    };\n    function assignTracks(segments, maxTracks, movingId = null, movingFrom = null, movingTo = null) {\n        let tracks = [];\n        segments.forEach(seg => { seg._track = undefined; });\n        let movingSeg = null;\n        if (movingId && movingFrom !== null && movingTo !== null) {\n            movingSeg = segments.find(s => s.id === movingId);\n            if (movingSeg) {\n                movingSeg._pendingFrom = movingFrom;\n                movingSeg._pendingTo = movingTo;\n            }\n        }\n        segments.forEach(seg => {\n            if (movingSeg && seg.id === movingSeg.id) return;\n            let placed = false;\n            if (typeof seg._forceTrack === 'number' && seg._forceTrack >= 0 && maxTracks) {\n                let t = seg._forceTrack;\n                if (t < maxTracks) {\n                    if (!tracks[t]) tracks[t] = [];\n                    let overlap = tracks[t].some(other =>\n                        !(seg.to <= other.from || seg.from >= other.to)\n                    );\n                    if (!overlap) {\n                        seg._track = t;\n                        tracks[t].push(seg);\n                        placed = true;\n                    }\n                }\n            }\n            if (!placed) {\n                let limit = maxTracks || (tracks.length + 1);\n                for (let t = 0; t < limit; t++) {\n                    if (!tracks[t]) tracks[t] = [];\n                    let overlap = tracks[t].some(other =>\n                        !(seg.to <= other.from || seg.from >= other.to)\n                    );\n                    if (!overlap) {\n                        seg._track = t;\n                        tracks[t].push(seg);\n                        placed = true;\n                        break;\n                    }\n                }\n            }\n            if (!placed) {\n                seg._track = -1;\n            }\n        });\n        if (movingSeg) {\n            let placed = false;\n            let limit = maxTracks || (tracks.length + 1);\n            for (let t = 0; t < limit; t++) {\n                if (!tracks[t]) tracks[t] = [];\n                let overlap = tracks[t].some(other =>\n                    !(\n                        (movingTo <= (other._pendingFrom ?? other.from)) ||\n                        (movingFrom >= (other._pendingTo ?? other.to))\n                    )\n                );\n                if (!overlap) {\n                    movingSeg._track = t;\n                    tracks[t].push(movingSeg);\n                    placed = true;\n                    break;\n                }\n            }\n            if (!placed) {\n                movingSeg._track = -1;\n            }\n            delete movingSeg._pendingFrom;\n            delete movingSeg._pendingTo;\n        }\n        return tracks.length;\n    }\n    let globalMouseMove = null, globalMouseUp = null;\n    function cleanupListeners() {\n        if (globalMouseMove) {\n            document.removeEventListener('mousemove', globalMouseMove, true);\n            globalMouseMove = null;\n        }\n        if (globalMouseUp) {\n            document.removeEventListener('mouseup', globalMouseUp, true);\n            globalMouseUp = null;\n        }\n        document.body.style.userSelect = '';\n    }\n    timeline._render = function () {\n        bar.children().each(function (i, el) {\n            if (el !== seekLine.nodes[0] && el.classList && el.classList.contains(classes['media-timeline-seek-line'])) {\n                el.parentNode && el.parentNode.removeChild(el);\n            }\n        });\n        bar.html('');\n        bar.append(seekLine); // always keep only one seekLine\n        tracksBar.html('');\n        this._segments.sort((a, b) => a.from - b.from);\n        const tempDiv = document.createElement('div');\n        tempDiv.className = classes['media-timeline-segment'];\n        document.body.appendChild(tempDiv);\n        const segHeight = parseFloat(getComputedStyle(tempDiv).height) || 8;\n        const segMargin = parseFloat(getComputedStyle(tempDiv).marginTop) || 2;\n        document.body.removeChild(tempDiv);\n        let movingId = null, movingFrom = null, movingTo = null;\n        if (timeline._movingSeg) {\n            movingId = timeline._movingSeg.id;\n            movingFrom = timeline._movingSeg.from;\n            movingTo = timeline._movingSeg.to;\n        }\n        const trackCount = assignTracks(\n            this._segments,\n            this._maxTracks,\n            movingId,\n            movingFrom,\n            movingTo\n        );\n        const maxTracks = this._maxTracks || trackCount || 1;\n        const trackHeight = segHeight + 2 * segMargin + (parseFloat(getComputedStyle(document.body).getPropertyValue('--media-timeline-track-gap')) || 0);\n        const wrapperHeight = maxTracks * trackHeight;\n        timeline.css('height', wrapperHeight + 'px');\n        for (let t = 0; t < maxTracks; t++) {\n            const top = (t * trackHeight) + 'px';\n            const height = trackHeight + 'px';\n            const row = Q(`<div class=\"${classes['media-timeline-track-row']}\" style=\"top:${top};height:${height};\"></div>`);\n            const label = Q(`<div class=\"${classes['media-timeline-track-label']}\" style=\"top:${top};\">${t + 1}</div>`);\n            tracksBar.append(row);\n            tracksBar.append(label);\n        }\n        bar.off('mousedown', bar._timelineDeselectHandler);\n        bar._timelineDeselectHandler = function (e) {\n            if (\n                !e.target.classList.contains(classes['media-timeline-segment']) &&\n                !e.target.classList.contains(classes['media-timeline-handle'])\n            ) {\n                timeline.deselect();\n            }\n        };\n        bar.on('mousedown', bar._timelineDeselectHandler);\n        const barChildren = bar.children();\n        const segNodeMap = {};\n        if (barChildren && barChildren.nodes) {\n            for (let i = 0; i < barChildren.nodes.length; i++) {\n                const n = barChildren.nodes[i];\n                if (n.dataset && n.dataset.segId) segNodeMap[n.dataset.segId] = n;\n            }\n        }\n        const used = {};\n        for (const seg of this._segments) {\n            if (seg._track === -1 || typeof seg._track !== 'number') continue;\n            const left = (seg.from / this._length * 100).toFixed(2) + '%';\n            const width = ((seg.to - seg.from) / this._length * 100).toFixed(2) + '%';\n            const top = (seg._track * trackHeight) + 'px';\n            const height = segHeight + 'px';\n            const typeClass = classes[seg.type] || '';\n            const selectedClass = this._selected === seg.id ? classes['selected'] : '';\n            const segClass = [\n                classes['media-timeline-segment'],\n                typeClass,\n                selectedClass\n            ].filter(Boolean).join(' ');\n            let segDiv = segNodeMap && segNodeMap[seg.id];\n            if (segDiv) {\n                Q(segDiv).css({ left, width, top, height });\n                segDiv.className = segClass;\n                used[seg.id] = true;\n            } else {\n                segDiv = Q(`<div class=\"${segClass}\" style=\"left:${left};width:${width};top:${top};height:${height};\"></div>`);\n                const handleL = Q(`<div class=\"${classes['media-timeline-handle']} ${classes['left']}\"></div>`);\n                const handleR = Q(`<div class=\"${classes['media-timeline-handle']} ${classes['right']}\"></div>`);\n                segDiv.append(handleL, handleR);\n                handleL.on('mousedown', e => {\n                    e.preventDefault(); e.stopPropagation();\n                    cleanupListeners();\n                    timeline.select(seg.id);\n                    let startX = e.clientX, startFrom = seg.from;\n                    document.body.style.userSelect = 'none';\n                    globalMouseMove = ev => {\n                        let dx = ev.clientX - startX;\n                        let percent = dx / bar.nodes[0].offsetWidth;\n                        let ms = Math.round(startFrom + percent * this._length);\n                        ms = Math.max(0, Math.min(ms, seg.to - 1));\n                        timeline.modify(seg.id, ms, seg.to, \"left\");\n                    };\n                    globalMouseUp = () => {\n                        cleanupListeners();\n                        timeline._render();\n                    };\n                    document.addEventListener('mousemove', globalMouseMove, true);\n                    document.addEventListener('mouseup', globalMouseUp, true);\n                });\n                handleR.on('mousedown', e => {\n                    e.preventDefault(); e.stopPropagation();\n                    cleanupListeners();\n                    timeline.select(seg.id);\n                    let startX = e.clientX, startTo = seg.to;\n                    document.body.style.userSelect = 'none';\n                    globalMouseMove = ev => {\n                        let dx = ev.clientX - startX;\n                        let percent = dx / bar.nodes[0].offsetWidth;\n                        let ms = Math.round(startTo + percent * this._length);\n                        ms = Math.max(seg.from + 1, Math.min(ms, this._length));\n                        timeline.modify(seg.id, seg.from, ms, \"right\");\n                    };\n                    globalMouseUp = () => {\n                        cleanupListeners();\n                        timeline._render();\n                    };\n                    document.addEventListener('mousemove', globalMouseMove, true);\n                    document.addEventListener('mouseup', globalMouseUp, true);\n                });\n                segDiv.on('mousedown', e => {\n                    if (e.target.classList.contains(classes['media-timeline-handle'])) return;\n                    cleanupListeners();\n                    timeline.select(seg.id);\n                    let dragStartX = e.clientX;\n                    let origFrom = seg.from, origTo = seg.to;\n                    let newFrom = origFrom, newTo = origTo;\n                    document.body.style.userSelect = 'none';\n                    timeline._movingSeg = seg;\n                    globalMouseMove = ev => {\n                        let dx = ev.clientX - dragStartX;\n                        let percent = dx / bar.nodes[0].offsetWidth;\n                        let deltaMs = Math.round(percent * this._length);\n                        newFrom = origFrom + deltaMs;\n                        newTo = origTo + deltaMs;\n                        if (newFrom < 0) {\n                            newTo += -newFrom;\n                            newFrom = 0;\n                        }\n                        if (newTo > this._length) {\n                            newFrom -= (newTo - this._length);\n                            newTo = this._length;\n                        }\n                        if (newTo - newFrom < 1) return;\n                        if (seg.from !== newFrom || seg.to !== newTo) {\n                            seg.from = newFrom;\n                            seg.to = newTo;\n                            timeline._render();\n                            timeline._triggerChange(\"move\");\n                        }\n                    };\n                    globalMouseUp = () => {\n                        cleanupListeners();\n                        delete timeline._movingSeg;\n                        if (seg.from !== newFrom || seg.to !== newTo) {\n                            timeline.modify(seg.id, seg.from, seg.to, \"move\");\n                        }\n                    };\n                    document.addEventListener('mousemove', globalMouseMove, true);\n                    document.addEventListener('mouseup', globalMouseUp, true);\n                });\n                bar.append(segDiv);\n                used[seg.id] = true;\n                segDiv._segId = seg.id;\n            }\n        }\n        for (const segId in segNodeMap) {\n            if (!used[segId]) {\n                Q(segNodeMap[segId]).remove();\n            }\n        }\n        if (this._seekPos !== null && this._length > 0) {\n            const left = (this._seekPos / this._length * 100).toFixed(2) + '%';\n            seekLine.css({\n                left: left,\n                display: ''\n            });\n        } else {\n            seekLine.css('display', 'none');\n        }\n    };\n    return timeline;\n};"
            },
            "Media.Video": {
                "uuid": "d21a331c-2ec5-46ef-8773-24eda38db1b1",
                "name": "Media.Video",
                "method": "Component",
                "desc": "Video player with advanced controls and timeline support",
                "type": "Component",
                "example": [
                    "var player = Media.Video();",
                    "var player = Media.Video().load('video.mp4');",
                    "var player = Media.Video().load('video.mp4').autostart(true);",
                    "var player = Media.Video().load('video.mp4').play();",
                    "var player = Media.Video().load('video.mp4').play(5000, 10000);",
                    "var player = Media.Video().load('video.mp4').volume(0.5).loop(true);",
                    "var player = Media.Video().load('video.mp4').status(function(status){ console.log('Video status:', status); });"
                ],
                "dependencies": [
                    "style",
                    "Debounce"
                ],
                "script": "Media.prototype.Video = function(options = {}) {\n    if (!Media.videoClassesInitialized) {\n        Media.videoClasses = Q.style(`\n            --media-video-bg: #000;\n            --media-video-seekbar-bg: #222;\n            --media-video-seekbar-tr-color: #5af;\n            --media-video-seekbar-th-color: #fff;\n            --media-video-seekbar-group-bg: rgba(0,0,0,0.1);\n        `, `\n            .media-video-wrapper {\n                width: 100%;\n                height: 100%;\n                background: var(--media-video-bg, #000);\n                position: relative;\n                display: block;\n                overflow: hidden;\n            }\n            .media-video-element {\n                width: 100%;\n                height: 100%;\n                display: block;\n                background: var(--media-video-bg, #000);\n                object-fit: contain;\n            }\n            .media-video-controls {\n                display: flex;\n                gap: 8px;\n                align-items: center;\n            }\n            .media-video-seek-group {\n                width: 100%;\n                display: flex;\n                flex-direction: column;\n                gap: 0;\n                margin-bottom: 6px;\n                background: var(--media-video-seekbar-group-bg, #000);\n            }\n            .media-video-seek-scale {\n                width: 100%;\n                position: relative;\n                height: 8px;\n            }\n            .media-video-seekbar {\n                width: 100%;\n                height: 10px;\n                position: relative;\n                cursor: pointer;\n                background: var(--media-video-seekbar-bg, #222);\n                overflow: hidden;\n            }\n            .media-video-seekbar-track {\n                position: absolute;\n                left: 0; top: 0;\n                height: 100%;\n                background: var(--media-video-seekbar-tr-color, #5af);\n                width: 0;\n            }\n            .media-video-seekbar-thumb {\n                position: absolute;\n                top: 50%;\n                width: 1px;\n                height: 20px;\n                background: var(--media-video-seekbar-th-color, #fff);\n                border-radius: 4px;\n                box-shadow: 0 2px 8px #0008;\n                transform: translate(-50%,-50%);\n            }\n            .media-video-seek-info {\n                width: 100%;\n                display: flex;\n                justify-content: space-between;\n                font-size: 11px;\n                font-family: monospace;\n                color: #ccc;\n                margin-top: 2px;\n            }\n            .media-video-loader-overlay {\n                position: absolute;\n                left: 0; top: 0; width: 100%; height: 100%;\n                background: rgba(0,0,0,0.5);\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                z-index: 10;\n                flex-direction: column;\n                pointer-events: none;\n                opacity: 0;\n                transition: opacity 0.25s;                                                                                                               \n            }\n            .media-video-loader-overlay.visible {\n                opacity: 1;\n                pointer-events: auto;\n            }\n            .media-video-loader {\n                --c:no-repeat linear-gradient(white 0 0);\n                opacity: 0.5;\n                background: \n                    var(--c),var(--c),var(--c),\n                    var(--c),var(--c),var(--c),\n                    var(--c),var(--c),var(--c);\n                background-size: 16px 16px;\n                animation: \n                    l32-1 1s infinite,\n                    l32-2 1s infinite;\n                margin-bottom: 12px;\n            }\n            @keyframes l32-1 {\n                0%,100% {width:45px;height: 45px}\n                35%,65% {width:65px;height: 65px}\n            }\n            @keyframes l32-2 {\n                0%,40%  {background-position: 0 0,0 50%, 0 100%,50% 100%,100% 100%,100% 50%,100% 0,50% 0,0 0,  50% 50% }\n                60%,100%{background-position: 0 50%, 0 100%,50% 100%,100% 100%,100% 50%,100% 0,50% 0,0 0,  50% 50% }\n            }\n        `, null, {\n            'media-video-wrapper': 'media-video-wrapper',\n            'media-video-element': 'media-video-element',\n            'media-video-controls': 'media-video-controls',\n            'media-video-seek-scale': 'media-video-seek-scale',\n            'media-video-seekbar-track': 'media-video-seekbar-track',\n            'media-video-seekbar-thumb': 'media-video-seekbar-thumb',\n            'media-video-seekbar': 'media-video-seekbar',\n            'media-video-seek-info': 'media-video-seek-info',\n            'media-video-loader-overlay': 'media-video-loader-overlay',\n            'media-video-loader': 'media-video-loader',\n            'media-video-seek-group': 'media-video-seek-group',\n        },false);\n        Media.videoClassesInitialized = true;\n    }\n    const classes = Media.videoClasses;\n    const wrapper = Q(`<div class=\"${classes['media-video-wrapper']}\"></div>`);\n    const video = Q(`<video class=\"${classes['media-video-element']}\" preload=\"auto\"></video>`);\n    wrapper.append(video);\n    const loaderOverlay = Q(`<div class=\"${classes['media-video-loader-overlay']}\" style=\"display:none\"></div>`);\n    const loaderAnim = Q(`<div class=\"${classes['media-video-loader']}\"></div>`);\n    loaderOverlay.append(loaderAnim);\n    wrapper.append(loaderOverlay);\n    let _customOverlay = null;\n    let _status = \"idle\";\n    let _timetick = null;\n    let _statuscb = null;\n    let _loop = false;\n    let _tickRAF = null;\n    let _autostart = false;\n    let _playTo = null;\n    let _networkTimeout = null;\n    let _fpsSamples = [];\n    function updateLoader(st) {\n        if (st === \"loading\" || st === \"buffering\" || st === \"seeking\") {\n            Q.Debounce('media-video-loader', 1000, () => {\n                if (_status === st && (st === \"loading\" || st === \"buffering\" || st === \"seeking\")) {\n                    if (loaderOverlay.css('display') === 'none') {\n                        loaderOverlay.css('display', 'flex');\n                        setTimeout(() => loaderOverlay.addClass('visible'), 10);\n                    } else {\n                        loaderOverlay.addClass('visible');\n                    }\n                }\n            });\n            if (_networkTimeout) clearTimeout(_networkTimeout);\n            _networkTimeout = setTimeout(() => {\n                if (_status === \"loading\" || _status === \"buffering\" || _status === \"seeking\") {\n                    setStatus(\"networkfail\");\n                }\n            }, 30000);\n        } else {\n            Q.Debounce('media-video-loader', 0, () => {});\n            loaderOverlay.removeClass('visible');\n            loaderOverlay.nodes[0].addEventListener('transitionend', function handler(e) {\n                if (!loaderOverlay.hasClass('visible')) {\n                    loaderOverlay.css('display', 'none');\n                }\n                loaderOverlay.nodes[0].removeEventListener('transitionend', handler);\n            });\n            if (_networkTimeout) {\n                clearTimeout(_networkTimeout);\n                _networkTimeout = null;\n            }\n        }\n    }\n    const statusMap = {\n        \"playing\": \"playing\",\n        \"pause\": \"paused\",\n        \"ended\": \"ended\",\n        \"waiting\": \"buffering\",\n        \"seeking\": \"seeking\",\n        \"canplay\": \"ready\",\n        \"canplaythrough\": \"ready\",\n        \"loadstart\": \"loading\",\n        \"error\": \"failed\",\n        \"stalled\": \"networkfail\",\n        \"suspend\": \"networkfail\"\n    };\n    function setStatus(st) {\n        if (st === \"ready\" || st === \"playing\" || st === \"paused\" || st === \"ended\") {\n            if (_networkTimeout) {\n                clearTimeout(_networkTimeout);\n                _networkTimeout = null;\n            }\n            loaderOverlay.removeClass('visible');\n            loaderOverlay.css('display', 'none');\n        }\n        if (_status !== st) {\n            _status = st;\n            if (_statuscb) _statuscb(st);\n        }\n        if (!(st === \"ready\" || st === \"playing\" || st === \"paused\" || st === \"ended\")) {\n            updateLoader(st);\n        }\n    }\n    const updateStatus = (evt) => {\n        let st = statusMap[evt.type] || evt.type;\n        if (evt.type === \"error\") {\n            const err = video.nodes[0].error;\n            if (err) {\n                if (err.code === 2) st = \"networkfail\";\n                else st = \"failed\";\n            } else {\n                st = \"failed\";\n            }\n        }\n        if ((evt.type === \"canplay\" || evt.type === \"canplaythrough\")) {\n            if (_loop && _status === \"ended\") {\n                st = \"playing\";\n            } else if (video.nodes[0].paused) {\n                st = \"ready\";\n            } else if (!video.nodes[0].paused) {\n                st = \"playing\";\n            }\n        }\n        if (evt.type === \"ratechange\" && !video.nodes[0].paused) {\n            st = \"playing\";\n        }\n        setStatus(st);\n    };\n    [\"playing\", \"pause\", \"ended\", \"waiting\", \"seeking\", \"canplay\", \"canplaythrough\", \"loadstart\", \"error\", \"stalled\", \"suspend\", \"ratechange\"].forEach(ev =>\n        video.on(ev, updateStatus)\n    );\n    const tick = () => {\n        if (_timetick && !video.nodes[0].paused && !video.nodes[0].ended) {\n            _timetick(instance.pos());\n        }\n        const v = video.nodes[0];\n        let frames = null;\n        if (typeof v.getVideoPlaybackQuality === \"function\") {\n            const q = v.getVideoPlaybackQuality();\n            frames = q.totalVideoFrames || q.totalFrameCount || null;\n        } else if (typeof v.webkitDecodedFrameCount === \"number\") {\n            frames = v.webkitDecodedFrameCount;\n        } else if (typeof v.mozDecodedFrames === \"number\") {\n            frames = v.mozDecodedFrames;\n        }\n        if (frames !== null) {\n            const now = performance.now();\n            _fpsSamples.push({ t: now, f: frames });\n            while (_fpsSamples.length > 2 && (_fpsSamples[0].t < now - 1000)) {\n                _fpsSamples.shift();\n            }\n        }\n        const from = typeof instance._playFrom === \"number\" ? instance._playFrom : 0;\n        const to = typeof instance._playTo === \"number\" ? instance._playTo : null;\n        if (to !== null && !video.nodes[0].paused && !video.nodes[0].ended) {\n            if (instance.pos() >= to) {\n                if (_loop) {\n                    instance.seek(from);\n                    video.nodes[0].play();\n                } else {\n                    video.nodes[0].pause();\n                    instance._playTo = null;\n                    instance._playFrom = 0;\n                }\n            }\n        }\n        _tickRAF = requestAnimationFrame(tick);\n    };\n    video.on(\"play\", () => {\n        if (!_tickRAF) _tickRAF = requestAnimationFrame(tick);\n    });\n    video.on(\"pause\", () => {\n        if (_tickRAF) { cancelAnimationFrame(_tickRAF); _tickRAF = null; }\n    });\n    video.on(\"ended\", () => {\n        if (_tickRAF) { cancelAnimationFrame(_tickRAF); _tickRAF = null; }\n        if (_loop) instance.play();\n    });\n    const instance = wrapper;\n    let seekEventCb = null;\n    instance.onSeek = function(cb) {\n        seekEventCb = typeof cb === \"function\" ? cb : null;\n        return instance;\n    };\n    instance.load = function(url) {\n        video.attr('src', '');\n        video.nodes[0].removeAttribute('src');\n        video.nodes[0].load();\n        video.attr('src', url);\n        video.nodes[0].load();\n        setStatus(\"loading\");\n        if (_autostart) {\n            video.nodes[0].play();\n        }\n        return instance;\n    };\n    instance.play = function(from, to) {\n        let videoLen = instance.length();\n        if (typeof from === \"number\") {\n            instance.seek(from);\n            instance._playFrom = from;\n        }\n        if (typeof to === \"number\" && to > (typeof from === \"number\" ? from : 0)) {\n            instance._playTo = Math.min(to, videoLen);\n        }\n        if (typeof from !== \"number\" && typeof to !== \"number\") {\n            if (typeof instance._playFrom === \"number\" && typeof instance._playTo === \"number\") {\n                instance.seek(instance._playFrom);\n            } else {\n                instance._playFrom = 0;\n                instance._playTo = null;\n                instance.seek(0);\n            }\n        }\n        video.nodes[0].play().catch(error => {\n            console.error(\"Video playback error:\", error);\n            setStatus(\"failed\");\n        });\n        return instance;\n    };\n    instance.stop = function() {\n        video.nodes[0].pause();\n        instance._playTo = null;\n        instance._playFrom = 0;\n        instance.seek(0);\n        return instance;\n    };\n    instance.pause = function() {\n        video.nodes[0].pause();\n        instance._playTo = null;\n        instance._playFrom = 0;\n        return instance;\n    };\n    instance.seek = function(ms, _fromSeekBar) {\n        video.nodes[0].currentTime = ms / 1000;\n        if (!_fromSeekBar && seekEventCb) seekEventCb(ms);\n        return instance;\n    };\n    instance.speed = function(val) {\n        if (val === undefined) return video.nodes[0].playbackRate;\n        video.nodes[0].playbackRate = Math.max(0.1, Math.min(10, val));\n        return instance;\n    };\n    instance.loop = function(enable) {\n        if (enable === undefined) return _loop;\n        _loop = !!enable;\n        video.nodes[0].loop = false; // always false, we handle loop logic for both full and from-to\n        return instance;\n    };\n    instance.volume = function(val) {\n        if (val === undefined) return video.nodes[0].volume;\n        video.nodes[0].volume = Math.max(0, Math.min(1, val));\n        return instance;\n    };\n    instance.resolution = function() {\n        return {\n            width: video.nodes[0].videoWidth,\n            height: video.nodes[0].videoHeight\n        };\n    };\n    instance.boundaries = function() {\n        const rect = video.nodes[0].getBoundingClientRect();\n        const parent = wrapper.nodes[0].getBoundingClientRect();\n        return {\n            width: ((rect.width / parent.width) * 100) || 0,\n            height: ((rect.height / parent.height) * 100) || 0,\n            left: ((rect.left - parent.left) / parent.width * 100) || 0,\n            top: ((rect.top - parent.top) / parent.height * 100) || 0\n        };\n    };\n    instance.length = function() {\n        return Math.round((video.nodes[0].duration || 0) * 1000);\n    };\n    instance.pos = function() {\n        return Math.round((video.nodes[0].currentTime || 0) * 1000);\n    };\n    instance.timetick = function(cb) {\n        _timetick = typeof cb === \"function\" ? cb : null;\n        return instance;\n    };\n    instance.status = function(cb) {\n        _statuscb = typeof cb === \"function\" ? cb : null;\n        return instance;\n    };\n    instance.autostart = function(val) {\n        if (val === undefined) return _autostart;\n        _autostart = !!val;\n        return instance;\n    };\n    const frag = Q(`<div class=\"${classes['media-video-controls']}\"></div>`);\n    const btnPlay = Q('<button>').text(\"Play\").on('click', () => instance.play());\n    const btnPause = Q('<button>').text(\"Pause\").on('click', () => instance.pause());\n    const btnStop = Q('<button>').text(\"Stop\").on('click', () => instance.stop());\n    const form = Q.Form ? new Q.Form() : null;\n    let volSlider = null;\n    if (form && form.Slider) {\n        volSlider = form.Slider(instance.volume(), { min: 0, max: 1 });\n        volSlider.change(function(val) {\n            instance.volume(parseFloat(val));\n        });\n        video.on('volumechange', function() {\n            volSlider.val(instance.volume());\n        });\n    }\n    const speedValues = [\n        { value: 0.1, text: \"0.1x\" },\n        { value: 0.25, text: \"0.25x\" },\n        { value: 0.5, text: \"0.5x\" },\n        { value: 0.75, text: \"0.75x\" },\n        { value: 1, text: \"1x\" },\n        { value: 1.5, text: \"1.5x\" },\n        { value: 2, text: \"2x\" },\n        { value: 2.5, text: \"2.5x\" },\n        { value: 5, text: \"5x\" }\n    ];\n    let initialSpeedIdx = speedValues.findIndex(v => v.value === instance.speed());\n    if (initialSpeedIdx === -1) initialSpeedIdx = 4; // default 1x\n    let speedDropdown = null;\n    if (form && form.Dropdown) {\n        speedDropdown = form.Dropdown({\n            values: speedValues.map((v, i) => ({\n                value: v.value,\n                text: v.text,\n                default: i === initialSpeedIdx\n            })),\n            change: function(val) {\n                instance.speed(parseFloat(val));\n            }\n        });\n    }\n    const loop = Q('<input type=\"checkbox\">')\n        .prop('checked', instance.loop())\n        .attr('title', 'Loop')\n        .on('change', function() { instance.loop(this.checked); });\n    const loopLbl = Q('<label>').append(loop, document.createTextNode(\" Loop\"));\n    const auto = Q('<input type=\"checkbox\">')\n        .prop('checked', instance.autostart())\n        .attr('title', 'Autostart')\n        .on('change', function() { instance.autostart(this.checked); });\n    const autoLbl = Q('<label>').append(auto, document.createTextNode(\" Autostart\"));\n    function fmt(ms) {\n        ms = Math.max(0, Math.round(ms));\n        let s = Math.floor(ms / 1000), m = Math.floor(s / 60), h = Math.floor(m / 60);\n        let ms3 = (ms % 1000).toString().padStart(3, '0');\n        s = s % 60; m = m % 60;\n        return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms3}`;\n    }\n    const seekScale = Q(`<div class=\"${classes['media-video-seek-scale']}\"></div>`);\n    function renderScale() {\n        seekScale.html('');\n        const len = instance.length();\n        const scaleDiv = Q('<div style=\"position:absolute;left:0;top:0;width:100%;height:100%;\"></div>');\n        const scaleHeight = parseFloat(seekScale.css('height')) || 8;\n        for (let ms = 0; ms <= len; ms += 30000) {\n            const isMinute = ms % 60000 === 0;\n            const left = (ms / len * 100).toFixed(2) + '%';\n            const height = isMinute ? scaleHeight : scaleHeight * 0.5;\n            const top = isMinute ? 0 : (scaleHeight * 0.5) + 'px';\n            const mark = Q('<div>')\n                .css({\n                    position: 'absolute',\n                    left: left,\n                    top: top,\n                    width: '1px',\n                    height: height + 'px',\n                    background: isMinute ? '#fff' : '#aaa',\n                    opacity: isMinute ? 0.8 : 0.5\n                });\n            scaleDiv.append(mark);\n        }\n        seekScale.append(scaleDiv);\n    }\n    const seekBar = Q(`<div class=\"${classes['media-video-seekbar']}\"></div>`);\n    const seekTrack = Q(`<div class=\"${classes['media-video-seekbar-track']}\"></div>`);\n    const seekThumb = Q(`<div class=\"${classes['media-video-seekbar-thumb']}\"></div>`);\n    seekBar.append(seekTrack, seekThumb);\n    const seekInfo = Q(`<div class=\"${classes['media-video-seek-info']}\"></div>`);\n    const seekLeft = Q('<div>').css({flex:'1',textAlign:'left'});\n    const seekCenter = Q('<div>').css({flex:'1',textAlign:'center'});\n    const seekRight = Q('<div>').css({flex:'1',textAlign:'right'});\n    seekInfo.append(seekLeft, seekCenter, seekRight);\n    const seekGroup = Q(`<div class=\"${classes['media-video-seek-group']}\"></div>`);\n    seekGroup.append(seekScale, seekBar, seekInfo);\n    function updateSeekUI() {\n        const len = instance.length();\n        const pos = instance.pos();\n        const pct = len > 0 ? pos / len : 0;\n        seekTrack.css('width', (pct * 100) + '%');\n        seekThumb.css('left', (pct * 100) + '%');\n        seekLeft.text(fmt(0) + ' / ' + fmt(pos));\n        seekRight.text(fmt(len));\n        seekCenter.text('');\n    }\n    let dragging = false;\n    let lastSeekMs = null; // last seeked ms during seekbar drag\n    function seekToClientX(clientX, status) {\n        const rect = seekBar.nodes[0].getBoundingClientRect();\n        let rel = (clientX - rect.left) / rect.width;\n        rel = Math.max(0, Math.min(1, rel));\n        const len = instance.length();\n        const ms = Math.round(len * rel);\n        lastSeekMs = ms;\n        instance.seek(ms, true); // only UI update\n        updateSeekUI();\n        if (seekEventCb) seekEventCb(ms);\n    }\n    let mouseMoveHandler = null;\n    let mouseUpHandler = null;\n    seekBar.on('mousedown', function(e) {\n        dragging = true;\n        seekToClientX(e.clientX, 'start');\n        document.body.style.userSelect = 'none';\n        mouseMoveHandler = function(ev) {\n            if (dragging) {\n                seekToClientX(ev.clientX, 'move');\n            }\n        };\n        mouseUpHandler = function(ev) {\n            if (dragging) {\n                dragging = false;\n                document.body.style.userSelect = '';\n                seekToClientX(ev.clientX, 'end');\n                document.removeEventListener('mousemove', mouseMoveHandler);\n                document.removeEventListener('mouseup', mouseUpHandler);\n                mouseMoveHandler = null;\n                mouseUpHandler = null;\n            }\n        };\n        document.addEventListener('mousemove', mouseMoveHandler);\n        document.addEventListener('mouseup', mouseUpHandler);\n    });\n    video.on('timeupdate', updateSeekUI);\n    video.on('loadedmetadata', function() {\n        renderScale();\n        updateSeekUI();\n    });\n    video.on('durationchange', function() {\n        renderScale();\n        updateSeekUI();\n    });\n    setTimeout(() => {\n        renderScale();\n        updateSeekUI();\n    }, 0);\n    frag.append(seekGroup);\n    if (btnPlay) frag.append(btnPlay);\n    if (btnPause) frag.append(btnPause);\n    if (btnStop) frag.append(btnStop);\n    if (volSlider) frag.append(volSlider);\n    if (speedDropdown) frag.append(speedDropdown);\n    frag.append(loopLbl);\n    frag.append(autoLbl);\n    instance.control = function() {\n        return {\n            seekGroup,\n            seekScale,\n            seekBar,\n            seekInfo,\n            playButton: btnPlay,\n            pauseButton: btnPause,\n            stopButton: btnStop,\n            volumeSlider: volSlider,\n            speedSelector: speedDropdown,\n            loop: loopLbl,\n            autoPlay: autoLbl,\n            controlPanel: frag\n        };\n    };\n    instance.overlay = function(qobj) {\n        if (_customOverlay) {\n            Q(_customOverlay).remove();\n            _customOverlay = null;\n        }\n        if (qobj && typeof qobj === \"object\" && qobj.nodes && qobj.nodes[0]) {\n            wrapper.append(qobj);\n            _customOverlay = qobj.nodes[0];\n        }\n        return instance;\n    };\n    instance.wrapper = wrapper.nodes[0];\n    instance.video = video.nodes[0];\n    instance.fps = function() {\n        if (_fpsSamples.length < 2) return null;\n        const first = _fpsSamples[0], last = _fpsSamples[_fpsSamples.length - 1];\n        const dt = (last.t - first.t) / 1000;\n        const df = last.f - first.f;\n        if (dt > 0 && df >= 0) {\n            return df / dt;\n        }\n        return null;\n    };\n    return wrapper;\n};\nMedia.Video = Media.prototype.Video;"
            }
        },
        "statics": {
            "Average Color": {
                "uuid": "1425cd3c-6832-42d5-ba29-a86dae849a8c",
                "name": "Average Color",
                "method": "Static",
                "desc": "Calculates the average color of an image from a given source.",
                "type": "Image Processing",
                "example": [
                    "Q.AvgColor('https://example.com/profile.jpg', 'auto', function(color) { document.body.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`; });",
                    "Q.AvgColor(document.getElementById('myCanvas'), 2, function(result) { console.log(result); });",
                    "Q.AvgColor(headerImage.src, 5, function(avgColor) { /* ... */ });"
                ],
                "dependencies": [],
                "script": "Q.AvgColor = (source, sampleSize, callback) => {\n    const image = new Image();\n    image.crossOrigin = 'Anonymous';\n    if (typeof source === 'string') image.src = source;\n    else if (source instanceof HTMLCanvasElement) image.src = source.toDataURL();\n    else return console.error(\"Invalid image source provided.\");\n    image.onload = () => {\n      const canvas = Object.assign(document.createElement('canvas'), { width: image.width, height: image.height });\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const data = context.getImageData(0, 0, image.width, image.height).data;\n      const samplingRate = sampleSize === 'auto'\n        ? Math.max(1, Math.ceil(Math.sqrt(image.width * image.height) / 32))\n        : (typeof sampleSize === 'number' && sampleSize > 0 ? sampleSize : 1);\n      let totalRed = 0, totalGreen = 0, totalBlue = 0, count = 0;\n      for (let index = 0, len = data.length; index < len; index += samplingRate * 4) {\n        totalRed   += data[index];\n        totalGreen += data[index + 1];\n        totalBlue  += data[index + 2];\n        count++;\n      }\n      const avgColor = { r: (totalRed / count) | 0, g: (totalGreen / count) | 0, b: (totalBlue / count) | 0 };\n      typeof callback === 'function' && callback(avgColor);\n    };\n    image.onerror = () => console.error(\"Failed to load image.\");\n  };"
            },
            "CMYK to RGB Converter": {
                "uuid": "e729c2ac-4ee8-4457-a885-9276b710ffdd",
                "name": "CMYK to RGB Converter",
                "method": "Static",
                "desc": "Converts CMYK (Cyan, Magenta, Yellow, Key/Black) color values to RGB (Red, Green, Blue) format.",
                "type": "Color Conversion",
                "example": [
                    "const rgbColor = Q.CMYK2RGB(0.75, 0.0, 0.75, 0.0);",
                    "Q.CMYK2RGB(0.0, 0.8, 0.8, 0.0);",
                    "Q.CMYK2RGB(0.8, 0.0, 0.8, 0.0);",
                    "Q.CMYK2RGB(0.8, 0.8, 0.0, 0.0);"
                ],
                "dependencies": [],
                "script": "Q.CMYK2RGB = (c, m, y, k) => {\n  const r = 255 * (1 - c) * (1 - k);\n  const g = 255 * (1 - m) * (1 - k);\n  const b = 255 * (1 - y) * (1 - k);\n  return [Math.round(r), Math.round(g), Math.round(b)];\n};"
            },
            "Color Brightness": {
                "uuid": "bca0b6d6-1b61-4443-8f12-b7f79696f7ab",
                "name": "Color Brightness",
                "method": "Static",
                "desc": "Adjusts the brightness of a color by a specified percentage.",
                "type": "Color Manipulation",
                "example": [
                    "const highlightColor = Q.ColorBrightness('#3498db', 20);",
                    "const shadowColor = Q.ColorBrightness('#3498db', -30);",
                    "let hoverState = Q.ColorBrightness('rgb(52, 152, 219)', 15);",
                    "let activeState = Q.ColorBrightness('rgb(52, 152, 219)', -10);",
                    "Q.ColorBrightness('rgba(52, 152, 219, 0.8)', 25);"
                ],
                "dependencies": [],
                "script": "Q.ColorBrightness = (inputColor, percent) => {\n    if (!/^#|^rgb/.test(inputColor)) throw new Error('Unsupported format');\n    let red, green, blue, alpha = 1, isHex = false, factor = 1 + percent / 100;\n    if (inputColor[0] === '#') {\n      isHex = true;\n      const hexString = inputColor.slice(1);\n      if (hexString.length === 3) {\n        red = parseInt(hexString[0] + hexString[0], 16);\n        green = parseInt(hexString[1] + hexString[1], 16);\n        blue = parseInt(hexString[2] + hexString[2], 16);\n      } else if (hexString.length === 6) {\n        red = parseInt(hexString.slice(0, 2), 16);\n        green = parseInt(hexString.slice(2, 4), 16);\n        blue = parseInt(hexString.slice(4, 6), 16);\n      }\n    } else {\n      const match = inputColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n      if (match) {\n        red = +match[1];\n        green = +match[2];\n        blue = +match[3];\n        if (match[4] != null) alpha = parseFloat(match[4]);\n      }\n    }\n    const clamp = value => Math.min(255, Math.max(0, Math.round(value * factor)));\n    red = clamp(red);\n    green = clamp(green);\n    blue = clamp(blue);\n    return isHex\n      ? '#' + [red, green, blue].map(component => (`0${component.toString(16)}`).slice(-2)).join('')\n      : (alpha === 1 ? `rgb(${red}, ${green}, ${blue})` : `rgba(${red}, ${green}, ${blue}, ${alpha})`);\n  };"
            },
            "Debounce": {
                "uuid": "f85b6b93-a2d3-4910-ac9d-ccbba6424f8f",
                "name": "Debounce",
                "method": "Static",
                "desc": "Delays the execution of a function until after a specified wait period has elapsed since the last invocation.",
                "type": "Performance Optimization",
                "example": [
                    "Q.Debounce('search-query', 500, function() { fetchSearchResults(searchInput.value); });",
                    "Q.Debounce('resize-chart', 250, function() { redrawChart(window.innerWidth * 0.8); });",
                    "Q.Debounce('form-save', 300, function() { saveData(formData); });"
                ],
                "dependencies": [],
                "script": "Q.Debounce = (id, time, callback) => {\n    const debounceStorage = Q.getGLOBAL('Debounce') || {};\n    debounceStorage[id] && clearTimeout(debounceStorage[id]);\n    debounceStorage[id] = setTimeout(callback, time);\n    Q.setGLOBAL({ Debounce: debounceStorage });\n  };"
            },
            "HSL to RGB Converter": {
                "uuid": "b36eca39-25de-4f76-a810-d1b475b8931d",
                "name": "HSL to RGB Converter",
                "method": "Static",
                "desc": "Converts HSL (Hue, Saturation, Lightness) color values to RGB (Red, Green, Blue) format.",
                "type": "Color Conversion",
                "example": [
                    "const rgbColor = Q.HSL2RGB(0, 1, 0.5);",
                    "let rgb = Q.HSL2RGB(0.5, 0.8, 0.5);",
                    "var buttonColor = Q.HSL2RGB(0.33, 0.5, 0.7);"
                ],
                "dependencies": [],
                "script": "Q.HSL2RGB = (h, s, l) => {\n    if (s === 0) {\n      const gray = l * 255;\n      return [gray, gray, gray];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s,\n          p = 2 * l - q,\n          hueToRgb = (t) => {\n            t < 0 && (t += 1);\n            t > 1 && (t -= 1);\n            return t < 1 / 6 ? p + (q - p) * 6 * t\n                 : t < 1 / 2 ? q\n                 : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t)\n                 : p;\n          };\n    return [hueToRgb(h + 1 / 3) * 255, hueToRgb(h) * 255, hueToRgb(h - 1 / 3) * 255];\n  };"
            },
            "ID Generator": {
                "uuid": "70ece7a0-d457-48eb-9eb0-528ba0c48af5",
                "name": "ID Generator",
                "method": "Static",
                "desc": "Generates a random hexadecimal identifier with customizable length and prefix.",
                "type": "Utility",
                "example": [
                    "const uniqueId = Q.ID();",
                    "let elementId = Q.ID(12, 'element-');",
                    "var inputId = Q.ID(10, 'input_');",
                    "var labelId = Q.ID(10, 'label_');"
                ],
                "dependencies": [],
                "script": "Q.ID = (length = 8, prefix = '') =>\n    prefix + Array.from({ length }, () => (Math.random() * 16 | 0).toString(16)).join('');"
            },
            "Is Dark Color": {
                "uuid": "dbd39ac4-2a90-445a-b0d3-e82015bfca47",
                "name": "Is Dark Color",
                "method": "Static",
                "desc": "Determines if a color is considered dark based on its luminance value.",
                "type": "Color Analysis",
                "example": [
                    "const backgroundColor = '#3498db'; const textColor = Q.isDarkColor(backgroundColor) ? '#ffffff' : '#000000'; document.querySelector('.card').style.color = textColor;",
                    "let buttonColor = 'rgb(52, 152, 219)'; let textShade = Q.isDarkColor(buttonColor, 15) ? 'white' : 'black'; document.getElementById('action-button').classList.add(`text-${textShade}`);",
                    "var headerBg = '#6a1b9a'; var customThreshold = 120; var headerTextClass = Q.isDarkColor(headerBg, 10, customThreshold) ? 'light-text' : 'dark-text'; document.querySelector('header').classList.add(headerTextClass);"
                ],
                "dependencies": [],
                "script": "Q.isDarkColor = (color, margin = 20, threshold = 100) => {\n    let red, green, blue;\n    if (color[0] === '#') {\n      const hex = color.slice(1);\n      const parts = hex.length === 3\n        ? [hex[0] + hex[0], hex[1] + hex[1], hex[2] + hex[2]]\n        : hex.length === 6\n        ? [hex.slice(0, 2), hex.slice(2, 4), hex.slice(4, 6)]\n        : null;\n      if (!parts) throw Error('Invalid hex format');\n      [red, green, blue] = parts.map(v => parseInt(v, 16));\n    } else if (color.startsWith('rgb')) {\n      const arr = color.match(/\\d+/g);\n      if (arr && arr.length >= 3) [red, green, blue] = arr.map(Number);\n      else throw Error('Invalid format');\n    } else throw Error('Unsupported format');\n    return Math.sqrt(0.299 * red ** 2 + 0.587 * green ** 2 + 0.114 * blue ** 2) + margin < threshold;\n  };"
            },
            "LAB to RGB Converter": {
                "uuid": "3c2efc78-7e03-4957-a089-4ee0372dbcd3",
                "name": "LAB to RGB Converter",
                "method": "Static",
                "desc": "Converts LAB (Lightness, a*, b*) color values to RGB (Red, Green, Blue) format.",
                "type": "Color Conversion",
                "example": [
                    "const l = 54.29; const a = 80.81; const b = 69.89; const rgbColor = Q.LAB2RGB(l, a, b); console.log(`R: ${rgbColor[0]}, G: ${rgbColor[1]}, B: ${rgbColor[2]}`);",
                    "function adjustSaturation(r, g, b, factor) { const lab = Q.RGB2LAB(r, g, b); lab[1] = lab[1] * factor; lab[2] = lab[2] * factor; return Q.LAB2RGB(lab[0], lab[1], lab[2]); }"
                ],
                "dependencies": [],
                "script": "Q.LAB2RGB = (L, a, b) => {\n  const fy = (L + 16) / 116;\n  const fx = a / 500 + fy;\n  const fz = fy - b / 200;\n  const xRef = 95.047;\n  const yRef = 100.0;\n  const zRef = 108.883;\n  const fx3 = Math.pow(fx, 3);\n  const fy3 = Math.pow(fy, 3);\n  const fz3 = Math.pow(fz, 3);\n  const x = xRef * (fx3 > 0.008856 ? fx3 : (fx - 16/116) / 7.787);\n  const y = yRef * (fy3 > 0.008856 ? fy3 : (fy - 16/116) / 7.787);\n  const z = zRef * (fz3 > 0.008856 ? fz3 : (fz - 16/116) / 7.787);\n  let r = (x * 0.032406 + y * -0.015372 + z * -0.004986) / 100;\n  let g = (x * -0.009689 + y * 0.018758 + z * 0.000415) / 100;\n  let b_val = (x * 0.000557 + y * -0.002040 + z * 0.010570) / 100;\n  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;\n  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;\n  b_val = b_val > 0.0031308 ? 1.055 * Math.pow(b_val, 1/2.4) - 0.055 : 12.92 * b_val;\n  r = Math.max(0, Math.min(1, r));\n  g = Math.max(0, Math.min(1, g));\n  b_val = Math.max(0, Math.min(1, b_val));\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b_val * 255)];\n};"
            },
            "RGB to CMYK Converter": {
                "uuid": "e6b309fc-b33f-4c8b-aada-2348aea57ade",
                "name": "RGB to CMYK Converter",
                "method": "Static",
                "desc": "Converts RGB (Red, Green, Blue) color values to CMYK (Cyan, Magenta, Yellow, Key/Black) format.",
                "type": "Color Conversion",
                "example": [
                    "const red = 255; const green = 0; const blue = 0; const cmykColor = Q.RGB2CMYK(red, green, blue); console.log(`C: ${(cmykColor[0] * 100).toFixed(0)}%, M: ${(cmykColor[1] * 100).toFixed(0)}%, Y: ${(cmykColor[2] * 100).toFixed(0)}%, K: ${(cmykColor[3] * 100).toFixed(0)}%`);",
                    "const color1 = Q.RGB2CMYK(200, 50, 50); const color2 = Q.RGB2CMYK(50, 50, 200); const inkUsage1 = color1[0] + color1[1] + color1[2] + color1[3]; const inkUsage2 = color2[0] + color2[1] + color2[2] + color2[3]; console.log(`Color 1 ink usage: ${(inkUsage1 * 100).toFixed(1)}%`); console.log(`Color 2 ink usage: ${(inkUsage2 * 100).toFixed(1)}%`);"
                ],
                "dependencies": [],
                "script": "Q.RGB2CMYK = (r, g, b) => {\n  r = r / 255;\n  g = g / 255;\n  b = b / 255;\n  const k = 1 - Math.max(r, g, b);\n  if (k === 1) return [0, 0, 0, 1];\n  const c = (1 - r - k) / (1 - k);\n  const m = (1 - g - k) / (1 - k);\n  const y = (1 - b - k) / (1 - k);\n  return [c, m, y, k];\n};"
            },
            "RGB to HSL Converter": {
                "uuid": "6858c7be-5768-43d3-89c3-53bc3c350496",
                "name": "RGB to HSL Converter",
                "method": "Static",
                "desc": "Converts RGB (Red, Green, Blue) color values to HSL (Hue, Saturation, Lightness) format.",
                "type": "Color Conversion",
                "example": [
                    "const red = 255; const green = 0; const blue = 0; const hslColor = Q.RGB2HSL(red, green, blue); console.log(`Hue: ${hslColor[0].toFixed(2)}, Saturation: ${hslColor[1].toFixed(2)}, Lightness: ${hslColor[2].toFixed(2)}`);",
                    "let baseRed = 64; let baseGreen = 128; let baseBlue = 255; let hsl = Q.RGB2HSL(baseRed, baseGreen, baseBlue); let lighterHSL = [hsl[0], hsl[1], Math.min(1, hsl[2] + 0.2)];",
                    "var rgb = {r: 142, g: 68, b: 173}; var hsl = Q.RGB2HSL(rgb.r, rgb.g, rgb.b); var adjustedHue = (hsl[0] + 0.5) % 1; var complementaryHsl = [adjustedHue, hsl[1], hsl[2]];"
                ],
                "dependencies": [],
                "script": "Q.RGB2HSL = (r, g, b) => {\n    r /= 255, g /= 255, b /= 255;\n    const max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2, d = max - min;\n    if (!d) h = s = 0;\n    else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0)\n        : max === g ? (b - r) / d + 2\n        : (r - g) / d + 4;\n      h /= 6;\n    }\n    return [h, s, l];\n  };"
            },
            "RGB to LAB Converter": {
                "uuid": "fe2c1416-6f7d-4a0f-800d-98c0e99ca239",
                "name": "RGB to LAB Converter",
                "method": "Static",
                "desc": "Converts RGB (Red, Green, Blue) color values to LAB (Lightness, a*, b*) color space format.",
                "type": "Color Conversion",
                "example": [
                    "const red = 255; const green = 0; const blue = 0; const labColor = Q.RGB2LAB(red, green, blue); console.log(`L: ${labColor[0].toFixed(2)}, a*: ${labColor[1].toFixed(2)}, b*: ${labColor[2].toFixed(2)}`);",
                    "const color1 = Q.RGB2LAB(255, 100, 50); const color2 = Q.RGB2LAB(200, 150, 100); const distance = Math.sqrt(Math.pow(color2[0] - color1[0], 2) + Math.pow(color2[1] - color1[1], 2) + Math.pow(color2[2] - color1[2], 2)); console.log(`Perceptual color distance: ${distance.toFixed(2)}`);"
                ],
                "dependencies": [],
                "script": "Q.RGB2LAB = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n  const x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;\n  const y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;\n  const z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;\n  const xRef = 95.047;\n  const yRef = 100.0;\n  const zRef = 108.883;\n  const xNorm = x / xRef;\n  const yNorm = y / yRef;\n  const zNorm = z / zRef;\n  const fx = xNorm > 0.008856 ? Math.pow(xNorm, 1/3) : (7.787 * xNorm) + (16/116);\n  const fy = yNorm > 0.008856 ? Math.pow(yNorm, 1/3) : (7.787 * yNorm) + (16/116);\n  const fz = zNorm > 0.008856 ? Math.pow(zNorm, 1/3) : (7.787 * zNorm) + (16/116);\n  const L = (116 * fy) - 16;\n  const a = 500 * (fx - fy);\n  const b_val = 200 * (fy - fz);\n  return [L, a, b_val];\n};"
            }
        }
    }
};
function Highlight(code) {
    // Escape HTML
    const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    // Szintaktikus formázás: új sor ;, =>, {, } után, és behúzás
    // 1. Új sor karakterek beszúrása
    code = code
        .replace(/;(?=(?![\r\n]))/g, ';\n')
        .replace(/=>\s*/g, '=>\n')
        .replace(/{/g, '{\n')
        .replace(/}/g, '}\n');

    // 2. Behúzás (egyszerű, nem tökéletes, de működik)
    let indent = 0;
    code = code.split('\n').map(line => {
        let trimmed = line.trim();
        if (trimmed.endsWith('}')) indent--;
        let result = '    '.repeat(Math.max(indent, 0)) + trimmed;
        if (trimmed.endsWith('{')) indent++;
        return result;
    }).join('\n');

    // Escape HTML (csak most!)
    code = escapeHTML(code);

    // Patterns in order: multiline comment, singleline comment, string, number, keyword, class, method, bracket, etc.
    const patterns = [
        // Multiline comments
        {
            regex: /\/\*[\s\S]*?\*\//g,
            className: "comment"
        },
        // Single-line comments (javítva: csak sor végéig tart)
        {
            regex: /\/\/[^\n\r]*/g,
            className: "comment"
        },
        // Template strings (backticks)
        {
            regex: /`(?:\\[\s\S]|[^\\`])*`/g,
            className: "string"
        },
        // Double-quoted strings
        {
            regex: /"(?:\\.|[^"\\])*"/g,
            className: "string"
        },
        // Single-quoted strings
        {
            regex: /'(?:\\.|[^'\\])*'/g,
            className: "string"
        },
        // Numbers (integer, float, hex, binary, octal)
        {
            regex: /\b(0[xX][\da-fA-F]+|0[bB][01]+|0[oO][0-7]+|\d+(\.\d+)?([eE][+-]?\d+)?)\b/g,
            className: "number"
        },
        // Keywords (JS reserved words)
        {
            regex: /\b(?:function|return|if|else|for|while|const|let|var|new|typeof|instanceof|switch|case|break|continue|do|try|catch|finally|throw|class|extends|super|import|from|export|default|await|async|in|of|this|null|undefined|true|false)\b/g,
            className: "keyword"
        },
        // Class names (simple heuristic: PascalCase identifiers)
        {
            regex: /\b[A-Z][A-Za-z0-9_]*\b/g,
            className: "class"
        },
        // Methods (common JS DOM/jQuery methods)
        {
            regex: /\b(?:addClass|after|animate|append|attr|before|bind|blur|children|click|clone|closest|css|data|detach|each|empty|eq|fadeIn|fadeOut|fadeTo|fadeToggle|find|first|focus|hasClass|height|hide|html|id|index|inside|is|isExists|last|map|next|off|offset|on|parent|position|prepend|prev|prop|remove|removeAttr|removeClass|removeData|removeProp|removeTransition|scrollHeight|scrollLeft|scrollTop|scrollWidth|show|siblings|size|text|toggle|toggleClass|trigger|unwrap|val|wait|walk|width|wrap|wrapAll|zIndex)\b/g,
            className: "method"
        },
        // Brackets
        {
            regex: /[()[\]{}]/g,
            className: "bracket"
        }
        // NINCS operator!
    ];

    // To avoid nested spans, replace matches with unique tokens, then replace tokens with spans
    let tokenId = 0;
    const tokens = {};
    patterns.forEach(({ regex, className }) => {
        code = code.replace(regex, match => {
            const key = `__HLTOKEN${tokenId++}__`;
            tokens[key] = `<span class="hl ${className}">${match}</span>`;
            return key;
        });
    });

    // Replace tokens with their span-wrapped content
    code = code.replace(/__HLTOKEN\d+__/g, m => tokens[m]);

    // <pre><code> blokkba csomagolás
    return `<pre><code class="hljs">${code}</code></pre>`;
}

const IDS = {};

function CodeBuilder() {
    const activeBlocks = document.querySelectorAll(".block.active");


    const applyScript = (script) => {
        const sizedata = document.querySelector(".sizedata");
        let BaseScript = JSON.parse(JSON.stringify(DATA.base));
        BaseScript = BaseScript.replace("return Q;", script + "\nreturn Q;");
        let codeBlock = document.querySelector(".codeData");
        codeBlock.innerHTML = minify(BaseScript);
        sizedata.innerHTML = "Library size: " + CalculateSizeKB(BaseScript);
    }




    if (!activeBlocks.length) {
        applyScript("");
        return;
    }

    const script = Array.from(activeBlocks)
        .map(block => {
            let blockScript = "";
            // Traverse the IDS structure to find the matching script
            for (const name in IDS) {
                const blockData = IDS[name];
                if (blockData.uuid == block.id) {
                    blockScript = blockData.script || "";
                    break;
                }
            }
            return blockScript;
        })
        .join("");

    applyScript(script);

    // console.log(script);
}


function classFormat(text) {
    return text.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");
}

function minify(code) {
    return code.replace(/^\s*/gm, "").replace(/\n/g, "");
}

function CalculateSizeKB(code) {
    return (new Blob([code]).size / 1024).toFixed(2) + " KB";
}

function createTags(tags) {
    const tagsContainer = document.createElement("div");
    tagsContainer.className = "tags";
    // Ensure tags is always an array
    if (!Array.isArray(tags)) {
        tags = typeof tags === "undefined" || tags === null ? [] : [String(tags)];
    }
    tags.forEach(tag => {
        const tagElement = document.createElement("span");
        tagElement.className = "tag";
        tagElement.innerHTML = tag;
        tagsContainer.appendChild(tagElement);
    });
    return tagsContainer;
}

function createCodeCategory(title) {
    const categoryContainer = document.createElement("div");
    categoryContainer.className = "code_category";
    categoryContainer.innerHTML = `<h2 class='code_category_title'>${title}</h2>`;
    const categoryContent = document.createElement("div");
    categoryContent.className = "code_content";
    categoryContent.id = classFormat(title);
    categoryContainer.appendChild(categoryContent);
    return categoryContainer;
}

function createBlock(contentData) {
    const { uuid, name, method, desc, example, dependencies } = contentData;
    const block = document.createElement("div");
    block.className = "block";
    block.id = uuid;
    block.innerHTML = `<h2>${name}</h2><div class="block_method">${method || ""}</div>`;

    const blockContent = document.createElement("div");
    blockContent.className = "block_content";
    block.appendChild(blockContent);

    blockContent.innerHTML = `<p>${desc}</p>`;

    // Handle example: can be string, array, or object
    if (typeof example === "object" && example !== null && !Array.isArray(example)) {
        // If example is an object, create a block_example for each key
        Object.entries(example).forEach(([key, value]) => {
            const blockExample = document.createElement("div");
            blockExample.className = "block_example";
            blockExample.innerHTML = `<b>${key}:</b>` +
                (Array.isArray(value)
                    ? value.map(ex =>
                        typeof ex === "string"
                            ? Highlight(ex)
                            : typeof ex === "object" && ex !== null
                                ? Highlight(JSON.stringify(ex, null, 2))
                                : Highlight(String(ex))
                    ).join("")
                    : (typeof value === "string"
                        ? Highlight(value)
                        : typeof value === "object" && value !== null
                            ? Highlight(JSON.stringify(value, null, 2))
                            : Highlight(String(value))
                    )
                );
            blockContent.appendChild(blockExample);
        });
    } else if (Array.isArray(example)) {
        // If example is an array, create a single block_example
        const blockExample = document.createElement("div");
        blockExample.className = "block_example";
        blockExample.innerHTML = example.map(ex =>
            typeof ex === "string"
                ? Highlight(ex)
                : typeof ex === "object" && ex !== null
                    ? Highlight(JSON.stringify(ex, null, 2))
                    : Highlight(String(ex))
        ).join("");
        blockContent.appendChild(blockExample);
    } else {
        // Otherwise, treat as string or fallback
        const blockExample = document.createElement("div");
        blockExample.className = "block_example";
        blockExample.innerHTML = (typeof example === "string"
            ? Highlight(example)
            : typeof example === "object" && example !== null
                ? Highlight(JSON.stringify(example, null, 2))
                : Highlight(String(example))
        );
        blockContent.appendChild(blockExample);
    }

    if (dependencies.length > 0) {
        const blockDependencies = document.createElement("div");
        blockDependencies.className = "block_dependencies";
        blockDependencies.innerHTML = "<b>Dependencies</b>";
        blockDependencies.appendChild(createTags(dependencies));
        blockContent.appendChild(blockDependencies);
    }

    block.addEventListener("click", function (event) {
        if (event.currentTarget.contains(event.target)) {
            block.classList.toggle("active");
            if (block.classList.contains("active")) {
                dependencies.forEach(dep => {
                    const depBlock = document.getElementById(IDS[dep]?.uuid);
                    if (depBlock && !depBlock.classList.contains("active")) {
                        depBlock.click();
                    }
                });
            }
            CodeBuilder();
        }
    });

    return block;
}

function createTab(name, identifier, contentData) {
    const tabHeader = document.querySelector(".tab_header");
    const tabContainer = document.querySelector(".tab_container");

    const tab = document.createElement("div");
    tab.className = "tab";
    tab.innerHTML = name;
    tab.setAttribute("data-identifier", identifier);

    const tabContent = document.createElement("div");
    tabContent.className = "tab_content";
    tabContent.setAttribute("data-identifier", identifier);

    const types = [...new Set(contentData.map(c => c.type))];
    types.forEach(type => tabContent.appendChild(createCodeCategory(type)));
    contentData.forEach(content => {
        tabContent.querySelector(`#${classFormat(content.type)}`).appendChild(createBlock(content));
    });

    tab.addEventListener("click", function () {
        document.querySelectorAll(".tab, .tab_content").forEach(el => el.classList.remove("active"));
        tab.classList.add("active");
        tabContent.classList.add("active");
    });

    tabHeader.appendChild(tab);
    tabContainer.appendChild(tabContent);

    return tab;
}

function createTabs() {
    const methods = new Set();
    let pos = 0;
    // Use DATA.scripts instead of DATA
    Object.values(DATA.scripts).forEach(category => {
        // we must get the key of the object
        let categoryName = Object.keys(DATA.scripts)[pos];
        pos++;

        if (typeof category === 'object') {
            const contentData = [];
            Object.values(category).forEach(({ method, uuid, desc, type, example, dependencies, script }) => {
                if (!methods.has(categoryName)) {
                    methods.add(categoryName);
                    Object.values(category).forEach(block => {
                        contentData.push({ ...block });
                        if (block.dependencies === undefined) {
                            block.dependencies = [];
                        }
                        IDS[block.name] = { uuid: block.uuid, script: block.script, dependencies: block.dependencies };
                    });
                    createTab(categoryName, categoryName, contentData);
                }
            });
        }
    });

    //choose .download button
    const downloadButton = document.querySelector(".download");
    const codeBlock = document.querySelector(".codeData");

    //add event listener to download button
    downloadButton.addEventListener("click", () => {
        const code = codeBlock.innerText;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vulpiniq.js";
        a.click();
        URL.revokeObjectURL(url);
    });


}

document.addEventListener("DOMContentLoaded", createTabs);
</script>
</head>
<body>
    <div class="container">
<div class="left_side">
<div class="header">
    <h1>VulpiniQ</h1>
    <p>Build your own VulpiniQ Library</p>
    </div>
<textarea class="codeData" placeholder="Enter your code here"></textarea>
<div class="footer">
    <div class="sizedata">No code recently</div>
    <button class="btn download">Download</button>
</div>
</div>
<div class="right_side">
    <div class="tab_header">
    </div>
    <div class="tab_container">
    </div>
</div>
    </div>
    <!-- <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>
    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div> -->
</body>
</html>