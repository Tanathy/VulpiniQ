<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>
    <link rel="stylesheet" href="builder.css">
<style>* { margin: 0; padding: 0; box-sizing: border-box; /* outline: 1px solid rgba(255, 255, 255, 0.2); */}body { font-family: 'Arial', sans-serif; background-color: #0e0e0e; color: #a3a3a3; line-height: 1.6; font-size: 12px;}::-webkit-scrollbar { width: 8px; height: 8px;}::-webkit-scrollbar-track { background: #2e2e2e;}::-webkit-scrollbar-thumb { background: #555; border-radius: 4px;}::-webkit-scrollbar-thumb:hover { background: #777;}.container{ display: flex;}.left_side{width: 50%;background-color: #0000003d;border-right: 1px solid #ffffff15;}.right_side{ flex-shrink: 0; width: 50%;padding-left:5px}.tab_header{display:flex;}.tab{padding: 5px 15px;cursor: pointer;}.tab.active{background: rgba(255, 255, 255, 0.2);color: #c4c4c4;}.tab_container{overflow-x: hidden;height: calc(100vh - 30px);padding: 0 5px;}.tags{display: flex;flex-wrap: wrap;}.tag{ padding: 0px 9px; margin: 3px; background: #333; border-radius: 5px; cursor: default;}.block{ cursor: default;padding:10px; background: #ffffff09; border-radius: 10px; /* outline: 1px solid #ffffff10; */ width: 100%;}.block.active { background: #ffffff18;}.block_example{ padding: 8px; background: #00000033; border-radius: 12px; width: 100%; margin-top: 10px;}.code_content{ display: grid; grid-template-columns: repeat(2, 1fr); /* Create 3 equal columns */ gap: 10px; /* Add gap between grid items */}.block_dependencies{ margin-top: 10px;}.block_title{ font-size: 16px; font-weight: bold; margin-bottom: 20px;}.code_category_title{ font-size: 20px; font-weight: bold; margin: 15px 0}.code_category{margin-bottom: 40px;}.codeData{ padding: 10px; background: #00000033; border-radius: 12px; width: calc(100% - 10px); height: 200px; margin-top: 10px; color: #a3a3a3; text-align: justify; border: 1px solid #ffffff10; box-sizing: border-box; margin: 5px; resize: vertical; max-height: 400px;}.codeData:focus{ outline: none;}.footer{display:flex;}.sizedata{ margin: 0 20px; display: flex; align-items: center;}.btn { padding: 5px 10px; background: #333; color: #a3a3a3; border: none; border-radius: 5px; cursor: pointer;}.tab_content{ display: none;}.tab_content.active{ display: block;}.bracket { color: #e7e192;}.bracket_inner { color: #96a8f5;}.class,.object { color: #bb6485; font-weight: bold;}.keyword { color: #f78c6c;}.operator { color: #ff5370;}.method { color: #82aaff;}.string { color: #d8a378; font-weight: bold;}.number { color: #f78c6c;}.comment { color: #428f59 !important;}</style>
<script>
var DATA = {
    "frame": "const Q = (() => {\n    'use strict';\n    const _ob = Object, _ar = Array, _ma = Math, _da = Date, _re = RegExp,\n        _st = setTimeout, _un = undefined, _n = null, _nl = NodeList,\n        _el = Element, _si = setInterval, _c = console, _ct = clearTimeout,\n        _ci = clearInterval, _pr = Promise, _str = String, _nu = Number,\n        _bo = Boolean, _json = JSON, _map = Map, _set = Set, _sym = Symbol,\n        _win = window, _doc = document, _loc = location, _hist = history,\n        _ls = localStorage, _ss = sessionStorage, _f = fetch, _ev = Event,\n        _ac = AbortController, _as = AbortSignal, _err = Error;\n    let GLOBAL = {};\n    let styleData = {\n        elements: [],\n        root: '',\n        generic: \"\",\n        responsive: {},\n        element: _n,\n        init: false\n    };\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib_set') || createStyleElement();\n            styleData.init = true;\n        }\n        let finalStyles = styleData.root ? `:root {${styleData.root}}\\n` : '';\n        finalStyles += styleData.generic;\n        const breakpoints = _ob.keys(styleData.responsive);\n        for (let i = 0; i < breakpoints.length; i++) {\n            const size = breakpoints[i];\n            const css = styleData.responsive[size];\n            if (css) {\n                finalStyles += `\\n@media (max-width: ${size}) {\\n${css}\\n}`;\n            }\n        }\n        styleData.element.textContent = finalStyles;\n    }\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib_set';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n    window.addEventListener('load', applyStyles, { once: true });\n    function Q(identifier, attributes, props) {\n        if (!(this instanceof Q)) return new Q(identifier, attributes, props);\n        if (identifier && identifier.nodeType) {\n            this.nodes = [identifier];\n            return;\n        }\n        if (identifier instanceof Q) {\n            this.nodes = identifier.nodes;\n            return;\n        }\n        if (identifier?.constructor === _nl) {\n            this.nodes = _ar.from(identifier);\n            return;\n        }\n        if (typeof identifier === 'string') {\n            const isCreating = attributes || identifier.indexOf('<') > -1;\n            if (isCreating) {\n                const template = document.createElement('template');\n                template.innerHTML = identifier.trim();\n                this.nodes = _ar.from(template.content.childNodes);\n                if (attributes) {\n                    const attrEntries = _ob.entries(attributes);\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = attrEntries.length; j < m; j++) {\n                            const [attr, val] = attrEntries[j];\n                            if (attr === 'class') {\n                                element.classList.add(...(Array.isArray(val) ? val : val.split(/\\s+/)));\n                            } else if (attr === 'style') {\n                                if (typeof val === 'object') {\n                                    const styleEntries = _ob.entries(val);\n                                    for (let k = 0, p = styleEntries.length; k < p; k++) {\n                                        const [prop, propVal] = styleEntries[k];\n                                        element.style[prop] = propVal;\n                                    }\n                                } else {\n                                    element.style.cssText = val;\n                                }\n                            } else if (attr === 'text') {\n                                element.textContent = val;\n                            } else if (attr === 'html') {\n                                element.innerHTML = val;\n                            } else {\n                                element.setAttribute(attr, val);\n                            }\n                        }\n                    }\n                }\n                if (props) {\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = props.length; j < m; j++) {\n                            element[props[j]] = true;\n                        }\n                    }\n                }\n            } else {\n                this.nodes = _ar.from(document.querySelectorAll(identifier));\n            }\n        }\n    }\n    Q.Ext = (methodName, functionImplementation) =>\n        (Q.prototype[methodName] = functionImplementation, Q);\n    Q.getGLOBAL = key => GLOBAL[key];\n    Q.setGLOBAL = value => (GLOBAL = { ...GLOBAL, ...value });\n    Q.style = (root = _n, style = '', responsive = _n, mapping = _n, enable_mapping = true) => {\n        const cleanUp = (str) => {\n            str= str.replace(/^\\s*[\\r\\n]/gm, '');\n            str = str.replace(/\\s+/g, ' ');\n            str = str.replace(/;;/g, ';');\n            return str.trim();\n        }\n        if (mapping && enable_mapping) {\n            const keys = _ob.keys(mapping);\n            const generateSecureCSSClassName = () => {\n                const letters = 'abcdefghijklmnopqrstuvwxyz';\n                const allChars = letters + '0123456789';\n                const length = _ma.floor(_ma.random() * 3) + 6;  \n                const firstChar = letters.charAt(_ma.floor(_ma.random() * letters.length));\n                const remainingChars = Array.from({ length: length - 1 }, () => \n                    allChars.charAt(_ma.floor(_ma.random() * allChars.length))\n                ).join('');\n                return firstChar + remainingChars;\n            };\n            const getUniqueClassName = () => {\n                let newKey;\n                do {\n                    newKey = generateSecureCSSClassName();\n                } while (styleData.elements.includes(newKey));\n                styleData.elements.push(newKey);\n                return newKey;\n            };\n            keys.forEach((key) => {\n                let newKey = getUniqueClassName();\n                if (style && typeof style === 'string') {\n                    style = style.replace(new _re(`\\\\.${key}\\\\b`, 'gm'), `.${newKey}`);\n                    style = style.replace(new _re(`^\\\\s*\\\\.${key}\\\\s*{`, 'gm'), `.${newKey} {`);\n                    style = style.replace(new _re(`(,\\\\s*)\\\\.${key}\\\\b`, 'gm'), `$1.${newKey}`);\n                    style = style.replace(new _re(`(\\\\s+)\\\\.${key}\\\\b`, 'gm'), `$1.${newKey}`);\n                }\n                mapping[key] = mapping[key].replace(key, newKey);\n            });\n        }\n        if (root && typeof root === 'string') {\n            styleData.root += root.trim() + ';';\n            styleData.root = cleanUp(styleData.root);\n        }\n        if (style && typeof style === 'string') {\n            styleData.generic += style;\n            styleData.generic = cleanUp(styleData.generic);\n        }\n        if (responsive && typeof responsive === 'object') {\n            const breakpoints = _ob.entries(responsive);\n            for (let i = 0; i < breakpoints.length; i++) {\n                const [size, css] = breakpoints[i];\n                if (css && typeof css === 'string') {\n                    if (!styleData.responsive[size]) {\n                        styleData.responsive[size] = '';\n                    }\n                    styleData.responsive[size] += css + '\\n';\n                }\n            }\n        }\n        if (document.readyState === 'complete') {\n            applyStyles();\n        }\n        return mapping;\n    };\n    Q._ = {\n        ob: _ob, ar: _ar, ma: _ma, da: _da, re: _re, st: _st, un: _un,\n        n: _n, nl: _nl, el: _el, si: _si, c: _c, ct: _ct, ci: _ci,\n        pr: _pr, str: _str, nu: _nu, bo: _bo, json: _json, map: _map,\n        set: _set, sym: _sym, win: _win, doc: _doc, loc: _loc, hist: _hist,\n        ls: _ls, ss: _ss, f: _f, ev: _ev, ac: _ac, as: _as, err: _err\n    };\n    return Q;\n})();",
    "basics": {
        "Done": {
            "uuid": "803e2252-28b7-469c-a69c-036c5d403b4f",
            "name": "Done",
            "method": "Static",
            "desc": "Executes a function once the window's load event is fired, indicating all resources are loaded.",
            "type": "Event Handling",
            "example": [
                "Q.Done(() => console.log('All resources loaded!'));",
                "let postLoad = () => { document.body.classList.add('loaded'); }; Q.Done(postLoad);",
                "Q.Done(() => { document.getElementById('preloader').classList.add('fade-out'); });",
                "const calculateLayout = () => { const imageHeights = Array.from(document.images).map(img => img.height); console.log('All image heights:', imageHeights); }; Q.Done(calculateLayout);"
            ],
            "dependencies": [],
            "script": "Q.Done=((c)=>{\n    window.addEventListener(\"load\",()=>{while(c.length)c.shift()();c=0});\n    return f=>c?c.push(f):f()\n})([]);"
        },
        "Leaving": {
            "uuid": "ed38c61a-912b-48fb-a773-acb9d0be593f",
            "name": "Leaving",
            "method": "Static",
            "desc": "Attaches a function to the window's beforeunload event, allowing actions before the page is closed or refreshed.",
            "type": "Event Handling",
            "example": [
                "Q.Leaving(e => e.preventDefault());",
                "let goodbyeMessage = e => { e.preventDefault(); e.returnValue = 'Are you sure you want to leave?'; }; Q.Leaving(goodbyeMessage);",
                "Q.Leaving(event => { if (document.querySelector('form').dataset.modified === 'true') { event.preventDefault(); event.returnValue = 'You have unsaved changes'; } });",
                "const saveState = e => { localStorage.setItem('appState', JSON.stringify(currentState)); }; Q.Leaving(saveState);"
            ],
            "dependencies": [],
            "script": "Q.Leaving=((c)=>{\n    let ev;\n    window.addEventListener(\"beforeunload\",e=>{\n      ev=e;while(c.length)c.shift()(e);c=0\n    });\n    return f=>c?c.push(f):f(ev)\n  })([]);"
        },
        "Ready": {
            "uuid": "2c11399c-e7d5-4d16-ba02-48bc953d9b4e",
            "name": "Ready",
            "method": "Static",
            "desc": "Executes a function when the document is fully loaded, ensuring all elements are accessible.",
            "type": "Event Handling",
            "example": [
                "Q.Ready(() => console.log('Document is ready!'));",
                "let init = () => { console.log('Initialization complete.'); }; Q.Ready(init);",
                "Q.Ready(() => { document.getElementById('loader').style.display = 'none'; document.getElementById('content').style.display = 'block'; });",
                "const setupEventListeners = () => { document.querySelectorAll('.clickable').forEach(el => el.addEventListener('click', handleClick)); }; Q.Ready(setupEventListeners);"
            ],
            "dependencies": [],
            "script": "Q.Ready=((c)=>{\n    document.readyState==='loading'?document.addEventListener(\"DOMContentLoaded\",()=>{while(c.length)c.shift()();c=0},{once:1}):c=0;\n    return f=>c?c.push(f):f();\n  })([]);"
        },
        "Resize": {
            "uuid": "33ecab50-fa7f-49d2-9c15-7481de294f7c",
            "name": "Resize",
            "method": "Static",
            "desc": "Attaches a function to the window's resize event, executing it with the new innerWidth and innerHeight.",
            "type": "Event Handling",
            "example": [
                "Q.Resize((width, height) => console.log(`Window resized to ${width}x${height}`));",
                "let resizeHandler = (width, height) => { document.body.style.fontSize = (width / 100) + 'em'; }; Q.Resize(resizeHandler);",
                "Q.Resize((width, height) => { const ratio = width / height; document.getElementById('container').style.aspectRatio = ratio; });",
                "const updateLayout = (w, h) => { if (w < 768) { document.body.classList.add('mobile'); } else { document.body.classList.remove('mobile'); } }; Q.Resize(updateLayout);"
            ],
            "dependencies": [],
            "script": "Q.Resize=((c)=>{\n    addEventListener(\"resize\",()=>{\n      for(let i=0,l=c.length;i<l;) c[i++](innerWidth,innerHeight)\n    });\n    return f=>c.push(f)\n  })([]);"
        }
    },
    "methods": {
        "addClass": {
            "uuid": "e7bed137-b0c2-484b-bc70-0ec86c56f449",
            "name": "addClass",
            "method": "Prototype",
            "desc": "Adds one or more classes to each node, ignoring duplicates.",
            "type": "Class Manipulation",
            "example": "Q(selector).addClass(\"class1\"); // Adds a single class\nQ(selector).addClass(\"class1 class2\"); // Adds multiple classes",
            "dependencies": [],
            "script": "Q.Ext('addClass', function (classes) {\n    var list = classes.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].classList.add.apply(nodes[i].classList, list);\n    }\n    return this;\n});"
        },
        "after": {
            "uuid": "c7ecfc0f-06af-485e-aded-b6f2df7d9ab4",
            "name": "after",
            "method": "Prototype",
            "desc": "Inserts content after each element in the current set of matched elements.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).after(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML",
                "Q(selector).after(document.createElement(\"div\")); // Adds a div element",
                "Q(selector).after(Q(otherSelector)); // Inserts a Q object",
                "Q(selector).after([document.createElement(\"span\"), document.createElement(\"img\")]); // Inserts multiple elements"
            ],
            "dependencies": [],
            "script": "Q.Ext('after', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const target = nodes[i];\n    const parent = target.parentNode;\n    if (!parent) continue;\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const content = contents[j];\n      if (typeof content === \"string\") {\n        target.insertAdjacentHTML('afterend', content);\n      } else if (content instanceof HTMLElement) {\n        if (target.nextSibling) {\n          parent.insertBefore(content, target.nextSibling);\n        } else {\n          parent.appendChild(content);\n        }\n      } else if (content instanceof Q) {\n        if (target.nextSibling) {\n          parent.insertBefore(content.nodes[0], target.nextSibling);\n        } else {\n          parent.appendChild(content.nodes[0]);\n        }\n      } else if (Array.isArray(content) || content instanceof NodeList) {\n        const subNodes = Array.from(content);\n        let nextSibling = target.nextSibling;\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          if (nextSibling) {\n            parent.insertBefore(subNodes[k], nextSibling);\n            nextSibling = subNodes[k].nextSibling;\n          } else {\n            parent.appendChild(subNodes[k]);\n          }\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "animate": {
            "uuid": "500f2559-e1a7-4769-a8df-b0f9e4ceb15d",
            "name": "animate",
            "method": "Prototype",
            "desc": "Animates each node using specified CSS properties over a given duration, with an optional callback when complete.",
            "type": "Animation",
            "example": [
                "Q(selector).animate(500, { opacity: 0 }, () => { console.log('Fade out complete'); }); // Fades out over 500ms",
                "Q(selector).animate(1000, { left: \"100px\", top: \"50px\" }); // Moves to new position in 1 second",
                "Q(selector).animate(700, { opacity: 1, backgroundColor: \"#ff0000\" }, () => { alert('Animation finished!'); }); // Changes opacity and background color"
            ],
            "dependencies": [],
            "script": "Q.Ext('animate', function (duration, properties, callback) {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var element = nodes[i],\n        keys = Object.keys(properties),\n        transitionProperties = '';\n    for (var j = 0, klen = keys.length; j < klen; j++) {\n      transitionProperties += keys[j] + ' ' + duration + 'ms' + (j < klen - 1 ? ', ' : '');\n    }\n    element.style.transition = transitionProperties;\n    for (var j = 0; j < klen; j++) {\n      var prop = keys[j];\n      element.style[prop] = properties[prop];\n    }\n    if (typeof callback === 'function') {\n      setTimeout((function(el){\n          return function(){ callback.call(el); };\n      })(element), duration);\n    }\n  }\n  return this;\n});"
        },
        "append": {
            "uuid": "19c0c703-5ca0-4c30-a7d4-19a9307e2824",
            "name": "append",
            "method": "Prototype",
            "desc": "Appends child nodes, HTML, or multiple elements to each node.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).append(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML",
                "Q(selector).append(document.createElement(\"div\")); // Adds a div element",
                "Q(selector).append(Q(otherSelector)); // Appends a Q object",
                "Q(selector).append([document.createElement(\"span\"), document.createElement(\"img\")]); // Appends multiple elements",
                "Q(selector).append(document.querySelectorAll(\".items\")); // Appends a NodeList of elements"
            ],
            "dependencies": [],
            "script": "Q.Ext('append', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const child = contents[j];\n      if (typeof child === \"string\") {\n        parent.insertAdjacentHTML('beforeend', child);\n      } else if (child instanceof HTMLElement || child instanceof Q) {\n        parent.appendChild(child.nodes ? child.nodes[0] : child);\n      } else if (Array.isArray(child) || child instanceof NodeList) {\n        const subNodes = Array.from(child);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.appendChild(subNodes[k]);\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "attr": {
            "uuid": "ea00ed74-e27e-4efc-8e25-959af7b6f37a",
            "name": "attr",
            "method": "Prototype",
            "desc": "Gets or sets attributes on the nodes, supporting multiple attributes at once.",
            "type": "Attribute Manipulation",
            "example": [
                "Q(selector).attr(\"id\", \"newId\"); // Sets the 'id' attribute to 'newId'",
                "Q(selector).attr({ \"src\": \"image.jpg\", \"alt\": \"An image\" }); // Sets multiple attributes",
                "Q(selector).attr(\"href\"); // Gets the 'href' attribute value"
            ],
            "dependencies": [],
            "script": "Q.Ext('attr', function (attribute, value) {\n    var nodes = this.nodes;\n    if (typeof attribute === 'object') {\n        var keys = Object.keys(attribute);\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            var node = nodes[i];\n            for (var j = 0, klen = keys.length; j < klen; j++) {\n                node.setAttribute(keys[j], attribute[keys[j]]);\n            }\n        }\n        return this;\n    } else {\n        if (value === undefined) {\n            return nodes[0] && nodes[0].getAttribute(attribute) || null;\n        }\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            nodes[i].setAttribute(attribute, value);\n        }\n        return this;\n    }\n});"
        },
        "before": {
            "uuid": "cf77c4b4-399e-42b9-981f-d40aaa91f548",
            "name": "before",
            "method": "Prototype",
            "desc": "Inserts content before each element in the current set of matched elements.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).before(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML",
                "Q(selector).before(document.createElement(\"div\")); // Adds a div element",
                "Q(selector).before(Q(otherSelector)); // Inserts a Q object",
                "Q(selector).before([document.createElement(\"span\"), document.createElement(\"img\")]); // Inserts multiple elements"
            ],
            "dependencies": [],
            "script": "Q.Ext('before', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const target = nodes[i];\n    const parent = target.parentNode;\n    if (!parent) continue;\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const content = contents[j];\n      if (typeof content === \"string\") {\n        target.insertAdjacentHTML('beforebegin', content);\n      } else if (content instanceof HTMLElement) {\n        parent.insertBefore(content, target);\n      } else if (content instanceof Q) {\n        parent.insertBefore(content.nodes[0], target);\n      } else if (Array.isArray(content) || content instanceof NodeList) {\n        const subNodes = Array.from(content);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.insertBefore(subNodes[k], target);\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "bind": {
            "uuid": "4a195ac5-9110-450a-a73d-cc753e45093d",
            "name": "bind",
            "method": "Prototype",
            "desc": "Adds an event listener to each node, allowing for event delegation to improve performance.",
            "type": "Event Handling",
            "example": [
                "Q(selector).bind(\"click\", () => console.log(\"Clicked\")); // Logs 'Clicked' when any matching node is clicked",
                "Q('.btn').bind(\"mouseover\", (e) => { console.log(`Hovered over: ${e.target.tagName}`); }); // Logs the tag name of the hovered element"
            ],
            "dependencies": [],
            "script": "Q.Ext('bind', function (event, handler) {\n    if (!this._eventDelegation) {\n        this._eventDelegation = {};\n    }\n    if (!this._eventDelegation[event]) {\n        document.addEventListener(event, (e) => {\n            var nodes = this.nodes;\n            for (var i = 0, l = nodes.length; i < l; i++) {\n                if (nodes[i].contains(e.target)) {\n                    handler.call(e.target, e);\n                }\n            }\n        });\n        this._eventDelegation[event] = true;\n    }\n    return this;\n});"
        },
        "blur": {
            "uuid": "9b856282-eb34-48f9-bea7-07d60e908529",
            "name": "blur",
            "method": "Prototype",
            "desc": "Removes focus from the first node in the selection, effectively blurring it.",
            "type": "Form Manipulation",
            "example": [
                "Q(selector).blur(); // Removes focus from the first matched input field",
                "Q('.active').blur(); // Blurs the first active element",
                "Q('textarea').blur(); // Blurs the first textarea in the selection"
            ],
            "dependencies": [],
            "script": "Q.Ext('blur', function () {\n    var nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].blur();\n    }\n    return this;\n});"
        },
        "children": {
            "uuid": "7d3dd89b-e583-4532-8690-517d90e1ab8f",
            "name": "children",
            "method": "Prototype",
            "desc": "Gets the direct child elements of each node, optionally filtered by a selector.",
            "type": "Traversal",
            "example": [
                "const items = Q('ul').children();",
                "Q('#menu').children('.active').addClass('highlight');",
                "const visibleItems = Q('.container').children(':visible');",
                "const selector = 'li'; Q('nav').children(selector).css('display', 'inline-block');"
            ],
            "dependencies": [],
            "script": "Q.Ext('children', function (selector) {\n  const result = [];\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    if (!parent || !parent.children) continue;\n    const childElements = parent.children;\n    if (selector) {\n      for (let j = 0; j < childElements.length; j++) {\n        if (childElements[j].matches && childElements[j].matches(selector)) {\n          result.push(childElements[j]);\n        }\n      }\n    } else {\n      for (let j = 0; j < childElements.length; j++) {\n        result.push(childElements[j]);\n      }\n    }\n  }\n  return new Q(result);\n});"
        },
        "click": {
            "uuid": "af99aab8-9f1c-4168-8b7f-75fcadd961c6",
            "name": "click",
            "method": "Prototype",
            "desc": "Simulates a click event on each node in the selection.",
            "type": "Event Handling",
            "example": [
                "Q(selector).click();",
                "Q('.button').click();"
            ],
            "dependencies": [],
            "script": "Q.Ext('click', function () {\n    var nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].click();\n    }\n    return this;\n});"
        },
        "clone": {
            "uuid": "e9c810c3-d298-43ab-9e87-8c0a34d1568e",
            "name": "clone",
            "method": "Prototype",
            "desc": "Creates a deep copy of the first node in the selection, including its child nodes.",
            "type": "DOM Manipulation",
            "example": [
                "let clonedNode = Q(selector).clone();",
                "Q(selector).clone().appendTo('#target');"
            ],
            "dependencies": [],
            "script": "Q.Ext('clone', function () {\n    return new Q(this.nodes[0].cloneNode(true));\n});"
        },
        "closest": {
            "uuid": "81ec5bb8-991f-4998-a35c-c744b4885b84",
            "name": "closest",
            "method": "Prototype",
            "desc": "Finds the nearest ancestor node of the first node that matches a given selector.",
            "type": "Traversal",
            "example": [
                "Q(selector).closest('.parent');",
                "Q(selector).closest('#container');",
                "Q(selector).closest('[data-role=wrapper]');"
            ],
            "dependencies": [],
            "script": "Q.Ext('closest', function (selector) {\n    let node = this.nodes[0];\n    while (node) {\n        if (node.matches && node.matches(selector)) {\n            return new Q(node);\n        }\n        node = node.parentElement;\n    }\n    return null;\n});"
        },
        "css": {
            "uuid": "ab7a853a-9ea1-4bfc-baf7-40bfaea93298",
            "name": "css",
            "method": "Prototype",
            "desc": "Gets or sets one or more CSS properties for the nodes.",
            "type": "CSS Manipulation",
            "example": [
                "const color = Q('#element').css('color');",
                "Q('.highlight').css('background-color', '#ffff00');",
                "Q('header').css({ position: 'fixed', top: 0, width: '100%' });",
                "const fontSize = 16; Q('.text').css('font-size', fontSize + 'px');"
            ],
            "dependencies": [],
            "script": "Q.Ext('css', function(property, value) {\n  const nodes = this.nodes;\n  if (typeof property === 'object') {\n      for (let i = 0, len = nodes.length; i < len; i++) {\n          const elemStyle = nodes[i].style;\n          for (const key in property) {\n              elemStyle[key] = property[key];\n          }\n      }\n      return this;\n  }\n  if (value === Q._.un) return getComputedStyle(nodes[0])[property];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].style[property] = value;\n  }\n  return this;\n});"
        },
        "data": {
            "uuid": "d4a11784-7081-4583-b8a4-e121b306136d",
            "name": "data",
            "method": "Prototype",
            "desc": "Retrieves or sets data-* attributes on the selected nodes. Provides an easy way to store and access custom data associated with the elements.",
            "type": "Data Manipulation",
            "example": [
                "Q(selector).data('userId', 123);",
                "const userId = Q('#user').data('userId'); // Retrieves the userId data attribute",
                "Q('#user').data('role', 'admin'); // Sets the role data attribute to 'admin'"
            ],
            "dependencies": [],
            "script": "Q.Ext('data', function (key, value) {\n    const nodes = this.nodes;\n    if (value === Q._.un) {\n        return nodes[0] && nodes[0].dataset[key] || Q._.n;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].dataset[key] = value;\n    }\n    return this;\n});"
        },
        "detach": {
            "uuid": "5d374446-e2c5-404a-993f-8f0d7bc7061b",
            "name": "detach",
            "method": "Method",
            "desc": "Removes the elements from the DOM but keeps them in memory for later reattachment.",
            "type": "Method",
            "example": [
                "const element = Q('#myElement').detach(); // Element is removed from DOM but preserved",
                "Q('#container').append(element); // Reattach the element later"
            ],
            "dependencies": [],
            "script": "Q.Ext('detach', function() {\n    const nodes = this.nodes;\n    const detachedNodes = [];\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        const parent = node.parentNode;\n        if (parent) {\n            detachedNodes.push(node);\n            parent.removeChild(node);\n        }\n    }\n    this.nodes = detachedNodes;\n    return this;\n});"
        },
        "each": {
            "uuid": "82a10829-0224-445e-8c11-a9c963799096",
            "name": "each",
            "method": "Prototype",
            "desc": "Iterates over all nodes in the Q object and executes a callback on each node, providing access to the index and element.",
            "type": "Iteration",
            "example": [
                "Q(selector).each((index, element) => console.log(index, element));",
                "Q('.items').each((i, el) => el.style.color = 'red'); // Changes text color of all items to red"
            ],
            "dependencies": [],
            "script": "Q.Ext('each', function (callback) {\n    if (!this.nodes) return this;\n    const nodes = this.nodes;\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        callback.call(nodes[i], i, nodes[i]);\n    }\n    return this;\n});"
        },
        "empty": {
            "uuid": "05b0d920-f4b8-48c0-842a-894b1bf8ed72",
            "name": "empty",
            "method": "Prototype",
            "desc": "Empties the innerHTML of each node.",
            "type": "Content Manipulation",
            "example": [
                "Q(selector).empty();",
                "Q('.container').empty(); // Clears all content inside elements with the class 'container'",
                "Q('#main').empty(); // Clears all content inside the element with the ID 'main'",
                "Q('div').empty(); // Clears all content inside all <div> elements"
            ],
            "dependencies": [],
            "script": "Q.Ext('empty', function () {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].innerHTML = '';\n  }\n  return this;\n});"
        },
        "eq": {
            "uuid": "b49fd06a-6b39-4b42-86a2-8ffb243ee957",
            "name": "eq",
            "method": "Prototype",
            "desc": "Returns a specific node by index.",
            "type": "Traversal",
            "example": [
                "Q(selector).eq(1);",
                "const secondItem = Q('.list-item').eq(1); // Retrieves the second list item"
            ],
            "dependencies": [],
            "script": "Q.Ext('eq', function (index) {\n  var node = this.nodes[index];\n  return node ? new Q(node) : null;\n});"
        },
        "fadeIn": {
            "uuid": "6a117d6c-c6e5-4023-9a7c-e76228222b80",
            "name": "fadeIn",
            "method": "Prototype",
            "desc": "Fades in all nodes over a specified duration.",
            "type": "Animation",
            "example": [
                "Q('#notification').fadeIn(500);",
                "Q('.hidden-content').fadeIn();",
                "Q('.modal').fadeIn(300, () => Q('.modal-content').slideDown());",
                "const duration = 1000; Q('#welcome-message').fadeIn(duration, () => console.log('Animation complete'));"
            ],
            "dependencies": [],
            "script": "Q.Ext('fadeIn', function(duration, callback) {\n    duration = duration || 400;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var elemStyle = el.style;\n            elemStyle.display = '';\n            elemStyle.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            elemStyle.opacity = 1;\n            setTimeout(function() {\n                elemStyle.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeOut": {
            "uuid": "2c602b84-ff10-4f0c-930f-3bd715284392",
            "name": "fadeOut",
            "method": "Prototype",
            "desc": "Fades out all nodes over a specified duration and then sets display to none.",
            "type": "Animation",
            "example": [
                "Q('#notification').fadeOut(500);",
                "Q('.temporary-message').fadeOut();",
                "Q('.modal').fadeOut(300, () => Q('.modal-backdrop').fadeOut());",
                "const duration = 800; Q('#splash-screen').fadeOut(duration, () => console.log('Animation complete'));"
            ],
            "dependencies": [],
            "script": "Q.Ext('fadeOut', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var elemStyle = el.style;\n            elemStyle.transition = 'opacity ' + duration + 'ms';\n            elemStyle.opacity = 0;\n            setTimeout(function() {\n                elemStyle.transition = '';\n                elemStyle.display = 'none';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeTo": {
            "uuid": "df0c1d80-b857-4942-a1f5-b0da486e6b6d",
            "name": "fadeTo",
            "method": "Prototype",
            "desc": "Fades each node to a specific opacity.",
            "type": "Display",
            "example": [
                "Q(selector).fadeTo(0.5, 400, function() { console.log('Faded to 50%'); });",
                "Q('.element').fadeTo(0.75, 1000);",
                "Q('#box').fadeTo(0, 200).fadeTo(1, 200);"
            ],
            "dependencies": [],
            "script": "Q.Ext('fadeTo', function(opacity, duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            style.opacity = opacity;\n            setTimeout(function() {\n                style.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeToggle": {
            "uuid": "5b558861-1ffa-4c61-8104-2ced105ac25d",
            "name": "fadeToggle",
            "method": "Prototype",
            "desc": "Toggles the fade state of each node.",
            "type": "Display",
            "example": [
                "Q(selector).fadeToggle(1000);",
                "Q('.menu-items').fadeToggle(500);",
                "Q('#notification').fadeToggle(800, function() { console.log('Animation complete'); });"
            ],
            "dependencies": [],
            "script": "Q.Ext('fadeToggle', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var computed = window.getComputedStyle(nodes[i]);\n        if (computed.opacity === '0') {\n            this.fadeIn(duration, callback);\n        } else {\n            this.fadeOut(duration, callback);\n        }\n    }\n    return this;\n});"
        },
        "find": {
            "uuid": "42152205-1676-4abb-9c76-7676323871c8",
            "name": "find",
            "method": "Prototype",
            "desc": "Finds descendants of each node that match the selector.",
            "type": "Traversal",
            "example": [
                "Q('#container').find('.item');",
                "const nestedImages = Q('.article').find('img');",
                "const selector = '[data-role=\"button\"]'; Q('nav').find(selector);",
                "Q('form').find('input:invalid').addClass('error');"
            ],
            "dependencies": [],
            "script": "Q.Ext('find', function(selector) {\n    var parent = this.nodes[0];\n    if (!parent) return null;\n    var found = parent.querySelectorAll(selector);\n    return found.length ? Q(found) : null;\n});"
        },
        "first": {
            "uuid": "ef71c25b-a5af-4a0f-8f36-37a2abc0ddd7",
            "name": "first",
            "method": "Prototype",
            "desc": "Returns the first node.",
            "type": "Traversal",
            "example": [
                "Q(selector).first();",
                "Q('li').first();",
                "Q('.item').first().addClass('active');"
            ],
            "dependencies": [],
            "script": "Q.Ext('first', function () {\n    return new Q(this.nodes[0]);\n});"
        },
        "focus": {
            "uuid": "5c741fbe-d292-4e82-92d9-3fcdb53c548a",
            "name": "focus",
            "method": "Prototype",
            "desc": "Focuses on the first node.",
            "type": "Form Manipulation",
            "example": [
                "Q('input#username').focus();",
                "Q('.search-box').focus();",
                "Q(selector).click(function() { Q('#target-field').focus(); });"
            ],
            "dependencies": [],
            "script": "Q.Ext('focus', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].focus();\n    }\n    return this;\n});"
        },
        "hasClass": {
            "uuid": "1e6542af-53f3-49fb-8cc5-4d832b55e08c",
            "name": "hasClass",
            "method": "Prototype",
            "desc": "Checks if the first node has a specific class.",
            "type": "Class Manipulation",
            "example": [
                "var hasActiveClass = Q(selector).hasClass('active');",
                "if (Q(selector).hasClass('disabled')) { /* disable functionality */ }",
                "Q(selector).hasClass('highlight') ? doSomething() : doSomethingElse();"
            ],
            "dependencies": [],
            "script": "Q.Ext('hasClass', function(className) {\n    var node = this.nodes[0];\n    return (node && node.classList.contains(className)) || false;\n});"
        },
        "height": {
            "uuid": "9033b0f0-9141-4a0b-a326-2aa79a14fa44",
            "name": "height",
            "method": "Prototype",
            "desc": "Gets or sets the height of the first node.",
            "type": "Dimensions",
            "example": [
                "Q(selector).height();",
                "Q('#content').height('300px');",
                "const elemHeight = Q('.box').height();",
                "Q('.panel').height('50vh');"
            ],
            "dependencies": [],
            "script": "Q.Ext('height', function (value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0].offsetHeight;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.height = value;\n    }\n    return this;\n});"
        },
        "hide": {
            "uuid": "d2c1876d-ab3e-4f6a-a257-5c74cced062e",
            "name": "hide",
            "method": "Prototype",
            "desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
            "type": "Display",
            "example": [
                "Q(selector).hide();",
                "Q(selector).hide(500);",
                "Q(selector).hide(1000, function() { console.log('Element hidden'); });"
            ],
            "dependencies": [],
            "script": "Q.Ext('hide', function (duration, callback) {\n    duration = duration || 0;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        if (duration === 0) {\n            node.style.display = 'none';\n            if (callback) callback();\n        } else {\n            node.style.transition = 'opacity ' + duration + 'ms';\n            node.style.opacity = 1;\n            setTimeout((function(n) {\n                return function() {\n                    n.style.opacity = 0;\n                    n.addEventListener('transitionend', function handler() {\n                        n.style.display = 'none';\n                        n.style.transition = '';\n                        n.removeEventListener('transitionend', handler);\n                        if (callback) callback();\n                    });\n                };\n            })(node), 0);\n        }\n    }\n    return this;\n});"
        },
        "html": {
            "uuid": "91a211cd-253f-491e-a2d8-ed750dd93cef",
            "name": "html",
            "method": "Prototype",
            "desc": "Gets or sets the innerHTML of the nodes. This method allows for easy manipulation of the content inside the selected elements.",
            "type": "Content Manipulation",
            "example": [
                "const currentHtml = Q(selector).html();",
                "Q(selector).html('<div>New Content</div>');",
                "Q(selector).html(['<span>First</span>', '<span>Second</span>']);",
                "const newNode = Q('<p>Paragraph</p>'); Q(selector).html(newNode);",
                "Q(selector).html(document.createElement('div'));",
                "const nodeList = document.querySelectorAll('.child'); Q(selector).html(nodeList);",
                "Q(selector).html([]);",
                "Q(selector).html(null);"
            ],
            "dependencies": [],
            "script": "Q.Ext('html', function (content) {\n    var nodes = this.nodes;\n    if (content === undefined) {\n        return nodes[0] ? nodes[0].innerHTML : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        node.innerHTML = '';\n        var appendContent = function(child) {\n            if (typeof child === 'string') {\n                node.insertAdjacentHTML('beforeend', child);\n            } else if (child instanceof Q) {\n                for (var j = 0, clen = child.nodes.length; j < clen; j++) {\n                    node.appendChild(child.nodes[j]);\n                }\n            } else if (child instanceof HTMLElement || child instanceof Node) {\n                node.appendChild(child);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                var subs = Array.from(child);\n                for (var k = 0, slen = subs.length; k < slen; k++) {\n                    node.appendChild(subs[k]);\n                }\n            }\n        };\n        if (Array.isArray(content) || content instanceof NodeList) {\n            var contArr = Array.from(content);\n            for (var m = 0, mlen = contArr.length; m < mlen; m++) {\n                appendContent(contArr[m]);\n            }\n        } else {\n            appendContent(content);\n        }\n    }\n    return this;\n});"
        },
        "id": {
            "uuid": "430611e1-5226-4db1-b001-cfda11931da5",
            "name": "id",
            "method": "Prototype",
            "desc": "Gets or sets the id attribute of the first node.",
            "type": "Attributes",
            "example": [
                "const elementId = Q(selector).id(); // Retrieves the id",
                "Q(selector).id('new-id'); // Sets the id to 'new-id'",
                "const oldId = Q('#element').id(); // Get current id",
                "Q('.element').id('dynamic-id-' + index); // Set dynamic id"
            ],
            "dependencies": [],
            "script": "Q.Ext('id', function (ident) {\n    var node = this.nodes[0];\n    if (ident === undefined) return node.id;\n    node.id = ident;\n    return this;\n});"
        },
        "index": {
            "uuid": "7cfba006-2235-424d-81bc-b1de4e90ce2c",
            "name": "index",
            "method": "Prototype",
            "desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
            "type": "Traversal",
            "example": [
                "const position = Q('.item').index(); // Get position of element",
                "Q('.moveMe').index(2); // Move element to third position",
                "Q('.item').index(0); // Move to first position",
                "Q('.item').index(999); // Move to last position (appends)"
            ],
            "dependencies": [],
            "script": "Q.Ext('index', function (index) {\n    var first = this.nodes[0];\n    if (index === undefined) {\n        return Array.prototype.indexOf.call(first.parentNode.children, first);\n    }\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i],\n            parent = node.parentNode;\n        if (!parent) continue;\n        var children = Array.from(parent.children);\n        parent.removeChild(node);\n        if (index >= children.length) {\n            parent.appendChild(node);\n        } else {\n            parent.insertBefore(node, children[index]);\n        }\n    }\n    return this;\n});"
        },
        "inside": {
            "uuid": "beb4786e-e239-430e-b4e7-5796f487b409",
            "name": "inside",
            "method": "Prototype",
            "desc": "Checks if the first node is inside another node, determined by a specific selector.",
            "type": "Traversal",
            "example": [
                "Q(selector).inside(\".parent\");",
                "if(Q('.child').inside('#container')) { /* do something */ }",
                "Q('.item').inside('section.content')"
            ],
            "dependencies": [],
            "script": "Q.Ext('inside', function (selector) {\n    var node = this.nodes[0];\n    return node ? node.closest(selector) !== null : false;\n});"
        },
        "is": {
            "uuid": "aa055fd8-8fb1-4e8e-8538-c25e2fa281de",
            "name": "is",
            "method": "Prototype",
            "desc": "Checks if the first node matches a specific selector or condition, allowing for dynamic queries and element comparisons.",
            "type": "Utilities",
            "example": [
                "Q(selector).is(':visible');",
                "Q(selector).is('.active');",
                "Q(selector).is(function() { return this.tagName === 'DIV'; });",
                "Q(selector).is(anotherElement);",
                "Q(selector).is(Q('.comparable'));",
                "if(Q('input').is(':checked')) { /* process checked input */ }"
            ],
            "dependencies": [],
            "script": "Q.Ext('is', function (selector) {\n    var node = this.nodes[0];\n    if (!node) return false;\n    if (typeof selector === 'function') {\n        return selector.call(node, 0, node);\n    }\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return node.offsetWidth > 0 && node.offsetHeight > 0;\n            case ':hidden':\n                return node.offsetWidth === 0 || node.offsetHeight === 0;\n            case ':hover':\n                return node === document.querySelector(':hover');\n            case ':focus':\n                return node === document.activeElement;\n            case ':blur':\n                return node !== document.activeElement;\n            case ':checked':\n                return node.checked;\n            case ':selected':\n                return node.selected;\n            case ':disabled':\n                return node.disabled;\n            case ':enabled':\n                return !node.disabled;\n            default:\n                return node.matches(selector);\n        }\n    }\n    if (selector instanceof HTMLElement || selector instanceof Node) {\n        return node === selector;\n    }\n    if (selector instanceof Q) {\n        return node === selector.nodes[0];\n    }\n    return false;\n});"
        },
        "isExists": {
            "uuid": "1bcaf2e1-a2da-49c1-b0d3-524436641ce5",
            "name": "isExists",
            "method": "Prototype",
            "desc": "Checks if the first node exists in the DOM.",
            "type": "Utilities",
            "example": [
                "Q(selector).isExists();",
                "Q.isExists('.ok')",
                "if(Q('#myElement').isExists()) { /* do something */ }"
            ],
            "dependencies": [],
            "script": "Q.Ext('isExists', function () {\n    var node = this.nodes[0];\n    return node ? document.body.contains(node) : false;\n});\nQ.isExists = function (selector) {\n    return document.querySelector(selector) !== null;\n};"
        },
        "last": {
            "uuid": "97418d3b-ba14-4d38-8774-c0939185f96b",
            "name": "last",
            "method": "Prototype",
            "desc": "Returns the last node.",
            "type": "Traversal",
            "example": [
                "Q(selector).last();",
                "Q('li').last().addClass('last-item');",
                "const lastParagraph = Q('p').last();",
                "Q('.section').last().css('margin-bottom', '0');"
            ],
            "dependencies": [],
            "script": "Q.Ext('last', function () {\n    var nodes = this.nodes;\n    return new Q(nodes[nodes.length - 1]);\n});"
        },
        "map": {
            "uuid": "14ff1984-9db1-41d6-b629-a5c3eb6447ec",
            "name": "map",
            "method": "Prototype",
            "desc": "Maps each node to a new array.",
            "type": "Array",
            "example": [
                "Q(selector).map(el => el.innerHTML);",
                "const heights = Q('.box').map(el => el.prop('offsetHeight'));",
                "const texts = Q('p').map(el => el.text());",
                "const data = Q('[data-value]').map(el => el.attr('data-value'));"
            ],
            "dependencies": [],
            "script": "Q.Ext('map', function (callback) {\n    var result = [],\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        result.push(callback(new Q(nodes[i])));\n    }\n    return result;\n});"
        },
        "next": {
            "uuid": "11e6e83a-5e1d-4b14-9301-30bca860e42f",
            "name": "next",
            "method": "Prototype",
            "desc": "Gets the next sibling element of each node, optionally filtered by a selector.",
            "type": "Traversal",
            "example": [
                "const nextElement = Q('#current').next();",
                "Q('li.active').next().addClass('upcoming');",
                "Q('.panel').next('div.panel').toggle();",
                "const nextSlide = Q('.current-slide').next('.slide');"
            ],
            "dependencies": [],
            "script": "Q.Ext('next', function(selector) {\n    const result = [];\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        let next = node.nextElementSibling;\n        if (next && (!selector || next.matches(selector))) {\n            result.push(next);\n        }\n    }\n    const instance = new Q();\n    instance.nodes = result;\n    return instance;\n});"
        },
        "off": {
            "uuid": "85cbbf5d-cfb1-4b55-9686-76152ff13d7a",
            "name": "off",
            "method": "Prototype",
            "desc": "Removes an event listener from each node.",
            "type": "Event Handling",
            "example": [
                "Q(selector).off(\"click\", handler);",
                "Q('button').off('click touchstart', handleInteraction);",
                "Q('#form').off('submit', validateForm);",
                "Q('.dropdown').off('mouseenter mouseleave', toggleMenu, { capture: true });"
            ],
            "dependencies": [],
            "script": "Q.Ext('off', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].removeEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
        },
        "offset": {
            "uuid": "e636fca5-bf89-4c7b-aebc-2fe8327e9f8e",
            "name": "offset",
            "method": "Prototype",
            "desc": "Gets the position of the first node relative to the document.",
            "type": "Position",
            "example": [
                "const pos = Q('#element').offset();",
                "const { top, left } = Q('.tooltip-trigger').offset();",
                "Q('#popup').css({ top: Q('#reference').offset().top + 10 + 'px' });",
                "const coords = Q('button').offset(); console.log(`Document position: ${coords.left}, ${coords.top}`);"
            ],
            "dependencies": [],
            "script": "Q.Ext('offset', function () {\n    var node = this.nodes[0],\n        rect = node.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX\n    };\n});"
        },
        "on": {
            "uuid": "ba0b9f1e-9934-4385-baff-0b91b4e88902",
            "name": "on",
            "method": "Prototype",
            "desc": "Adds an event listener to each node.",
            "type": "Event Handling",
            "example": [
                "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
                "Q('button').on('click keypress', handleInteraction);",
                "Q('#form').on('submit', function(e) { e.preventDefault(); });",
                "Q('.draggable').on('mousedown', startDrag, { passive: true });"
            ],
            "dependencies": [],
            "script": "Q.Ext('on', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].addEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
        },
        "parent": {
            "uuid": "49e63019-ca8c-4c4e-b106-9330edd72d93",
            "name": "parent",
            "method": "Prototype",
            "desc": "Gets the parent element of each node, optionally filtered by a selector.",
            "type": "Traversal",
            "example": [
                "const container = Q('#element').parent();",
                "Q('li.active').parent().addClass('has-active-item');",
                "Q('.error-message').parent('form').addClass('has-error');",
                "const formParent = Q('input[name=\"email\"]').parent('.form-group');"
            ],
            "dependencies": [],
            "script": "Q.Ext('parent', function () {\n    var node = this.nodes[0];\n    return new Q(node ? node.parentNode : null);\n});"
        },
        "position": {
            "uuid": "d0c077cd-0fad-4e4d-89fb-20d1b3e56c07",
            "name": "position",
            "method": "Prototype",
            "desc": "Gets the position of the first node relative to its offset parent.",
            "type": "Position",
            "example": [
                "const pos = Q('#element').position();",
                "const { top, left } = Q('.item').position();",
                "Q('#tooltip').css({ top: Q('#target').position().top + 20 + 'px' });",
                "const buttonPos = Q('button').position(); console.log(`X: ${buttonPos.left}, Y: ${buttonPos.top}`);"
            ],
            "dependencies": [],
            "script": "Q.Ext('position', function () {\n    var node = this.nodes[0];\n    return {\n        top: node.offsetTop,\n        left: node.offsetLeft\n    };\n});"
        },
        "prepend": {
            "uuid": "d3ddf5ff-ee44-43eb-bb62-e86f41613d07",
            "name": "prepend",
            "method": "Prototype",
            "desc": "Inserts content at the beginning of each node.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).prepend('<span>New content</span>');",
                "Q('.list').prepend('<li>First item</li>');",
                "const newElement = document.createElement('div'); Q('#container').prepend(newElement);",
                "Q('.message').prepend(`<strong class=\"prefix\">${prefix}:</strong> `);"
            ],
            "dependencies": [],
            "script": "Q.Ext('prepend', function () {\n    var nodes = this.nodes,\n        contents = Array.prototype.slice.call(arguments),\n        i, j, k, parent, child, subNodes;\n    for (i = 0; i < nodes.length; i++) {\n        parent = nodes[i];\n        for (j = 0; j < contents.length; j++) {\n            child = contents[j];\n            if (typeof child === 'string') {\n                parent.insertAdjacentHTML('afterbegin', child);\n            } else if (child instanceof Q) {\n                parent.insertBefore(child.nodes[0], parent.firstChild);\n            } else if (child instanceof HTMLElement || child instanceof Node) {\n                parent.insertBefore(child, parent.firstChild);\n            } else if (Array.isArray(child) || child instanceof NodeList) {\n                subNodes = Array.from(child);\n                for (k = 0; k < subNodes.length; k++) {\n                    parent.insertBefore(subNodes[k], parent.firstChild);\n                }\n            }\n        }\n    }\n    return this;\n});"
        },
        "prev": {
            "uuid": "4c3f3997-4129-4cc1-a857-47cce32d0f07",
            "name": "prev",
            "method": "Prototype",
            "desc": "Gets the previous sibling element of each node, optionally filtered by a selector.",
            "type": "Traversal",
            "example": [
                "const previousElement = Q('#current').prev();",
                "Q('li.active').prev().addClass('completed');",
                "Q('.step-3').prev('.step').trigger('focus');",
                "const prevSlide = Q('.current-slide').prev('.slide');"
            ],
            "dependencies": [],
            "script": "Q.Ext('prev', function(selector) {\n    const result = [];\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        let previous = node.previousElementSibling;\n        if (previous && (!selector || previous.matches(selector))) {\n            result.push(previous);\n        }\n    }\n    const instance = new Q();\n    instance.nodes = result;\n    return instance;\n});"
        },
        "prop": {
            "uuid": "58609f12-e7a7-4273-90d8-06e95239e997",
            "name": "prop",
            "method": "Prototype",
            "desc": "Gets or sets a property on the nodes.",
            "type": "Property Manipulation",
            "example": [
                "Q(selector).prop(property, value);",
                "Q('input[type=\"checkbox\"]').prop('checked', true);",
                "const isDisabled = Q('#submit-button').prop('disabled');",
                "Q('textarea').prop('readOnly', false);"
            ],
            "dependencies": "",
            "script": "Q.Ext('prop', function (property, value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0] ? nodes[0][property] : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i][property] = value;\n    }\n    return this;\n});"
        },
        "remove": {
            "uuid": "f35b2a4b-1d41-4535-aed8-5b8056836060",
            "name": "remove",
            "method": "Prototype",
            "desc": "Removes all nodes from the DOM.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).remove();",
                "Q('.temporary-message').remove();",
                "Q('#confirm-dialog').fadeOut().remove();",
                "if (shouldDelete) { Q('.deleted-items').remove(); }"
            ],
            "dependencies": [],
            "script": "Q.Ext('remove', function() {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].remove();\n    }\n    return this;\n});"
        },
        "removeAttr": {
            "uuid": "156c885e-7d42-46d7-ac26-3c7f6268e044",
            "name": "removeAttr",
            "method": "Prototype",
            "desc": "Removes an attribute from each node.",
            "type": "Attribute Manipulation",
            "example": [
                "Q(selector).removeAttr(attribute);",
                "Q('input').removeAttr('disabled');",
                "Q('.product').removeAttr('data-id');",
                "Q('img').removeAttr('src');"
            ],
            "dependencies": "",
            "script": "Q.Ext('removeAttr', function (attribute) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].removeAttribute(attribute);\n    }\n    return this;\n});"
        },
        "removeClass": {
            "uuid": "59e28299-9b03-4e20-b24b-1b4f581bf4f5",
            "name": "removeClass",
            "method": "Prototype",
            "desc": "Removes the specified class from each node.",
            "type": "Class Manipulation",
            "example": [
                "Q(selector).removeClass('highlight');",
                "Q('.card').removeClass('active selected');",
                "const errorClass = 'invalid'; Q('.form-input').removeClass(errorClass);",
                "Q('.temp-element').removeClass(); // Removes all classes"
            ],
            "dependencies": [],
            "script": "Q.Ext('removeClass', function (classes) {\n    var list = classes.split(' ');\n    for (var i = 0, len = this.nodes.length; i < len; i++) {\n        this.nodes[i].classList.remove.apply(this.nodes[i].classList, list);\n    }\n    return this;\n});"
        },
        "removeData": {
            "uuid": "6de3da11-e6b7-4d6a-8264-31183e8eb144",
            "name": "removeData",
            "method": "Prototype",
            "desc": "Removes a data-* attribute from each node.",
            "type": "Data Manipulation",
            "example": [
                "Q(selector).removeData(key);",
                "Q('.user-cards').removeData('userId');",
                "Q('#product').removeData('price');"
            ],
            "dependencies": "",
            "script": "Q.Ext('removeData', function (key) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i].dataset[key];\n    }\n    return this;\n});"
        },
        "removeProp": {
            "uuid": "8608ba8e-ea3d-465b-9a71-b6e27d2e4ec5",
            "name": "removeProp",
            "method": "Prototype",
            "desc": "Removes a property from each node.",
            "type": "Property Manipulation",
            "example": [
                "Q(selector).removeProp(property);",
                "Q('.elements').removeProp('customProperty');",
                "Q('#form-elements').removeProp('validated');"
            ],
            "dependencies": "",
            "script": "Q.Ext('removeProp', function (property) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i][property];\n    }\n    return this;\n});"
        },
        "removeTransition": {
            "uuid": "c1c98ec3-0564-453b-8e36-00b11a28001e",
            "name": "removeTransition",
            "method": "Prototype",
            "desc": "Removes the transition from each node.",
            "type": "Display",
            "example": [
                "Q(selector).removeTransition();",
                "Q('.animated-elements').removeTransition();",
                "Q('#modal').removeTransition().hide();"
            ],
            "dependencies": "",
            "script": "Q.Ext('removeTransition', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.transition = '';\n    }\n    return this;\n});"
        },
        "scrollHeight": {
            "uuid": "b5ec44d1-e689-43c3-883f-c8f4bc0233d3",
            "name": "scrollHeight",
            "method": "Prototype",
            "desc": "Returns the scroll height of the first node.",
            "type": "Dimensions",
            "example": [
                "const height = Q('#content').scrollHeight();",
                "if (Q('.panel').scrollHeight() > Q('.panel').height()) { /* content is overflowing */ }",
                "const totalHeight = Q('#long-text').scrollHeight();",
                "const scrollPercentage = Q('#container').scrollTop() / (Q('#container').scrollHeight() - Q('#container').height());"
            ],
            "dependencies": [],
            "script": "Q.Ext('scrollHeight', function () {\n    var node = this.nodes[0];\n    return node.scrollHeight;\n});"
        },
        "scrollLeft": {
            "uuid": "4e0878ad-12cc-4c9b-9637-1dc375731dc5",
            "name": "scrollLeft",
            "method": "Prototype",
            "desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": [
                "const position = Q('.scrollable').scrollLeft();",
                "Q('#horizontal-container').scrollLeft(200);",
                "Q('.slider').scrollLeft(50, true); // Increment by 50px",
                "const scrollAmount = 100; Q('.carousel').scrollLeft(scrollAmount, true);"
            ],
            "dependencies": "",
            "script": "Q.Ext('scrollLeft', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollLeft;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollLeft = current.scrollWidth - current.clientWidth;\n        current.scrollLeft = increment \n            ? Math.min(current.scrollLeft + value, maxScrollLeft) \n            : Math.min(value, maxScrollLeft);\n    }\n    return this;\n});"
        },
        "scrollTop": {
            "uuid": "aa226826-b87d-4621-bc84-a666a96e49c2",
            "name": "scrollTop",
            "method": "Prototype",
            "desc": "Gets or sets the vertical scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": [
                "const position = Q('#container').scrollTop();",
                "Q('.scroll-area').scrollTop(300);",
                "Q('#content').scrollTop(100, true); // Increment by 100px",
                "const scrollAmount = 50; Q('.panel').scrollTop(scrollAmount, true);"
            ],
            "dependencies": "",
            "script": "Q.Ext('scrollTop', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollTop;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollTop = current.scrollHeight - current.clientHeight;\n        current.scrollTop = increment \n            ? Math.min(current.scrollTop + value, maxScrollTop) \n            : Math.min(value, maxScrollTop);\n    }\n    return this;\n});"
        },
        "scrollWidth": {
            "uuid": "01fc4cbd-b979-43b7-93ac-44635d36660a",
            "name": "scrollWidth",
            "method": "Prototype",
            "desc": "Returns the scroll width of the first node.",
            "type": "Dimensions",
            "example": [
                "const width = Q('#content').scrollWidth();",
                "if (Q('.panel').scrollWidth() > Q('.panel').width()) { /* content is overflowing */ }",
                "const scrollableWidth = Q('#scrollable-area').scrollWidth();",
                "const scrollPercentage = Q('#container').scrollLeft() / (Q('#container').scrollWidth() - Q('#container').width());"
            ],
            "dependencies": [],
            "script": "Q.Ext('scrollWidth', function () {\n    var node = this.nodes[0];\n    return node.scrollWidth;\n});"
        },
        "show": {
            "uuid": "8bbc8b69-f3cf-4ec9-81a7-da7f377faf9a",
            "name": "show",
            "method": "Prototype",
            "desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
            "type": "Display",
            "example": [
                "Q(selector).show();",
                "Q('#modal').show(500);",
                "Q('.notification').show(300, () => console.log('Animation completed'));",
                "const fadeTime = 800; Q('.hidden-content').show(fadeTime);"
            ],
            "dependencies": "",
            "script": "Q.Ext('show', function (duration = 0, callback) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const element = this.nodes[i];\n        if (duration === 0) {\n            element.style.display = '';\n            if (callback) callback();\n        } else {\n            element.style.transition = `opacity ${duration}ms`;\n            element.style.opacity = 0;\n            element.style.display = '';\n            setTimeout(() => {\n                element.style.opacity = 1;\n                element.addEventListener('transitionend', () => {\n                    element.style.transition = '';\n                    if (callback) callback();\n                }, { once: true });\n            }, 0);\n        }\n    }\n    return this;\n});"
        },
        "siblings": {
            "uuid": "502620f6-7cee-4345-8b25-988c7055f32a",
            "name": "siblings",
            "method": "Prototype",
            "desc": "Gets all sibling elements of each node, optionally filtered by a selector.",
            "type": "Traversal",
            "example": [
                "const allSiblings = Q('#middle').siblings();",
                "Q('.active').siblings().removeClass('active');",
                "Q('li.selected').siblings('li.optional').hide();",
                "const siblingLinks = Q('.current-page').siblings('a');"
            ],
            "dependencies": [],
            "script": "Q.Ext('siblings', function(selector) {\n    const result = [];\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        const parent = node.parentNode;\n        if (parent) {\n            const children = parent.children;\n            for (let j = 0; j < children.length; j++) {\n                if (children[j] !== node) {\n                    if (!selector || children[j].matches(selector)) {\n                        result.push(children[j]);\n                    }\n                }\n            }\n        }\n    }\n    const instance = new Q();\n    instance.nodes = result;\n    return instance;\n});"
        },
        "size": {
            "uuid": "61cbd89b-5bbc-49aa-adb1-44ed64c0dbda",
            "name": "size",
            "method": "Prototype",
            "desc": "Returns the width and height of the first node.",
            "type": "Dimensions",
            "example": [
                "const dimensions = Q('#box').size();",
                "const { width, height } = Q('.container').size();",
                "if (Q('#element').size().width > 500) { /* logic here */ }",
                "const ratio = Q('.image').size().width / Q('.image').size().height;"
            ],
            "dependencies": "",
            "script": "Q.Ext('size', function () {\n    const node = this.nodes[0];\n\treturn {\n\t\twidth: node.offsetWidth,\n\t\theight: node.offsetHeight\n\t};\n});"
        },
        "text": {
            "uuid": "1fa299f6-02bf-4e47-bc25-2fbbeb56ae78",
            "name": "text",
            "method": "Prototype",
            "desc": "Gets or sets the text content of the nodes.",
            "type": "Content Manipulation",
            "example": [
                "Q(selector).text(string);",
                "const message = Q('#notification').text();",
                "Q('.error').text('An error occurred');",
                "Q('li').text(function(i) { return `Item ${i+1}`; });"
            ],
            "dependencies": "",
            "script": "Q.Ext('text', function (content) {\n    if (content === undefined) {\n        return this.nodes[0]?.textContent || null;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].textContent = content;\n    }\n    return this;\n});"
        },
        "toggle": {
            "uuid": "6b884725-b1e1-418f-8882-f1551289a5b3",
            "name": "toggle",
            "method": "Prototype",
            "desc": "Toggles the display of each node.",
            "type": "Display",
            "example": [
                "Q(selector).toggle();",
                "Q('#details').toggle();",
                "Q('.expandable').click(function() { Q(this).next().toggle(); });",
                "const panels = Q('.panel'); panels.toggle();"
            ],
            "dependencies": [],
            "script": "Q.Ext('toggle', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.display = (nodes[i].style.display === 'none' ? '' : 'none');\n    }\n    return this;\n});"
        },
        "toggleClass": {
            "uuid": "ad162ff6-898b-42a6-b666-563496f20ad5",
            "name": "toggleClass",
            "method": "Prototype",
            "desc": "Toggles a class on each node.",
            "type": "Class Manipulation",
            "example": [
                "Q(selector).toggleClass('active');",
                "Q('#menu-button').toggleClass('open');",
                "const highlightClass = 'highlight'; Q('.selectable').toggleClass(highlightClass);",
                "Q(event.target).toggleClass('selected').siblings().toggleClass('dimmed');"
            ],
            "dependencies": [],
            "script": "Q.Ext('toggleClass', function (className) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].classList.toggle(className);\n    }\n    return this;\n});"
        },
        "trigger": {
            "uuid": "970736fe-2499-46f1-8560-0e522ccd1054",
            "name": "trigger",
            "method": "Prototype",
            "desc": "Triggers a specific event on each node.",
            "type": "Event Handling",
            "example": [
                "Q('#submitButton').trigger('click');",
                "Q('.accordion-header').trigger('mouseenter');",
                "const eventName = 'change'; Q('input').trigger(eventName);",
                "Q('.custom-element').trigger('customEvent');"
            ],
            "dependencies": [],
            "script": "Q.Ext('trigger', function (event) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].dispatchEvent(new Event(event));\n    }\n    return this;\n});"
        },
        "unwrap": {
            "uuid": "72450c41-6143-425d-bea0-8d8992953469",
            "name": "unwrap",
            "method": "Prototype",
            "desc": "Removes the parent wrapper of each node.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).unwrap();",
                "Q('span.highlight').unwrap();",
                "Q('.inner-content').unwrap().addClass('standalone');",
                "if (shouldRemoveWrapper) { Q('.wrapped-items').unwrap(); }"
            ],
            "dependencies": [],
            "script": "Q.Ext('unwrap', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const el = this.nodes[i];\n        const parent = el.parentNode;\n        if (parent && parent !== document.body) {\n            parent.replaceWith(...parent.childNodes);\n        }\n    }\n    return this;\n});"
        },
        "val": {
            "uuid": "0cfc1590-8985-4f18-a6ab-894985cadd61",
            "name": "val",
            "method": "Prototype",
            "desc": "Gets or sets the value of form elements in the nodes.",
            "type": "Form Manipulation",
            "example": [
                "Q('input').val('New text');",
                "const username = Q('#username').val();",
                "Q('select').val('option2');",
                "Q('textarea').val('').val(Q('#template').text());"
            ],
            "dependencies": [],
            "script": "Q.Ext('val', function(input) {\n    if (input === undefined) return this.nodes[0]?.value || null;\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].value = input;\n    }\n    return this;\n});"
        },
        "wait": {
            "uuid": "eab4a9a3-1bc7-48e4-bc6e-9cc12f2abcf0",
            "name": "wait",
            "method": "Prototype",
            "desc": "Returns a promise that resolves after a given time. Useful for delaying actions.",
            "type": "Utility",
            "example": [
                "Q('.text').wait(1000).text('Hello, World!');",
                "async function animate() { await Q('#element').addClass('start').wait(500).addClass('end'); }",
                "Q('.notification').show().wait(3000).then(q => q.hide());",
                "const delay = 800; Q('.message').fadeIn().wait(delay).fadeOut();"
            ],
            "dependencies": [],
            "script": "Q.Ext('wait', function(ms) {\n\treturn new Promise(resolve => setTimeout(() => resolve(this), ms));\n});"
        },
        "walk": {
            "uuid": "ce21e5ba-45ae-49be-bdfe-24ef4356c6a6",
            "name": "walk",
            "method": "Prototype",
            "desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter.",
            "type": "Iteration",
            "example": [
                "Q(selector).walk((node) => console.log(node));",
                "Q('li').walk((node, index) => node.textContent = `Item ${index + 1}`);",
                "Q('.items').walk((node) => node.classList.add('processed'), true);",
                "let total = 0; Q('input').walk((node) => total += parseInt(node.value) || 0);"
            ],
            "dependencies": [],
            "script": "Q.Ext('walk', function (callback, useQObject = false) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = useQObject ? Q(this.nodes[i]) : this.nodes[i];\n        callback.call(this.nodes[i], node, i);\n    }\n    return this;\n});"
        },
        "width": {
            "uuid": "cdf9af0d-f069-42aa-8f2c-f98e3199a4c4",
            "name": "width",
            "method": "Prototype",
            "desc": "Gets or sets the width of the first node.",
            "type": "Dimensions",
            "example": [
                "Q(selector).width();",
                "Q('#content').width('500px');",
                "const elemWidth = Q('.box').width();",
                "Q('.column').width('50%');"
            ],
            "dependencies": [],
            "script": "Q.Ext('width', function (value) {\n    if (typeof value === 'undefined') {\n        return this.nodes[0] ? this.nodes[0].offsetWidth : undefined;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.width = value;\n    }\n    return this;\n});"
        },
        "wrap": {
            "uuid": "3b5529bf-82c8-4274-81aa-b109a13383ea",
            "name": "wrap",
            "method": "Prototype",
            "desc": "Wraps each node with the specified wrapper element.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).wrap(\"<div class='wrapper'></div>\");",
                "Q('p').wrap('<article class=\"content\"></article>');",
                "const wrapperDiv = document.createElement('div');",
                "Q('.list-item').wrap(wrapperDiv);"
            ],
            "dependencies": [],
            "script": "Q.Ext('wrap', function (wrapper) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        const parent_Node = node.parentNode;\n        let newParentElement;\n        if (typeof wrapper === 'string') {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = wrapper.trim();\n            newParentElement = tempDiv.firstElementChild.cloneNode(true);\n        } else {\n            newParentElement = wrapper;\n        }\n        parent_Node.insertBefore(newParentElement, node);\n        newParentElement.appendChild(node);\n    }\n    return this;\n});"
        },
        "wrapAll": {
            "uuid": "900701de-878c-4d4a-82e1-2d1fde24e923",
            "name": "wrapAll",
            "method": "Prototype",
            "desc": "Wraps all nodes together in a single wrapper element.",
            "type": "DOM Manipulation",
            "example": [
                "Q(selector).wrapAll(\"<div class='wrapper'></div>\");",
                "Q('.items').wrapAll('<section id=\"container\"></section>');",
                "const wrapperElement = document.createElement('div');",
                "Q('.related-posts').wrapAll(wrapperElement);"
            ],
            "dependencies": [],
            "script": "Q.Ext('wrapAll', function (wrapper) {\n    if (!this.nodes.length) return this;\n    const parent = this.nodes[0].parentNode;\n    let newParent = typeof wrapper === 'string'\n        ? ((tempDiv => (tempDiv.innerHTML = wrapper.trim(), tempDiv.firstElementChild))\n           (document.createElement('div')))\n        : wrapper;\n    parent.insertBefore(newParent, this.nodes[0]);\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        newParent.appendChild(this.nodes[i]);\n    }\n    return this;\n});"
        },
        "zIndex": {
            "uuid": "31e18eb5-0631-4a60-bb25-248b4b4bec37",
            "name": "zIndex",
            "method": "Prototype",
            "desc": "Gets or sets the z-index of the first node.",
            "type": "Display",
            "example": [
                "Q(selector).zIndex();",
                "Q('.overlay').zIndex(10);",
                "const currentIndex = Q('#popup').zIndex();",
                "Q('.modal').zIndex(Q('.header').zIndex() + 5);"
            ],
            "dependencies": [],
            "script": "Q.Ext('zIndex', function (value) {\n    const node = this.nodes[0];\n    if (!node) return;\n    if (value === undefined) {\n        let Index = node.style.zIndex || window.getComputedStyle(node).zIndex;\n        return Index;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.zIndex = value;\n    }\n    return this;\n});"
        }
    },
    "plugins": {
        "Container": {
            "uuid": "42dac7d3-fe0a-4e68-952b-3fa1523a504a",
            "name": "Container",
            "method": "Plugin",
            "desc": "Useful to create containers for your elements, like tabs, accordions, etc.",
            "type": "Constructor",
            "example": "var container = Q.Container(); // Create a new container instance",
            "dependencies": [
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "Icons"
            ],
            "script": "function Container(options = {}) {\n    if (!(this instanceof Container)) {\n        return new Container(options);\n    }\n    this.elements = [];\n    this.options = options;\n    if (!Container.initialized) {\n        Container.classes = Q.style('', `\n            .container_icon {\n                width: 100%;\n                height: 100%;\n                color: #777; /* Default color */\n                pointer-events: none;\n                z-index: 1;\n            }\n        `, null, {\n            'container_icon': 'container_icon'\n        });\n        Q.Icons();\n        Container.initialized = true;\n        console.log('Container core initialized');\n    }\n}\nContainer.prototype.Icon = function(icon) {\n    const iconInstance = Q.Icons();\n    return iconInstance.get(icon, 'container_icon');\n};\nQ.Container = Container;"
        },
        "Container.Tab": {
            "uuid": "89d5dca8-0950-471e-9e71-0f832d009128",
            "name": "Container.Tab",
            "method": "Method",
            "desc": "Tab component for Container plugin",
            "type": "Method",
            "example": [
                "var container = Q.Container(); var tabs = container.Tab([{title: 'Tab 1', value: 'tab1', content: 'Content 1'}, {title: 'Tab 2', value: 'tab2', content: 'Content 2'}]);"
            ],
            "dependencies": [
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "find",
                "scrollTop",
                "scrollLeft",
                "html",
                "text",
                "data",
                "click"
            ],
            "script": "Container.prototype.Tab = function(data, horizontal = true) {\n    if (!Container.tabClassesInitialized) {\n        Container.tabClasses = Q.style('', `\n            .tab_navigation_buttons {\n                box-sizing: border-box;\n                width: 30px;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                user-select: none;\n            }\n            .tab_navigation_buttons_vertical {\n                width: auto;\n                height: 20px;\n            }\n            .tab_navigation_buttons:hover {\n                background-color: var(--form-default-background-hover);\n            }\n            .tab_container {\n                width: 100%;\n                min-height: 300px;\n            }\n            .tab_container_vertical {\n                display: flex;\n            }\n            .tab_navigation_header {\n                background-color: var(--form-default-background);\n                display: flex;\n            }\n            .tab_navigation_header_vertical {\n                flex-direction: column;\n                width: auto;\n            }\n            .tab_navigation_tabs {\n                user-select: none;\n                display: flex;\n                flex-direction: row;\n                width: 100%;\n                overflow: hidden;\n            }\n            .tab_navigation_tabs_vertical {\n                flex-direction: column;\n            }\n            .tab_active {\n                background-color: var(--form-default-accent-color);\n                color: var(--form-default-accent-text-color);\n                color: #fff;\n            }\n            .tab {\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                cursor: default;\n                padding: var(--form-default-padding);\n                font-size: var(--form-default-font-size);\n                white-space: nowrap;     /* prevent text wrap */\n            }\n            .tab_disabled {\n                background-color: var(--form-default-background-disabled);\n                color: var(--form-default-text-color-disabled);\n            }\n            .tab_content {\n                display: none;\n                width: 100%;\n                height: 100%;\n                overflow: auto;\n            }\n            .tab_content_active {\n                display: block;\n            }\n            .tab_content_container {\n                width: 100%;\n                height: 100%;\n                overflow: auto;\n                position: relative;\n            }\n        `, null, {\n            'tab_navigation_buttons': 'tab_navigation_buttons',\n            'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n            'tab_container': 'tab_container',\n            'tab_container_vertical': 'tab_container_vertical',\n            'tab_navigation_header': 'tab_navigation_header',\n            'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n            'tab_navigation_tabs': 'tab_navigation_tabs',\n            'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n            'tab_active': 'tab_active',\n            'tab': 'tab',\n            'tab_disabled': 'tab_disabled',\n            'tab_content_container': 'tab_content_container'\n        });\n        Container.tabClassesInitialized = true;\n    }\n    const wrapper = Q('<div>', { class: Container.tabClasses.tab_container });\n    const header = Q('<div>', { class: Container.tabClasses.tab_navigation_header });\n    const prevBtn = Q('<div>', { class: Container.tabClasses.tab_navigation_buttons });\n    const nextBtn = Q('<div>', { class: Container.tabClasses.tab_navigation_buttons });\n    const tabs = Q('<div>', { class: Container.tabClasses.tab_navigation_tabs });\n    const contentContainer = Q('<div>', { class: Container.tabClasses.tab_content_container });\n    if (!horizontal) {\n        wrapper.addClass(Container.tabClasses.tab_container_vertical);\n        header.addClass(Container.tabClasses.tab_navigation_header_vertical);\n        tabs.addClass(Container.tabClasses.tab_navigation_tabs_vertical);\n        prevBtn.addClass(Container.tabClasses.tab_navigation_buttons_vertical);\n        nextBtn.addClass(Container.tabClasses.tab_navigation_buttons_vertical);\n        prevBtn.html('\u25b2');\n        nextBtn.html('\u25bc');\n    } else {\n        prevBtn.html('\u25c0');\n        nextBtn.html('\u25b6');\n    }\n    header.append(prevBtn, tabs, nextBtn);\n    wrapper.append(header, contentContainer);\n    function updateNavButtons() {\n        const el = tabs.nodes[0];\n        const hasOverflow = horizontal\n            ? el.scrollWidth > el.clientWidth\n            : el.scrollHeight > el.clientHeight;\n        const disp = hasOverflow ? 'flex' : 'none';\n        prevBtn.css('display', disp);\n        nextBtn.css('display', disp);\n    }\n    const data_tabs = {};\n    const data_contents = {};\n    let activeTab = null;\n    prevBtn.off('click').on('click', () => {\n        const scrollAmount = horizontal ? tabs.width() : tabs.height();\n        const el = tabs.nodes[0];\n        if (el && el.scrollBy) {\n            el.scrollBy({\n                left: horizontal ? -scrollAmount : 0,\n                top:  horizontal ? 0 : -scrollAmount,\n                behavior: 'smooth'\n            });\n        } else {\n            horizontal ? tabs.scrollLeft(-scrollAmount, true)\n                       : tabs.scrollTop(-scrollAmount, true);\n        }\n    });\n    nextBtn.off('click').on('click', () => {\n        const scrollAmount = horizontal ? tabs.width() : tabs.height();\n        const el = tabs.nodes[0];\n        if (el && el.scrollBy) {\n            el.scrollBy({\n                left: horizontal ?  scrollAmount : 0,\n                top:  horizontal ?  0 :  scrollAmount,\n                behavior: 'smooth'\n            });\n        } else {\n            horizontal ? tabs.scrollLeft( scrollAmount, true)\n                       : tabs.scrollTop( scrollAmount, true);\n        }\n    });\n    data.forEach(item => {\n        const tab = Q('<div>', { class: Container.tabClasses.tab })\n            .attr('data-value', item.value)\n            .text(item.title);\n        if (item.disabled) {\n            tab.addClass(Container.tabClasses.tab_disabled);\n        }\n        let content;\n        if (typeof item.content === 'string') {\n            content = Q('<div>').html(item.content);\n        } else if (item.content instanceof Element) {\n            content = Q(item.content);\n        } else if (item.content instanceof Q) {\n            content = item.content;\n        } else {\n            content = Q('<div>');\n        }\n        data_tabs[item.value] = tab;\n        data_contents[item.value] = content;\n        tab.on('click', function() {\n            if (tab.hasClass(Container.tabClasses.tab_disabled)) return;\n            const activeTabs = tabs.find('.' + Container.tabClasses.tab_active);\n            if (activeTabs) activeTabs.removeClass(Container.tabClasses.tab_active);\n            tab.addClass(Container.tabClasses.tab_active);\n            showContent(item.value);\n        });\n        tabs.append(tab);\n    });\n    updateNavButtons();\n    function showContent(value) {\n        if (!data_contents[value]) return;\n        if (activeTab && data_contents[activeTab]) {\n            data_contents[activeTab].detach();\n        }\n        activeTab = value;\n        contentContainer.append(data_contents[value]);\n    }\n    wrapper.select = function(value) {\n        const tab = data_tabs[value];\n        if (tab) tab.click();\n        return this;\n    };\n    wrapper.disabled = function(value, state) {\n        const tab = data_tabs[value];\n        if (tab) {\n            state ? tab.addClass(Container.tabClasses.tab_disabled) : \n                  tab.removeClass(Container.tabClasses.tab_disabled);\n        }\n        return this;\n    };\n    wrapper.addTab = function(tabData) {\n        if (!tabData) return null;\n        const tab = Q('<div>', { class: Container.tabClasses.tab })\n            .attr('data-value', tabData.value)\n            .text(tabData.title);\n        if (tabData.disabled) {\n            tab.addClass(Container.tabClasses.tab_disabled);\n        }\n        let content;\n        if (typeof tabData.content === 'string') {\n            content = Q('<div>').html(tabData.content);\n        } else if (tabData.content instanceof Element) {\n            content = Q(tabData.content);\n        } else if (tabData.content instanceof Q) {\n            content = tabData.content;\n        } else {\n            content = Q('<div>');\n        }\n        data_tabs[tabData.value] = tab;\n        data_contents[tabData.value] = content;\n        tab.on('click', function() {\n            if (tab.hasClass(Container.tabClasses.tab_disabled)) return;\n            const activeTabs = tabs.find('.' + Container.tabClasses.tab_active);\n            if (activeTabs) activeTabs.removeClass(Container.tabClasses.tab_active);\n            tab.addClass(Container.tabClasses.tab_active);\n            showContent(tabData.value);\n        });\n        tabs.append(tab);\n        updateNavButtons();\n        return tab;\n    };\n    wrapper.removeTab = function(value) {\n        if (data_tabs[value]) {\n            data_tabs[value].remove();\n            if (activeTab === value) {\n                const availableTab = Object.keys(data_tabs).find(key => key !== value);\n                if (availableTab) {\n                    this.select(availableTab);\n                } else {\n                    contentContainer.empty();\n                    activeTab = null;\n                }\n            }\n            if (data_contents[value]) {\n                data_contents[value].remove();\n            }\n            delete data_tabs[value];\n            delete data_contents[value];\n        }\n        updateNavButtons();\n        return this;\n    };\n    wrapper.getContent = function(value) {\n        return data_contents[value] || null;\n    };\n    wrapper.updateContent = function(value, newContent) {\n        if (!data_contents[value]) return this;\n        if (typeof newContent === 'string') {\n            data_contents[value].html(newContent);\n        } else if (newContent instanceof Element || newContent instanceof Q) {\n            data_contents[value].empty().append(newContent);\n        }\n        return this;\n    };\n    this.elements.push(wrapper);\n    return wrapper;\n};"
        },
        "Container.Table": {
            "uuid": "6587a940-1637-4f66-aeb1-014f8596137d",
            "name": "Container.Table",
            "method": "Method",
            "desc": "Datatable component for Container plugin",
            "type": "Method",
            "example": [
                "var tbl = Q.Container().Table(dataArray, { pageSize: 25 });"
            ],
            "dependencies": [
                "style",
                "append",
                "on",
                "find",
                "html",
                "text",
                "val",
                "click"
            ],
            "script": "Container.prototype.Table = function (data = [], options = {}) {\n  if (!Array.isArray(data)) throw new Error('Container.Table: data must be an array of objects');\n  const defaults = {\n    pageSize: 10,\n    sizes: [],\n    pageButtonLimit: 5,\n    debounce: 250,\n    search: true,\n    sort: true,\n    filter: true,\n    page: true,\n    info: true,\n    language: ['Search...', 'No results found.', 'Showing [PAGE] to [ALL_PAGES] of [TOTAL] entries','First', 'Prev', 'Next', 'Last'],\n  };\n  options = Object.assign({}, defaults, options);\n  const {\n    debounce: debounceTime,\n    search: enableSearch,\n    sort: enableSort,\n    filter: enableFilter,\n    page: enablePage,\n    info: enableInfo\n  } = options;\n  if (!Container.tableClassesInitialized) {\n    Container.tableClasses = Q.style('', `\n      .tbl_wrapper { display: flex; flex-direction: column; }\n      .tbl_top { display: flex; justify-content: space-between; margin-bottom: 5px; }\n      .tbl_table { width:100%; border-collapse: collapse; \n      border-radius: var(--form-default-border-radius);\n      overflow: hidden;\n      }\n      .tbl_table th, .tbl_table td {\n      border: var(--form-default-dataset-border);\n      padding:6px;\n      text-align:left;\n      cursor: default;\n      }\n      .tbl_row.selected { background: var(--form-default-accent-color); color: var(--form-default-accent-text-color); }\n            .tbl_table th\n      {\n        background: var(--form-default-dataset-header-background);\n        color: var(--form-default-dataset-header-text-color);\n        font-weight: var(--form-default-dataset-header-font-weight);\n        font-size: var(--form-default-dataset-header-font-size);\n        padding-right: 25px;\n}\n        .tbl_table td\n      {\n        font-size: var(--form-default-dataset-header-data-font-size);\n        color: var(--form-default-dataset-data-text-color);\n    }\n      .tbl_bottom {\n      display: flex;\n      justify-content: space-between;\n      margin-top:5px; \n      font-size: var(--form-default-dataset-header-data-font-size);\n      color: var(--form-default-dataset-data-text-color);\n      }\n      .tbl_pagination {\n      display:flex;\n      gap:2px;\n      }\n      .tbl_page_btn {\n      padding: 5px 15px;\n      cursor: default;\n      user-select: none;\n      }\n      .tbl_page_btn.active { \n      background: var(--form-default-accent-color);\n        color: var(--form-default-text-color-active);\n    }\n      .tbl_table th { position: relative; }\n      .tbl_table th .sort-icons {\n        position: absolute; right: 8px; top: 50%;\n        transform: translateY(-50%);\n        display: flex; flex-direction: column;\n        font-size: 8px; line-height: 1.3;\n      }\n      .sort_active {\n      color: var(--form-default-accent-color);\n    }\n    `, null, {\n      'tbl_wrapper': 'tbl_wrapper',\n      'tbl_top': 'tbl_top',\n      'tbl_search': 'tbl_search',\n      'tbl_page_size': 'tbl_page_size',\n      'tbl_table': 'tbl_table',\n      'tbl_row': 'tbl_row',\n      'tbl_bottom': 'tbl_bottom',\n      'tbl_pagination': 'tbl_pagination',\n      'tbl_page_btn': 'tbl_page_btn',\n      'sort-icons': 'sort-icons',\n      'asc': 'asc', 'desc': 'desc',\n      'sort_active': 'sort_active',\n      'active': 'active',\n      'selected': 'selected',\n    }, true);\n    Container.tableClassesInitialized = true;\n  }\n  const wrapper = Q('<div>', { class: Container.tableClasses.tbl_wrapper });\n  const top = Q('<div>', { class: Container.tableClasses.tbl_top });\n  let allData = [...data],\n    currentPage = 1,\n    sortKey = null,\n    sortOrder = 'off',\n    selectedIdx = null,\n    onChange = null,\n    filteredIndices = [];\n  const columnSizes = options.sizes;\n  const form = new Q.Form();\n  const searchInput = form.TextBox('text', '', options.language[0]);\n  const search = Q('<div>', { class: Container.tableClasses.tbl_search })\n    .append(searchInput.nodes[0]);\n  if (enableSearch) top.append(search);\n  const searchDebounceId = Q.ID('tbl_search_');\n  const table = Q('<table>', { class: Container.tableClasses.tbl_table });\n  const bottom = Q('<div>', { class: Container.tableClasses.tbl_bottom });\n  const status = Q('<div>');\n  const pagination = Q('<div>', { class: Container.tableClasses.tbl_pagination });\n  bottom.append(status, pagination);\n  wrapper.append(top, table, bottom);\n  let pageSizeVal = options.pageSize;\n  const pageSizeDropdown = form.Dropdown({\n    values: [10, 25, 50, 100].map(n => ({ value: n, text: '' + n, default: n === pageSizeVal }))\n  });\n  const pageSize = Q('<div>', { class: Container.tableClasses.tbl_page_size })\n    .append(pageSizeDropdown.nodes[0]);\n  if (enablePage) top.append(pageSize);\n  pageSizeDropdown.change(v => {\n    pageSizeVal = +v;\n    currentPage = 1;\n    render();\n  });\n  pageSizeVal = +pageSizeDropdown.val().value;\n  function render() {\n    const rawVal = searchInput.val() || '';\n    const term = rawVal.trim();\n    if (enableFilter) {\n      filteredIndices = allData.map((row, i) => i);\n      if (term.includes(':')) {\n        const clauses = term.split(',').map(c => {\n          const [field, ...rest] = c.split(':');\n          return [field.trim(), rest.join(':').trim()];\n        });\n        filteredIndices = filteredIndices.filter(i => {\n          const row = allData[i];\n          return clauses.every(([field, val]) => {\n            const fv = row[field];\n            if (fv == null) return false;\n            const str = typeof fv === 'object' ? JSON.stringify(fv) : String(fv);\n            return str.toLowerCase().includes(val.toLowerCase());\n          });\n        });\n      } else {\n        const lower = term.toLowerCase();\n        filteredIndices = filteredIndices.filter(i =>\n          JSON.stringify(allData[i]).toLowerCase().includes(lower)\n        );\n      }\n    } else {\n      filteredIndices = allData.map((_, i) => i);\n    }\n    if (enableSort && sortKey && sortOrder !== 'off') {\n      filteredIndices.sort((a, b) => {\n        const aVal = allData[a][sortKey];\n        const bVal = allData[b][sortKey];\n        if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;\n        if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;\n        return 0;\n      });\n    }\n    const total = filteredIndices.length;\n    const totalPages = Math.ceil(total / pageSizeVal) || 1;\n    currentPage = Math.min(currentPage, totalPages);\n    const start = (currentPage - 1) * pageSizeVal,\n      end = start + pageSizeVal;\n    const pageIndices = enablePage\n      ? filteredIndices.slice(start, end)\n      : filteredIndices;\n    const keys = Object.keys(allData[0] || {});\n    const thead = `<thead><tr>${keys.map((k, i) => {\n      const icons = enableSort\n        ? `<span class=\"${Container.tableClasses['sort-icons']}\">\n               <span class=\"${Container.tableClasses.asc}\">\u25b2</span>\n               <span class=\"${Container.tableClasses.desc}\">\u25bc</span>\n             </span>`\n        : '';\n      return `<th data-key=\"${k}\"${columnSizes[i] ? ` style=\"width:${columnSizes[i]}\"` : ''}>${k}${icons}</th>`;\n    }).join('')\n      }</tr></thead>`;\n    const tbody = pageIndices.map(idx => {\n      const row = allData[idx];\n      return `<tr data-idx=\"${idx}\" class=\"${Container.tableClasses.tbl_row}${idx === selectedIdx ? ' '+ Container.tableClasses.selected : ''}\">${Object.values(row).map(v => {\n        if (Array.isArray(v)) return `<td>${v.join(', ')}</td>`;\n        if (typeof v === 'object') return `<td>${JSON.stringify(v)}</td>`;\n        return `<td>${v}</td>`;\n      }).join('')\n        }</tr>`;\n    }).join('');\n    table.html('');\n    table.append(thead + `<tbody>${tbody}</tbody>`);\n    if (enableInfo) {\n      if (total === 0) {\n        status.html(options.language[1]);\n      } else{\n      const pageInfo = options.language[2]\n        .replace('[PAGE]', currentPage)\n        .replace('[ALL_PAGES]', totalPages)\n        .replace('[TOTAL]', total);\n      status.html(pageInfo);\n      }\n    }\n    if (enablePage) {\n      pagination.html('');\n      [options.language[3], options.language[4]].forEach(t => {\n        const btn = `<span class=\"${Container.tableClasses.tbl_page_btn}\" data-action=\"${t.toLowerCase()}\">${t}</span>`;\n        pagination.append(btn);\n      });\n      const limit = options.pageButtonLimit;\n      const half = Math.floor(limit / 2);\n      let startPage = Math.max(1, currentPage - half);\n      let endPage = Math.min(totalPages, startPage + limit - 1);\n      if (endPage - startPage + 1 < limit) {\n        startPage = Math.max(1, endPage - limit + 1);\n      }\n      for (let p = startPage; p <= endPage; p++) {\n        const cls = p === currentPage ? ' '+ Container.tableClasses.active : '';\n        pagination.append(`<span class=\"${Container.tableClasses.tbl_page_btn + cls}\" data-page=\"${p}\">${p}</span>`);\n      }\n      [options.language[5], options.language[6]].forEach(t => {\n        const btn = `<span class=\"${Container.tableClasses.tbl_page_btn}\" data-action=\"${t.toLowerCase()}\">${t}</span>`;\n        pagination.append(btn);\n      });\n    }\n  }\n  if (enableSearch) {\n    searchInput.change(() => {\n      Q.Debounce(searchDebounceId, debounceTime, () => {\n        currentPage = 1;\n        render();\n      });\n    });\n  }\n  table.on('click', evt => {\n    const th = evt.target.closest('th');\n    const tr = evt.target.closest('tr[data-idx]');\n    if (enableSort && th) {\n      const key = th.dataset.key;\n      if (sortKey === key) {\n        if (sortOrder === 'off') sortOrder = 'asc';\n        else if (sortOrder === 'asc') sortOrder = 'desc';\n        else { sortOrder = 'off'; sortKey = null; }\n      } else {\n        sortKey = key;\n        sortOrder = 'asc';\n      }\n      render();\n      document\n        .querySelectorAll(`.${Container.tableClasses.sort_active}`)\n        .forEach(el => el.classList.remove(Container.tableClasses.sort_active));\n      if (sortOrder != 'off') {\n        const arrowKey = sortOrder === 'asc' ? Container.tableClasses.asc : Container.tableClasses.desc;\n        const head = Q(`[data-key=\"${key}\"] .${Container.tableClasses[arrowKey]}`)\n        console.log('arrowKey', arrowKey);\n        head.addClass(Container.tableClasses.sort_active);\n      }\n    } else if (tr) {\n      const idx = +tr.dataset.idx;\n      wrapper.select(idx);\n    }\n  });\n  if (enablePage) {\n    pagination.on('click', evt => {\n      const tgt = evt.target;\n      if (tgt.dataset.page) currentPage = +tgt.dataset.page;\n      else if (tgt.dataset.action === 'first') currentPage = 1;\n      else if (tgt.dataset.action === 'prev') currentPage = Math.max(1, currentPage - 1);\n      else if (tgt.dataset.action === 'next') currentPage = Math.min(Math.ceil(filteredIndices.length / pageSizeVal), currentPage + 1);\n      else if (tgt.dataset.action === 'last') currentPage = Math.ceil(filteredIndices.length / pageSizeVal);\n      render();\n    });\n  }\n  wrapper.load = function (newData, stayOn = false) {\n    allData = [...newData];\n    if (!stayOn) { sortKey = null; sortOrder = 'off'; currentPage = 1; }\n    wrapper; render(); return this;\n  };\n  wrapper.select = function (idx, key, val) {\n    if (key != null) {\n      const found = allData.findIndex(o => o[key] === val);\n      if (found >= 0) idx = found;\n    }\n    selectedIdx = idx;\n    table.find('tr').removeClass(Container.tableClasses.selected);\n    table.find(`tr[data-idx=\"${idx}\"]`).addClass(Container.tableClasses.selected);\n    if (onChange) onChange(idx, allData[idx]);\n    return this;\n  };\n  wrapper.change = function (cb) { onChange = cb; return this; };\n  wrapper.index = function (idx) { return wrapper.select(idx); };\n  wrapper.clear = function () { allData = []; render(); return this; };\n  this.elements.push(wrapper);\n  render();\n  return wrapper;\n};"
        },
        "Container.Window": {
            "uuid": "5216c3c4-cd4f-4705-9061-3cb76b3388b2",
            "name": "Container.Window",
            "method": "Plugin",
            "desc": "Creates a draggable, resizable window container with title bar and control buttons",
            "type": "Method",
            "example": "var win = Q.Container().Window({ title: 'My Window', content: 'Hello World' }); win.Open();",
            "dependencies": [
                "style",
                "on",
                "off",
                "addClass",
                "removeClass",
                "append",
                "css",
                "attr",
                "html",
                "text",
                "width",
                "height",
                "data",
                "detach",
                "show",
                "hide",
                "css",
                "bind",
                "Icons"
            ],
            "script": "Container.prototype.Window = function(options = {}) {\n    const defaults = {\n        title: 'Window',\n        content: '',\n        resizable: true,\n        minimizable: true,\n        maximizable: true,\n        closable: true,\n        draggable: true,\n        x: 50,           // Kezdeti X poz\u00edci\u00f3 (sz\u00e1zal\u00e9kban a k\u00e9perny\u0151h\u00f6z k\u00e9pest)\n        y: 50,           // Kezdeti Y poz\u00edci\u00f3 (sz\u00e1zal\u00e9kban a k\u00e9perny\u0151h\u00f6z k\u00e9pest)\n        width: 400,      // Ablak sz\u00e9less\u00e9ge (px)\n        height: 300,     // Ablak magass\u00e1ga (px)\n        minWidth: 200,   // Minim\u00e1lis sz\u00e9less\u00e9g (px)\n        minHeight: 150,  // Minim\u00e1lis magass\u00e1g (px)\n        zIndex: 1000,    // Alap\u00e9rtelmezett z-index\n        minimizePosition: 'bottom-left', // Minimaliz\u00e1l\u00e1s poz\u00edci\u00f3ja (ha nem t\u00e1lc\u00e1ra megy)\n        minimizeContainer: null,         // Egyedi kont\u00e9ner minimaliz\u00e1l\u00e1shoz (ha kell)\n        minimizeOffset: 10,              // Minimaliz\u00e1lt ablak eltol\u00e1sa (px)\n        animate: 150,     // Anim\u00e1ci\u00f3 id\u0151tartama (ms)\n        shadow: true, // Drop shadow effect\n        shadowColor: 'rgba(0, 0, 0, 0.5)', // Shadow color\n        shadowBlur: 10, // Shadow blur radius\n        shadowOffsetX: 0, // Shadow offset X\n        shadowOffsetY: 5, // Shadow offset Y\n        shadowSpread: 0, // Shadow spread radius\n        blur: true, // Blur effect on titlebar to blur the background which is behind the window\n        blurInactive: true, // Blur effect when the window is inactive\n        blurRadius: 10, // Blur radius\n        blurGradientOpacity: 0.3, // 0.0 (transparent) ... 1.0 (fully opaque) for left side of gradient\n    };\n    if (!Container.windowClassesInitialized) {\n        Container.windowClasses = Q.style(`\n            --window-bg-color:rgb(37, 37, 37);\n            --window-shadow-color: rgba(0, 0, 0, 0.1);\n            --window-titlebar-bg:rgb(17, 17, 17);\n            --window-titlebar-text: #ffffff;\n            --window-button-bg:rgb(17, 17, 17);\n            --window-button-hover-bg: #777777;\n            --window-button-text: #ffffff;\n            --window-close-color: #e74c3c;\n            --window-titlebar-height: 28px; /* Add fixed titlebar height */\n        `, `\n            .window_container {\n                position: fixed; /* Change from absolute to fixed */\n                min-width: 200px;\n                border-radius: 4px;\n                display: flex;\n                flex-direction: column;\n                overflow: hidden;\n                z-index: 1000;\n                transition-property: opacity, transform, width, height, top, left;\n                transition-timing-function: ease-out;\n            }\n            .window_titlebar {\n                color: var(--window-titlebar-text);\n                background-color: var(--window-titlebar-bg);\n                font-size: 12px;\n                cursor: default;\n                user-select: none;\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n                box-sizing: border-box;\n                height: var(--window-titlebar-height); /* Fixed height for titlebar */\n            }\n            .window_title {\n                white-space: nowrap;\n                overflow: hidden;\n                text-overflow: ellipsis;\n                flex: 1;\n                margin: 0 10px;\n                text-shadow: 0px 1px 5px rgba(0, 0, 0, 1.0);\n            }\n            .window_controls {\n                display: flex;\n                height:100%;\n            }\n            .window_button {\n                background-color: var(--window-button-bg);\n                cursor: default;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                position: relative;\n                height: 100%;\n                width: 30px;\n            }\n            .window_button:hover {\n                background-color: var(--window-button-hover-bg);\n            }\n            .window_close:hover {\n                background-color: var(--window-close-color);\n            }\n            .window_content {\n                flex: 1;\n                overflow: auto;\n                padding: 10px;\n                position: relative;\n                background-color: var(--window-bg-color);\n                box-sizing: border-box;\n            }\n            .window_content:empty {\n            padding: 0;\n            }\n            .window_resize_handle {\n                position: absolute;\n                z-index: 1;\n            }\n            .window_resize_n {\n                top: 0;\n                left: 0;\n                right: 0;\n                height: 5px;\n                cursor: n-resize;\n            }\n            .window_resize_e {\n                top: 0;\n                right: 0;\n                bottom: 0;\n                width: 5px;\n                cursor: e-resize;\n            }\n            .window_resize_s {\n                bottom: 0;\n                left: 0;\n                right: 0;\n                height: 5px;\n                cursor: s-resize;\n            }\n            .window_resize_w {\n                top: 0;\n                left: 0;\n                bottom: 0;\n                width: 5px;\n                cursor: w-resize;\n            }\n            .window_resize_nw {\n                top: 0;\n                left: 0;\n                width: 10px;\n                height: 10px;\n                cursor: nw-resize;\n            }\n            .window_resize_ne {\n                top: 0;\n                right: 0;\n                width: 10px;\n                height: 10px;\n                cursor: ne-resize;\n            }\n            .window_resize_se {\n                bottom: 0;\n                right: 0;\n                width: 10px;\n                height: 10px;\n                cursor: se-resize;\n            }\n            .window_resize_sw {\n                bottom: 0;\n                left: 0;\n                width: 10px;\n                height: 10px;\n                cursor: sw-resize;\n            }\n            .window_minimized {\n                height: var(--window-titlebar-height) !important; /* Fixed to titlebar height */\n                width: auto !important;\n                min-width: 200px;\n                position: fixed !important;\n                bottom: 10px;\n                left: 10px;\n                overflow: hidden;\n            }\n            .window_minimized .window_content {\n                display: none !important; /* Biztos\u00edtjuk, hogy val\u00f3ban ne jelenjen meg */\n                height: 0 !important;\n            }\n            .window_minimized .window_resize_handle {\n                display: none;\n            }\n            .window_maximized {\n                top: 0 !important;\n                left: 0 !important;\n                width: 100% !important;\n                height: 100% !important;\n                border-radius: 0;\n                position: fixed !important;\n            }\n            .window_maximized .window_resize_handle {\n                display: none;\n            }\n            .window_button_icon {\n                width: 10px;\n                height: 10px;\n                color: var(--window-button-text);\n                pointer-events: none;\n            }\n            .window_taskbar_btn {\n                min-width: 100px;\n                max-width: 220px;\n                overflow: hidden;\n                text-overflow: ellipsis;\n                white-space: nowrap;\n                background: #222;\n                color: #fff;\n                border: 1px solid #444;\n                border-radius: 4px;\n                padding: 0 12px;\n                height: 28px;\n                display: flex;\n                align-items: center;\n                cursor: pointer;\n                font-size: 13px;\n                box-sizing: border-box;\n            }\n        `, null, {\n            'window_container': 'window_container',\n            'window_titlebar': 'window_titlebar',\n            'window_title': 'window_title',\n            'window_controls': 'window_controls',\n            'window_button': 'window_button',\n            'window_minimize': 'window_minimize',\n            'window_maximize': 'window_maximize',\n            'window_restore': 'window_restore',\n            'window_close': 'window_close',\n            'window_content': 'window_content',\n            'window_resize_handle': 'window_resize_handle',\n            'window_resize_n': 'window_resize_n',\n            'window_resize_e': 'window_resize_e',\n            'window_resize_s': 'window_resize_s',\n            'window_resize_w': 'window_resize_w',\n            'window_resize_nw': 'window_resize_nw',\n            'window_resize_ne': 'window_resize_ne',\n            'window_resize_se': 'window_resize_se',\n            'window_resize_sw': 'window_resize_sw',\n            'window_minimized': 'window_minimized',\n            'window_maximized': 'window_maximized',\n            'window_button_icon': 'window_button_icon',\n            'window_taskbar_btn': 'window_taskbar_btn'\n        },false);\n        Container.windowClassesInitialized = true;\n    }\n    if (!Container.taskbar) {\n        let taskbarStyle = {\n            position: 'fixed',\n            height: '32px',\n            zIndex: 1000,\n            display: 'flex',\n            alignItems: 'center',\n            maxWidth: '100vw',\n            minHeight: '0',\n            minWidth: '0'\n        };\n        switch (defaults.minimizePosition || 'bottom-left') {\n            case 'bottom-right':\n                taskbarStyle.right = defaults.minimizeOffset + 'px';\n                taskbarStyle.bottom = defaults.minimizeOffset + 'px';\n                break;\n            case 'top-left':\n                taskbarStyle.left = defaults.minimizeOffset + 'px';\n                taskbarStyle.top = defaults.minimizeOffset + 'px';\n                break;\n            case 'top-right':\n                taskbarStyle.right = defaults.minimizeOffset + 'px';\n                taskbarStyle.top = defaults.minimizeOffset + 'px';\n                break;\n            case 'bottom-left':\n            default:\n                taskbarStyle.left = defaults.minimizeOffset + 'px';\n                taskbarStyle.bottom = defaults.minimizeOffset + 'px';\n                break;\n        }\n        Container.taskbar = Q('<div>', { class: Container.windowClasses.window_taskbar || 'window_taskbar' }).css(taskbarStyle);\n        Q('body').append(Container.taskbar);\n    }\n    const settings = Object.assign({}, defaults, options);\n    const windowElement = Q('<div>', { class: Container.windowClasses.window_container });\n    if (settings.shadow) {\n        windowElement.css({\n            boxShadow: `${settings.shadowOffsetX}px ${settings.shadowOffsetY}px ${settings.shadowBlur}px ${settings.shadowSpread}px ${settings.shadowColor}`\n        });\n    } else {\n        windowElement.css({ boxShadow: 'none' });\n    }\n    const titlebar = Q('<div>', { class: Container.windowClasses.window_titlebar });\n    function setTitlebarBlurElement(titlebarElem, active, blurRadius, gradientOpacity, animateMs) {\n        if (!titlebarElem) return;\n        if (typeof animateMs === 'number' && animateMs > 0) {\n            titlebarElem.style.transition = `backdrop-filter ${animateMs}ms, -webkit-backdrop-filter ${animateMs}ms, background-image ${animateMs}ms`;\n        } else {\n            titlebarElem.style.transition = '';\n        }\n        if (active) {\n            titlebarElem.style.backdropFilter = `blur(${blurRadius}px)`;\n            titlebarElem.style.WebkitBackdropFilter = `blur(${blurRadius}px)`;\n            titlebarElem.style.backgroundColor = 'transparent';\n            const buttonBg = getComputedStyle(document.documentElement)\n                .getPropertyValue('--window-button-bg') || '#111';\n            const leftAlpha = Math.max(0, Math.min(1, gradientOpacity));\n            titlebarElem.style.backgroundImage =\n                `linear-gradient(to right, rgba(17,17,17,${leftAlpha}), ${buttonBg.trim()} 80%)`;\n        } else {\n            titlebarElem.style.backdropFilter = 'blur(0px)';\n            titlebarElem.style.WebkitBackdropFilter = 'blur(0px)';\n            titlebarElem.style.backgroundColor = '';\n            titlebarElem.style.backgroundImage = '';\n        }\n    }\n    function updateAllTitlebarBlur() {\n        const allWindows = document.querySelectorAll('.' + Container.windowClasses.window_container);\n        let maxZ = -Infinity, activeWindow = null;\n        allWindows.forEach(win => {\n            const z = parseInt(win.style.zIndex || window.getComputedStyle(win).zIndex, 10) || 0;\n            if (z > maxZ) {\n                maxZ = z;\n                activeWindow = win;\n            }\n        });\n        allWindows.forEach(win => {\n            const tb = win.querySelector('.' + Container.windowClasses.window_titlebar);\n            if (!tb) return;\n            if (settings.blurInactive) {\n                setTitlebarBlurElement(\n                    tb,\n                    win !== activeWindow,\n                    settings.blurRadius,\n                    settings.blurGradientOpacity,\n                    settings.animate\n                );\n            } else if (settings.blur) {\n                setTitlebarBlurElement(tb, true, settings.blurRadius, settings.blurGradientOpacity, 0);\n            } else {\n                setTitlebarBlurElement(tb, false, settings.blurRadius, settings.blurGradientOpacity, 0);\n            }\n        });\n    }\n    if (settings.blurInactive) {\n        setTimeout(updateAllTitlebarBlur, 0);\n        windowElement.on('mousedown', function () {\n            setTimeout(updateAllTitlebarBlur, 0);\n        });\n    } else if (settings.blur) {\n        setTitlebarBlurElement(titlebar.nodes[0], true, settings.blurRadius, settings.blurGradientOpacity, 0);\n    } else {\n        setTitlebarBlurElement(titlebar.nodes[0], false, settings.blurRadius, settings.blurGradientOpacity, 0);\n    }\n    const titleElement = Q('<div>', { class: Container.windowClasses.window_title }).text(settings.title);\n    const controls = Q('<div>', { class: Container.windowClasses.window_controls });\n    const contentContainer = Q('<div>', { class: Container.windowClasses.window_content });\n    if (settings.minimizable) {\n        const minimizeButton = Q('<div>', { \n            class: Container.windowClasses.window_button + ' ' + Container.windowClasses.window_minimize\n        });\n        minimizeButton.append(this.Icon('window-minimize').addClass(Container.windowClasses.window_button_icon));\n        controls.append(minimizeButton);\n    }\n    if (settings.maximizable) {\n        const maximizeButton = Q('<div>', { \n            class: Container.windowClasses.window_button + ' ' + Container.windowClasses.window_maximize\n        });\n        maximizeButton.append(this.Icon('window-full').addClass(Container.windowClasses.window_button_icon));\n        controls.append(maximizeButton);\n    }\n    if (settings.closable) {\n        const closeButton = Q('<div>', { \n            class: Container.windowClasses.window_button + ' ' + Container.windowClasses.window_close\n        });\n        closeButton.append(this.Icon('window-close').addClass(Container.windowClasses.window_button_icon));\n        controls.append(closeButton);\n    }\n    titlebar.append(titleElement, controls);\n    windowElement.append(titlebar, contentContainer);\n    if (settings.resizable) {\n        const resizeHandles = [\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_n, 'data-resize': 'n' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_e, 'data-resize': 'e' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_s, 'data-resize': 's' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_w, 'data-resize': 'w' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_nw, 'data-resize': 'nw' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_ne, 'data-resize': 'ne' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_se, 'data-resize': 'se' }),\n            Q('<div>', { class: Container.windowClasses.window_resize_handle + ' ' + Container.windowClasses.window_resize_sw, 'data-resize': 'sw' })\n        ];\n        for (let i = 0; i < resizeHandles.length; i++) {\n            windowElement.append(resizeHandles[i]);\n        }\n    }\n    if (settings.content) {\n        if (typeof settings.content === 'string') {\n            contentContainer.html(settings.content);\n        } else if (settings.content instanceof Element || settings.content instanceof Q) {\n            contentContainer.append(settings.content);\n        }\n    }\n    let isMinimized = false;\n    let isMaximized = false;\n    let previousState = {\n        width: settings.width,\n        height: settings.height,\n        x: 0,\n        y: 0\n    };\n    let isOpen = false;\n    let isAnimating = false;\n    let taskbarButton = null;\n    function setTransitionDuration(duration) {\n        if (!settings.animate) return;\n        windowElement.css('transition-duration', duration + 'ms');\n    }\n    function resetTransition() {\n        setTimeout(() => {\n            windowElement.css('transition-duration', '');\n            isAnimating = false;\n        }, settings.animate);\n    }\n    function calculateInitialPosition() {\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const windowWidth = settings.width;\n        const windowHeight = settings.height;\n        let left = (viewportWidth * settings.x / 100) - (windowWidth / 2);\n        let top = (viewportHeight * settings.y / 100) - (windowHeight / 2);\n        left = Math.max(0, Math.min(left, viewportWidth - windowWidth));\n        top = Math.max(0, Math.min(top, viewportHeight - windowHeight));\n        return { left, top };\n    }\n    function setInitialPositionAndSize() {\n        const position = calculateInitialPosition();\n        windowElement.css({\n            position: 'fixed', // Use fixed instead of absolute\n            width: settings.width + 'px',\n            height: settings.height + 'px',\n            left: position.left + 'px',\n            top: position.top + 'px',\n            zIndex: settings.zIndex\n        });\n        previousState.x = position.left;\n        previousState.y = position.top;\n    }\n    function bringToFront() {\n        const windowIndex = Container.openWindows.indexOf(windowElement.nodes[0]);\n        if (windowIndex !== -1) {\n            Container.openWindows.splice(windowIndex, 1);\n        }\n        Container.openWindows.push(windowElement.nodes[0]);\n        updateZIndices();\n        if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n    }\n    function updateZIndices() {\n        const baseZIndex = settings.zIndex;\n        for (let i = 0; i < Container.openWindows.length; i++) {\n            const windowNode = Container.openWindows[i];\n            windowNode.style.zIndex = baseZIndex + i;\n        }\n        Container.highestZIndex = baseZIndex + Container.openWindows.length - 1;\n    }\n    function setupDraggable() {\n        if (!settings.draggable) return;\n        let isDragging = false;\n        let startX, startY, startLeft, startTop;\n        function onMouseMove(e) {\n            if (!isDragging) return;\n            const dx = e.clientX - startX;\n            const dy = e.clientY - startY;\n            const newLeft = startLeft + dx;\n            const newTop = startTop + dy;\n            if (isMinimized) {\n                const viewportWidth = window.innerWidth;\n                const viewportHeight = window.innerHeight;\n                const minWidth = windowElement.width();\n                const minHeight = windowElement.height();\n                const constrainedLeft = Math.max(0, Math.min(newLeft, viewportWidth - minWidth));\n                const constrainedTop = Math.max(0, Math.min(newTop, viewportHeight - minHeight));\n                windowElement.css({\n                    left: constrainedLeft + 'px',\n                    top: constrainedTop + 'px',\n                    right: 'auto',\n                    bottom: 'auto'\n                });\n                return;\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            const windowWidth = windowElement.width();\n            const windowHeight = windowElement.height();\n            const constrainedLeft = Math.max(0, Math.min(newLeft, viewportWidth - windowWidth));\n            const constrainedTop = Math.max(0, Math.min(newTop, viewportHeight - windowHeight));\n            windowElement.css({\n                left: constrainedLeft + 'px',\n                top: constrainedTop + 'px',\n                right: 'auto',\n                bottom: 'auto'\n            });\n            previousState.x = constrainedLeft;\n            previousState.y = constrainedTop;\n        }\n        function onMouseUp() {\n            isDragging = false;\n            Q(document).off('mousemove', onMouseMove);\n            Q(document).off('mouseup', onMouseUp);\n        }\n        Q(titlebar).on('mousedown', function(e) {\n            if (isMaximized || isMinimized) return;\n            isDragging = true;\n            startX = e.clientX;\n            startY = e.clientY;\n            startLeft = parseInt(windowElement.css('left'), 10);\n            startTop = parseInt(windowElement.css('top'), 10);\n            bringToFront();\n            Q(document).on('mousemove', onMouseMove);\n            Q(document).on('mouseup', onMouseUp);\n            e.preventDefault();\n        });\n        Q(titlebar).on('dblclick', function(e) {\n            if (settings.maximizable) {\n                toggleMaximize();\n            }\n        });\n    }\n    function setupResizable() {\n        if (!settings.resizable) return;\n        let isResizing = false;\n        let resizeDirection = '';\n        let startX, startY, startWidth, startHeight, startLeft, startTop;\n        const resizeHandles = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_resize_handle);\n        function onMouseMove(e) {\n            if (!isResizing) return;\n            const dx = e.clientX - startX;\n            const dy = e.clientY - startY;\n            let newWidth = startWidth;\n            let newHeight = startHeight;\n            let newLeft = startLeft;\n            let newTop = startTop;\n            if (resizeDirection.includes('e')) {\n                newWidth = startWidth + dx;\n            }\n            if (resizeDirection.includes('s')) {\n                newHeight = startHeight + dy;\n            }\n            if (resizeDirection.includes('w')) {\n                newWidth = startWidth - dx;\n                newLeft = startLeft + dx;\n            }\n            if (resizeDirection.includes('n')) {\n                newHeight = startHeight - dy;\n                newTop = startTop + dy;\n            }\n            if (newWidth < settings.minWidth) {\n                if (resizeDirection.includes('w')) {\n                    newLeft = startLeft + startWidth - settings.minWidth;\n                }\n                newWidth = settings.minWidth;\n            }\n            if (newHeight < settings.minHeight) {\n                if (resizeDirection.includes('n')) {\n                    newTop = startTop + startHeight - settings.minHeight;\n                }\n                newHeight = settings.minHeight;\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            if (newLeft + newWidth > viewportWidth) {\n                if (resizeDirection.includes('e')) {\n                    newWidth = viewportWidth - newLeft;\n                }\n            }\n            if (newTop + newHeight > viewportHeight) {\n                if (resizeDirection.includes('s')) {\n                    newHeight = viewportHeight - newTop;\n                }\n            }\n            if (newLeft < 0) {\n                if (resizeDirection.includes('w')) {\n                    const adjustment = -newLeft;\n                    newLeft = 0;\n                    newWidth -= adjustment;\n                }\n            }\n            if (newTop < 0) {\n                if (resizeDirection.includes('n')) {\n                    const adjustment = -newTop;\n                    newTop = 0;\n                    newHeight -= adjustment;\n                }\n            }\n            windowElement.css({\n                width: newWidth + 'px',\n                height: newHeight + 'px',\n                left: newLeft + 'px',\n                top: newTop + 'px'\n            });\n            previousState.width = newWidth;\n            previousState.height = newHeight;\n            previousState.x = newLeft;\n            previousState.y = newTop;\n        }\n        function onMouseUp() {\n            isResizing = false;\n            Q(document).off('mousemove', onMouseMove);\n            Q(document).off('mouseup', onMouseUp);\n        }\n        for (let i = 0; i < resizeHandles.length; i++) {\n            const handle = resizeHandles[i];\n            Q(handle).on('mousedown', function(e) {\n                if (isMaximized || isMinimized) return;\n                isResizing = true;\n                resizeDirection = this.getAttribute('data-resize');\n                startX = e.clientX;\n                startY = e.clientY;\n                startWidth = windowElement.width();\n                startHeight = windowElement.height();\n                startLeft = parseInt(windowElement.css('left'), 10);\n                startTop = parseInt(windowElement.css('top'), 10);\n                windowElement.css('zIndex', settings.zIndex + 10);\n                Q(document).on('mousemove', onMouseMove);\n                Q(document).on('mouseup', onMouseUp);\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n    }\n    function setupControls() {\n        const minimizeButtons = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_minimize);\n        if (minimizeButtons.length) {\n            for (let i = 0; i < minimizeButtons.length; i++) {\n                Q(minimizeButtons[i]).on('click', function() {\n                    bringToFront(); \n                    toggleMinimize();\n                });\n            }\n        }\n        const maximizeButtons = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_maximize);\n        if (maximizeButtons.length) {\n            for (let i = 0; i < maximizeButtons.length; i++) {\n                Q(maximizeButtons[i]).on('click', function() {\n                    bringToFront(); \n                    toggleMaximize();\n                });\n            }\n        }\n        const closeButtons = windowElement.nodes[0].querySelectorAll('.' + Container.windowClasses.window_close);\n        if (closeButtons.length) {\n            for (let i = 0; i < closeButtons.length; i++) {\n                Q(closeButtons[i]).on('click', function() {\n                    closeWindow();\n                });\n            }\n        }\n        Q(contentContainer).on('mousedown', function() {\n            bringToFront();\n        });\n    }\n    if (!Container.highestZIndex) {\n        Container.highestZIndex = settings.zIndex;\n        Container.openWindows = [];\n    }\n    function toggleMinimize() {\n        if (isAnimating) return;\n        isAnimating = true;\n        if (!isMinimized) {\n            const rect = windowElement.nodes[0].getBoundingClientRect();\n            const start = {\n                width: rect.width,\n                height: rect.height,\n                left: rect.left,\n                top: rect.top,\n                opacity: 1\n            };\n            let taskbarRect = { left: 0, top: window.innerHeight, width: 160, height: 28 };\n            if (Container.taskbar && taskbarButton) {\n                const btnRect = taskbarButton.nodes[0].getBoundingClientRect();\n                taskbarRect = {\n                    left: btnRect.left,\n                    top: btnRect.top,\n                    width: btnRect.width,\n                    height: btnRect.height\n                };\n            } else if (Container.taskbar) {\n                const barRect = Container.taskbar.nodes[0].getBoundingClientRect();\n                taskbarRect.left = barRect.left;\n                taskbarRect.top = barRect.top;\n            }\n            windowElement.css({\n                willChange: 'width,height,left,top,opacity',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`\n            });\n            windowElement.css({\n                width: start.width + 'px',\n                height: start.height + 'px',\n                left: start.left + 'px',\n                top: start.top + 'px',\n                opacity: 1\n            });\n            setTimeout(() => {\n                windowElement.css({\n                    width: taskbarRect.width + 'px',\n                    height: taskbarRect.height + 'px',\n                    left: taskbarRect.left + 'px',\n                    top: taskbarRect.top + 'px',\n                    opacity: 0.2\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                if (!taskbarButton) {\n                    let shortTitle = settings.title;\n                    if (shortTitle.length > 18) {\n                        shortTitle = shortTitle.slice(0, 15) + '...';\n                    }\n                    taskbarButton = Q('<div>', { class: Container.windowClasses.window_taskbar_btn, text: shortTitle });\n                    taskbarButton.on('click', function() {\n                        toggleMinimize();\n                    });\n                    if (settings.minimizePosition === 'bottom-left' || settings.minimizePosition === 'top-left') {\n                        Q(Container.taskbar).prepend(taskbarButton);\n                    } else {\n                        Q(Container.taskbar).append(taskbarButton);\n                    }\n                }\n                windowElement.detach();\n                isMinimized = true;\n                isAnimating = false;\n            }, settings.animate + 10);\n        } else {\n            Q('body').append(windowElement);\n            let btnRect = { left: 0, top: window.innerHeight, width: 160, height: 28 };\n            if (taskbarButton) {\n                const rect = taskbarButton.nodes[0].getBoundingClientRect();\n                btnRect = {\n                    left: rect.left,\n                    top: rect.top,\n                    width: rect.width,\n                    height: rect.height\n                };\n            }\n            const end = {\n                width: previousState.width,\n                height: previousState.height,\n                left: previousState.x,\n                top: previousState.y,\n                opacity: 1\n            };\n            windowElement.css({\n                willChange: 'width,height,left,top,opacity',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`,\n                width: btnRect.width + 'px',\n                height: btnRect.height + 'px',\n                left: btnRect.left + 'px',\n                top: btnRect.top + 'px',\n                opacity: 0.2,\n                display: ''\n            });\n            setTimeout(() => {\n                windowElement.css({\n                    width: end.width + 'px',\n                    height: end.height + 'px',\n                    left: end.left + 'px',\n                    top: end.top + 'px',\n                    opacity: 1\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                if (taskbarButton) {\n                    taskbarButton.remove();\n                    taskbarButton = null;\n                }\n                isMinimized = false;\n                bringToFront();\n                isAnimating = false;\n            }, settings.animate + 10);\n        }\n    }\n    function toggleMaximize() {\n        if (isAnimating) return;\n        isAnimating = true;\n        if (!isMaximized) {\n            const rect = windowElement.nodes[0].getBoundingClientRect();\n            const start = {\n                width: rect.width,\n                height: rect.height,\n                left: rect.left,\n                top: rect.top\n            };\n            windowElement.css({\n                willChange: 'width,height,left,top',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`,\n                width: start.width + 'px',\n                height: start.height + 'px',\n                left: start.left + 'px',\n                top: start.top + 'px'\n            });\n            setTimeout(() => {\n                windowElement.addClass(Container.windowClasses.window_maximized);\n                windowElement.css({\n                    left: 0,\n                    top: 0,\n                    width: '100vw',\n                    height: '100vh',\n                    borderRadius: 0\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                isMaximized = true;\n                previousState.width = start.width;\n                previousState.height = start.height;\n                previousState.x = start.left;\n                previousState.y = start.top;\n                isAnimating = false;\n            }, settings.animate + 10);\n        } else {\n            const end = {\n                width: previousState.width,\n                height: previousState.height,\n                left: previousState.x,\n                top: previousState.y\n            };\n            windowElement.removeClass(Container.windowClasses.window_maximized);\n            windowElement.css({\n                willChange: 'width,height,left,top',\n                transition: `all ${settings.animate}ms cubic-bezier(.4,0,.2,1)`,\n                width: '100vw',\n                height: '100vh',\n                left: 0,\n                top: 0,\n                borderRadius: '0'\n            });\n            setTimeout(() => {\n                windowElement.css({\n                    width: end.width + 'px',\n                    height: end.height + 'px',\n                    left: end.left + 'px',\n                    top: end.top + 'px',\n                    borderRadius: '4px'\n                });\n            }, 10);\n            setTimeout(() => {\n                windowElement.css({ transition: '', willChange: '' });\n                isMaximized = false;\n                isAnimating = false;\n            }, settings.animate + 10);\n        }\n    }\n    function closeWindow() {\n        if (isAnimating) return;\n        if (taskbarButton) {\n            taskbarButton.remove();\n            taskbarButton = null;\n        }\n        const savedContent = windowElement.data('detached-content');\n        if (savedContent) {\n            windowElement.removeData('detached-content');\n        }\n        if (settings.animate) {\n            isAnimating = true;\n            setTransitionDuration(settings.animate);\n            windowElement.css({\n                opacity: '0',\n                transform: 'scale(0.90)'\n            });\n            setTimeout(() => {\n                if (windowElement.nodes[0]._resizeHandler) {\n                    window.removeEventListener('resize', windowElement.nodes[0]._resizeHandler);\n                    windowElement.nodes[0]._resizeHandler = null;\n                }\n                const windowIndex = Container.openWindows.indexOf(windowElement.nodes[0]);\n                if (windowIndex !== -1) {\n                    Container.openWindows.splice(windowIndex, 1);\n                    updateZIndices();\n                }\n                windowElement.remove();\n                isOpen = false;\n            }, settings.animate);\n        } else {\n            if (windowElement.nodes[0]._resizeHandler) {\n                window.removeEventListener('resize', windowElement.nodes[0]._resizeHandler);\n                windowElement.nodes[0]._resizeHandler = null;\n            }\n            const windowIndex = Container.openWindows.indexOf(windowElement.nodes[0]);\n            if (windowIndex !== -1) {\n                Container.openWindows.splice(windowIndex, 1);\n                updateZIndices();\n            }\n            windowElement.remove();\n            isOpen = false;\n        }\n        setTimeout(function() {\n            const selector = '.' + (Container.windowClasses.window_container || 'window_container');\n            if (!Q(selector).nodes.length) {\n                if (Container.taskbar) {\n                    Q(Container.taskbar).remove();\n                    Container.taskbar = null;\n                }\n            }\n        }, 0);\n        if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n    }\n    function handleWindowResize() {\n        if (isMaximized) {\n            return;\n        }\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const currentWidth = windowElement.width();\n        const currentHeight = windowElement.height();\n        let currentLeft = parseInt(windowElement.css('left'), 10);\n        let currentTop = parseInt(windowElement.css('top'), 10);\n        let needsUpdate = false;\n        if (currentWidth > viewportWidth) {\n            windowElement.css('width', viewportWidth + 'px');\n            previousState.width = viewportWidth;\n            needsUpdate = true;\n        }\n        if (currentHeight > viewportHeight) {\n            windowElement.css('height', viewportHeight + 'px');\n            previousState.height = viewportHeight;\n            needsUpdate = true;\n        }\n        if (currentLeft + currentWidth > viewportWidth) {\n            currentLeft = Math.max(0, viewportWidth - currentWidth);\n            needsUpdate = true;\n        }\n        if (currentTop + currentHeight > viewportHeight) {\n            currentTop = Math.max(0, viewportHeight - currentHeight);\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            windowElement.css({\n                left: currentLeft + 'px',\n                top: currentTop + 'px'\n            });\n            previousState.x = currentLeft;\n            previousState.y = currentTop;\n        }\n    }\n    function setupWindowResizeHandler() {\n        function resizeHandler() {\n            handleWindowResize();\n        }\n        windowElement.nodes[0]._resizeHandler = resizeHandler;\n        window.addEventListener('resize', resizeHandler);\n    }\n    const windowAPI = {\n        Open: function() {\n            if (!isOpen) {\n                Q('body').append(windowElement);\n                setInitialPositionAndSize(); // This now uses fixed positioning\n                if (settings.animate) {\n                    windowElement.css({\n                        opacity: '0',\n                        transform: 'scale(0.90)'\n                    });\n                    void windowElement.nodes[0].offsetWidth;\n                    isAnimating = true;\n                    setTransitionDuration(settings.animate);\n                    windowElement.css({\n                        opacity: '1',\n                        transform: 'scale(1)'\n                    });\n                    resetTransition();\n                }\n                setupDraggable();\n                setupResizable();\n                setupControls();\n                setupWindowResizeHandler();\n                isOpen = true;\n                bringToFront();\n                if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n            } else {\n                windowElement.show();\n                bringToFront();\n            }\n            return this;\n        },\n        Close: function() {\n            closeWindow();\n            if (settings.blurInactive) setTimeout(updateAllTitlebarBlur, 0);\n            return this;\n        },\n        Content: function(content) {\n            if (content === undefined) {\n                return contentContainer.html();\n            }\n            contentContainer.empty();\n            if (typeof content === 'string') {\n                contentContainer.html(content);\n            } else if (content instanceof Element || content instanceof Q) {\n                contentContainer.append(content);\n            }\n            return this;\n        },\n        Title: function(title) {\n            if (title === undefined) {\n                return titleElement.text();\n            }\n            titleElement.text(title);\n            return this;\n        },\n        Position: function(x, y) {\n            if (x === undefined || y === undefined) {\n                return {\n                    x: parseInt(windowElement.css('left'), 10),\n                    y: parseInt(windowElement.css('top'), 10)\n                };\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            const windowWidth = windowElement.width();\n            const windowHeight = windowElement.height();\n            let left = typeof x === 'string' && x.endsWith('%') \n                ? (viewportWidth * parseInt(x, 10) / 100) - (windowWidth / 2)\n                : x;\n            let top = typeof y === 'string' && y.endsWith('%')\n                ? (viewportHeight * parseInt(y, 10) / 100) - (windowHeight / 2)\n                : y;\n            left = Math.max(0, Math.min(left, viewportWidth - windowWidth));\n            top = Math.max(0, Math.min(top, viewportHeight - windowHeight));\n            windowElement.css({\n                left: left + 'px',\n                top: top + 'px'\n            });\n            previousState.x = left;\n            previousState.y = top;\n            return this;\n        },\n        Size: function(width, height) {\n            if (width === undefined || height === undefined) {\n                return {\n                    width: windowElement.width(),\n                    height: windowElement.height()\n                };\n            }\n            const viewportWidth = window.innerWidth;\n            const viewportHeight = window.innerHeight;\n            let currentLeft = parseInt(windowElement.css('left'), 10);\n            let currentTop = parseInt(windowElement.css('top'), 10);\n            width = Math.max(settings.minWidth, width);\n            height = Math.max(settings.minHeight, height);\n            if (currentLeft + width > viewportWidth) {\n                currentLeft = Math.max(0, viewportWidth - width);\n                windowElement.css('left', currentLeft + 'px');\n                previousState.x = currentLeft;\n            }\n            if (currentTop + height > viewportHeight) {\n                currentTop = Math.max(0, viewportHeight - height);\n                windowElement.css('top', currentTop + 'px');\n                previousState.y = currentTop;\n            }\n            windowElement.css({\n                width: width + 'px',\n                height: height + 'px'\n            });\n            previousState.width = width;\n            previousState.height = height;\n            return this;\n        },\n        Minimize: function() {\n            if (!isMinimized) {\n                toggleMinimize();\n            }\n            return this;\n        },\n        Maximize: function() {\n            if (!isMaximized) {\n                toggleMaximize();\n            }\n            return this;\n        },\n        Restore: function() {\n            if (isMinimized) {\n                toggleMinimize();\n            } else if (isMaximized) {\n                toggleMaximize();\n            }\n            return this;\n        },\n        IsMinimized: function() {\n            return isMinimized;\n        },\n        IsMaximized: function() {\n            return isMaximized;\n        },\n        IsOpen: function() {\n            return isOpen;\n        },\n        Element: function() {\n            return windowElement;\n        },\n        BringToFront: function() {\n            bringToFront();\n            return this;\n        },\n        MinimizePosition: function(position, container, offset) {\n            if (position === undefined) {\n                return {\n                    position: settings.minimizePosition,\n                    container: settings.minimizeContainer,\n                    offset: settings.minimizeOffset\n                };\n            }\n            if (position) {\n                settings.minimizePosition = position;\n            }\n            if (container !== undefined) {\n                settings.minimizeContainer = container;\n            }\n            if (offset !== undefined) {\n                settings.minimizeOffset = offset;\n            }\n            if (isMinimized) {\n                toggleMinimize();\n                toggleMinimize();\n            }\n            return this;\n        },\n        Animation: function(duration) {\n            if (duration === undefined) {\n                return settings.animate;\n            }\n            settings.animate = parseInt(duration) || 0;\n            return this;\n        }\n    };\n    this.elements.push(windowAPI);\n    return windowAPI;\n};"
        },
        "Cookie": {
            "uuid": "1cebe2ca-6e23-4b2a-928a-8e4a3bbb4996",
            "name": "Cookie",
            "method": "Static",
            "desc": "A utility function to set, get, and delete cookies.",
            "type": "Utility",
            "example": [
                "// Set a cookie named 'myCookie' with the value 'myValue' that expires in 7 days\nQ.Cookie('myCookie', 'myValue', { days: 7 });",
                "// Get the value of the cookie named 'myCookie'\nlet cookieValue = Q.Cookie('myCookie');\nconsole.log(cookieValue); // Output: myValue",
                "// Delete the cookie named 'myCookie'\nQ.Cookie('myCookie', null);"
            ],
            "dependencies": [],
            "script": "Q.Cookie = function (cookieKey, cookieValue, cookieOptions = {}) {\n    const buildOptions = (options) => {\n      let optionsStr = '';\n      if (options.days) optionsStr += `expires=${new Date(Date.now() + options.days * 86400000).toUTCString()}; `;\n      if (options.path) optionsStr += `path=${options.path}; `;\n      if (options.domain) optionsStr += `domain=${options.domain}; `;\n      if (options.secure) optionsStr += 'secure; ';\n      return optionsStr;\n    };\n    if (arguments.length > 1) {\n      if (cookieValue === null || cookieValue === '') {\n        cookieValue = '';\n        cookieOptions = { ...cookieOptions, days: -1 };\n      }\n      return document.cookie = `${cookieKey}=${cookieValue}; ${buildOptions(cookieOptions)}`;\n    }\n    const allCookies = document.cookie.split('; ');\n    for (let i = 0, len = allCookies.length; i < len; i++) {\n      const currentCookie = allCookies[i];\n      const indexEqual = currentCookie.indexOf('=');\n      if (indexEqual > -1 && currentCookie.slice(0, indexEqual).trim() === cookieKey) {\n        return currentCookie.slice(indexEqual + 1);\n      }\n    }\n    return undefined;\n  };"
        },
        "Fetch": {
            "uuid": "f1129f46-5a59-4c2a-a9ed-50160259ccc8",
            "name": "Fetch",
            "method": "Static",
            "desc": "A utility function to make HTTP requests using the Fetch API with extended features.",
            "type": "Utility",
            "example": [
                "// Make a GET request\nQ.Fetch('https://example.com/data', (error, data) => {\n  if (error) {\n    console.error('Error:', error);\n  } else {\n    console.log('Data:', data);\n  }\n});",
                "// Make a POST request with a JSON body\nQ.Fetch('https://example.com/submit', (error, data) => {\n  if (error) {\n    console.error('Error:', error);\n  } else {\n    console.log('Data:', data);\n  }\n}, {\n  method: 'POST',\n  body: { name: 'John', age: 30 }\n});",
                "// Make a request with query parameters\nQ.Fetch('https://example.com/search', (error, data) => {\n  if (error) {\n    console.error('Error:', error);\n  } else {\n    console.log('Data:', data);\n  }\n}, {\n  query: { q: 'keyword', page: 1 }\n});",
                "// Abort a request\nlet fetchRequest = Q.Fetch('https://example.com/long-running-task', (error, data) => {\n  // ...\n});\nsetTimeout(() => {\n  fetchRequest.abort();\n}, 5000);"
            ],
            "dependencies": [],
            "script": "Q.Fetch = function (url, callback, options = {}) {\n    const {\n        method = 'GET',\n        headers = {},\n        body,\n        contentType = 'application/json',\n        responseType = 'json',\n        credentials = 'same-origin',\n        retries = 3,\n        retryDelay = 1000,\n        exponentialBackoff = false,\n        timeout = 0,\n        validateResponse = (data) => data,\n        query = null,\n        signal: externalSignal = null\n    } = options;\n    if (query && typeof query === 'object') {\n        const urlObject = new URL(url, location.origin);\n        Object.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value));\n        url = urlObject.toString();\n    }\n    let requestBody = body;\n    if (body && typeof body === 'object' && contentType === 'application/json' && !(body instanceof FormData)) {\n        try { requestBody = JSON.stringify(body); } catch (error) { callback(new Error('Failed to serialize request body'), null); return; }\n    }\n    headers['Content-Type'] = headers['Content-Type'] || contentType;\n    const controller = new AbortController();\n    const { signal } = controller;\n    if (externalSignal) {\n        externalSignal.addEventListener('abort', () => controller.abort(), { once: true });\n    }\n    const doFetch = (attempt) => {\n        let timeoutId = null;\n        if (timeout) { timeoutId = setTimeout(() => controller.abort(), timeout); }\n        fetch(url, { method, headers, body: requestBody, credentials, signal })\n            .then(response => {\n                if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);\n                switch (responseType) {\n                    case 'json': return response.json();\n                    case 'text': return response.text();\n                    case 'blob': return response.blob();\n                    case 'arrayBuffer': return response.arrayBuffer();\n                    default: throw new Error('Unsupported response type');\n                }\n            })\n            .then(result => {\n                if (timeoutId) clearTimeout(timeoutId);\n                return validateResponse(result);\n            })\n            .then(validatedData => callback(null, validatedData))\n            .catch(error => {\n                if (timeoutId) clearTimeout(timeoutId);\n                if (error.name === 'AbortError') {\n                    callback(new Error('Fetch request was aborted'), null);\n                } else if (attempt < retries) {\n                    const delay = exponentialBackoff ? retryDelay * (2 ** attempt) : retryDelay;\n                    setTimeout(() => doFetch(attempt + 1), delay);\n                } else {\n                    callback(error, null);\n                }\n            });\n    };\n    doFetch(0);\n    return { abort: () => controller.abort() };\n};"
        },
        "Form.Button": {
            "uuid": "64179ce7-b5a4-4cf3-be3a-b9a2e0cdecdf",
            "name": "Form.Button",
            "method": "Component",
            "desc": "Button component for Form plugin",
            "type": "Component",
            "example": "var button = Q.Form.Button('Click me'); button.click(function() { alert('Clicked!'); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "text",
                "click"
            ],
            "script": "Form.prototype.Button = function(text = '') {\n    if (!Form.buttonClassesInitialized) {\n        Form.buttonClasses = Q.style(null, `\n            .button {\n                user-select: none;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n                border-radius: var(--form-default-border-radius);\n                padding: var(--form-default-padding);\n            }\n            .button:hover {\n                background-color: var(--form-default-background-hover);\n                color: var(--form-default-text-color-hover);\n            }\n            .button:active {\n                background-color: var(--form-default-background-active);\n                color: var(--form-default-text-color-active);\n            }\n            .button_disabled {\n                opacity: 0.6;\n                cursor: not-allowed;\n            }\n        `, null, {\n            'button_disabled': 'button_disabled',\n            'button': 'button'\n        });\n        Form.buttonClassesInitialized = true;\n    }\n    const button = Q(`<div class=\"${Form.buttonClasses.button}\">${text}</div>`);\n    button.click = function(callback) {\n        button.on('click', callback);\n        return button;\n    };\n    button.disabled = function(state) {\n        if (state) {\n            button.addClass(Form.buttonClasses.button_disabled);\n        } else {\n            button.removeClass(Form.buttonClasses.button_disabled);\n        }\n        return button;\n    };\n    button.setText = function(newText) {\n        button.text(newText);\n        return button;\n    };\n    button.remove = function() {\n        button.remove();\n        return button;\n    };\n    this.elements.push(button);\n    this.FX_Ripple(button);\n    return button;\n};"
        },
        "Form.CheckBox": {
            "uuid": "d0755f1a-d180-4ae0-a9b6-81af1345a8dd",
            "name": "Form.CheckBox",
            "method": "Component",
            "desc": "CheckBox component for Form plugin",
            "type": "Component",
            "example": "var checkbox = Q.Form.CheckBox(true, 'Check me'); checkbox.change(function(checked) { console.log(checked); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "prop",
                "trigger",
                "text"
            ],
            "script": "Form.prototype.CheckBox = function(checked = false, text = '') {\n    if (!Form.checkBoxClassesInitialized) {\n        Form.checkBoxClasses = Q.style('', `\n            .form_checkbox {\n                display: flex;\n                width: fit-content;\n                align-items: center;\n            }\n            .form_checkbox .form_label:empty {\n                display: none;\n            }\n            .form_checkbox .form_label {\n                padding-left: 5px;\n                user-select: none;\n            }\n            .form_checkbox_element {\n                position: relative;\n                width: 20px;\n                height: 20px;\n                background-color: var(--form-default-background);\n                border-radius: var(--form-default-border-radius);\n                cursor: pointer;\n            }\n            .form_checkbox_element.checked:before {\n                content: \"\";\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background-color: var(--form-default-accent-color);\n                border-radius: var(--form-default-border-radius);\n            }\n            .form_label {\n                padding-left: 5px;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n            .form_checkbox_element.disabled {\n                opacity: 0.5;\n                pointer-events: none;\n            }\n        `, null, {\n            'form_checkbox': 'form_checkbox',\n            'form_checkbox_element': 'form_checkbox_element',\n            'form_label': 'form_label',\n            'disabled': 'disabled',\n            'checked': 'checked'\n        });\n        Form.checkBoxClassesInitialized = true;\n    }\n    let ID = '_' + Q.ID();\n    const container = Q('<div class=\"' + Form.checkBoxClasses.form_checkbox + '\">');\n    const checkbox_container = Q('<div class=\"' + Form.checkBoxClasses.form_checkbox_element + '\">');\n    const labeltext = Q('<div class=\"' + Form.checkBoxClasses.form_label + '\">' + text + '</div>');\n    if (checked) {\n        checkbox_container.addClass(Form.checkBoxClasses['checked']);\n    }\n    checkbox_container.on('click', function(){\n        if (!checkbox_container.hasClass(Form.checkBoxClasses['disabled'])) {\n            const newState = !checkbox_container.hasClass(Form.checkBoxClasses['checked']);\n            checkbox_container.toggleClass(Form.checkBoxClasses['checked'], newState);\n            if (container._changeCallback) {\n                container._changeCallback(newState);\n            }\n        }\n    });\n    container.append(checkbox_container, labeltext);\n    container.checked = function(state) {\n        checkbox_container.toggleClass(Form.checkBoxClasses['checked'], state);\n        if (state && container._changeCallback) {\n            container._changeCallback(state);\n        }\n    };\n    container.change = function(callback) {\n        container._changeCallback = callback;\n    };\n    container.disabled = function(state) {\n        if (state) {\n            checkbox_container.addClass(Form.checkBoxClasses['disabled']);\n            container.addClass(Form.classes.form_disabled);\n        } else {\n            checkbox_container.removeClass(Form.checkBoxClasses['disabled']);\n            container.removeClass(Form.classes.form_disabled);\n        }\n    };\n    container.text = function(newText) {\n        labeltext.text(newText);\n    };\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form.ColorPicker": {
            "uuid": "fef0fb00-bdcc-4a04-9d65-7b48339e0638",
            "name": "Form.ColorPicker",
            "method": "Component",
            "desc": "Photoshop-like Color Picker component for Form plugin. Renders a canvas with an outer detail (24\u2013color) ring, a full\u2013rainbow middle ring, and an inner triangle for selecting saturation and brightness by mixing the selected hue with white and black.",
            "type": "Component",
            "example": [
                "// Basic usage",
                "var cp = Q.Form.ColorPicker();",
                "",
                "// With custom dimensions and callback",
                "var cp = Q.Form.ColorPicker({ width: 300, height: 350 });",
                "cp.change(function(color) { console.log('Selected color:', color); });",
                "",
                "// Setting a color programmatically",
                "cp.val('#FF0000'); // Set to red",
                "cp.val('rgb(0, 255, 0)'); // Set to green",
                "",
                "// Getting the current color value",
                "var currentColor = cp.val();",
                "",
                "// Adding to a container element",
                "Q('#color-picker-container').append(cp);",
                "",
                "// Using with a preview element",
                "var preview = Q('<div>').css({ width: '50px', height: '50px', border: '1px solid #999' });",
                "cp.change(function(color) { preview.css('background-color', color); });"
            ],
            "dependencies": [
                "Form",
                "canvas",
                "on",
                "attr",
                "val",
                "Debounce"
            ],
            "script": "Form.prototype.ColorPicker = function (options = {}) {\n    if (!Form.ColorPickerClassesInitialized) {\n        Form.colorPickerClasses = Q.style('', `\n            .q_form_color_picker_wrapper {\n                display: flex;\n                width: 100%;\n                height: 100%;\n                align-items: stretch;\n                justify-content: space-between;\n            }\n            .left_wrapper {\n                flex: 1;\n                width: 100%;\n                height: 100%;\n                display: flex;\n            }\n            .right_wrapper {\n                display: flex;\n                flex-direction: column;\n                flex: 1;\n                padding: 5px;\n            }\n            .section_snatches, .section_second, .section_third, .section_fourth {\n                flex: 1;\n                display: flex;\n                flex-direction: column;\n            }\n            .sections {\n                display: grid;\n                grid-template-columns: repeat(2, 1fr);\n                gap: 2px;\n                flex: 1;\n            }\n            .color_picker_input {\n                background-color: var(--form-default-background);\n                border-radius: var(--form-default-border-radius);\n                padding: 2px;\n                margin: 2px;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                outline: var(--form-default-outline);\n                border: 0;\n                width: 45px;\n                text-align: center;\n            }\n            .input_rgb888, .input_rgb565, .input_hsl\n            {\n            width: 100%;\n            }\n            .color_picker_input:focus {\n                outline: none;\n                background-color: var(--form-default-background-focus);\n                outline: var(--form-default-outline-focus);\n            }\n            /* Hide spinner buttons for number inputs */\n            .color_picker_input[type=\"number\"]::-webkit-inner-spin-button,\n            .color_picker_input[type=\"number\"]::-webkit-outer-spin-button {\n                -webkit-appearance: none;\n                margin: 0;\n            }\n            /* Firefox */\n            .color_picker_input[type=\"number\"] {\n                -moz-appearance: textfield;\n            }\n            .input_wrapper {\n                display: flex;\n                align-items: center;\n            }\n            .half_snatch {\n                height: 50%;\n                width: 100%;\n        }\n        .picker_blocks {\n        background: rgba(0, 0, 0, 0.1);\n        border-radius: var(--form-default-border-radius);\n        padding: 5px;\n        margin: 2px;\n        }\n            .input_snatches {\n            width:40px;\n            height:40px;\n            border-radius: 10px;\n            background-color: var(--form-default-background);\n            color: var(--form-default-text-color);\n            font-family: var(--form-default-font-family);\n            font-size: var(--form-default-font-size);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .snatches_wrapper {\n    display: grid;\n    grid-template-columns: repeat(6, 1fr);\n    justify-items: center;\n        }\n        .input_snatch_wrapper {\n            display: flex;\n            flex-direction: column;\n            width: 40px;\n            height: 40px;\n            border-radius: 10px;\n            overflow: hidden;\n        }\n            .input_prefix {\n            user-select: none;\n                width: 20px;\n                font-size: var(--form-default-font-size);\n                color: var(--form-default-text-color);\n                display:block;\n            }\n            .input_suffix {\n            user-select: none;\n                margin-left: 5px;\n                font-size: var(--form-default-font-size);\n                color: var(--form-default-text-color);\n                display:block;\n            }\n            .block_header {\n            user-select: none;\n                font-weight: bold;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                text-align: center;\n                grid-column: 1 / -1;\n            }\n            .snatches_add {\n            cursor: pointer;\n            user-select: none;\n            }\n            `, null, {\n            'sections': 'sections',\n            'q_form_color_picker_wrapper': 'q_form_color_picker_wrapper',\n            'left_wrapper': 'left_wrapper',\n            'right_wrapper': 'right_wrapper',\n            'color_picker_input': 'color_picker_input',\n            'input_wrapper': 'input_wrapper',\n            'input_prefix': 'input_prefix',\n            'input_suffix': 'input_suffix',\n            'section_snatches': 'section_snatches',\n            'section_first': 'section_first',\n            'section_second': 'section_second',\n            'section_third': 'section_third',\n            'section_fourth': 'section_fourth',\n            'input_snatches': 'input_snatches',\n            'input_snatch_wrapper': 'input_snatch_wrapper',\n            'half_snatch': 'half_snatch',\n            'block_hsb': 'block_hsb',\n            'block_rgb': 'block_rgb',\n            'block_lab': 'block_lab',\n            'block_cmyk': 'block_cmyk',\n            'block_rgb888': 'block_rgb888',\n            'block_rgb565': 'block_rgb565',\n            'block_rgb': 'block_rgb',\n            'block_hex': 'block_hex',\n            'block_hsl': 'block_hsl',\n            'input_h': 'input_h',\n            'input_s': 'input_s',\n            'input_b': 'input_b',\n            'input_r': 'input_r',\n            'input_g': 'input_g',\n            'input_b2': 'input_b2',\n            'input_l': 'input_l',\n            'input_a': 'input_a',\n            'input_b3': 'input_b3',\n            'input_c': 'input_c',\n            'input_m': 'input_m',\n            'input_y': 'input_y',\n            'input_k': 'input_k',\n            'input_rgb888': 'input_rgb888',\n            'input_rgb565': 'input_rgb565',\n            'input_rgb': 'input_rgb',\n            'input_hex': 'input_hex',\n            'input_hsl': 'input_hsl',\n            'input_lab': 'input_lab',\n            'input_cmyk': 'input_cmyk',\n            'block_header': 'block_header',\n            'snatches_wrapper': 'snatches_wrapper',\n            'picker_blocks': 'picker_blocks',\n            'snatches_add': 'snatches_add'\n        }, false);\n        Form.ColorPickerClassesInitialized = true;\n    }\n    const width = options.width || 300;\n    const height = options.height || 300;\n    const showDetails = options.showDetails !== undefined ? options.showDetails : true;\n    const initialColor = options.color || '#FF0000';\n    const wrapper = Q('<div>');\n    const canvas = Q(`<canvas width=\"${width}\" height=\"${height}\"></canvas>`);\n    let current_color, previous_color, input_h, input_s, input_b, input_r, input_g, input_b2, input_l, input_a, input_b3, input_c, input_m, input_y, input_k, input_rgb888, input_rgb565, input_rgb, input_hex, input_hsl, input_lab, input_cmyk;\n    let snatches = [];\n    if (showDetails) {\n        canvas.css({\n            'width': '100%',\n            'height': '100%',\n        });\n        wrapper.addClass(Form.colorPickerClasses.q_form_color_picker_wrapper);\n        const left_wrapper = Q('<div>', { class: Form.colorPickerClasses.left_wrapper });\n        const right_wrapper = Q('<div>', { class: Form.colorPickerClasses.right_wrapper });\n        const snatches_wrapper = Q('<div>', { class: Form.colorPickerClasses.snatches_wrapper + ' ' + Form.colorPickerClasses.picker_blocks });\n        const section_snatches = Q('<div>', { class: Form.colorPickerClasses.section_snatches });\n        const section_first = Q('<div>', { class: Form.colorPickerClasses.section_first });\n        const section_second = Q('<div>', { class: Form.colorPickerClasses.section_second + ' ' + Form.colorPickerClasses.sections });\n        const section_third = Q('<div>', { class: Form.colorPickerClasses.section_third + ' ' + Form.colorPickerClasses.sections });\n        const section_fourth = Q('<div>', { class: Form.colorPickerClasses.section_fourth + ' ' + Form.colorPickerClasses.sections });\n        const block_hsb = Q('<div>', { class: Form.colorPickerClasses.block_hsb + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_rgb = Q('<div>', { class: Form.colorPickerClasses.block_rgb + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_lab = Q('<div>', { class: Form.colorPickerClasses.block_lab + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_cmyk = Q('<div>', { class: Form.colorPickerClasses.block_cmyk + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_rgb888 = Q('<div>', { class: Form.colorPickerClasses.block_rgb888 + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_rgb565 = Q('<div>', { class: Form.colorPickerClasses.block_rgb565 + ' ' + Form.colorPickerClasses.picker_blocks });\n        const block_hsl = Q('<div>', { class: Form.colorPickerClasses.block_hsl + ' ' + Form.colorPickerClasses.picker_blocks });\n        const header_hsb = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'HSB Color'\n        });\n        const header_rgb = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'RGB Color'\n        });\n        const header_lab = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'LAB Color'\n        });\n        const header_cmyk = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'CMYK Color'\n        });\n        const header_rgb888 = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'RGB888'\n        });\n        const header_rgb565 = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'RGB565'\n        });\n        const header_hsl = Q('<div>', {\n            class: Form.colorPickerClasses.block_header,\n            text: 'HSL Color'\n        });\n        const createInputWithLabel = (type, className, value, min, max, prefix, suffix) => {\n            const wrapper = Q('<div>', { class: Form.colorPickerClasses.input_wrapper });\n            const prefixElement = Q('<span>', { class: Form.colorPickerClasses.input_prefix, text: prefix });\n            const input = Q('<input>', {\n                type: type,\n                class: Form.colorPickerClasses.color_picker_input + ' ' + className,\n                value: value\n            });\n            if (type === 'number') {\n                input.attr('min', min);\n                input.attr('max', max);\n            } else if (type === 'text') {\n                input.attr('maxlength', max || 20);\n            }\n            wrapper.append(prefixElement, input);\n            if (suffix) {\n                const suffixElement = Q('<span>', { class: Form.colorPickerClasses.input_suffix, text: suffix });\n                wrapper.append(suffixElement);\n            }\n            return { wrapper, input };\n        };\n        const snatch_add = Q('<div>', { class: Form.colorPickerClasses.input_snatches + ' ' + Form.colorPickerClasses.snatches_add, text: '+' });\n        const snatch_1 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_2 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_3 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_4 = Q('<div>', { class: Form.colorPickerClasses.input_snatches});\n        const snatch_prev_current_wrapper = Q('<div>', { class: Form.colorPickerClasses.input_snatch_wrapper });\n        current_color = Q('<div>', { class: Form.colorPickerClasses.half_snatch });\n        previous_color = Q('<div>', { class: Form.colorPickerClasses.half_snatch });\n        snatch_prev_current_wrapper.append(current_color,previous_color);\n        snatches = [snatch_1, snatch_2, snatch_3, snatch_4];\n        snatches.forEach(slot => slot.on('click', () => {\n            const col = slot.css('background-color');\n            if (col) wrapper.val(col);\n        }));\n        snatch_add.on('click', () => {\n            for (let i = snatches.length - 1; i > 0; i--) {\n                snatches[i].css('background-color', snatches[i - 1].css('background-color'));\n            }\n            snatches[0].css('background-color', current_color.css('background-color'));\n        });\n        const input_h_obj = createInputWithLabel('number', Form.colorPickerClasses.input_h, 0, 0, 360, 'H:', '\u00b0');\n        const input_s_obj = createInputWithLabel('number', Form.colorPickerClasses.input_s, 0, 0, 100, 'S:', '%');\n        const input_b_obj = createInputWithLabel('number', Form.colorPickerClasses.input_b, 0, 0, 100, 'B:', '%');\n        const input_r_obj = createInputWithLabel('number', Form.colorPickerClasses.input_r, 0, 0, 255, 'R:');\n        const input_g_obj = createInputWithLabel('number', Form.colorPickerClasses.input_g, 0, 0, 255, 'G:');\n        const input_b2_obj = createInputWithLabel('number', Form.colorPickerClasses.input_b2, 0, 0, 255, 'B:');\n        const input_l_obj = createInputWithLabel('number', Form.colorPickerClasses.input_l, 0, 0, 100, 'L:');\n        const input_a_obj = createInputWithLabel('number', Form.colorPickerClasses.input_a, 0, -128, 127, 'a:');\n        const input_b3_obj = createInputWithLabel('number', Form.colorPickerClasses.input_b3, 0, -128, 127, 'b:');\n        const input_c_obj = createInputWithLabel('number', Form.colorPickerClasses.input_c, 0, 0, 100, 'C:', '%');\n        const input_m_obj = createInputWithLabel('number', Form.colorPickerClasses.input_m, 0, 0, 100, 'M:', '%');\n        const input_y_obj = createInputWithLabel('number', Form.colorPickerClasses.input_y, 0, 0, 100, 'Y:', '%');\n        const input_k_obj = createInputWithLabel('number', Form.colorPickerClasses.input_k, 0, 0, 100, 'K:', '%');\n        const input_rgb888_obj = createInputWithLabel('text', Form.colorPickerClasses.input_rgb888, '0x000000', null, 8, '888:');\n        const input_rgb565_obj = createInputWithLabel('text', Form.colorPickerClasses.input_rgb565, '0x0000', null, 6, '565:');\n        const input_rgb_obj = createInputWithLabel('text', Form.colorPickerClasses.input_rgb, 'rgb(0,0,0)', null, 20, 'RGB:');\n        const input_hex_obj = createInputWithLabel('text', Form.colorPickerClasses.input_hex, '#000000', null, 7, 'Hex:');\n        const input_hsl_obj = createInputWithLabel('text', Form.colorPickerClasses.input_hsl, 'hsl(0,0%,0%)', null, 20, 'HSL:');\n        const input_lab_obj = createInputWithLabel('text', Form.colorPickerClasses.input_lab, 'lab(0,0,0)', null, 20, 'LAB:');\n        const input_cmyk_obj = createInputWithLabel('text', Form.colorPickerClasses.input_cmyk, 'cmyk(0%,0%,0%,0%)', null, 20, 'CMYK:');\n        input_h = input_h_obj.input;\n        input_s = input_s_obj.input;\n        input_b = input_b_obj.input;\n        input_r = input_r_obj.input;\n        input_g = input_g_obj.input;\n        input_b2 = input_b2_obj.input;\n        input_l = input_l_obj.input;\n        input_a = input_a_obj.input;\n        input_b3 = input_b3_obj.input;\n        input_c = input_c_obj.input;\n        input_m = input_m_obj.input;\n        input_y = input_y_obj.input;\n        input_k = input_k_obj.input;\n        input_rgb888 = input_rgb888_obj.input;\n        input_rgb565 = input_rgb565_obj.input;\n        input_rgb = input_rgb_obj.input;\n        input_hex = input_hex_obj.input;\n        input_hsl = input_hsl_obj.input;\n        input_lab = input_lab_obj.input;\n        input_cmyk = input_cmyk_obj.input;\n        function setupInputListeners() {\n            input_h.on('input', updateFromHSB);\n            input_s.on('input', updateFromHSB);\n            input_b.on('input', updateFromHSB);\n            input_r.on('input', updateFromRGB);\n            input_g.on('input', updateFromRGB);\n            input_b2.on('input', updateFromRGB);\n            input_l.on('input', updateFromLAB);\n            input_a.on('input', updateFromLAB);\n            input_b3.on('input', updateFromLAB);\n            input_c.on('input', updateFromCMYK);\n            input_m.on('input', updateFromCMYK);\n            input_y.on('input', updateFromCMYK);\n            input_k.on('input', updateFromCMYK);\n            input_hex.on('input', updateFromHex);\n            input_rgb.on('input', updateFromRGBString);\n            input_hsl.on('input', updateFromHSLString);\n        }\n        function updateFromHSB() {\n            const h = parseInt(input_h.val()) / 360;\n            const s = parseInt(input_s.val()) / 100;\n            const b = parseInt(input_b.val()) / 100;\n            const [r, g, b2] = Q.HSL2RGB(h, s, (2 * b - b * s) / 2); // Convert HSB to RGB\n            updatePickerFromRGB(Math.round(r), Math.round(g), Math.round(b2));\n        }\n        function updateFromRGB() {\n            const r = parseInt(input_r.val());\n            const g = parseInt(input_g.val());\n            const b = parseInt(input_b2.val());\n            updatePickerFromRGB(r, g, b);\n        }\n        function updateFromLAB() {\n            const l = parseFloat(input_l.val());\n            const a = parseFloat(input_a.val());\n            const b = parseFloat(input_b3.val());\n            const [r, g, b2] = labToRGB(l, a, b);\n            updatePickerFromRGB(r, g, b2);\n        }\n        function updateFromCMYK() {\n            const c = parseInt(input_c.val()) / 100;\n            const m = parseInt(input_m.val()) / 100;\n            const y = parseInt(input_y.val()) / 100;\n            const k = parseInt(input_k.val()) / 100;\n            const r = Math.round(255 * (1 - c) * (1 - k));\n            const g = Math.round(255 * (1 - m) * (1 - k));\n            const b = Math.round(255 * (1 - y) * (1 - k));\n            updatePickerFromRGB(r, g, b);\n        }\n        function updateFromHex() {\n            const hex = input_hex.val();\n            if (hex.match(/^#[0-9A-Fa-f]{6}$/)) {\n                const r = parseInt(hex.slice(1, 3), 16);\n                const g = parseInt(hex.slice(3, 5), 16);\n                const b = parseInt(hex.slice(5, 7), 16);\n                updatePickerFromRGB(r, g, b);\n            }\n        }\n        function updateFromRGBString() {\n            const rgbStr = input_rgb.val();\n            const match = rgbStr.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n            if (match) {\n                const r = parseInt(match[1]);\n                const g = parseInt(match[2]);\n                const b = parseInt(match[3]);\n                updatePickerFromRGB(r, g, b);\n            }\n        }\n        function updateFromHSLString() {\n            const hslStr = input_hsl.val();\n            const match = hslStr.match(/hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/);\n            if (match) {\n                const h = parseInt(match[1]) / 360;\n                const s = parseInt(match[2]) / 100;\n                const l = parseInt(match[3]) / 100;\n                const [r, g, b] = Q.HSL2RGB(h, s, l);\n                updatePickerFromRGB(Math.round(r), Math.round(g), Math.round(b));\n            }\n        }\n        function updatePickerFromRGB(r, g, b) {\n            const [h, s, l] = Q.RGB2HSL(r, g, b);\n            selectedHue = h; // Store just the hue\n            positionHueMarker(h);\n            positionTriangleMarker(s, l);\n            drawPicker();\n            return `rgb(${r},${g},${b})`;\n        }\n        function positionHueMarker(hue) {\n            const angle = hue * 2 * Math.PI;\n            const innerRingMiddleRadius = innerRadius - innerRingThickness / 2;\n            markers.outer = {\n                x: centerX + innerRingMiddleRadius * Math.cos(angle),\n                y: ringCenterY + innerRingMiddleRadius * Math.sin(angle)\n            };\n            if (outerSegments > 0) {\n                const segmentIndex = Math.floor(hue * outerSegments) % outerSegments;\n                selectedOuterSegment = (angle >= 0) ? segmentIndex : null;\n            }\n        }\n        function positionTriangleMarker(s, l) {\n            const totalHeight = bottomLeftVertex.y - topVertex.y;\n            const relativeY = 1 - s;\n            const y = topVertex.y + relativeY * totalHeight;\n            const triangleWidthAtY = (bottomRightVertex.x - bottomLeftVertex.x) * relativeY;\n            let relativeX;\n            if (relativeY === 0) {\n                relativeX = 0.5;\n            } else {\n                if (l <= 0.5) {\n                    relativeX = 1 - (l / 0.5);\n                } else {\n                    relativeX = (1 - l) / 0.5;\n                }\n            }\n            const leftX = centerX - triangleWidthAtY / 2;\n            const x = leftX + relativeX * triangleWidthAtY;\n            markers.triangle = { x, y };\n        }\n        function updateInputsFromColor(color) {\n            if (!color) return;\n            let r, g, b;\n            if (color.startsWith('rgb')) {\n                const match = color.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n                if (match) {\n                    r = parseInt(match[1]);\n                    g = parseInt(match[2]);\n                    b = parseInt(match[3]);\n                }\n            } else if (color.startsWith('#')) {\n                r = parseInt(color.slice(1, 3), 16);\n                g = parseInt(color.slice(3, 5), 16);\n                b = parseInt(color.slice(5, 7), 16);\n            }\n            if (r === undefined || g === undefined || b === undefined) return;\n            input_r.val(r);\n            input_g.val(g);\n            input_b2.val(b);\n            const hex = '#' +\n                r.toString(16).padStart(2, '0') +\n                g.toString(16).padStart(2, '0') +\n                b.toString(16).padStart(2, '0');\n            input_hex.val(hex);\n            input_rgb.val(`rgb(${r},${g},${b})`);\n            const [h, s, l] = Q.RGB2HSL(r, g, b);\n            input_h.val(Math.round(h * 360));\n            input_s.val(Math.round(s * 100));\n            input_b.val(Math.round((l * 2 / (2 - s)) * 100)); // Convert L to B (brightness)\n            input_hsl.val(`hsl(${Math.round(h * 360)},${Math.round(s * 100)}%,${Math.round(l * 100)}%)`);\n            const [l_val, a_val, b_val] = rgbToLab(r, g, b);\n            input_l.val(Math.round(l_val));\n            input_a.val(Math.round(a_val));\n            input_b3.val(Math.round(b_val));\n            input_lab.val(`lab(${Math.round(l_val)},${Math.round(a_val)},${Math.round(b_val)})`);\n            const [c, m, y, k] = rgbToCmyk(r, g, b);\n            input_c.val(Math.round(c * 100));\n            input_m.val(Math.round(m * 100));\n            input_y.val(Math.round(y * 100));\n            input_k.val(Math.round(k * 100));\n            input_cmyk.val(`cmyk(${Math.round(c * 100)}%,${Math.round(m * 100)}%,${Math.round(y * 100)}%,${Math.round(k * 100)}%)`);\n            input_rgb888.val('0x' +\n                r.toString(16).padStart(2, '0') +\n                g.toString(16).padStart(2, '0') +\n                b.toString(16).padStart(2, '0'));\n            const r5 = Math.round(r * 31 / 255) & 0x1F;\n            const g6 = Math.round(g * 63 / 255) & 0x3F;\n            const b5 = Math.round(b * 31 / 255) & 0x1F;\n            const rgb565 = (r5 << 11) | (g6 << 5) | b5;\n            input_rgb565.val('0x' + rgb565.toString(16).padStart(4, '0'));\n        }\n        function rgbToCmyk(r, g, b) {\n            return Q.RGB2CMYK(r, g, b);\n        }\n        function rgbToLab(r, g, b) {\n            return Q.RGB2LAB(r, g, b);\n        }\n        function labToRGB(l, a, b) {\n            return Q.LAB2RGB(l, a, b);\n        }\n        setupInputListeners();\n        block_hsb.append(header_hsb, input_h_obj.wrapper, input_s_obj.wrapper, input_b_obj.wrapper);\n        block_rgb.append(header_rgb, input_r_obj.wrapper, input_g_obj.wrapper, input_b2_obj.wrapper);\n        block_lab.append(header_lab, input_l_obj.wrapper, input_a_obj.wrapper, input_b3_obj.wrapper);\n        block_cmyk.append(header_cmyk, input_c_obj.wrapper, input_m_obj.wrapper, input_y_obj.wrapper, input_k_obj.wrapper);\n        block_rgb888.append(header_rgb888, input_rgb888_obj.wrapper);\n        block_rgb565.append(header_rgb565, input_rgb565_obj.wrapper);\n        block_hsl.append(header_hsl, input_hsl_obj.wrapper);\n        snatches_wrapper.append(snatch_prev_current_wrapper, snatch_1, snatch_2, snatch_3, snatch_4, snatch_add);\n        section_first.append(snatches_wrapper);\n        section_second.append(block_hsb, block_rgb, block_lab, block_cmyk);\n        section_third.append(block_rgb888, block_rgb565, block_hsl);\n        left_wrapper.append(canvas);\n        right_wrapper.append(section_snatches, section_first, section_second, section_third, section_fourth);\n        wrapper.append(left_wrapper, right_wrapper);\n    }\n    else {\n        canvas.css({\n            'width': width + 'px',\n            'height': height + 'px',\n        });\n        wrapper.append(canvas);\n    }\n    const ctx = canvas.nodes[0].getContext('2d');\n    const centerX = width / 2;\n    const ringCenterY = height / 2;\n    const minDimension = Math.min(width, height);\n    const globalRadius = options.globalRadius || (minDimension * 0.46);\n    const outerRingThickness = options.outerRingThickness || (globalRadius * 0.05);\n    const innerRingThickness = options.innerRingThickness || (globalRadius * 0.15);\n    const ringPadding = options.ringPadding || (globalRadius * 0.02);\n    const outerRadius = globalRadius;\n    const innerRadius = outerRadius - outerRingThickness - ringPadding;\n    const innerMostRadius = innerRadius - innerRingThickness - ringPadding;\n    const triangleVertexRadius = innerMostRadius - (globalRadius * 0.07);\n    const topVertex = {\n        x: centerX,\n        y: ringCenterY - triangleVertexRadius\n    };\n    const bottomLeftVertex = {\n        x: centerX - triangleVertexRadius * Math.sin(Math.PI / 3),\n        y: ringCenterY + triangleVertexRadius * Math.cos(Math.PI / 3)\n    };\n    const bottomRightVertex = {\n        x: centerX + triangleVertexRadius * Math.sin(Math.PI / 3),\n        y: ringCenterY + triangleVertexRadius * Math.cos(Math.PI / 3)\n    };\n    let selectedHue = 0; // Store hue as a number (0-1) instead of a color string\n    let selectedOuterSegment = null;\n    let activeArea = 'inner';\n    let markers = {\n        outer: { x: centerX, y: ringCenterY },\n        triangle: { x: centerX, y: ringCenterY }\n    };\n    const outerSegments = options.outerSegments || 18;\n    const outerColors = Array.from({ length: outerSegments }, (_, i) => {\n        const hue = i * (1 / outerSegments);\n        const [r, g, b] = Q.HSL2RGB(hue, 1, 0.5);\n        return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n    });\n    const defaultHue = 0;\n    const defaultSaturation = 1;\n    const defaultLightness = 0.5;\n    const middleRingAngle = (defaultHue / 360) * 2 * Math.PI;\n    const middleRingRadius = innerRadius - innerRingThickness / 2;\n    markers.outer = {\n        x: centerX + middleRingRadius * Math.cos(middleRingAngle),\n        y: ringCenterY + middleRingRadius * Math.sin(middleRingAngle)\n    };\n    markers.triangle = {\n        x: topVertex.x,\n        y: topVertex.y\n    };\n    function drawPicker() {\n        current_color.css({\n            'background-color': `rgb(${input_r.val()},${input_g.val()},${input_b2.val()})`\n        });\n        ctx.clearRect(0, 0, width, height);\n        drawOuterRing();\n        drawMiddleRing();\n        drawTriangle();\n        drawMarkers();\n    }\n    function drawOuterRing() {\n        const segAngle = (2 * Math.PI) / outerSegments;\n        for (let i = 0; i < outerSegments; i++) {\n            const startAngle = i * segAngle;\n            const endAngle = startAngle + segAngle;\n            ctx.beginPath();\n            ctx.arc(centerX, ringCenterY, outerRadius, startAngle, endAngle);\n            ctx.arc(centerX, ringCenterY, outerRadius - outerRingThickness, endAngle, startAngle, true);\n            ctx.closePath();\n            ctx.fillStyle = outerColors[i];\n            ctx.fill();\n        }\n    }\n    function drawMiddleRing() {\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(centerX, ringCenterY, innerRadius, 0, 2 * Math.PI);\n        ctx.closePath();\n        if (ctx.createConicGradient) {\n            const grad = ctx.createConicGradient(0, centerX, ringCenterY);\n            grad.addColorStop(0, \"hsl(0, 100%, 50%)\");\n            grad.addColorStop(0.17, \"hsl(60, 100%, 50%)\");\n            grad.addColorStop(0.33, \"hsl(120, 100%, 50%)\");\n            grad.addColorStop(0.5, \"hsl(180, 100%, 50%)\");\n            grad.addColorStop(0.67, \"hsl(240, 100%, 50%)\");\n            grad.addColorStop(0.83, \"hsl(300, 100%, 50%)\");\n            grad.addColorStop(1, \"hsl(360, 100%, 50%)\");\n            ctx.fillStyle = grad;\n        } else {\n            const grad = ctx.createLinearGradient(0, 0, width, 0);\n            grad.addColorStop(0, \"#FF0000\");\n            grad.addColorStop(0.17, \"#FFFF00\");\n            grad.addColorStop(0.33, \"#00FF00\");\n            grad.addColorStop(0.5, \"#00FFFF\");\n            grad.addColorStop(0.67, \"#0000FF\");\n            grad.addColorStop(0.83, \"#FF00FF\");\n            grad.addColorStop(1, \"#FF0000\");\n            ctx.fillStyle = grad;\n        }\n        ctx.fill();\n        ctx.globalCompositeOperation = 'destination-out';\n        ctx.beginPath();\n        ctx.arc(centerX, ringCenterY, innerRadius - innerRingThickness, 0, 2 * Math.PI);\n        ctx.closePath();\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawTriangle() {\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(centerX, ringCenterY, innerMostRadius * 0.8, 0, 2 * Math.PI);\n        ctx.closePath();\n        ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n        ctx.fill();\n        ctx.restore();\n        ctx.save();\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.6)\";\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 5;\n        ctx.shadowBlur = 10;\n        ctx.beginPath();\n        ctx.moveTo(topVertex.x, topVertex.y);\n        ctx.lineTo(bottomLeftVertex.x, bottomLeftVertex.y);\n        ctx.lineTo(bottomRightVertex.x, bottomRightVertex.y);\n        ctx.closePath();\n        ctx.fillStyle = \"#000\";\n        ctx.fill();\n        ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.beginPath();\n        ctx.moveTo(topVertex.x, topVertex.y);\n        ctx.lineTo(bottomLeftVertex.x, bottomLeftVertex.y);\n        ctx.lineTo(bottomRightVertex.x, bottomRightVertex.y);\n        ctx.closePath();\n        ctx.clip();\n        const gradHoriz = ctx.createLinearGradient(bottomLeftVertex.x, bottomLeftVertex.y, bottomRightVertex.x, bottomRightVertex.y);\n        gradHoriz.addColorStop(0, \"rgba(255,255,255,1)\");\n        gradHoriz.addColorStop(1, \"rgba(255,255,255,0)\");\n        ctx.fillStyle = gradHoriz;\n        ctx.globalCompositeOperation = 'normal';\n        ctx.fillRect(bottomLeftVertex.x, topVertex.y, bottomRightVertex.x - bottomLeftVertex.x, bottomLeftVertex.y - topVertex.y);\n        const [r, g, b] = Q.HSL2RGB(selectedHue, 1, 0.5);\n        const pureHueColor = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n        const gradVert = ctx.createLinearGradient(topVertex.x, topVertex.y, topVertex.x, bottomLeftVertex.y);\n        gradVert.addColorStop(0, pureHueColor); // Use pure hue color instead of selectedHue\n        gradVert.addColorStop(1, \"#000\");\n        ctx.fillStyle = gradVert;\n        ctx.globalCompositeOperation = 'color';\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawMarkers() {\n        ctx.save();\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 4;\n        ctx.shadowColor = \"rgba(0, 0, 0, 0.5)\";\n        ctx.shadowBlur = 5;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 2;\n        if (activeArea === 'inner') {\n            const markerSize = innerRingThickness / 3; // Half the thickness for better visibility\n            ctx.beginPath();\n            ctx.arc(markers.outer.x, markers.outer.y, markerSize, 0, 2 * Math.PI);\n            ctx.stroke();\n        } else if (activeArea === 'outer' && selectedOuterSegment !== null) {\n            const segAngle = (2 * Math.PI) / outerSegments;\n            const startAngle = selectedOuterSegment * segAngle;\n            const endAngle = startAngle + segAngle;\n            ctx.strokeStyle = \"#FFFFFF\";\n            ctx.lineWidth = 5;\n            ctx.beginPath();\n            ctx.arc(centerX, ringCenterY, outerRadius, startAngle, endAngle);\n            ctx.arc(centerX, ringCenterY, outerRadius - outerRingThickness, endAngle, startAngle, true);\n            ctx.closePath();\n            ctx.stroke();\n        }\n        ctx.strokeStyle = \"#FFF\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(markers.triangle.x, markers.triangle.y, 5, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.restore();\n    }\n    function computeColor() {\n        let hue = 0;\n        if (typeof selectedHue === 'string') {\n            if (selectedHue.startsWith('rgb')) {\n                const rgbMatch = selectedHue.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n                if (rgbMatch) {\n                    const [r, g, b] = [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];\n                    const [h] = Q.RGB2HSL(r, g, b);\n                    hue = h;\n                }\n            } else if (selectedHue.startsWith('#')) {\n                hue = 0;\n            }\n        }\n        const triangleMarker = markers.triangle;\n        const totalHeight = bottomLeftVertex.y - topVertex.y;\n        const totalWidth = bottomRightVertex.x - bottomLeftVertex.x;\n        const relativeY = (triangleMarker.y - topVertex.y) / totalHeight;\n        const triangleWidthAtY = totalWidth * relativeY;\n        const leftBoundAtY = centerX - (triangleWidthAtY / 2);\n        const relativeX = triangleWidthAtY === 0 ? 0.5 :\n            (triangleMarker.x - leftBoundAtY) / triangleWidthAtY;\n        let saturation = 1 - (1 - relativeX) * relativeY;\n        let lightness = 1 - relativeY * relativeX;\n        saturation = Math.max(0, Math.min(1, saturation));\n        lightness = Math.max(0, Math.min(1, lightness));\n        return `hsl(${Math.round(hue * 360)}, ${Math.round(saturation * 100)}%, ${Math.round(lightness * 100)}%)`;\n    }\n    let dragging = null;\n    function handleEvent(e) {\n        const rect = canvas.nodes[0].getBoundingClientRect();\n        const scaleX = width / rect.width;\n        const scaleY = height / rect.height;\n        const canvasX = (e.clientX - rect.left) * scaleX;\n        const canvasY = (e.clientY - rect.top) * scaleY;\n        if (dragging === 'triangle') {\n            const constrained = constrainToTriangle(canvasX, canvasY, topVertex, bottomLeftVertex, bottomRightVertex);\n            markers.triangle = constrained;\n            const triangleColor = computeTriangleColor(constrained.x, constrained.y);\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(triangleColor);\n            }\n            drawPicker();\n            return; // Exit early as we've handled the drag event\n        }\n        if (dragging === 'inner_ring') {\n            const constrained = constrainToHueRing(canvasX, canvasY);\n            markers.outer = constrained;\n            const angle = Math.atan2(constrained.y - ringCenterY, constrained.x - centerX);\n            const hue = (angle >= 0 ? angle : angle + 2 * Math.PI) / (2 * Math.PI);\n            selectedHue = hue;\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(computeTriangleColor(markers.triangle.x, markers.triangle.y));\n            }\n            drawPicker();\n            return; // Exit early as we've handled the drag event\n        }\n        const distFromCenter = Math.sqrt(Math.pow(canvasX - centerX, 2) + Math.pow(canvasY - ringCenterY, 2));\n        if (distFromCenter <= outerRadius && distFromCenter >= outerRadius - outerRingThickness) {\n            const angle = Math.atan2(canvasY - ringCenterY, canvasX - centerX);\n            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;\n            const segmentIndex = Math.floor(normalizedAngle / ((2 * Math.PI) / outerSegments));\n            selectedOuterSegment = segmentIndex;\n            selectedHue = segmentIndex / outerSegments;\n            activeArea = 'outer';\n            if (e.type === 'mousedown') {\n                dragging = false;\n            }\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(computeTriangleColor(markers.triangle.x, markers.triangle.y));\n            }\n        }\n        else if (distFromCenter <= innerRadius && distFromCenter >= innerRadius - innerRingThickness) {\n            const angle = Math.atan2(canvasY - ringCenterY, canvasX - centerX);\n            const innerRingMiddleRadius = innerRadius - innerRingThickness / 2;\n            markers.outer = {\n                x: centerX + innerRingMiddleRadius * Math.cos(angle),\n                y: ringCenterY + innerRingMiddleRadius * Math.sin(angle)\n            };\n            const hue = (angle >= 0 ? angle : angle + 2 * Math.PI) / (2 * Math.PI);\n            selectedHue = hue;\n            selectedOuterSegment = null;\n            activeArea = 'inner';\n            if (e.type === 'mousedown') {\n                dragging = 'inner_ring';\n            }\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(computeTriangleColor(markers.triangle.x, markers.triangle.y));\n            }\n        }\n        else if (isPointInTriangle(canvasX, canvasY, topVertex, bottomLeftVertex, bottomRightVertex)) {\n            markers.triangle = { x: canvasX, y: canvasY };\n            const triangleColor = computeTriangleColor(canvasX, canvasY);\n            if (e.type === 'mousedown') {\n                dragging = 'triangle';\n            }\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(triangleColor);\n            }\n        }\n        drawPicker();\n    }\n    function constrainToHueRing(x, y) {\n        const angle = Math.atan2(y - ringCenterY, x - centerX);\n        const innerRingMiddleRadius = innerRadius - innerRingThickness / 2;\n        return {\n            x: centerX + innerRingMiddleRadius * Math.cos(angle),\n            y: ringCenterY + innerRingMiddleRadius * Math.sin(angle)\n        };\n    }\n    function computeTriangleColor(x, y) {\n        const totalHeight = bottomLeftVertex.y - topVertex.y;\n        const relativeY = Math.max(0, Math.min(1, (y - topVertex.y) / totalHeight));\n        const triangleWidthAtY = (bottomRightVertex.x - bottomLeftVertex.x) * relativeY;\n        const leftX = centerX - triangleWidthAtY / 2;\n        const rightX = centerX + triangleWidthAtY / 2;\n        const relativeX = Math.max(0, Math.min(1, (x - leftX) / (rightX - leftX)));\n        const saturation = 1 - relativeY;\n        let lightness = 0.5;\n        if (relativeY > 0) {\n            lightness = 0.5 * (1 - relativeY) + relativeY * (1 - relativeX);\n        }\n        const clampedSaturation = Math.max(0, Math.min(1, saturation));\n        const clampedLightness = Math.max(0, Math.min(1, lightness));\n        const [r, g, b] = Q.HSL2RGB(selectedHue, clampedSaturation, clampedLightness);\n        return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;\n    }\n    function isPointInTriangle(px, py, v1, v2, v3) {\n        const d1 = sign(px, py, v1.x, v1.y, v2.x, v2.y);\n        const d2 = sign(px, py, v2.x, v2.y, v3.x, v3.y);\n        const d3 = sign(px, py, v3.x, v3.y, v1.x, v1.y);\n        const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n        const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n        return !(has_neg && has_pos);\n    }\n    function sign(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return (p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y);\n    }\n    let onMouseMoveHandler, onMouseUpHandler;\n    function attachGlobalListeners() {\n        onMouseMoveHandler = handleMouseMove.bind(this);\n        onMouseUpHandler = handleMouseUp.bind(this);\n        Q(document).on('mousemove', onMouseMoveHandler);\n        Q(document).on('mouseup', onMouseUpHandler);\n    }\n    function removeGlobalListeners() {\n        Q(document).off('mousemove', onMouseMoveHandler);\n        Q(document).off('mouseup', onMouseUpHandler);\n    }\n    function handleMouseDown(e) {\n        handleEvent(e);\n        if (dragging) {\n            previous_color.css({\n                'background-color': `rgb(${input_r.val()},${input_g.val()},${input_b2.val()})`\n            });\n            attachGlobalListeners();\n        }\n    }\n    function handleMouseMove(e) {\n        if (dragging === 'inner_ring' || dragging === 'hue_stripe' || dragging === 'triangle') {\n            handleEvent(e);\n        }\n    }\n    function handleMouseUp(e) {\n        dragging = false;\n        removeGlobalListeners();\n    }\n    canvas.on('mousedown', handleMouseDown);\n    function constrainToTriangle(x, y, v1, v2, v3) {\n        if (isPointInTriangle(x, y, v1, v2, v3)) {\n            return { x, y };\n        }\n        const denominator = ((v2.y - v3.y) * (v1.x - v3.x) + (v3.x - v2.x) * (v1.y - v3.y));\n        let a = ((v2.y - v3.y) * (x - v3.x) + (v3.x - v2.x) * (y - v3.y)) / denominator;\n        let b = ((v3.y - v1.y) * (x - v3.x) + (v1.x - v3.x) * (y - v3.y)) / denominator;\n        let c = 1 - a - b;\n        if (a < 0) a = 0;\n        if (b < 0) b = 0;\n        if (c < 0) c = 0;\n        const sum = a + b + c;\n        if (sum > 0) {\n            a /= sum;\n            b /= sum;\n            c /= sum;\n        } else {\n            a = b = c = 1 / 3;\n        }\n        return {\n            x: a * v1.x + b * v2.x + c * v3.x,\n            y: a * v1.y + b * v2.y + c * v3.y\n        };\n    }\n    wrapper.change = function (callback) {\n        const originalCallback = callback;\n        wrapper.changeCallback = function (color) {\n            Q.Debounce('colorpicker_change', 10, function () {\n                if (showDetails && input_h) {\n                    updateInputsFromColor(color);\n                }\n                originalCallback(color);\n            });\n        };\n        return this;\n    };\n    wrapper.val = function (color) {\n        if (!color) {\n            return computeColor();\n        }\n        if (color.startsWith('#') || color.startsWith('rgb')) {\n            let r, g, b;\n            if (color.startsWith('rgb')) {\n                const rgbMatch = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n                if (rgbMatch) {\n                    r = parseInt(rgbMatch[1]);\n                    g = parseInt(rgbMatch[2]);\n                    b = parseInt(rgbMatch[3]);\n                }\n            } else if (color.startsWith('#')) {\n                const hex = color.slice(1);\n                if (hex.length === 3) {\n                    r = parseInt(hex[0] + hex[0], 16);\n                    g = parseInt(hex[1] + hex[1], 16);\n                    b = parseInt(hex[2] + hex[2], 16);\n                } else if (hex.length === 6) {\n                    r = parseInt(hex.slice(0, 2), 16);\n                    g = parseInt(hex.slice(2, 4), 16);\n                    b = parseInt(hex.slice(4, 6), 16);\n                }\n            }\n            const [h, s, l] = Q.RGB2HSL(r, g, b);\n            selectedHue = h;\n            positionHueMarker(h);\n            positionTriangleMarker(s, l);\n            drawPicker();\n            current_color.css('background-color', color);\n            previous_color.css('background-color', color);\n            if (typeof wrapper.changeCallback === 'function') {\n                wrapper.changeCallback(color);\n            }\n        }\n        return this;\n    };\n    wrapper.destroy = function () {\n        canvas.off('mousedown', handleMouseDown);\n        removeGlobalListeners();\n        dragging = false;\n        return this;\n    };\n    wrapper.Snatch = function (index) {\n        return snatches[index]\n            ? snatches[index].css('background-color')\n            : null;\n    };\n    drawPicker();\n    console.log('ColorPicker drawn on canvas');\n    if (showDetails) {\n        updateInputsFromColor(initialColor);\n        current_color.css('background-color', initialColor);\n        previous_color.css('background-color', initialColor);\n    }\n    this.elements.push(wrapper);\n    return wrapper;\n};"
        },
        "Form.Dropdown": {
            "uuid": "daaa94a9-d370-4579-9ae8-03d666ebad0a",
            "name": "Form.Dropdown",
            "method": "Form",
            "desc": "A customizable dropdown list component for selecting options from a list.",
            "type": "UI Component",
            "example": [
                "// Basic dropdown with options\nconst dropdown = form.Dropdown({\n  values: [\n    {value: '1', text: 'Option 1'},\n    {value: '2', text: 'Option 2'},\n    {value: '3', text: 'Option 3', default: true},\n    {value: '4', text: 'Option 4', disabled: true}\n  ]\n});\n\n// Listen for selection changes\ndropdown.change((value, text, index) => {\n  console.log(`Selected: ${text} with value ${value} at index ${index}`);\n});\n\n// Add dropdown to container\nQ('#myContainer').append(dropdown);",
                "// Create an empty dropdown and add options later\nconst dropdown = form.Dropdown({\"max-height\": 300});\n\n// Add options programmatically\ndropdown.add('val1', 'First Option');\ndropdown.add('val2', 'Second Option');\ndropdown.add('val3', 'Third Option');\n\n// Disable the second option\ndropdown.disable([1]);\n\n// Programmatically select first option\ndropdown.select(0);",
                "// Get current selection\nconst dropdown = form.Dropdown(options);\n// Later in code\nconst selected = dropdown.val();\nconsole.log(`Current value: ${selected.value}`);\nconsole.log(`Current text: ${selected.text}`);\nconsole.log(`Current index: ${selected.index}`);\n\n// Completely replace all options\ndropdown.val([\n  {value: 'new1', text: 'New Option 1'},\n  {value: 'new2', text: 'New Option 2'}\n]);"
            ],
            "dependencies": [
                "Form",
                "Icons"
            ],
            "script": "Form.prototype.Dropdown = function(options = {}) {\n    if (!Form.dropdownStyles) {\n        Form.dropdownStyles = Q.style('', `\n            .form_dropdown {\n                position: relative;\n                width: 100%;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                cursor: pointer;\n                user-select: none;\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n            }\n            .selected_text {\n            padding-right: 10px;\n        }\n            .form_dropdown.disabled {\n                opacity: 0.6;\n                cursor: not-allowed;\n                pointer-events: none;\n            }\n            .form_dropdown_selected {\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n                padding: var(--form-default-padding);\n                line-height: normal;\n                cursor: pointer;\n                user-select: none;\n                width: 100%;\n            }\n            .form_dropdown_items {\n                position: absolute;\n                top: 100%;\n                left: 0;\n                right: 0;\n                margin-top: 3px;\n                z-index: 1000;\n                max-height: 200px;\n                overflow-y: auto;\n                background-color: var(--form-default-background);\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                box-shadow: var(--form-default-shadow);\n                display: none;\n                color: var(--form-default-text-color);\n                font-family: var(--form-default-font-family);\n            }\n            .form_dropdown_item {\n                padding: var(--form-default-padding);\n                cursor: pointer;\n            }\n            .form_dropdown_item:hover {\n                background-color: var(--form-default-accent-color);\n                color: var(--form-default-accent-text-color);\n            }\n            .form_dropdown_item.selected {\n                background-color: var(--form-default-selected-background-color);\n                color: var(--form-default-selected-text-color);\n                font-weight: 500;\n            }\n            .form_dropdown_items {\n                display: none;\n            }\n            .form_dropdown_arrow {\n                transition: transform 0.2s ease-in-out;\n                transform: scale(2.0);\n            }\n            .form_dropdown.open .form_dropdown_arrow {\n                transform: rotate(180deg) scale(2.0);\n            }\n            .form_dropdown.open .form_dropdown_items {\n                display: block;\n                position: absolute;\n                width: 100%;\n                z-index: 1000;\n                overflow-y: auto;\n                top: 100%;\n            }\n            .form_dropdown.up .form_dropdown_items {\n                top: auto;\n                bottom: 100%;\n                margin-top: 0;\n                margin-bottom: 3px;\n            }\n        `, null, {\n            'selected_text': 'selected_text',\n            'form_dropdown': 'form_dropdown',\n            'open': 'open',\n            'disabled': 'disabled',\n            'selected': 'selected',\n            'form_dropdown_selected': 'form_dropdown_selected', \n            'form_dropdown_items': 'form_dropdown_items',\n            'form_dropdown_item': 'form_dropdown_item',\n            'form_dropdown_arrow': 'form_dropdown_arrow',\n            'up': 'up'\n        },true);\n    }\n    const container = Q('<div>').addClass(Form.dropdownStyles['form_dropdown']);\n    const header = Q('<div>').addClass(Form.dropdownStyles['form_dropdown_selected']);\n    const label = Q('<div>').text('Select an option').addClass(Form.dropdownStyles['selected_text']);\n    const arrow = Q('<div>').addClass(Form.dropdownStyles['form_dropdown_arrow']).html('&#9662;');\n    header.append(label, arrow);\n    const listContainer = Q('<div>')\n        .addClass(Form.dropdownStyles['form_dropdown_items'])\n        .addClass(Form.classes['scrollbar']);\n    container.append(header, listContainer);\n    if (!Form.dropdownCloseListenerInitialized) {\n        Q(document).on('click', () => {\n            Q('.' + Form.dropdownStyles['form_dropdown'])\n              .removeClass(Form.dropdownStyles['open']);\n        });\n        Form.dropdownCloseListenerInitialized = true;\n    }\n    if (options['max-height']) {\n        listContainer.css('maxHeight', options['max-height'] + 'px');\n    }\n    let selectedValue = null;\n    let selectedText = '';\n    let selectedIndex = -1;\n    let isDisabled = options.disabled || false;\n    let changeCallback = options.change || null;\n    if (isDisabled) { container.addClass(Form.dropdownStyles['disabled']); }\n    header.on('click', function(e) {\n        e.stopPropagation();\n        if (isDisabled) return;\n        const openCl = Form.dropdownStyles['open'];\n        const upCl = Form.dropdownStyles['up'];\n        if (container.hasClass(openCl)) {\n            container.removeClass(upCl);\n        } else {\n            const rect = container.nodes[0].getBoundingClientRect();\n            const itemsH = listContainer.nodes[0].scrollHeight;\n            if (rect.bottom + itemsH > window.innerHeight) {\n                container.addClass(upCl);\n            } else {\n                container.removeClass(upCl);\n            }\n        }\n        container.toggleClass(openCl);\n    });\n    function selectItem(index) {\n        const items = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n        if (!items) return;\n        items.removeClass(Form.dropdownStyles['selected']);\n        const item = items.eq(index);\n        if (item.hasClass(Form.dropdownStyles['disabled'])) return;\n        item.addClass(Form.dropdownStyles['selected']);\n        selectedValue = item.attr('data-value');\n        selectedText  = item.text();\n        selectedIndex = index;\n        label.text(selectedText);\n        container.removeClass(Form.dropdownStyles['open']);\n        if (typeof changeCallback === 'function') {\n            changeCallback(selectedValue, selectedText, selectedIndex);\n        }\n    }\n    if (options.values && Array.isArray(options.values)) {\n        setValues(options.values);\n    }\n    function setValues(values) {\n        listContainer.html('');\n        let defaultIndex = -1;\n        if (!Array.isArray(values) || values.length === 0) { return; }\n        values.forEach((item, index) => {\n            if (!item || typeof item !== 'object' || item.value === undefined || item.text === undefined) { return; }\n            const dropdownItem = Q('<div>')\n                .addClass(Form.dropdownStyles['form_dropdown_item'])\n                .attr('data-value', item.value)\n                .text(item.text);\n            if (item.disabled) { dropdownItem.addClass(Form.dropdownStyles['disabled']); }\n            if (item.default) { defaultIndex = index; }\n            dropdownItem.on('click', function(e) {\n                e.stopPropagation();\n                if (!dropdownItem.hasClass(Form.dropdownStyles['disabled'])) {\n                    selectItem(index);\n                }\n            });\n            listContainer.append(dropdownItem);\n        });\n        if (defaultIndex < 0) defaultIndex = 0;\n        selectItem(defaultIndex);\n    }\n    const dropdownAPI = {\n        val: function(values) {\n            if (values === undefined) {\n                return { value: selectedValue, text: selectedText, index: selectedIndex };\n            }\n            setValues(values);\n            return this;\n        },\n        change: function(callback) {\n            changeCallback = callback;\n            return this;\n        },\n        disabled: function(state) {\n            isDisabled = !!state;\n            if (isDisabled) { container.addClass(Form.dropdownStyles['disabled']); }\n            else { container.removeClass(Form.dropdownStyles['disabled']); }\n            return this;\n        },\n        select: function(index) {\n            selectItem(index);\n            return this;\n        },\n        index: function(index) {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            if (index >= 0 && index < items.length) {\n                const item = Q(items[index]);\n                return { value: item.attr('data-value'), text: item.text() };\n            }\n            return null;\n        },\n        disable: function(indexes) {\n            if (!Array.isArray(indexes)) return this;\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            indexes.forEach(idx => {\n                if (idx >= 0 && idx < items.length) {\n                    Q(items[idx]).addClass(Form.dropdownStyles['disabled']);\n                }\n            });\n            return this;\n        },\n        enable: function(indexes) {\n            if (!Array.isArray(indexes)) return this;\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            indexes.forEach(idx => {\n                if (idx >= 0 && idx < items.length) {\n                    Q(items[idx]).removeClass(Form.dropdownStyles['disabled']);\n                }\n            });\n            return this;\n        },\n        text: function(index, newText) {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            if (index >= 0 && index < items.length) {\n                const item = Q(items[index]);\n                item.text(newText);\n                if (index === selectedIndex) {\n                    selectedText = newText;\n                    label.text(newText);\n                }\n            }\n            return this;\n        },\n        add: function(value, text) {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            const newIndex = items.length;\n            const dropdownItem = Q('<div>')\n                .addClass(Form.dropdownStyles['form_dropdown_item'])\n                .attr('data-value', value)\n                .text(text);\n            dropdownItem.on('click', function(e) {\n                e.stopPropagation();\n                if (!dropdownItem.hasClass(Form.dropdownStyles['disabled'])) {\n                    selectItem(newIndex);\n                }\n            });\n            listContainer.append(dropdownItem);\n            return newIndex;\n        },\n        remove: function(index) {\n            if (index !== undefined) {\n                const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n                const items = found ? found.nodes : [];\n                if (index >= 0 && index < items.length) {\n                    Q(items[index]).remove();\n                    if (index === selectedIndex) {\n                        selectedValue = null;\n                        selectedText = '';\n                        selectedIndex = -1;\n                        label.text('Select an option');\n                    }\n                }\n                return this;\n            } else {\n                container.remove();\n                return null;\n            }\n        },\n        getCount: function() {\n            const found = listContainer.find('.' + Form.dropdownStyles['form_dropdown_item']);\n            const items = found ? found.nodes : [];\n            return items.length;\n        }\n    };\n    for (const key in dropdownAPI) {\n        if (dropdownAPI.hasOwnProperty(key)) {\n            container[key] = dropdownAPI[key];\n        }\n    }\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form": {
            "uuid": "ecff473a-b303-46ef-9dd0-f5ddcfc48727",
            "name": "Form",
            "method": "Plugin",
            "desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
            "type": "Plugin",
            "example": "var containers = Q.Form()",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "hasClass",
                "text",
                "html",
                "val",
                "click",
                "closest",
                "empty",
                "show",
                "hide",
                "css",
                "attr",
                "prop",
                "remove",
                "add"
            ],
            "script": "function Form(options = {}) {\n    if (!(this instanceof Form)) {\n        return new Form(options);\n    }\n    this.elements = [];\n    this.options = options;\n    if (!Form.initialized) {\n        Form.classes = Q.style(`\n            --form-default-accent-color: rgb(100, 60, 240);\n            --form-default-accent-text-color: #fff;\n            --form-default-font-size: 12px;\n            --form-default-font-family: Arial, sans-serif;\n            --form-default-dataset-header-font-weight: 600;\n            --form-default-dataset-header-font-size: 12px;\n            --form-default-dataset-header-data-font-size: 12px;\n            --form-default-dataset-header-background: rgba(127, 127, 127, 0.10);\n            --form-default-dataset-header-text-color: #fff;\n            --form-default-dataset-border: 1px solid rgba(127, 127, 127, 0.24);\n            --form-default-shadow: 0px 0px 5px rgba(0, 0, 0, 0.5);\n            --form-default-shadow-active: 0px 0px 5px rgba(100, 60, 240, 0.5);\n            --form-default-shadow-focus: 0px 0px 5px rgba(100, 60, 240, 0.5);\n            --form-default-shadow-hover: 0px 0px 5px rgba(100, 60, 240, 0.5);\n            --form-default-background-active: rgb(46, 46, 46);\n            --form-default-background-focus: rgb(46, 46, 46);\n            --form-default-background-hover: rgb(46, 46, 46);\n            --form-default-background-disabled: rgb(46, 46, 46);\n            --form-default-background: rgb(46, 46, 46);\n            --form-default-border-active: 1px solid var(--form-default-accent-color);\n            --form-default-border-focus: 1px solid var(--form-default-accent-color);\n            --form-default-border-hover: 1px solid var(--form-default-accent-color);\n            --form-default-border: 1px solid rgba(255, 255, 255, 0.03);\n            --form-default-outline-active: var(--form-default-border-active);\n            --form-default-outline-focus: var(--form-default-border-focus);\n            --form-default-outline-hover: var(--form-default-border-hover);\n            --form-default-outline: var(--form-default-border);\n            --form-default-border-radius: 5px;\n            --form-default-margin: 0px 0px 0px 0px;\n            --form-default-padding: 5px 10px 5px 10px;\n            --form-default-text-color-active: #fff;\n            --form-default-text-color-focus: #fff;\n            --form-default-text-color-hover: #fff;\n            --form-default-text-color-disabled: #999;\n            --form-default-text-color: #999;\n            --form-default-text-active: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-text-focus: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-text-hover: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-text: normal var(--form-default-font-size) var(--form-default-font-family);\n            --form-default-width: 100%;\n        `, `\n            .form_icon {\n                width: 100%;\n                height: 100%;\n                color: #fff;\n                pointer-events: none;\n            }\n            .form_close_button {\n                user-select: none;\n                -webkit-user-select: none;\n                position: absolute;\n                top: 0px;\n                right: 0px;\n                width: 18px;\n                height: 18px;\n                background-color: rgba(0, 0, 0, 0.5);\n                color: #fff;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                font-size: 12px;\n                cursor: pointer;\n            }\n            .form_close_button:hover {\n                background-color: rgba(220, 53, 69, 0.8);\n            }\n            /* New scrollbar customization class */\n            .scrollbar::-webkit-scrollbar {\n                width: 12px;\n            }\n            .scrollbar::-webkit-scrollbar-track {\n                background:transparent;\n            }\n            .scrollbar::-webkit-scrollbar-thumb {\n                background-color: #888;\n                border-radius: 10px;\n                border: 3px solid rgb(37, 37, 37);\n            }\n            .scrollbar {\n                scrollbar-color: #888 rgb(48, 48, 48);\n            }\n            /* ripple effect container */\n            .form_ripple_container {\n                position: relative;\n                overflow: hidden;\n            }\n            .form_ripple_container::after {\n                content: '';\n                position: absolute;\n                border-radius: 50%;\n                background: rgba(255,255,255,0.2);\n                width: var(--ripple-size);\n                height: var(--ripple-size);\n                top: var(--ripple-y);\n                left: var(--ripple-x);\n                transform: scale(0);\n            }\n            .form_ripple_container.rippleing::after {\n                animation: form_ripple 0.4s linear;\n            }\n            @keyframes form_ripple {\n                to {\n                    transform: scale(4);\n                    opacity: 0;\n                }\n            }\n        `, null, {\n            'form_icon': 'form_icon',\n            'form_close_button': 'form_close_button',\n            'scrollbar': 'scrollbar',\n            'form_ripple_container': 'form_ripple_container',\n            'rippleing': 'rippleing'\n        });\n        Form.initialized = true;\n        console.log('Form core initialized');\n    }\n}\nForm.prototype.Icon = function (icon) {\n    let iconElement = Q('<div>');\n    iconElement.addClass('svg_' + icon + ' form_icon');\n    return iconElement;\n};\n/* FX_Ripple: pseudo\u2011element approach */\nForm.prototype.FX_Ripple = function(el) {\n    const element = el instanceof Q ? el.nodes[0] : el;\n    if (!element) return this;\n    if (getComputedStyle(element).position === 'static') {\n        element.style.position = 'relative';\n    }\n    element.classList.add(Form.classes.form_ripple_container);\n    element.addEventListener('click', function(e) {\n        const rect = element.getBoundingClientRect();\n        const size = Math.max(rect.width, rect.height);\n        element.style.setProperty('--ripple-size', size + 'px');\n        element.style.setProperty(\n            '--ripple-x',\n            (e.clientX - rect.left - size/2) + 'px'\n        );\n        element.style.setProperty(\n            '--ripple-y',\n            (e.clientY - rect.top  - size/2) + 'px'\n        );\n        element.classList.add(Form.classes.rippleing);\n        setTimeout(() => {\n            element.classList.remove(Form.classes.rippleing);\n        }, 400);\n    });\n    return this;\n};\nQ.Form = Form;"
        },
        "Form.ProgressBar": {
            "uuid": "60c99d8c-958e-484e-b8d5-d8f58f60c74a",
            "name": "Form.ProgressBar",
            "method": "Component",
            "desc": "Progress bar component with min, max, val methods",
            "type": "Component",
            "example": "var pb = Q.Form.ProgressBar(0,100,30); pb.max(200).min(10).val(50);",
            "dependencies": [
                "Form",
                "style",
                "find",
                "css"
            ],
            "script": "Form.prototype.ProgressBar = function(min = 0, max = 100, value = 0) {\n    if (!Form.progressClassesInitialized) {\n        Form.progressClasses = Q.style(null, `\n            .progress_bar {\n                width: 100%;\n                background-color: var(--form-default-background);\n                border-radius: var(--form-default-border-radius);\n                overflow: hidden;\n            }\n            .progress_fill {\n            position: relative;\n                height: var(--form-default-font-size);\n                background-color: var(--form-default-accent-color);\n                width: 0%;\n                border-radius: var(--form-default-border-radius);\n            }\n            .progress_fill:before {\n                content: \"\";\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: linear-gradient(90deg,rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.10) 95%, rgba(255, 255, 255, 0.20) 100%);\n                background-size: 200% 100%;\n                animation: gradient 2s linear infinite;\n            }\n            @keyframes gradient {\n                0% { background-position: 100% 100%; }\n                100% { background-position: -100% 100%; }\n            }\n        `, null, {\n            'progress_bar': 'progress_bar',\n            'progress_fill': 'progress_fill'\n        });\n        Form.progressClassesInitialized = true;\n    }\n    const bar = Q(\n        `<div class=\"${Form.progressClasses.progress_bar}\">\n            <div class=\"${Form.progressClasses.progress_fill}\"></div>\n        </div>`\n    );\n    let _min = min, _max = max, _val = value;\n    const fill = bar.find(`.${Form.progressClasses.progress_fill}`);\n    const update = () => {\n        const pct = _max > _min\n            ? ((_val - _min) / (_max - _min)) * 100\n            : 0;\n        fill.css('width', Math.min(Math.max(pct, 0), 100) + '%');\n    };\n    bar.min = function(v) { _min = v; update(); return bar; };\n    bar.max = function(v) { _max = v; update(); return bar; };\n    bar.val = function(v) {\n        if (v === undefined) return _val;\n        _val = v; update(); return bar;\n    };\n    update();\n    this.elements.push(bar);\n    return bar;\n};"
        },
        "Form.Radio": {
            "uuid": "3b93965e-24ea-45d3-bc0e-65adf18b7741",
            "name": "Form.Radio",
            "method": "Component",
            "desc": "Radio component using only HTML elements with val, selected, disable, select methods",
            "type": "Component",
            "example": "var rg = Q.Form.Radio([{value:'a',text:'A'}]); rg.change((i,v,t)=>{}); rg.disable(0); rg.select(0);",
            "dependencies": [
                "Form",
                "style",
                "empty",
                "append",
                "on",
                "addClass",
                "removeClass"
            ],
            "script": "Form.prototype.Radio = function(options = []) {\n    if (!Form.radioClassesInitialized) {\n        Form.radioClasses = Q.style(null, `\n            .form_radio { display: flex; flex-direction: column; gap: 5px; }\n            .form_radio_item { display: flex; align-items: center; cursor: pointer;\n            color: var(--form-default-text-color);\n            font: var(--form-default-text); font-size: var(--form-default-font-size);\n            }\n            .form_radio_item::before {\n                content: \"\";\n                display: inline-block;\n                width: 16px;\n                height: 16px;\n                margin-right: 8px;\n                background-color: var(--form-default-background);\n                border-radius: 50%;\n            }\n            .form_radio_item:hover::before {\n                outline: 2px solid var(--form-default-accent-color);\n            }\n            .form_radio_item.selected::before {\n                background-color: var(--form-default-accent-color);\n            }\n            .form_radio_item.disabled {\n                opacity: 0.5;\n                pointer-events: none;\n            }\n        `, null, {\n            'form_radio': 'form_radio',\n            'form_radio_item': 'form_radio_item',\n            'selected': 'selected',\n            'disabled': 'disabled'\n        },false);\n        Form.radioClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.radioClasses.form_radio}\"></div>`);\n    let _options = options.map(o => ({\n        value: o.value,\n        text: o.text,\n        enabled: o.enabled !== false,\n        selected: !!o.selected,\n        disabled: !!o.disabled\n    }));\n    let _changeCallback;\n    function render() {\n        container.empty();\n        _options.forEach((opt, idx) => {\n            const item = Q(`<div class=\"${Form.radioClasses.form_radio_item}\">${opt.text}</div>`);\n            if (opt.selected) item.addClass(Form.radioClasses.selected);\n            if (opt.disabled) item.addClass(Form.radioClasses.disabled);\n            item.on('click', () => {\n                if (opt.disabled) return;\n                select(idx);\n            });\n            opt._el = item;\n            container.append(item);\n        });\n    }\n    function select(idx) {\n        _options.forEach((o, i) => {\n            const sel = i === idx;\n            o.selected = sel;\n            if (sel) {\n                o._el.addClass(Form.radioClasses.selected);\n            } else {\n                o._el.removeClass(Form.radioClasses.selected);\n            }\n        });\n        if (_changeCallback) {\n            const o = _options[idx];\n            _changeCallback(idx, o.value, o.text);\n        }\n    }\n    container.val = function(vals) {\n        if (vals === undefined) {\n            return _options.map(({_el,...o}) => o);\n        }\n        _options = vals.map(o => ({\n            value: o.value,\n            text: o.text,\n            enabled: o.enabled !== false,\n            selected: !!o.selected,\n            disabled: !!o.disabled\n        }));\n        render();\n        return container;\n    };\n    container.selected = function() {\n        const idx = _options.findIndex(o => o.selected);\n        const o = _options[idx] || {};\n        return { index: idx, value: o.value, text: o.text };\n    };\n    container.disable = function(idx) {\n        const o = _options[idx];\n        if (o) { o.disabled = true; o._el.addClass(Form.radioClasses.disabled); }\n        return container;\n    };\n    container.select = function(idx) {\n        select(idx);\n        return container;\n    };\n    container.change = function(cb) { _changeCallback = cb; return container; };\n    render();\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form.Slider": {
            "uuid": "16707972-9c73-44f8-a081-2e3e31f580e2",
            "name": "Form.Slider",
            "method": "Component",
            "desc": "Slider input component implemented with divs (no native <input>)",
            "type": "Component",
            "example": "var slider = Q.Form.Slider(10, {min:0, max:100}); slider.change(v=>console.log(v));",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "on",
                "css"
            ],
            "script": "Form.prototype.Slider = function(initial = 0, options = {}) {\n    if (!Form.sliderClassesInitialized) {\n        Form.sliderClasses = Q.style(null, `\n            .slider { position: relative; width: 100%; height: 8px; background: var(--form-default-background); border-radius: 4px; cursor: pointer; }\n            .slider_track { position: absolute; height:100%; background: var(--form-default-accent-color); border-radius: 4px; }\n            .slider_thumb { position: absolute; top:50%; transform:translate(-50%,-50%); width:5px; height:100%; background: var('--form-default-accent-color'); border-radius: 4px; cursor: pointer; }\n        `, null, {\n            'slider': 'slider',\n            'slider_track': 'slider_track',\n            'slider_thumb': 'slider_thumb'\n        });\n        Form.sliderClassesInitialized = true;\n    }\n    const min = options.min ?? 0, max = options.max ?? 100;\n    let val = Math.min(max, Math.max(min, initial)), callbacks = [];\n    const slider = Q(`<div class=\"${Form.sliderClasses.slider}\">\n        <div class=\"${Form.sliderClasses.slider_track}\"></div>\n        <div class=\"${Form.sliderClasses.slider_thumb}\"></div>\n    </div>`);\n    const containerEl = slider.nodes[0],\n          trackEl     = containerEl.children[0],\n          thumbEl     = containerEl.children[1];\n    function updateThumb() {\n        const pct = (val-min)/(max-min)*100;\n        trackEl.style.width = pct+'%';\n        thumbEl.style.left = pct+'%';\n    }\n    updateThumb();\n    slider.on('mousedown', e => {\n        const rect = containerEl.getBoundingClientRect();\n        const setFromX = x => {\n            let rel = (x - rect.left)/rect.width;\n            rel = Math.max(0,Math.min(1,rel));\n            val = min + rel*(max-min);\n            updateThumb();\n            callbacks.forEach(cb=>cb(val));\n        };\n        setFromX(e.clientX);\n        const move = me=> setFromX(me.clientX),\n              up   = ()=>{ document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };\n        document.addEventListener('mousemove', move);\n        document.addEventListener('mouseup', up);\n    });\n    slider.min = v => v===undefined ? min : (null, slider);\n    slider.max = v => v===undefined ? max : (null, slider);\n    slider.val = v => {\n        if (v===undefined) return val;\n        val = Math.min(max, Math.max(min, v));\n        updateThumb();\n        callbacks.forEach(cb=>cb(val));\n        return slider;\n    };\n    slider.change = cb => { callbacks.push(cb); return slider; };\n    this.elements.push(slider);\n    return slider;\n};"
        },
        "Form.Tags": {
            "uuid": "a95e114f-9815-440e-96ee-ed222834798e",
            "name": "Form.Tags",
            "method": "Component",
            "desc": "Tags component for Form plugin",
            "type": "Component",
            "example": "var tags = Q.Form.Tags('tag1,tag2,tag3', 'Add tags...'); tags.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop",
                "html",
                "before",
                "after",
                "css",
                "find",
                "focus",
                "children"
            ],
            "script": "Form.prototype.Tags = function(value = '', placeholder = '', options = {}) {\n    const defaultOptions = {\n        separator: ',',\n        maxTags: null,\n        minChars: 1\n    };\n    options = Object.assign({}, defaultOptions, options);\n    if (!Form.tagsClassesInitialized) {\n        Form.tagsClasses = Q.style('', `\n            .form_tags_container {\n                display: flex;\n                flex-wrap: wrap;\n                gap: 5px;\n                width: 100%;\n                min-height: 36px;\n                padding: 3px;\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-input-background-color);\n                cursor: text;\n            }\n            .form_tags_container:focus-within {\n                border-color: var(--form-default-outline-focus);\n                outline: none;\n            }\n            .form_tag {\n            position:relative;\n            overflow: hidden;\n                display: inline-flex;\n                align-items: center;\n                padding: 0 30px 0 5px;\n                background: var(--form-default-background);\n                color: var(--form-default-text-color);\n                border-radius: var(--form-default-border-radius);\n                font-size: var(--form-default-font-size);\n                font-family: var(--form-default-font-family);\n                user-select: none;\n            }\n            .form_tag_editable {\n                background-color: var(--form-default-background-hover);\n            }\n            .form_tag_remove {\n                display: flex;\n                position: absolute;\n                right: 0;\n                cursor: pointer;\n                width: 20px;\n                height: 100%;\n                align-items: center;\n                justify-content: center;\n                font-size: 12px;\n            }\n            .form_tag_input {\n                flex-grow: 1;\n                min-width: 60px;\n                border: none;\n                outline: none;\n                padding: 5px;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                background: transparent;\n                color: var(--form-default-text-color);\n            }\n            .form_tag.dragging {\n                opacity: 0.2;\n            }\n            .form_tag[draggable=true] {\n                cursor: move;\n            }\n        `, null, {\n            'form_tags_container': 'form_tags_container',\n            'form_tag': 'form_tag',\n            'form_tag_editable': 'form_tag_editable',\n            'form_tag_remove': 'form_tag_remove',\n            'form_tag_input': 'form_tag_input'\n        });\n        Form.tagsClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.tagsClasses.form_tags_container}\"></div>`);\n    const input = Q(`<input class=\"${Form.tagsClasses.form_tag_input}\" placeholder=\"${placeholder}\" type=\"text\">`);\n    const state = {\n        tags: [],\n        draggedTag: null,\n        currentEditTag: null\n    };\n    container.append(input);\n    if (value && typeof value === 'string' && value.trim() !== '') {\n        const initialTags = value.split(options.separator)\n                               .map(tag => tag.trim())\n                               .filter(Boolean);\n        initialTags.forEach(tag => addTag(tag));\n    }\n    function addTag(text) {\n        if (!text || text.length < options.minChars) return;\n        if (options.maxTags !== null && state.tags.length >= options.maxTags) return;\n        if (state.tags.includes(text)) return;\n        const tag = Q(`<div class=\"${Form.tagsClasses.form_tag}\" draggable=\"true\"></div>`);\n        const tagText = Q(`<span>${text}</span>`);\n        const removeBtn = Q(`<span class=\"${Form.tagsClasses.form_tag_remove}\">\u00d7</span>`);\n        tag.append(tagText, removeBtn);\n        state.tags.push(text);\n        input.before(tag);\n        setupDragAndDrop(tag);\n        tag.on('click', function(e) {\n            if (e.target.classList.contains(Form.tagsClasses.form_tag_remove.split(' ')[0])) return;\n            tag.html('');\n            tag.addClass(Form.tagsClasses.form_tag_editable);\n            const editInput = Q(`<input type=\"text\" value=\"${text}\" style=\"border:none; background:transparent; color:inherit; outline:none; width:auto;\">`);\n            tag.append(editInput);\n            editInput.focus();\n            state.currentEditTag = { tag, originalText: text };\n            editInput.on('blur', function() {\n                finishEditing(editInput.val());\n            });\n            editInput.on('keydown', function(e) {\n                if (e.key === 'Enter') {\n                    finishEditing(editInput.val());\n                    e.preventDefault();\n                } else if (e.key === 'Escape') {\n                    finishEditing(text); \n                    e.preventDefault();\n                }\n            });\n        });\n        removeBtn.on('click', function() {\n            removeTag(tag, text);\n        });\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function finishEditing(newText) {\n        if (!state.currentEditTag) return;\n        const { tag, originalText } = state.currentEditTag;\n        const index = state.tags.indexOf(originalText);\n        if (index !== -1) {\n            state.tags.splice(index, 1);\n        }\n        if (newText && newText.trim() && newText.length >= options.minChars) {\n            tag.removeClass(Form.tagsClasses.form_tag_editable);\n            tag.html(`<span>${newText}</span><span class=\"${Form.tagsClasses.form_tag_remove}\">\u00d7</span>`);\n            tag.find(`.${Form.tagsClasses.form_tag_remove.split(' ')[0]}`).on('click', function() {\n                removeTag(tag, newText);\n            });\n            state.tags.push(newText);\n        } else {\n            tag.remove();\n        }\n        state.currentEditTag = null;\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function removeTag(tagElement, text) {\n        tagElement.remove();\n        const index = state.tags.indexOf(text);\n        if (index !== -1) {\n            state.tags.splice(index, 1);\n        }\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n    }\n    function setupDragAndDrop(tag) {\n        tag.on('dragstart', function(e) {\n            state.draggedTag = tag;\n            tag.addClass('dragging');\n            if (e.dataTransfer) {\n                e.dataTransfer.setData('text/plain', '');\n                e.dataTransfer.effectAllowed = 'move';\n            }\n        });\n        tag.on('dragend', function() {\n            state.draggedTag = null;\n            tag.removeClass('dragging');\n        });\n        tag.on('dragover', function(e) {\n            if (e.preventDefault) {\n                e.preventDefault(); \n            }\n            return false;\n        });\n        tag.on('dragenter', function(e) {\n            e.preventDefault();\n        });\n        tag.on('drop', function(e) {\n            e.stopPropagation();\n            if (!state.draggedTag || state.draggedTag === tag) {\n                return;\n            }\n            const allTags = Array.from(container.children()).filter(\n                el => el.classList.contains(Form.tagsClasses.form_tag.split(' ')[0])\n            );\n            const fromIndex = allTags.indexOf(state.draggedTag);\n            const toIndex = allTags.indexOf(tag);\n            if (fromIndex < toIndex) {\n                tag.after(state.draggedTag);\n            } else {\n                tag.before(state.draggedTag);\n            }\n            const movedTag = state.tags.splice(fromIndex, 1)[0];\n            state.tags.splice(toIndex, 0, movedTag);\n            if (typeof container.changeCallback === 'function') {\n                container.changeCallback(state.tags.join(options.separator));\n            }\n            return false;\n        });\n    }\n    container.on('click', function(e) {\n        if (e.target === container.element) {\n            input.focus();\n        }\n    });\n    input.on('keydown', function(e) {\n        if (e.key === 'Enter' || e.key === ',' || e.key === ';' || (options.separator === ' ' && e.key === ' ')) {\n            const value = input.val().trim();\n            if (value) {\n                addTag(value);\n                input.val('');\n                e.preventDefault();\n            }\n        }\n        else if (e.key === 'Backspace' && input.val() === '' && state.tags.length > 0) {\n            const tagElements = container.nodes[0].querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n            if (tagElements.length > 0) {\n                const lastTag = Q(tagElements[tagElements.length - 1]);\n                lastTag.click(); \n            }\n        }\n    });\n    input.on('paste', function(e) {\n        let pastedText;\n        if (window.clipboardData && window.clipboardData.getData) {\n            pastedText = window.clipboardData.getData('Text');\n        } else if (e.clipboardData && e.clipboardData.getData) {\n            pastedText = e.clipboardData.getData('text/plain');\n        }\n        if (pastedText) {\n            e.preventDefault();\n            const tags = pastedText.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n            tags.forEach(tag => addTag(tag));\n            input.val('');\n        }\n    });\n    input.on('blur', function() {\n        const inputValue = input.val();\n        const value = inputValue ? inputValue.trim() : '';\n        if (value) {\n            addTag(value);\n            input.val('');\n        }\n    });\n    container.val = function(value) {\n        if (value === undefined) {\n            return state.tags.join(options.separator);\n        }\n        if (value === '') {\n            if (container.nodes && container.nodes.length > 0) {\n                const tagElements = container.nodes[0].querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n                for (let i = 0; i < tagElements.length; i++) {\n                    if (tagElements[i].parentNode) {\n                        tagElements[i].parentNode.removeChild(tagElements[i]);\n                    }\n                }\n            }\n            state.tags = [];\n        } else {\n            if (container.nodes && container.nodes.length > 0) {\n                const tagElements = container.nodes[0].querySelectorAll(`.${Form.tagsClasses.form_tag.split(' ')[0]}`);\n                for (let i = 0; i < tagElements.length; i++) {\n                    if (tagElements[i].parentNode) {\n                        tagElements[i].parentNode.removeChild(tagElements[i]);\n                    }\n                }\n            }\n            state.tags = [];\n            const newTags = value.split(options.separator).map(tag => tag.trim()).filter(Boolean);\n            newTags.forEach(tag => addTag(tag));\n        }\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.tags.join(options.separator));\n        }\n        return container;\n    };\n    container.placeholder = function(text) {\n        input.attr('placeholder', text);\n        return container;\n    };\n    container.disabled = function(state) {\n        input.prop('disabled', state);\n        container.css('pointer-events', state ? 'none' : 'auto');\n        if (state) {\n            container.addClass(Form.classes.q_form_disabled);\n        } else {\n            container.removeClass(Form.classes.q_form_disabled);\n        }\n        return container;\n    };\n    container.setSeparator = function(separator) {\n        options.separator = separator;\n        return container;\n    };\n    container.reset = function() {\n        return container.val('');\n    };\n    container.change = function(callback) {\n        container.changeCallback = callback;\n        return container;\n    };\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form.TextArea": {
            "uuid": "7f00f466-6291-420e-ad62-404767f2d002",
            "name": "Form.TextArea",
            "method": "Component",
            "desc": "TextArea component for Form plugin",
            "type": "Component",
            "example": "var textarea = Q.Form.TextArea('Initial content', 'Enter text...'); textarea.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Form.prototype.TextArea = function(value = '', placeholder = '') {\n    if (!Form.textAreaClassesInitialized) {\n        Form.textAreaClasses = Q.style('', `\n            .form_textarea {\n                width: 100%;\n                padding: var(--form-default-padding);\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n                outline: var(--form-default-outline);\n                border: 0;\n                resize: none;\n                min-height: 100px;\n            }\n            .form_textarea:focus {\n                outline: var(--form-default-outline-focus);\n            }\n        `, null, {\n            'form_textarea': 'form_textarea'\n        });\n        Form.textAreaClassesInitialized = true;\n    }\n    const textarea = Q('<textarea>')\n        .addClass(Form.textAreaClasses.form_textarea)\n        .attr('placeholder', placeholder)\n        .val(value);\n    textarea.disabled = function(state) {\n        textarea.prop('disabled', state);\n        return textarea;\n    };\n    textarea.reset = function() {\n        textarea.val('');\n        return textarea;\n    };\n    textarea.resizeable = function(x = true, y = true) {\n        textarea.css('resize', (x ? 'horizontal' : 'none') + ' ' + (y ? 'vertical' : 'none'));\n        return textarea;\n    }\n    textarea.change = function(callback) {\n        textarea.on('input', function() {\n            callback(this.value);\n        });\n        return textarea;\n    };\n    this.elements.push(textarea);\n    return textarea;\n};"
        },
        "Form.TextBox": {
            "uuid": "78f94647-88c7-4425-a947-1f1f68899fa9",
            "name": "Form.TextBox",
            "method": "Component",
            "desc": "TextBox component for Form plugin",
            "type": "Component",
            "example": "var textbox = Q.Form.TextBox('text', 'Initial value', 'Enter text...'); textbox.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Form.prototype.TextBox = function(type = 'text', value = '', placeholder = '') {\n    if (!Form.textBoxClassesInitialized) {\n        Form.textBoxClasses = Q.style('', `\n            .q_form_input {\n                width: 100%;\n                font-family: var(--form-default-font-family);\n                padding: var(--form-default-padding);\n                font-size: var(--form-default-font-size);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                color: var(--form-default-text-color);\n                border: 0;\n                resize: none;\n                transition: background-color 0s ease, color 0s ease, outline 0s ease;\n            }\n            /* Fix for autofill background color */\n            .q_form_input:-webkit-autofill,\n            .q_form_input:-webkit-autofill:hover,\n            .q_form_input:-webkit-autofill:focus,\n            .q_form_input:-webkit-autofill:active {\n                -webkit-box-shadow: 0 0 0 30px var(--form-default-background) inset !important;\n                -webkit-text-fill-color: var(--form-default-text-color) !important;\n                transition: background-color 5000s ease-in-out 0s;\n                background-color: var(--form-default-background) !important;\n            }\n            .q_form_input:hover {\n                outline: var(--form-default-outline-hover);\n                background-color: var(--form-default-background-hover);\n            }\n            .q_form_input:hover:-webkit-autofill {\n                -webkit-box-shadow: 0 0 0 30px var(--form-default-background-hover) inset !important;\n                background-color: var(--form-default-background-hover) !important;\n            }\n            .q_form_input:focus {\n                outline: var(--form-default-outline-focus);\n                background-color: var(--form-default-background-focus);\n            }\n            .q_form_input:focus:-webkit-autofill {\n                -webkit-box-shadow: 0 0 0 30px var(--form-default-background-focus) inset !important;\n                background-color: var(--form-default-background-focus) !important;\n            }\n            .q_form_input:active {\n                outline: var(--form-default-outline-active);\n                background-color: var(--form-default-background-active);\n            }\n            .q_form_input:disabled {\n                background-color: var(--form-default-background-disabled);\n                color: var(--form-default-text-color-disabled);\n                cursor: not-allowed;\n            }\n        `, null, {\n            'q_form_input': 'q_form_input'\n        });\n        Form.textBoxClassesInitialized = true;\n    }\n    const input = Q(`<input class=\"${Form.textBoxClasses.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n    input.placeholder = function(text) {\n        input.attr('placeholder', text);\n    };\n    input.disabled = function(state) {\n        input.prop('disabled', state);\n        if (state) {\n            input.addClass(Form.classes.q_form_disabled);\n        } else {\n            input.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    input.reset = function() {\n        input.val('');\n    };\n    input.change = function(callback) {\n        input.on('change input', function() {\n            callback(this.value);\n        });\n    };\n    this.elements.push(input);\n    return input;\n};"
        },
        "Form.Uploader": {
            "uuid": "ec923d7c-835d-437e-85e7-929ec98edbda",
            "name": "Form.Uploader",
            "method": "Component",
            "desc": "File upload component with drag and drop functionality",
            "type": "Component",
            "example": "var uploader = Q.Form.Uploader({ fileTypes: '.jpg,.png', preview: true }); uploader.change(function(files) { console.log(files); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop",
                "html",
                "append",
                "css",
                "text",
                "remove"
            ],
            "script": "Form.prototype.Uploader = function (options = {}) {\n    const defaultOptions = {\n        fileTypes: '*', // Accepted file types: 'image/jpeg,image/png' or '.jpg,.png'\n        preview: true,  // Show previews for images/videos\n        thumbSize: 100, // Thumbnail size (px)\n        allowDrop: true, // Allow drag and drop\n        multiple: false, // Allow multiple file selection\n        placeholder: 'Drop files here or click to select'\n    };\n    options = Object.assign({}, defaultOptions, options);\n    if (!Form.uploaderClassesInitialized) {\n        Form.uploaderClasses = Q.style('', `\n            .form_uploader_container {\n            user-select: none;\n                -webkit-user-select: none;\n                display: flex;\n                flex-direction: column;\n                width: 100%;\n                outline: var(--form-default-outline);\n                border-radius: var(--form-default-border-radius);\n                background-color: var(--form-default-background);\n                padding: 10px;\n                color: var(--form-default-text-color);\n            }\n            .form_uploader_container.drag_over {\n                outline: var(--form-default-outline-active);\n                background-color: var(--form-default-background-hover);\n            }\n            .form_uploader_drop_area {\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                justify-content: center;\n                padding: 20px;\n                text-align: center;\n                cursor: pointer;\n                color: var(--form-default-text-color);\n                min-height: 120px;\n            }\n            .form_uploader_icon {\n                font-size: 32px;\n                margin-bottom: 10px;\n                opacity: 0.7;\n            }\n            .form_uploader_text {\n                margin-bottom: 10px;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n            .form_uploader_button {\n                padding: var(--form-default-padding);\n                background-color: var(--form-default-button-background-color);\n                color: var(--form-default-button-text-color);\n                border: none;\n                border-radius: var(--form-default-border-radius);\n                cursor: pointer;\n                font-family: var(--form-default-font-family);\n                font-size: var(--form-default-font-size);\n            }\n            .form_uploader_button:hover {\n                background-color: var(--form-default-background-hover);\n                color: var(--form-default-text-color-hover);\n            }\n            .form_uploader_input {\n                display: none;\n            }\n            .form_uploader_preview_container {\n                display: flex;\n                flex-wrap: wrap;\n                gap: 5px;\n                margin-top: 5px;\n            }\n            .form_uploader_preview_item {\n                position: relative;\n                border-radius: var(--form-default-border-radius);\n                overflow: hidden;\n                outline: var(--form-default-outline);\n            }\n            .form_uploader_preview_image {\n                object-fit: cover;\n                display: block;\n            }\n            .form_uploader_preview_video {\n                object-fit: cover;\n                display: block;\n            }\n            .form_uploader_preview_icon {\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                color: var(--form-default-input-text-color);\n                background-color: rgba(37, 37, 37, 0.8);\n                font-size: 24px;\n            }\n            .form_uploader_preview_info {\n                position: absolute;\n                bottom: 0;\n                left: 0;\n                right: 0;\n                padding: 4px 6px;\n                background: rgba(0, 0, 0, 0.7);\n                color: #fff;\n                font-size: 10px;\n                text-overflow: ellipsis;\n                white-space: nowrap;\n                overflow: hidden;\n            }\n        `, null, {\n            'form_uploader_container': 'form_uploader_container',\n            'drag_over': 'drag_over',\n            'form_uploader_drop_area': 'form_uploader_drop_area',\n            'form_uploader_icon': 'form_uploader_icon',\n            'form_uploader_text': 'form_uploader_text',\n            'form_uploader_button': 'form_uploader_button',\n            'form_uploader_input': 'form_uploader_input',\n            'form_uploader_preview_container': 'form_uploader_preview_container',\n            'form_uploader_preview_item': 'form_uploader_preview_item',\n            'form_uploader_preview_image': 'form_uploader_preview_image',\n            'form_uploader_preview_video': 'form_uploader_preview_video',\n            'form_uploader_preview_icon': 'form_uploader_preview_icon',\n            'form_uploader_preview_info': 'form_uploader_preview_info'\n        });\n        Form.uploaderClassesInitialized = true;\n    }\n    const container = Q(`<div class=\"${Form.classes.q_form} ${Form.uploaderClasses.form_uploader_container}\"></div>`);\n    const dropArea = Q(`<div class=\"${Form.uploaderClasses.form_uploader_drop_area}\"></div>`);\n    const uploadIcon = Q(`<div class=\"${Form.uploaderClasses.form_uploader_icon}\">\ud83d\udcc2</div>`);\n    const text = Q(`<div class=\"${Form.uploaderClasses.form_uploader_text}\">${options.placeholder}</div>`);\n    const browseButton = Q(`<button type=\"button\" class=\"${Form.uploaderClasses.form_uploader_button}\">Browse Files</button>`);\n    const fileInput = Q(`<input type=\"file\" class=\"${Form.uploaderClasses.form_uploader_input}\">`);\n    if (options.multiple) {\n        fileInput.attr('multiple', true);\n    }\n    if (options.fileTypes && options.fileTypes !== '*') {\n        fileInput.attr('accept', options.fileTypes);\n    }\n    dropArea.append(uploadIcon, text, browseButton);\n    container.append(dropArea, fileInput);\n    let previewContainer = null;\n    if (options.preview) {\n        previewContainer = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_container}\"></div>`);\n        container.append(previewContainer);\n    }\n    const state = {\n        files: [],\n        fileObjects: []\n    };\n    function formatFileSize(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n    function getFileExtension(filename) {\n        return filename.split('.').pop().toUpperCase();\n    }\n    function handleFiles(files) {\n        if (!files || files.length === 0) return;\n        Array.from(files).forEach(file => {\n            const fileInfo = {\n                name: file.name,\n                size: file.size,\n                formattedSize: formatFileSize(file.size),\n                type: file.type,\n                extension: getFileExtension(file.name)\n            };\n            state.files.push(fileInfo);\n            state.fileObjects.push(file);\n            if (options.preview) {\n                generatePreview(file, fileInfo);\n            }\n        });\n        if (typeof container.changeCallback === 'function') {\n            container.changeCallback(state.files);\n        }\n    }\n    function generatePreview(file, fileInfo) {\n        const previewItem = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_item}\"></div>`);\n        const fileInfoElement = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_info}\">${file.name} (${fileInfo.formattedSize})</div>`);\n        const removeButton = Q(`<div class=\"${Form.classes.form_close_button}\">\u00d7</div>`);\n        previewItem.css({\n            width: options.thumbSize + 'px',\n            height: options.thumbSize + 'px'\n        });\n        const titleInfo = `Name: ${file.name}\\nSize: ${fileInfo.formattedSize}\\nType: ${file.type}`;\n        previewItem.attr('title', titleInfo);\n        if (file.type.startsWith('image/')) {\n            const img = Q(`<img class=\"${Form.uploaderClasses.form_uploader_preview_image}\" alt=\"${file.name}\">`);\n            img.css({\n                width: '100%',\n                height: '100%'\n            });\n            img.attr('title', titleInfo);\n            const reader = new FileReader();\n            reader.onload = function (e) {\n                img.attr('src', e.target.result);\n                fileInfo.preview = e.target.result;\n            };\n            reader.readAsDataURL(file);\n            previewItem.append(img);\n        }\n        else if (file.type.startsWith('video/')) {\n            const video = Q(`<video class=\"${Form.uploaderClasses.form_uploader_preview_video}\" controls muted>`);\n            video.css({\n                width: '100%',\n                height: '100%'\n            });\n            video.attr('title', titleInfo);\n            const reader = new FileReader();\n            reader.onload = function (e) {\n                video.attr('src', e.target.result);\n                fileInfo.preview = e.target.result;\n            };\n            reader.readAsDataURL(file);\n            previewItem.append(video);\n        }\n        else {\n            const fileIcon = Q(`<div class=\"${Form.uploaderClasses.form_uploader_preview_icon}\"></div>`);\n            fileIcon.css({\n                width: '100%',\n                height: '100%'\n            });\n            fileIcon.attr('title', titleInfo);\n            fileIcon.text(fileInfo.extension);\n            previewItem.append(fileIcon);\n        }\n        previewItem.append(fileInfoElement, removeButton);\n        fileInfo.element = previewItem;\n        if (previewContainer) {\n            previewContainer.append(previewItem);\n        }\n        removeButton.on('click', () => {\n            removeFile(fileInfo);\n        });\n    }\n    function removeFile(fileInfo) {\n        const index = state.files.indexOf(fileInfo);\n        if (index !== -1) {\n            state.files.splice(index, 1);\n            state.fileObjects.splice(index, 1);\n            if (fileInfo.element) {\n                fileInfo.element.remove();\n            }\n            if (typeof container.changeCallback === 'function') {\n                container.changeCallback(state.files);\n            }\n        }\n    }\n    function resetUploader() {\n        state.files = [];\n        state.fileObjects = [];\n        if (previewContainer) {\n            previewContainer.html('');\n        }\n        fileInput.val('');\n    }\n    if (options.allowDrop) {\n        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n            dropArea.on(eventName, (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        });\n        ['dragenter', 'dragover'].forEach(eventName => {\n            dropArea.on(eventName, () => {\n                container.addClass(Form.uploaderClasses.drag_over);\n            });\n        });\n        ['dragleave', 'drop'].forEach(eventName => {\n            dropArea.on(eventName, () => {\n                container.removeClass(Form.uploaderClasses.drag_over);\n            });\n        });\n        dropArea.on('drop', (e) => {\n            const files = e.dataTransfer.files;\n            if (!options.multiple && files.length > 1) {\n                handleFiles([files[0]]);\n            } else {\n                handleFiles(files);\n            }\n        });\n    }\n    browseButton.on('click', function () {\n        fileInput.nodes[0].click();\n    });\n    dropArea.on('click', function (e) {\n        if (e.target !== browseButton.nodes[0]) {\n            fileInput.nodes[0].click();\n        }\n    });\n    fileInput.on('change', function () {\n        if (!options.multiple) {\n            resetUploader(); // Clear previous files if not multiple\n        }\n        handleFiles(this.files);\n    });\n    container.val = function (value) {\n        if (value === undefined) {\n            return {\n                files: state.files,\n                fileObjects: state.fileObjects\n            };\n        }\n        if (value === '' || value === null) {\n            resetUploader();\n            return container;\n        }\n        return container;\n    };\n    container.reset = function () {\n        resetUploader();\n        return container;\n    };\n    container.disabled = function (state) {\n        if (state) {\n            container.css('opacity', '0.5');\n            container.css('pointer-events', 'none');\n            fileInput.prop('disabled', true);\n        } else {\n            container.css('opacity', '1');\n            container.css('pointer-events', 'auto');\n            fileInput.prop('disabled', false);\n        }\n        return container;\n    };\n    container.change = function (callback) {\n        container.changeCallback = callback;\n        return container;\n    };\n    this.elements.push(container);\n    return container;\n};"
        },
        "Icons": {
            "uuid": "bfd17ab1-616e-457f-8a16-1821c205daf2",
            "name": "Icons",
            "method": "Plugin",
            "desc": "A plugin to add additional icons to the VulpiniQ library.",
            "type": "Plugin",
            "example": [
                "// Initialize the icons plugin\nQ.Icons();",
                "// Get an icon element\nlet icon = Q.Icons().get('arrow-down');\ndocument.body.appendChild(icon.el);",
                "// Get an icon element with additional classes\nlet icon2 = Q.Icons().get('arrow-down', 'my-custom-class');\ndocument.body.appendChild(icon2.el);"
            ],
            "dependencies": [],
            "script": "Q.Icons = function () {\n  let glob = Q.getGLOBAL('icons');\n  let classes = {};\n  if (glob && glob.icons) {\n    classes = glob.icons;\n  }\n  else {\n    classes = Q.style(`\n\t--icon_arrow-down: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 100.93685,31.353867 C 82.480099,48.598492 67.319803,62.707709 67.247301,62.707709 c -0.0725,0 -15.232809,-14.109215 -33.689561,-31.353842 L 3.5365448e-8,6.6845858e-7 H 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"M 31.353844,100.93685 C 14.109219,82.480099 1.6018623e-6,67.319803 1.6018623e-6,67.247301 1.6018623e-6,67.174801 14.109217,52.014492 31.353844,33.55774 L 62.70771,0 V 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"m 31.353868,33.55775 c 17.244625,18.456749 31.353842,33.617045 31.353842,33.689547 0,0.0725 -14.109215,15.232809 -31.353842,33.689563 L 1.6018623e-6,134.4946 V 67.247297 0 Z\"/></svg>');\n\t--icon_arrow-up: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 33.55775,31.353843 C 52.014499,14.109218 67.174795,6.6845858e-7 67.247297,6.6845858e-7 67.319797,6.6845858e-7 82.480106,14.109216 100.93686,31.353843 L 134.4946,62.707709 H 67.247297 3.5365448e-8 Z\"/></svg>');\n\t--icon_navigation-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2666.6667 2666.6667\"><path d=\"M 1276.6667,2434.5485 C 950.24325,2418.4963 647.60291,2257.2797 449.65648,1994.0001 360.09366,1874.8766 294.54616,1735.7649 260.06678,1591.6333 c -40.82486,-170.6571 -40.82486,-347.2761 0,-517.9332 71.52438,-298.98806 268.8554,-557.46223 540.12266,-707.48002 258.68606,-143.06006 568.06486,-175.54075 852.57376,-89.50899 276.927,83.73908 511.1437,274.85672 650.2832,530.62227 168.8614,310.40014 177.2264,688.09064 22.2995,1006.84964 -77.0037,158.4335 -189.7203,295.013 -331.3458,401.4939 -205.303,154.3568 -458.4668,231.6017 -717.3334,218.8716 z m 130.2294,-151.2014 c 229.6976,-18.6692 437.2639,-114.273 599.1754,-275.9766 47.6541,-47.593 83.7471,-91.4686 120.133,-146.0371 91.2885,-136.9067 142.8941,-286.0616 157.3086,-454.6667 3.0513,-35.6912 3.0513,-112.3088 0,-148 -9.7543,-114.0948 -35.6813,-216.2096 -79.956,-314.91095 C 2140.8657,803.99837 2044.7703,680.42081 1924.6667,585.10582 1705.8186,411.42656 1421.4281,342.88551 1146,397.43913 961.28159,434.02604 793.07082,524.16769 658.61926,658.61926 508.15954,809.07897 413.50356,1001.5246 386.76219,1211.3334 c -5.50464,43.1886 -7.16468,71.3013 -7.16468,121.3333 0,50.0321 1.66004,78.1448 7.16468,121.3333 31.40785,246.4213 158.34097,471.0271 353.9045,626.2276 118.14734,93.7625 258.15376,158.5796 405.33331,187.6524 50.7995,10.0346 91.5353,14.8142 153.3334,17.9909 18.4799,0.95 83.6306,-0.5787 107.5627,-2.5238 z m 134.7679,-630.3487 -208.3296,-208.3296 -207.9982,207.9951 -207.99834,207.9951 -54.66892,-54.6567 c -30.0679,-30.0612 -54.66892,-55.2602 -54.66892,-55.9978 0,-0.7375 93.30001,-94.6396 207.33338,-208.6711 l 207.3333,-207.3301 -206.6689,-206.6721 -206.66886,-206.67213 55.00599,-54.99402 55.006,-54.99402 206.66127,206.66447 206.6613,206.6646 207.6661,-207.6629 207.666,-207.66288 55.3378,55.32571 55.3378,55.32571 -207.6673,207.67046 -207.6673,207.6705 208.3339,208.3372 208.334,208.3371 -55.0055,54.9935 -55.0054,54.9935 z\"/></svg>');\n\t--icon_navigation-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 282.12556,619.5403 247.03663,609.52248 218.00001,595.4014 129.37889,552.30321 70.013661,466.90205 60.059145,368.19207 51.577814,284.09034 83.346262,198.0417 144.85111,138.52292 212.10881,73.437059 306.81846,45.865772 398.4674,64.691724 519.45153,89.543525 610.11296,190.57708 622.60754,314.47462 c 8.48133,84.10173 -23.28712,170.15036 -84.79196,229.66914 -59.89864,57.96444 -141.4913,86.4009 -224.85943,78.36742 z m 71.04386,-40.49085 c 101.01231,-18.37977 179.6848,-97.26565 198.14953,-198.68699 3.46591,-19.0372 3.48193,-65.25956 0.0291,-84 -18.78642,-101.96514 -96.94357,-180.11939 -198.8453,-198.83796 -18.89894,-3.471598 -65.10105,-3.471598 -84,0 C 197.45585,119.2095 119.27,197.39245 100.48802,299.33334 c -3.452807,18.74044 -3.436783,64.9628 0.0291,84 16.64224,91.4109 82.13775,165.12641 170.46427,191.85833 8.26023,2.49995 21.0186,5.49414 28.35193,6.65376 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 320.66668,412.53122 c -36.66667,-38.4534 -66.66667,-70.49248 -66.66667,-71.19795 0,-0.70547 30.15,-32.79758 67,-71.31579 l 67,-70.03311 v 141.34115 c 0,77.73764 -0.15,141.29162 -0.33333,141.23108 -0.18334,-0.0605 -30.33334,-31.57197 -67,-70.02538 z\"/></svg>');\n\t--icon_navigation-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 103.83077,602.35954 -10.876679,362.01744 104.94177,186.66667 225.81958,3.6559506 499.6699,21.151057 595.4014,218.00001 691.73222,416.0813 532.80292,643.69595 312.95615,622.51118 Z m 71.04386,-40.49085 C 527.6749,555.87785 617.23885,410.16562 575.1842,270.98141 536.24285,142.10102 399.55264,68.634561 270.98141,107.48249 119.67709,153.19925 50.784795,329.22352 130.9177,465.35432 c 35.94209,61.05887 100.57273,105.76313 168.41564,116.49111 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 294.66668,341.34179 V 199.98437 l 67,70.03311 c 36.85,38.51821 67,70.60056 67,71.2941 0,0.69354 -30.15,32.78948 -67,71.32431 l -67,70.06332 z\"/></svg>');\n\t--icon_window-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 2.8176856,98.903421 -4.0360052e-7,96.085741 22.611458,73.473146 45.222917,50.860554 22.611458,28.247962 -4.0360052e-7,5.6353711 2.8176856,2.8176851 5.6353716,-9.1835591e-7 28.247963,22.611458 50.860555,45.222916 73.473147,22.611458 96.085743,-9.1835591e-7 98.903423,2.8176851 101.72111,5.6353711 79.109651,28.247962 56.498193,50.860554 79.109651,73.473146 101.72111,96.085741 98.903423,98.903421 96.085743,101.72111 73.473147,79.109651 50.860555,56.498192 28.247963,79.109651 5.6353716,101.72111 Z\"/></svg>');\n\t--icon_window-full: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 H 50.860555 84.417403 V 50.860554 84.417401 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z\"/></svg>');\n\t--icon_window-minimize: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 0.5252846,83.893071 V 79.698469 H 50.860555 101.19582 v 4.194602 4.19461 H 50.860555 0.5252846 Z\"/></svg>');\n\t--icon_window-windowed: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 h 8.389212 8.389212 V 8.9144961 0.52528408 H 67.638978 101.19582 V 34.082131 67.638977 h -8.389207 -8.38921 v 8.389212 8.389212 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z M 92.806613,34.082131 V 8.9144961 H 67.638978 42.471343 v 4.1946059 4.194606 h 20.973029 20.973031 v 20.973029 20.973029 h 4.1946 4.19461 z\"/></svg>');\n\t--icon_zoom-in: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n\t--icon_zoom-out: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n`,`\n.svg_icon {-webkit-mask-size: cover;mask-size: cover;-webkit-mask-repeat: no-repeat;mask-repeat: no-repeat;-webkit-mask-position: center;mask-position: center;background-color: currentColor;}\n.svg_iconsize { width:100%;height:100%; }\n.arrow-down { mask-image: var(--icon_arrow-down);}\n.arrow-left { mask-image: var(--icon_arrow-left);}\n.arrow-right { mask-image: var(--icon_arrow-right);}\n.arrow-up { mask-image: var(--icon_arrow-up);}\n.navigation-close { mask-image: var(--icon_navigation-close);}\n.navigation-left { mask-image: var(--icon_navigation-left);}\n.navigation-right { mask-image: var(--icon_navigation-right);}\n.window-close { mask-image: var(--icon_window-close);}\n.window-full { mask-image: var(--icon_window-full);}\n.window-minimize { mask-image: var(--icon_window-minimize);}\n.window-windowed { mask-image: var(--icon_window-windowed);}\n.zoom-in { mask-image: var(--icon_zoom-in);}\n.zoom-out { mask-image: var(--icon_zoom-out);}\n`,null\n,{\n  \"arrow-down\": \"arrow-down\",\n  \"arrow-left\": \"arrow-left\",\n  \"arrow-right\": \"arrow-right\",\n  \"arrow-up\": \"arrow-up\",\n  \"navigation-close\": \"navigation-close\",\n  \"navigation-left\": \"navigation-left\",\n  \"navigation-right\": \"navigation-right\",\n  \"window-close\": \"window-close\",\n  \"window-full\": \"window-full\",\n  \"window-minimize\": \"window-minimize\",\n  \"window-windowed\": \"window-windowed\",\n  \"zoom-in\": \"zoom-in\",\n  \"zoom-out\": \"zoom-out\",\n  \"svg_icon\": \"svg_icon\",\n  \"svg_iconsize\": \"svg_iconsize\"\n}, false);\n  }\n  return {\n    get: function (name, additional = '') {\n      if (additional === '') {\n        additional = classes['svg_iconsize'];\n      }\n      return Q('<div>', {class: classes['svg_icon'] + ' ' + classes[name] + ' ' + additional});\n    }\n  }\n};"
        },
        "Image.Blur": {
            "uuid": "7f32c03e-14fb-4815-aaff-1d6d50fe8822",
            "name": "Image.Blur",
            "method": "Plugin",
            "desc": "Apply standard blur to images.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Blur({ radius: 5 }); // Applies a blur with a radius of 5 <br> image.Blur({ radius: 8, quality: 2 }); // Higher quality blur with larger radius",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Blur = function(blurOptions = {}) {\n        const defaults = {\n            type: 'gaussian', // gaussian, box, motion, lens\n            radius: 5,         // Basic blur radius\n            quality: 1,        // Number of iterations for higher quality\n            direction: 0,      // Angle in degrees\n            distance: 10,      // Distance of motion\n            focalDistance: 0.5,  // 0-1, center of focus\n            shape: 'circle',     // circle, hexagon, pentagon, octagon\n            blades: 6,           // Number of aperture blades (5-8)\n            bladeCurvature: 0,   // 0-1, curvature of blades\n            rotation: 0,         // Rotation angle of the aperture in degrees\n            specularHighlights: 0, // 0-1, brightness of highlights\n            noise: 0              // 0-1, amount of noise\n        };\n        const settings = Object.assign({}, defaults, blurOptions);\n        const canvas_node = this.node;\n        const ctx = canvas_node.getContext('2d', { willReadFrequently: true });\n        const data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        const pixels = data.data;\n        const width = canvas_node.width;\n        const height = canvas_node.height;\n        let blurredPixels;\n        switch(settings.type.toLowerCase()) {\n            case 'box':\n                blurredPixels = applyBoxBlur(pixels, width, height, settings);\n                break;\n            case 'motion':\n                blurredPixels = applyMotionBlur(pixels, width, height, settings);\n                break;\n            case 'lens':\n                blurredPixels = applyLensBlur(pixels, width, height, settings);\n                break;\n            case 'gaussian':\n            default:\n                blurredPixels = applyGaussianBlur(pixels, width, height, settings);\n                break;\n        }\n        for (let i = 0; i < pixels.length; i++) {\n            pixels[i] = blurredPixels[i];\n        }\n        ctx.putImageData(data, 0, 0);\n        this.saveToHistory();\n        return this;\n    };\n    function applyGaussianBlur(pixels, width, height, settings) {\n        const { kernel, size } = gaussianKernel(settings.radius);\n        const half = Math.floor(size / 2);\n        const iterations = Math.round(settings.quality);\n        let currentPixels = new Uint8ClampedArray(pixels);\n        for (let i = 0; i < iterations; i++) {\n            currentPixels = applyBlur(currentPixels, width, height, kernel, size, half);\n        }\n        return currentPixels;\n    }\n    function applyBoxBlur(pixels, width, height, settings) {\n        const radius = Math.round(settings.radius);\n        const iterations = Math.round(settings.quality);\n        const size = 2 * radius + 1;\n        const half = radius;\n        const kernel = new Float32Array(size * size);\n        const weight = 1 / (size * size);\n        for (let i = 0; i < size * size; i++) {\n            kernel[i] = weight;\n        }\n        let currentPixels = new Uint8ClampedArray(pixels);\n        for (let i = 0; i < iterations; i++) {\n            currentPixels = applyBlur(currentPixels, width, height, kernel, size, half);\n        }\n        return currentPixels;\n    }\n    function applyMotionBlur(pixels, width, height, settings) {\n        const radius = Math.max(1, Math.round(settings.radius));\n        const distance = Math.max(1, Math.round(settings.distance));\n        const angle = settings.direction * Math.PI / 180; // Convert to radians\n        const size = 2 * distance + 1;\n        const kernel = new Float32Array(size * size).fill(0);\n        const half = Math.floor(size / 2);\n        let totalWeight = 0;\n        for (let t = -half; t <= half; t++) {\n            const x = Math.round(Math.cos(angle) * t) + half;\n            const y = Math.round(Math.sin(angle) * t) + half;\n            if (x >= 0 && x < size && y >= 0 && y < size) {\n                let weight = 1;\n                if (radius > 1) {\n                    const dist = Math.abs(t) / half;\n                    weight = Math.exp(-dist * dist / (2 * (radius / distance) * (radius / distance)));\n                }\n                kernel[y * size + x] = weight;\n                totalWeight += weight;\n            }\n        }\n        if (totalWeight > 0) {\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= totalWeight;\n            }\n        }\n        return applyBlur(pixels, width, height, kernel, size, half);\n    }\n    function applyLensBlur(pixels, width, height, settings) {\n        const radius = Math.max(1, Math.round(settings.radius));\n        const size = 2 * radius + 1;\n        const half = radius;\n        const kernel = new Float32Array(size * size).fill(0);\n        const rotation = settings.rotation * Math.PI / 180; // Convert to radians\n        const blades = Math.max(5, Math.min(8, settings.blades));\n        const curvature = Math.max(0, Math.min(1, settings.bladeCurvature));\n        let totalWeight = 0;\n        const focalFactor = 1 - settings.focalDistance;\n        for (let y = 0; y < size; y++) {\n            for (let x = 0; x < size; x++) {\n                const dx = x - half;\n                const dy = y - half;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance <= radius) {\n                    const angle = Math.atan2(dy, dx) + rotation;\n                    let weight = 0;\n                    switch (settings.shape) {\n                        case 'hexagon':\n                        case 'pentagon':\n                        case 'octagon':\n                            const bladeAngle = 2 * Math.PI / blades;\n                            const normalizedAngle = (angle % bladeAngle) / bladeAngle - 0.5;\n                            const bladeDistance = radius * (1 - curvature * Math.abs(normalizedAngle));\n                            weight = distance <= bladeDistance ? 1 : 0;\n                            break;\n                        case 'circle':\n                        default:\n                            weight = 1;\n                            const normalizedDist = distance / radius;\n                            if (normalizedDist > focalFactor) {\n                                weight *= Math.max(0, 1 - (normalizedDist - focalFactor) / (1 - focalFactor));\n                            }\n                            break;\n                    }\n                    if (settings.specularHighlights > 0) {\n                        const highlightFactor = Math.max(0, 1 - distance / radius);\n                        weight *= 1 + settings.specularHighlights * highlightFactor * 2;\n                    }\n                    if (settings.noise > 0) {\n                        weight *= 1 + (Math.random() - 0.5) * settings.noise;\n                    }\n                    kernel[y * size + x] = Math.max(0, weight);\n                    totalWeight += kernel[y * size + x];\n                }\n            }\n        }\n        if (totalWeight > 0) {\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= totalWeight;\n            }\n        }\n        return applyBlur(pixels, width, height, kernel, size, half);\n    }\n    function gaussianKernel(radius) {\n        const size = 2 * radius + 1;\n        const kernel = new Float32Array(size * size);\n        const sigma = radius / 3;\n        let sum = 0;\n        const center = radius;\n        for (let y = 0; y < size; y++) {\n            for (let x = 0; x < size; x++) {\n                const dx = x - center;\n                const dy = y - center;\n                const weight = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));\n                kernel[y * size + x] = weight;\n                sum += weight;\n            }\n        }\n        for (let i = 0; i < kernel.length; i++) {\n            kernel[i] /= sum;\n        }\n        return { kernel, size };\n    }\n    function applyBlur(pixels, width, height, kernel, size, half) {\n        const output = new Uint8ClampedArray(pixels.length);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0, a = 0;\n                const dstOff = (y * width + x) * 4;\n                let weightSum = 0;\n                for (let ky = 0; ky < size; ky++) {\n                    for (let kx = 0; kx < size; kx++) {\n                        const ny = y + ky - half;\n                        const nx = x + kx - half;\n                        if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                            const srcOff = (ny * width + nx) * 4;\n                            const weight = kernel[ky * size + kx];\n                            r += pixels[srcOff] * weight;\n                            g += pixels[srcOff + 1] * weight;\n                            b += pixels[srcOff + 2] * weight;\n                            a += pixels[srcOff + 3] * weight;\n                            weightSum += weight;\n                        }\n                    }\n                }\n                if (weightSum > 0) {\n                    r /= weightSum;\n                    g /= weightSum;\n                    b /= weightSum;\n                    a /= weightSum;\n                }\n                output[dstOff] = r;\n                output[dstOff + 1] = g;\n                output[dstOff + 2] = b;\n                output[dstOff + 3] = a;\n            }\n        }\n        return output;\n    }"
        },
        "Image.Brightness": {
            "uuid": "0ad53e4e-adc4-4abd-b798-00fae1fd0761",
            "name": "Image.Brightness",
            "method": "Plugin",
            "desc": "Adjust image brightness.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Brightness(20); // Increases brightness by 20 <br> image.Brightness(-15, { clamp: true }); // Decreases brightness with value clamping",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Brightness = function(value, brightOptions = {}) {\n        const defaultOptions = {\n            preserveAlpha: true,\n            clamp: true   // Whether to clamp values to 0-255 range\n        };\n        const finalOptions = Object.assign({}, defaultOptions, brightOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] += value;     // Red\n            pixels[i + 1] += value; // Green\n            pixels[i + 2] += value; // Blue\n            if (finalOptions.clamp) {\n                pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        this.saveToHistory();\n        return this;\n    };"
        },
        "Image.Contrast": {
            "uuid": "0e5b9050-b3fa-4eb6-bf19-5e423c0f8aa3",
            "name": "Image.Contrast",
            "method": "Plugin",
            "desc": "Adjust image contrast.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Contrast(50); // Increases contrast by 50 <br> image.Contrast(-20, { preserveHue: true }); // Decreases contrast while preserving hue",
            "dependencies": "Image",
            "script": "(function() {\n    const originalImage = Q.Image;\n    Q.Image = function(options = {}) {\n        const Image = originalImage(options);\n        return Image;\n    };\n    Q.Image.prototype.Contrast = function(value, contrastOptions = {}) {\n        const defaultOptions = {\n            preserveHue: true,  \n            clamp: true        \n        };\n        const finalOptions = Object.assign({}, defaultOptions, contrastOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let factor = (259 * (value + 255)) / (255 * (259 - value));\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = factor * (pixels[i] - 128) + 128;\n            pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n            pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n            if (finalOptions.clamp) {\n                pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        this.saveToHistory();\n        return this;\n    };\n})();"
        },
        "Image": {
            "uuid": "684aa28f-b5eb-4cd7-9200-ae0125edf7e5",
            "name": "Image",
            "method": "Plugin",
            "desc": "Useful to manipulate images.",
            "type": "Component",
            "example": "var image = Q.Image();",
            "dependencies": "RGB2HSL, HSL2RGB",
            "script": "Q.Image = function (options) {\n    const defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        quality: 1,\n        historyLimit: 10,\n        autoSaveHistory: true    \n    };\n    this.options = Object.assign({}, defaultOptions, options);\n    this.canvas = Q('<canvas>');\n    this.node = this.canvas.nodes[0];\n    if (this.options.width && this.options.height) {\n        this.node.width = this.options.width;\n        this.node.height = this.options.height;\n    }\n    this.history = {\n        states: [],        \n        position: -1,      \n        isUndoRedoing: false \n    };\n};\nQ.Image.prototype.Load = function(src, callback) {\n    const img = new Image();\n    img.crossOrigin = 'Anonymous';\n    img.onload = () => {\n        if (this.node.width === 0 || this.node.height === 0 || \n            this.options.width === 0 || this.options.height === 0) {\n            this.node.width = img.width;\n            this.node.height = img.height;\n        }\n        const ctx = this.node.getContext('2d');\n        ctx.clearRect(0, 0, this.node.width, this.node.height);\n        ctx.drawImage(img, 0, 0, img.width, img.height, \n                      0, 0, this.node.width, this.node.height);\n        this.history.states = [];\n        this.history.position = -1;\n        this.saveToHistory();\n        if (callback) callback.call(this, null);\n    };\n    img.onerror = (err) => {\n        console.error('Hiba a k\u00e9p bet\u00f6lt\u00e9sekor:', src, err);\n        if (callback) callback.call(this, new Error('Error loading image'));\n    };\n    img.src = typeof src === 'string' ? src : src.src;\n    return this; // L\u00e1ncolhat\u00f3s\u00e1g!\n};\nQ.Image.prototype.Clear = function(fill = this.options.fill) {\n    let ctx = this.node.getContext('2d');\n    ctx.fillStyle = fill;\n    ctx.fillRect(0, 0, this.node.width, this.node.height);\n    this.saveToHistory();\n    return this; \n};\nQ.Image.prototype.Render = function(target) {\n    const targetNode = (typeof target === 'string')\n        ? document.querySelector(target)\n        : (target instanceof HTMLElement)\n            ? target\n            : (target.nodes ? target.nodes[0] : null);\n    if (!targetNode) {\n        console.error('Invalid render target');\n        return this;\n    }\n    let ctxTarget;\n    if (targetNode.tagName.toLowerCase() === 'canvas') {\n        targetNode.width = this.node.width;\n        targetNode.height = this.node.height;\n        ctxTarget = targetNode.getContext('2d');\n        ctxTarget.drawImage(this.node, 0, 0);\n    } else if (targetNode.tagName.toLowerCase() === 'img') {\n        targetNode.src = this.node.toDataURL(`image/${this.options.format}`, this.options.quality);\n    } else {\n        console.error('Unsupported element for rendering');\n    }\n    return this;\n};\nQ.Image.prototype.Save = function(filename) {\n    const dataUrl = this.node.toDataURL('image/' + this.options.format, this.options.quality);\n    const link = document.createElement('a');\n    link.download = filename;\n    link.href = dataUrl;\n    link.click();\n    link.remove();\n    return this;\n};\nQ.Image.prototype.saveToHistory = function() {\n    if (this.history.isUndoRedoing || !this.options.autoSaveHistory) return;\n    if (this.node.width === 0 || this.node.height === 0) return;\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const imageData = ctx.getImageData(0, 0, this.node.width, this.node.height);\n    if (this.history.position < this.history.states.length - 1) {\n        this.history.states.length = this.history.position + 1;\n    }\n    this.history.states.push(imageData);\n    if (this.history.states.length > this.options.historyLimit) {\n        this.history.states.shift();\n        if (this.history.position > 0) {\n            this.history.position--;\n        }\n    } else {\n        this.history.position++;\n    }\n};\n/* \n * IMPORTANT: Every image manipulation method should call saveToHistory() \n * after modifying the canvas to ensure proper history tracking.\n */\nQ.Image.prototype.Undo = function() {\n    return this.History(-1);\n};\nQ.Image.prototype.Redo = function() {\n    return this.History(1);\n};\nQ.Image.prototype.History = function(offset) {\n    if (this.history.states.length === 0) {\n        console.warn('No history states available.');\n        return this;\n    }\n    const target = this.history.position + offset;\n    if (target < 0 || target >= this.history.states.length) {\n        console.warn('Nem lehets\u00e9ges tov\u00e1bbi visszal\u00e9p\u00e9s vagy el\u0151reugr\u00e1s.');\n        return this;\n    }\n    this.history.isUndoRedoing = true;\n    const ctx = this.node.getContext('2d', { willReadFrequently: true });\n    const historyState = this.history.states[target];\n    if (this.node.width !== historyState.width || this.node.height !== historyState.height) {\n        this.node.width = historyState.width;\n        this.node.height = historyState.height;\n    }\n    ctx.putImageData(historyState, 0, 0);\n    this.history.position = target;\n    this.history.isUndoRedoing = false;\n    return this;\n};"
        },
        "JSON": {
            "uuid": "388b3fd2-51e5-4a47-9b29-1583535f2139",
            "name": "JSON",
            "method": "Instance",
            "desc": "A utility class to parse, deflate, inflate, merge, sort, flatten, and unflatten JSON data.",
            "type": "Utility",
            "example": [
                "// Create a new JSON instance\nlet jsonData = { name: 'John', age: 30, city: 'New York' };\nlet jsonInstance = new Q.JSON(jsonData);",
                "// Parse the JSON data and modify the values\njsonInstance.Parse({ modify: true }, (key, value) => {\n  if (typeof value === 'string') return value.toUpperCase();\n  return value;\n});\nconsole.log(jsonInstance.json); // Output: { name: 'JOHN', age: 30, city: 'NEW YORK' }",
                "// Deflate the JSON data\nlet deflated = jsonInstance.deflate(3);\nconsole.log(deflated);",
                "// Inflate the JSON data\nlet inflatedData = jsonInstance.inflate(deflated);\nconsole.log(inflatedData);",
                "// Merge with another JSON object\nlet otherJson = { country: 'USA' };\njsonInstance.merge(otherJson);\nconsole.log(jsonInstance.json); // Output: { name: 'JOHN', age: 30, city: 'NEW YORK', country: 'USA' }",
                "// Sort the keys\njsonInstance.sortKeys();\nconsole.log(jsonInstance.json);",
                "// Flatten the JSON data\nlet flattened = jsonInstance.flatten();\nconsole.log(flattened);",
                "// Unflatten the JSON data\nlet unflattenedData = jsonInstance.unflatten(flattened);\nconsole.log(unflattenedData);"
            ],
            "dependencies": [],
            "script": "Q.JSON = function (jsonData) {\n    if (!(this instanceof Q.JSON)) return new Q.JSON(jsonData);\n    this.json = jsonData;\n};\nQ.JSON.prototype.Parse = function (options = { modify: false, recursive: false }, callback) {\n    const { modify, recursive } = options;\n    const process = (data) => {\n        if (typeof data === 'object' && data && !Array.isArray(data)) {\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    const newValue = callback(key, data[key]);\n                    if (modify) data[key] = newValue;\n                    if (recursive && typeof data[key] === 'object' && data[key]) process(data[key]);\n                }\n            }\n        }\n    };\n    process(this.json);\n    return this.json;\n};\nQ.JSON.prototype.deflate = function (level) {\n    const map = {}, deflateCounter = { count: 1 };\n    const replaceRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                if (typeof obj[key] === 'object' && obj[key]) replaceRecursive(obj[key]);\n                if (key.length >= level) {\n                    if (!map[key]) { map[key] = `[${deflateCounter.count++}]`; }\n                    const newKey = map[key];\n                    obj[newKey] = obj[key]; delete obj[key];\n                }\n                if (typeof obj[key] === 'string' && obj[key].length >= level) {\n                    if (!map[obj[key]]) { map[obj[key]] = `[${deflateCounter.count++}]`; }\n                    obj[key] = map[obj[key]];\n                }\n            }\n        }\n    };\n    const deflatedData = JSON.parse(JSON.stringify(this.json));\n    replaceRecursive(deflatedData);\n    return { data: deflatedData, map: map };\n};\nQ.JSON.prototype.inflate = function (deflatedJson) {\n    const { data, map } = deflatedJson;\n    const reverseMap = Object.fromEntries(Object.entries(map).map(([k, v]) => [v, k]));\n    const restoreRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                const originalKey = reverseMap[key] || key;\n                const value = obj[key]; delete obj[key];\n                obj[originalKey] = value;\n                if (typeof obj[originalKey] === 'object' && obj[originalKey]) {\n                    restoreRecursive(obj[originalKey]);\n                } else if (reverseMap[obj[originalKey]]) {\n                    obj[originalKey] = reverseMap[obj[originalKey]];\n                }\n            }\n        }\n    };\n    const inflatedData = JSON.parse(JSON.stringify(data));\n    restoreRecursive(inflatedData);\n    return inflatedData;\n};\nQ.JSON.prototype.merge = function (otherJson) {\n    const deepMerge = (target, source) => {\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                if (typeof source[key] === 'object' && source[key] && !Array.isArray(source[key])) {\n                    target[key] = deepMerge(target[key] && typeof target[key] === 'object' ? target[key] : {}, source[key]);\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return deepMerge(this.json, otherJson);\n};\nQ.JSON.prototype.sortKeys = function (recursive = false, reverse = false) {\n    const sortObject = (obj) => {\n        const keys = Object.keys(obj).sort();\n        if (reverse) keys.reverse();\n        const sorted = {};\n        keys.forEach(key => {\n            sorted[key] = (recursive && typeof obj[key] === 'object' && obj[key] && !Array.isArray(obj[key])) ? sortObject(obj[key]) : obj[key];\n        });\n        return sorted;\n    };\n    this.json = sortObject(this.json);\n    return this.json;\n};\nQ.JSON.prototype.sortValues = function (reverse = false) {\n    if (typeof this.json !== 'object' || !this.json) return this.json;\n    const entries = Object.entries(this.json).sort((a, b) => {\n        const aValue = String(a[1]), bValue = String(b[1]);\n        return aValue.localeCompare(bValue);\n    });\n    if (reverse) entries.reverse();\n    const sorted = {};\n    for (const [key, value] of entries) sorted[key] = value;\n    this.json = sorted;\n    return this.json;\n};\nQ.JSON.prototype.sortByValues = function (keyProp, valueProp, reverse = false) {\n    if (!Array.isArray(this.json)) return this.json;\n    this.json.sort((a, b) => {\n        const cmpKey = String(a[keyProp]).localeCompare(String(b[keyProp]));\n        const cmpValue = String(a[valueProp]).localeCompare(String(b[valueProp]));\n        const cmp = cmpKey || cmpValue;\n        return reverse ? -cmp : cmp;\n    });\n    return this.json;\n};\nQ.JSON.prototype.flatten = function (prefix = '') {\n    const result = {};\n    const flattenRec = (obj, path) => {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                const newKey = path ? `${path}.${key}` : key;\n                if (typeof obj[key] === 'object' && obj[key] && !Array.isArray(obj[key])) {\n                    flattenRec(obj[key], newKey);\n                } else {\n                    result[newKey] = obj[key];\n                }\n            }\n        }\n    };\n    flattenRec(this.json, prefix);\n    return result;\n};\nQ.JSON.prototype.unflatten = function (flatObject) {\n    const result = {};\n    Object.keys(flatObject).forEach(compoundKey => {\n        compoundKey.split('.').reduce((accumulator, currentKey, index, keysArray) => {\n            if (index === keysArray.length - 1) {\n                accumulator[currentKey] = flatObject[compoundKey];\n            } else {\n                if (!accumulator[currentKey] || typeof accumulator[currentKey] !== 'object') {\n                    accumulator[currentKey] = {};\n                }\n            }\n            return accumulator[currentKey];\n        }, result);\n    });\n    this.json = result;\n    return result;\n};"
        },
        "Socket": {
            "uuid": "83ffc354-637a-4843-9f94-5a117f9c34db",
            "name": "Socket",
            "method": "Static",
            "desc": "A utility function to create and manage WebSocket connections.",
            "type": "Utility",
            "example": [
                "// Create a new WebSocket connection\nlet socket = Q.Socket('ws://example.com', (data) => {\n  console.log('Message received:', data);\n}, (status) => {\n  console.log('Status:', status);\n}, {\n  retries: 5,\n  delay: 1000,\n  pingInterval: 30000,\n  pingMessage: 'ping',\n  queueMessages: true\n});",
                "// Send a message\nsocket.send('Hello, server!');",
                "// Reconnect the socket\nsocket.reconnect();",
                "// Close the socket\nsocket.close();",
                "// Get the socket state\nlet state = socket.getState();\nconsole.log('Socket state:', state);"
            ],
            "dependencies": [],
            "script": "Q.Socket = function (url, onMessage, onStatus, options = {}) {\n    const {\n        retries = 5,                   \n        delay = 1000,                  \n        protocols = [],                \n        backoff = false,               \n        pingInterval = 0,              \n        pingMessage = 'ping',          \n        queueMessages = false,         \n        autoReconnect = true,          \n        onOpen = null,                 \n        onClose = null,                \n        onError = null                 \n    } = options;\n    let socket, attempts = 0, currentDelay = delay, pingId = null;\n    const messageQueue = [];\n    const connect = () => {\n        socket = new WebSocket(url, protocols);\n        socket.onopen = () => {\n            attempts = 0;\n            currentDelay = delay;\n            onStatus?.('connected');\n            onOpen?.();\n            if (queueMessages && messageQueue.length) {\n                while (messageQueue.length) {\n                    socket.send(messageQueue.shift());\n                }\n            }\n            if (pingInterval) {\n                pingId && clearInterval(pingId);\n                pingId = setInterval(() => {\n                    if (socket.readyState === WebSocket.OPEN) {\n                        socket.send(pingMessage);\n                    }\n                }, pingInterval);\n            }\n        };\n        socket.onmessage = event => onMessage?.(event.data);\n        socket.onerror = error => {\n            onStatus?.('error', error);\n            onError?.(error);\n        };\n        socket.onclose = event => {\n            onClose?.(event);\n            pingId && clearInterval(pingId);\n            if (autoReconnect && (retries === 0 || attempts < retries)) {\n                onStatus?.('closed');\n                attempts++;\n                setTimeout(() => {\n                    connect();\n                    if (backoff) {\n                        currentDelay *= 2;\n                    }\n                }, currentDelay);\n            } else {\n                onStatus?.('Max retries exceeded');\n            }\n        };\n    };\n    connect();\n    return {\n        send: message => {\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                socket.send(message);\n            } else if (queueMessages) {\n                messageQueue.push(message);\n            }\n        },\n        reconnect: () => connect(),\n        close: () => {\n            autoReconnect = false;\n            pingId && clearInterval(pingId);\n            socket.close();\n        },\n        getState: () => socket?.readyState\n    };\n};"
        },
        "Storage": {
            "uuid": "ae74eafe-f741-41ef-a823-ded966114903",
            "name": "Storage",
            "method": "Static",
            "desc": "A utility function to manage data in localStorage with optional compression.",
            "type": "Utility",
            "example": [
                "// Store a string in localStorage with compression enabled\nQ.Storage('myString', 'Hello, world!', true);",
                "// Store a JSON object in localStorage\nQ.Storage('myObject', { name: 'John', age: 30 });",
                "// Retrieve the string from localStorage\nlet myString = Q.Storage('myString');\nconsole.log(myString); // Output: Hello, world!",
                "// Retrieve the JSON object from localStorage\nlet myObject = Q.Storage('myObject');\nconsole.log(myObject); // Output: { name: 'John', age: 30 }",
                "// Remove the key from localStorage\nQ.Storage('myString', null);"
            ],
            "dependencies": [],
            "script": "Q.Storage = (function () {\n    const lzw_compress = (input) => {\n        let dictionary = {}, current = \"\", result = \"\", code = 256;\n        for (let index = 0; index < input.length; index++) {\n            const character = input.charAt(index);\n            const combined = current + character;\n            if (Object.prototype.hasOwnProperty.call(dictionary, combined)) {\n                current = combined;\n            } else {\n                result += current.length > 1\n                    ? String.fromCharCode(dictionary[current])\n                    : String.fromCharCode(current.charCodeAt(0));\n                dictionary[combined] = code++;\n                current = character;\n            }\n        }\n        if (current !== \"\") {\n            result += current.length > 1\n                ? String.fromCharCode(dictionary[current])\n                : String.fromCharCode(current.charCodeAt(0));\n        }\n        return result;\n    };\n    const lzw_decompress = (input) => {\n        let dictionary = {}, current = String.fromCharCode(input.charCodeAt(0)),\n            previous = current, result = current, code = 256, entry;\n        for (let index = 1; index < input.length; index++) {\n            const currentCode = input.charCodeAt(index);\n            if (currentCode < 256) {\n                entry = String.fromCharCode(currentCode);\n            } else {\n                entry = Object.prototype.hasOwnProperty.call(dictionary, currentCode)\n                    ? dictionary[currentCode]\n                    : previous + current;\n            }\n            result += entry;\n            current = entry.charAt(0);\n            dictionary[code++] = previous + current;\n            previous = entry;\n        }\n        return result;\n    };\n    return function (storageKey, storageValue, compressionEnabled = false) {\n        if (arguments.length > 1) { \n            if (storageValue === null || storageValue === '') {\n                localStorage.removeItem(storageKey);\n                return;\n            }\n            let dataString = typeof storageValue === 'string'\n                ? 'S|' + storageValue\n                : 'J|' + JSON.stringify(storageValue);\n            if (compressionEnabled) {\n                dataString = 'C|' + lzw_compress(dataString);\n            }\n            localStorage.setItem(storageKey, dataString);\n        } else {\n            let dataString = localStorage.getItem(storageKey);\n            if (dataString === null) return null;\n            if (dataString.startsWith('C|')) {\n                dataString = lzw_decompress(dataString.slice(2));\n            }\n            if (dataString.startsWith('S|')) {\n                return dataString.slice(2);\n            }\n            if (dataString.startsWith('J|')) {\n                try { return JSON.parse(dataString.slice(2)); } \n                catch (error) { return dataString.slice(2); }\n            }\n            try { return JSON.parse(dataString); } \n            catch (error) { return dataString; }\n        }\n    };\n})();"
        },
        "String": {
            "uuid": "a903056a-ea3d-493a-9dc5-5db71067bdfa",
            "name": "String",
            "method": "Instance",
            "desc": "A utility class to perform string operations.",
            "type": "Utility",
            "example": [
                "// Create a new String instance\nlet stringInstance = new Q.String('hello world');",
                "// Capitalize the first letter\nlet capitalized = stringInstance.capitalize();\nconsole.log(capitalized); // Output: Hello world",
                "// Calculate the Levenshtein distance\nlet distance = stringInstance.levenshtein('hallo world');\nconsole.log(distance);",
                "// Find matches using a regular expression\nlet matches = stringInstance.find(/world/);\nconsole.log(matches);",
                "// Replace all occurrences of a string\nlet replaced = stringInstance.replaceAll('world', 'VulpiniQ');\nconsole.log(replaced); // Output: hello VulpiniQ"
            ],
            "dependencies": [],
            "script": "Q.String = function (string) {\n    if (!(this instanceof Q.String)) {\n        return new Q.String(string);\n    }\n    this.string = string;\n};\nQ.String.prototype.capitalize = function () {\n    return this.string.charAt(0).toUpperCase() + this.string.slice(1);\n};\nQ.String.prototype.levenshtein = function (string) {\n    const a = this.string, b = string;\n    const matrix = Array.from({ length: a.length + 1 }, (_, i) => Array.from({ length: b.length + 1 }, (_, j) => i || j));\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\nQ.String.prototype.find = function (stringOrRegex) {\n    return this.string.match(stringOrRegex);\n};\nQ.String.prototype.replaceAll = function (stringOrRegex, replacement) {\n    return this.string.replace(new RegExp(stringOrRegex, 'g'), replacement);\n};"
        },
        "Thread": {
            "uuid": "362c9a2c-adfc-487f-8cff-fa88a9bdb40d",
            "name": "Thread",
            "method": "Static",
            "desc": "A utility function to create and manage a thread pool for executing tasks in parallel using web workers.",
            "type": "Utility",
            "example": [
                "// Create a new thread pool with 4 workers\nlet threadPool = Q.Thread(4);",
                "// Push a task to the thread pool\nthreadPool.Push((input) => {\n  let sum = 0;\n  for (let i = 0; i < input; i++) {\n    sum += i;\n  }\n  return sum;\n}, 100000).then(result => {\n  console.log('Result:', result);\n});",
                "// Add a result callback\nthreadPool.Result((result) => {\n  console.log('Task completed:', result);\n});",
                "// Add a done callback\nthreadPool.Done(() => {\n  console.log('All tasks completed');\n});",
                "// Abort the thread pool\n// threadPool.Abort();"
            ],
            "dependencies": [],
            "script": "(() => {\n    class ThreadPool {\n      constructor(maxWorkers = 1) {\n        this.maxWorkers = maxWorkers;\n        this.workers = [];\n        this.taskQueue = [];\n        this.activeTasks = new Map();\n        this.taskIdCounter = 0;\n        this.resultCallbacks = [];\n        this.doneCallbacks = [];\n        this.aborted = false;\n        this.blobURL = ThreadPool._createWorkerBlob();\n        for (let index = 0; index < maxWorkers; index++) {\n          this._addWorker();\n        }\n      }\n      static _createWorkerBlob() {\n        const code = `\n          self.onmessage = event => {\n            const { taskId, functionCode, parameters } = event.data;\n            let executionFunction;\n            try {\n              executionFunction = eval('(' + functionCode + ')');\n            } catch (error) {\n              self.postMessage({ taskId, error: error.toString() });\n              return;\n            }\n            Promise.resolve().then(() => executionFunction(...parameters)).then(\n              result => self.postMessage({ taskId, result }),\n              error => self.postMessage({ taskId, error: error.toString() })\n            );\n          };\n        `;\n        return URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));\n      }\n      _addWorker() {\n        const workerInstance = new Worker(this.blobURL);\n        workerInstance.busy = false;\n        workerInstance.onmessage = event => {\n          const { taskId, result, error } = event.data;\n          workerInstance.busy = false;\n          const task = this.activeTasks.get(taskId);\n          if (task) {\n            error !== undefined ? task.reject(new Error(error)) : task.resolve(result);\n            this.resultCallbacks.forEach(callbackFunction => callbackFunction({ id: taskId, result, error }));\n            this.activeTasks.delete(taskId);\n          }\n          this._processQueue();\n        };\n        workerInstance.onerror = () => { workerInstance.busy = false; };\n        this.workers.push(workerInstance);\n      }\n      _processQueue() {\n        if (this.aborted) return;\n        while (true) {\n          const idleIndex = this.workers.findIndex(workerInstance => !workerInstance.busy);\n          if (idleIndex === -1 || this.workers.length <= this.maxWorkers) break;\n          this.workers[idleIndex].terminate();\n          this.workers.splice(idleIndex, 1);\n        }\n        for (const workerInstance of this.workers) {\n          if (!workerInstance.busy && this.taskQueue.length) {\n            const task = this.taskQueue.shift();\n            workerInstance.busy = true;\n            this.activeTasks.set(task.id, task);\n            workerInstance.postMessage({ taskId: task.id, functionCode: task.functionCode, parameters: task.parameters });\n          }\n        }\n        if (!this.taskQueue.length && !this.activeTasks.size) {\n          const callbacks = this.doneCallbacks.slice();\n          this.doneCallbacks.length = 0;\n          callbacks.forEach(callbackFunction => callbackFunction());\n        }\n      }\n      Workers(newWorkerCount) {\n        if (this.aborted) return this;\n        this.maxWorkers = newWorkerCount;\n        if (newWorkerCount > this.workers.length) {\n          for (let index = 0, difference = newWorkerCount - this.workers.length; index < difference; index++) {\n            this._addWorker();\n          }\n        } else {\n          this._processQueue();\n        }\n        return this;\n      }\n      Push(taskInput, ...parameters) {\n        if (this.aborted) return Promise.reject(new Error('Thread aborted'));\n        const taskFunction = typeof taskInput === 'function' ? taskInput : (() => taskInput);\n        const taskId = ++this.taskIdCounter;\n        const task = { id: taskId, functionCode: taskFunction.toString(), parameters, resolve: null, reject: null };\n        const promiseResult = new Promise((resolve, reject) => { task.resolve = resolve; task.reject = reject; });\n        this.taskQueue.push(task);\n        this._processQueue();\n        return promiseResult;\n      }\n      Result(callbackFunction) {\n        if (typeof callbackFunction === 'function') this.resultCallbacks.push(callbackFunction);\n        return this;\n      }\n      Done(callbackFunction) {\n        if (typeof callbackFunction !== 'function') return this;\n        if (!this.taskQueue.length && !this.activeTasks.size) callbackFunction();\n        else this.doneCallbacks.push(callbackFunction);\n        return this;\n      }\n      Abort() {\n        this.aborted = true;\n        while (this.taskQueue.length) this.taskQueue.shift().reject(new Error('Task aborted'));\n        this.activeTasks.forEach(task => task.reject(new Error('Task aborted')));\n        this.activeTasks.clear();\n        this.workers.forEach(workerInstance => workerInstance.terminate());\n        this.workers = [];\n        this.doneCallbacks.length = 0;\n        this.resultCallbacks.length = 0;\n        URL.revokeObjectURL(this.blobURL);\n        return this;\n      }\n    }\n    Q.Thread = (maxWorkers = 1) => new ThreadPool(maxWorkers);\n  })();"
        },
        "Timer": {
            "uuid": "07f28d83-f764-4d6a-8e11-306fce262e55",
            "name": "Timer",
            "method": "Static",
            "desc": "A utility function to create and manage timers.",
            "type": "Utility",
            "example": [
                "// Create a new timer that executes every second and stops after 5 ticks\nlet timer = Q.Timer(() => {\n  console.log('Tick');\n}, 'myTimer', {\n  tick: 5,\n  delay: 1000,\n  interrupt: true,\n  done: () => {\n    console.log('Timer done');\n  }\n});",
                "// Pause the timer\ntimer.pause();",
                "// Resume the timer\ntimer.resume();",
                "// Stop the timer\ntimer.stop();",
                "// Stop all active timers\nQ.Timer.stopAll();"
            ],
            "dependencies": [],
            "script": "Q.Timer = (callback, identifier, options = {}) => {\n    const defaults = { tick: 1, delay: 1000, interrupt: false, autoStart: true, done: null };\n    const config = { ...defaults, ...options };\n    if (!Q.Timer.activeTimers) Q.Timer.activeTimers = new Map();\n    if (config.interrupt && Q.Timer.activeTimers.has(identifier)) Q.Timer.stop(identifier);\n    const timerControl = {\n      id: identifier,\n      tickCount: 0,\n      isPaused: false,\n      remainingDelay: config.delay,\n      startTime: 0,\n      timerHandle: null,\n      pause() {\n        if (!this.isPaused) {\n          this.isPaused = true;\n          clearTimeout(this.timerHandle);\n          const elapsed = Date.now() - this.startTime;\n          this.remainingDelay = config.delay - elapsed;\n        }\n        return this;\n      },\n      resume() {\n        if (this.isPaused) {\n          this.isPaused = false;\n          startTick(this.remainingDelay);\n        }\n        return this;\n      },\n      stop() { Q.Timer.stop(this.id); }\n    };\n    const startTick = (delayTime) => {\n      timerControl.startTime = Date.now();\n      timerControl.timerHandle = setTimeout(function tickHandler() {\n        callback();\n        timerControl.tickCount++;\n        if (config.tick > 0 && timerControl.tickCount >= config.tick) {\n          Q.Timer.stop(identifier);\n          if (typeof config.done === 'function') config.done();\n        } else {\n          timerControl.startTime = Date.now();\n          timerControl.timerHandle = setTimeout(tickHandler, config.delay);\n        }\n      }, delayTime);\n    };\n    if (config.autoStart) startTick(config.delay);\n    Q.Timer.activeTimers.set(identifier, timerControl);\n    return timerControl;\n  };\n  Q.Timer.stop = (identifier) => {\n    if (Q.Timer.activeTimers?.has(identifier)) {\n      const timerControl = Q.Timer.activeTimers.get(identifier);\n      clearTimeout(timerControl.timerHandle);\n      Q.Timer.activeTimers.delete(identifier);\n    }\n  };\n  Q.Timer.stopAll = () => {\n    if (Q.Timer.activeTimers) {\n      Q.Timer.activeTimers.forEach(timerControl => clearTimeout(timerControl.timerHandle));\n      Q.Timer.activeTimers.clear();\n    }\n  };"
        }
    },
    "statics": {
        "Average Color": {
            "uuid": "b7ed5d8c-6c01-4679-a720-318d02d3dc23",
            "name": "Average Color",
            "method": "Static",
            "desc": "Calculates the average color of an image from a given source.",
            "type": "Image Processing",
            "example": [
                "const avatarUrl = 'https://example.com/profile.jpg';\nQ.AvgColor(avatarUrl, 'auto', (color) => {\n  document.body.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;\n});",
                "const canvas = document.getElementById('myCanvas');\nlet dominantColor;\nQ.AvgColor(canvas, 2, (result) => {\n  dominantColor = result;\n  console.log(`Average color: RGB(${result.r}, ${result.g}, ${result.b})`);\n});",
                "var headerImage = document.querySelector('.hero-image');\nvar sampleSize = 5;\nQ.AvgColor(headerImage.src, sampleSize, function(avgColor) {\n  const textColor = avgColor.r + avgColor.g + avgColor.b > 382 ? '#000' : '#fff';\n  headerImage.nextElementSibling.style.color = textColor;\n});"
            ],
            "dependencies": [],
            "script": "Q.AvgColor = (source, sampleSize, callback) => {\n    const image = new Image();\n    image.crossOrigin = 'Anonymous';\n    if (typeof source === 'string') image.src = source;\n    else if (source instanceof HTMLCanvasElement) image.src = source.toDataURL();\n    else return console.error(\"Invalid image source provided.\");\n    image.onload = () => {\n      const canvas = Object.assign(document.createElement('canvas'), { width: image.width, height: image.height });\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const data = context.getImageData(0, 0, image.width, image.height).data;\n      const samplingRate = sampleSize === 'auto'\n        ? Math.max(1, Math.ceil(Math.sqrt(image.width * image.height) / 32))\n        : (typeof sampleSize === 'number' && sampleSize > 0 ? sampleSize : 1);\n      let totalRed = 0, totalGreen = 0, totalBlue = 0, count = 0;\n      for (let index = 0, len = data.length; index < len; index += samplingRate * 4) {\n        totalRed   += data[index];\n        totalGreen += data[index + 1];\n        totalBlue  += data[index + 2];\n        count++;\n      }\n      const avgColor = { r: (totalRed / count) | 0, g: (totalGreen / count) | 0, b: (totalBlue / count) | 0 };\n      typeof callback === 'function' && callback(avgColor);\n    };\n    image.onerror = () => console.error(\"Failed to load image.\");\n  };"
        },
        "CMYK to RGB Converter": {
            "uuid": "6f4ae54c-f46e-4adc-8909-e8755230bce5",
            "name": "CMYK to RGB Converter",
            "method": "Static",
            "desc": "Converts CMYK (Cyan, Magenta, Yellow, Key/Black) color values to RGB (Red, Green, Blue) format.",
            "type": "Color Conversion",
            "example": [
                "// Convert a print-specific color from CMYK to RGB\nconst cyan = 0.75; // 75%\nconst magenta = 0.0; // 0%\nconst yellow = 0.75; // 75%\nconst black = 0.0; // 0%\nconst rgbColor = Q.CMYK2RGB(cyan, magenta, yellow, black);\nconsole.log(`R: ${rgbColor[0]}, G: ${rgbColor[1]}, B: ${rgbColor[2]}`);",
                "// Preview a CMYK color palette in RGB\nconst cmykPalette = [\n  [0.0, 0.8, 0.8, 0.0], // Red-like\n  [0.8, 0.0, 0.8, 0.0], // Green-like\n  [0.8, 0.8, 0.0, 0.0], // Blue-like\n];\nconst rgbPalette = cmykPalette.map(color => \n  Q.CMYK2RGB(color[0], color[1], color[2], color[3])\n);\nconsole.log('RGB Palette for display:', rgbPalette);"
            ],
            "dependencies": [],
            "script": "Q.CMYK2RGB = (c, m, y, k) => {\n  const r = 255 * (1 - c) * (1 - k);\n  const g = 255 * (1 - m) * (1 - k);\n  const b = 255 * (1 - y) * (1 - k);\n  return [Math.round(r), Math.round(g), Math.round(b)];\n};"
        },
        "Color Brightness": {
            "uuid": "1815efe2-1c9b-4514-8968-35ba90e8ed34",
            "name": "Color Brightness",
            "method": "Static",
            "desc": "Adjusts the brightness of a color by a specified percentage.",
            "type": "Color Manipulation",
            "example": [
                "const baseColor = '#3498db';\nconst highlightColor = Q.ColorBrightness(baseColor, 20);  // Lighten by 20%\nconst shadowColor = Q.ColorBrightness(baseColor, -30);  // Darken by 30%",
                "let primaryColor = 'rgb(52, 152, 219)';\nlet hoverState = Q.ColorBrightness(primaryColor, 15);\nlet activeState = Q.ColorBrightness(primaryColor, -10);",
                "var buttonColors = [];\nvar baseShade = 'rgba(52, 152, 219, 0.8)';\nfor (let i = -50; i <= 50; i += 25) {\n  buttonColors.push(Q.ColorBrightness(baseShade, i));\n}"
            ],
            "dependencies": [],
            "script": "Q.ColorBrightness = (inputColor, percent) => {\n    if (!/^#|^rgb/.test(inputColor)) throw new Error('Unsupported format');\n    let red, green, blue, alpha = 1, isHex = false, factor = 1 + percent / 100;\n    if (inputColor[0] === '#') {\n      isHex = true;\n      const hexString = inputColor.slice(1);\n      if (hexString.length === 3) {\n        red = parseInt(hexString[0] + hexString[0], 16);\n        green = parseInt(hexString[1] + hexString[1], 16);\n        blue = parseInt(hexString[2] + hexString[2], 16);\n      } else if (hexString.length === 6) {\n        red = parseInt(hexString.slice(0, 2), 16);\n        green = parseInt(hexString.slice(2, 4), 16);\n        blue = parseInt(hexString.slice(4, 6), 16);\n      }\n    } else {\n      const match = inputColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n      if (match) {\n        red = +match[1];\n        green = +match[2];\n        blue = +match[3];\n        if (match[4] != null) alpha = parseFloat(match[4]);\n      }\n    }\n    const clamp = value => Math.min(255, Math.max(0, Math.round(value * factor)));\n    red = clamp(red);\n    green = clamp(green);\n    blue = clamp(blue);\n    return isHex\n      ? '#' + [red, green, blue].map(component => (`0${component.toString(16)}`).slice(-2)).join('')\n      : (alpha === 1 ? `rgb(${red}, ${green}, ${blue})` : `rgba(${red}, ${green}, ${blue}, ${alpha})`);\n  };"
        },
        "Debounce": {
            "uuid": "1a0a5901-d127-4800-93ab-643cd1f7c242",
            "name": "Debounce",
            "method": "Static",
            "desc": "Delays the execution of a function until after a specified wait period has elapsed since the last invocation.",
            "type": "Performance Optimization",
            "example": [
                "// Debounce search input to reduce API calls\nconst searchInput = document.getElementById('search');\nsearchInput.addEventListener('input', function() {\n  Q.Debounce('search-query', 500, function() {\n    fetchSearchResults(searchInput.value);\n  });\n});",
                "// Debounce window resize handler\nlet chartWidth;\nwindow.addEventListener('resize', function() {\n  Q.Debounce('resize-chart', 250, function() {\n    chartWidth = window.innerWidth * 0.8;\n    redrawChart(chartWidth);\n  });\n});",
                "var saveButton = document.getElementById('save-form');\nvar formData = {};\nsaveButton.addEventListener('click', function() {\n  Q.Debounce('form-save', 300, function() {\n    saveData(formData);\n  });\n});"
            ],
            "dependencies": [],
            "script": "Q.Debounce = (id, time, callback) => {\n    const debounceStorage = Q.getGLOBAL('Debounce') || {};\n    debounceStorage[id] && clearTimeout(debounceStorage[id]);\n    debounceStorage[id] = setTimeout(callback, time);\n    Q.setGLOBAL({ Debounce: debounceStorage });\n  };"
        },
        "HSL to RGB Converter": {
            "uuid": "51959c50-818f-44eb-bff4-63a23e361f91",
            "name": "HSL to RGB Converter",
            "method": "Static",
            "desc": "Converts HSL (Hue, Saturation, Lightness) color values to RGB (Red, Green, Blue) format.",
            "type": "Color Conversion",
            "example": [
                "// Convert pure red in HSL to RGB\nconst hue = 0;        // Red in HSL has 0 hue\nconst saturation = 1;  // Full saturation\nconst lightness = 0.5; // Medium lightness\nconst rgbColor = Q.HSL2RGB(hue, saturation, lightness);\nconsole.log(`Red: ${Math.round(rgbColor[0])}, Green: ${Math.round(rgbColor[1])}, Blue: ${Math.round(rgbColor[2])}`);",
                "// Generate a rainbow color palette\nlet rainbowColors = [];\nfor (let i = 0; i < 360; i += 30) {\n  const h = i / 360;\n  const rgb = Q.HSL2RGB(h, 0.8, 0.5);\n  rainbowColors.push(`rgb(${Math.round(rgb[0])}, ${Math.round(rgb[1])}, ${Math.round(rgb[2])}`);\n}",
                "var h = 0.33; // Green hue\nvar s = 0.5;  // Medium saturation\nvar l = 0.7;  // Slightly lighter\nvar buttonColor = Q.HSL2RGB(h, s, l);\ndocument.querySelector('.success-button').style.backgroundColor = `rgb(${Math.round(buttonColor[0])}, ${Math.round(buttonColor[1])}, ${Math.round(buttonColor[2])})`;"
            ],
            "dependencies": [],
            "script": "Q.HSL2RGB = (h, s, l) => {\n    if (s === 0) {\n      const gray = l * 255;\n      return [gray, gray, gray];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s,\n          p = 2 * l - q,\n          hueToRgb = (t) => {\n            t < 0 && (t += 1);\n            t > 1 && (t -= 1);\n            return t < 1 / 6 ? p + (q - p) * 6 * t\n                 : t < 1 / 2 ? q\n                 : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t)\n                 : p;\n          };\n    return [hueToRgb(h + 1 / 3) * 255, hueToRgb(h) * 255, hueToRgb(h - 1 / 3) * 255];\n  };"
        },
        "ID Generator": {
            "uuid": "bf318cd3-8030-48da-9877-3a8a267e4f4f",
            "name": "ID Generator",
            "method": "Static",
            "desc": "Generates a random hexadecimal identifier with customizable length and prefix.",
            "type": "Utility",
            "example": [
                "// Create a basic ID with default length\nconst uniqueId = Q.ID();",
                "// Generate a longer ID with a descriptive prefix\nlet elementId = Q.ID(12, 'element-');\ndocument.getElementById('container').innerHTML = `<div id=\"${elementId}\">New Content</div>`;",
                "// Create multiple IDs for form elements\nvar inputId = Q.ID(10, 'input_');\nvar labelId = Q.ID(10, 'label_');\ndocument.querySelector('form').innerHTML += `<label id=\"${labelId}\" for=\"${inputId}\">Name:</label><input id=\"${inputId}\" type=\"text\">`;"
            ],
            "dependencies": [],
            "script": "Q.ID = (length = 8, prefix = '') =>\n    prefix + Array.from({ length }, () => (Math.random() * 16 | 0).toString(16)).join('');"
        },
        "Is Dark Color": {
            "uuid": "4af89b51-d450-4e6c-b7bc-58c7c8529d68",
            "name": "Is Dark Color",
            "method": "Static",
            "desc": "Determines if a color is considered dark based on its luminance value.",
            "type": "Color Analysis",
            "example": [
                "// Basic usage with a hex color\nconst backgroundColor = '#3498db';\nconst textColor = Q.isDarkColor(backgroundColor) ? '#ffffff' : '#000000';\ndocument.querySelector('.card').style.color = textColor;",
                "// Using RGB format with custom margin\nlet buttonColor = 'rgb(52, 152, 219)';\nlet textShade = Q.isDarkColor(buttonColor, 15) ? 'white' : 'black';\ndocument.getElementById('action-button').classList.add(`text-${textShade}`);",
                "// Custom threshold for special design cases\nvar headerBg = '#6a1b9a';\nvar customThreshold = 120;\nvar headerTextClass = Q.isDarkColor(headerBg, 10, customThreshold) ? 'light-text' : 'dark-text';\ndocument.querySelector('header').classList.add(headerTextClass);"
            ],
            "dependencies": [],
            "script": "Q.isDarkColor = (color, margin = 20, threshold = 100) => {\n    let red, green, blue;\n    if (color[0] === '#') {\n      const hex = color.slice(1);\n      const parts = hex.length === 3\n        ? [hex[0] + hex[0], hex[1] + hex[1], hex[2] + hex[2]]\n        : hex.length === 6\n        ? [hex.slice(0, 2), hex.slice(2, 4), hex.slice(4, 6)]\n        : null;\n      if (!parts) throw Error('Invalid hex format');\n      [red, green, blue] = parts.map(v => parseInt(v, 16));\n    } else if (color.startsWith('rgb')) {\n      const arr = color.match(/\\d+/g);\n      if (arr && arr.length >= 3) [red, green, blue] = arr.map(Number);\n      else throw Error('Invalid format');\n    } else throw Error('Unsupported format');\n    return Math.sqrt(0.299 * red ** 2 + 0.587 * green ** 2 + 0.114 * blue ** 2) + margin < threshold;\n  };"
        },
        "LAB to RGB Converter": {
            "uuid": "fbbf32ea-15e5-4408-8225-30fd4c9aa6bf",
            "name": "LAB to RGB Converter",
            "method": "Static",
            "desc": "Converts LAB (Lightness, a*, b*) color values to RGB (Red, Green, Blue) format.",
            "type": "Color Conversion",
            "example": [
                "// Convert a LAB color to RGB\nconst l = 54.29;\nconst a = 80.81;\nconst b = 69.89;\nconst rgbColor = Q.LAB2RGB(l, a, b);\nconsole.log(`R: ${rgbColor[0]}, G: ${rgbColor[1]}, B: ${rgbColor[2]}`);",
                "// Create a color manipulation function using LAB space\nfunction adjustSaturation(r, g, b, factor) {\n  // Convert to LAB\n  const lab = Q.RGB2LAB(r, g, b);\n  // Adjust a* and b* (color components) while preserving L (lightness)\n  lab[1] = lab[1] * factor;\n  lab[2] = lab[2] * factor;\n  // Convert back to RGB\n  return Q.LAB2RGB(lab[0], lab[1], lab[2]);\n}"
            ],
            "dependencies": [],
            "script": "Q.LAB2RGB = (L, a, b) => {\n  const fy = (L + 16) / 116;\n  const fx = a / 500 + fy;\n  const fz = fy - b / 200;\n  const xRef = 95.047;\n  const yRef = 100.0;\n  const zRef = 108.883;\n  const fx3 = Math.pow(fx, 3);\n  const fy3 = Math.pow(fy, 3);\n  const fz3 = Math.pow(fz, 3);\n  const x = xRef * (fx3 > 0.008856 ? fx3 : (fx - 16/116) / 7.787);\n  const y = yRef * (fy3 > 0.008856 ? fy3 : (fy - 16/116) / 7.787);\n  const z = zRef * (fz3 > 0.008856 ? fz3 : (fz - 16/116) / 7.787);\n  let r = (x * 0.032406 + y * -0.015372 + z * -0.004986) / 100;\n  let g = (x * -0.009689 + y * 0.018758 + z * 0.000415) / 100;\n  let b_val = (x * 0.000557 + y * -0.002040 + z * 0.010570) / 100;\n  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;\n  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;\n  b_val = b_val > 0.0031308 ? 1.055 * Math.pow(b_val, 1/2.4) - 0.055 : 12.92 * b_val;\n  r = Math.max(0, Math.min(1, r));\n  g = Math.max(0, Math.min(1, g));\n  b_val = Math.max(0, Math.min(1, b_val));\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b_val * 255)];\n};"
        },
        "RGB to CMYK Converter": {
            "uuid": "58e4ea40-303c-4999-b8e7-2a32f627c1b6",
            "name": "RGB to CMYK Converter",
            "method": "Static",
            "desc": "Converts RGB (Red, Green, Blue) color values to CMYK (Cyan, Magenta, Yellow, Key/Black) format.",
            "type": "Color Conversion",
            "example": [
                "// Convert a vivid red from RGB to CMYK\nconst red = 255;\nconst green = 0;\nconst blue = 0;\nconst cmykColor = Q.RGB2CMYK(red, green, blue);\nconsole.log(`C: ${(cmykColor[0] * 100).toFixed(0)}%, M: ${(cmykColor[1] * 100).toFixed(0)}%, Y: ${(cmykColor[2] * 100).toFixed(0)}%, K: ${(cmykColor[3] * 100).toFixed(0)}%`);",
                "// Compare ink usage between two colors\nconst color1 = Q.RGB2CMYK(200, 50, 50);\nconst color2 = Q.RGB2CMYK(50, 50, 200);\nconst inkUsage1 = color1[0] + color1[1] + color1[2] + color1[3];\nconst inkUsage2 = color2[0] + color2[1] + color2[2] + color2[3];\nconsole.log(`Color 1 ink usage: ${(inkUsage1 * 100).toFixed(1)}%`);\nconsole.log(`Color 2 ink usage: ${(inkUsage2 * 100).toFixed(1)}%`);"
            ],
            "dependencies": [],
            "script": "Q.RGB2CMYK = (r, g, b) => {\n  r = r / 255;\n  g = g / 255;\n  b = b / 255;\n  const k = 1 - Math.max(r, g, b);\n  if (k === 1) return [0, 0, 0, 1];\n  const c = (1 - r - k) / (1 - k);\n  const m = (1 - g - k) / (1 - k);\n  const y = (1 - b - k) / (1 - k);\n  return [c, m, y, k];\n};"
        },
        "RGB to HSL Converter": {
            "uuid": "d882374d-8c67-4c6b-a478-6e4274832601",
            "name": "RGB to HSL Converter",
            "method": "Static",
            "desc": "Converts RGB (Red, Green, Blue) color values to HSL (Hue, Saturation, Lightness) format.",
            "type": "Color Conversion",
            "example": [
                "// Convert a vivid red from RGB to HSL\nconst red = 255;\nconst green = 0;\nconst blue = 0;\nconst hslColor = Q.RGB2HSL(red, green, blue);\nconsole.log(`Hue: ${hslColor[0].toFixed(2)}, Saturation: ${hslColor[1].toFixed(2)}, Lightness: ${hslColor[2].toFixed(2)}`);",
                "// Generate a lighter shade of a color\nlet baseRed = 64;\nlet baseGreen = 128;\nlet baseBlue = 255;\nlet hsl = Q.RGB2HSL(baseRed, baseGreen, baseBlue);\nlet lighterHSL = [hsl[0], hsl[1], Math.min(1, hsl[2] + 0.2)];",
                "var rgb = {r: 142, g: 68, b: 173};\nvar hsl = Q.RGB2HSL(rgb.r, rgb.g, rgb.b);\nvar adjustedHue = (hsl[0] + 0.5) % 1; // Complementary color\nvar complementaryHsl = [adjustedHue, hsl[1], hsl[2]];"
            ],
            "dependencies": [],
            "script": "Q.RGB2HSL = (r, g, b) => {\n    r /= 255, g /= 255, b /= 255;\n    const max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2, d = max - min;\n    if (!d) h = s = 0;\n    else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0)\n        : max === g ? (b - r) / d + 2\n        : (r - g) / d + 4;\n      h /= 6;\n    }\n    return [h, s, l];\n  };"
        },
        "RGB to LAB Converter": {
            "uuid": "ef297fd7-84c1-4d67-998c-d5ca77d9b8e6",
            "name": "RGB to LAB Converter",
            "method": "Static",
            "desc": "Converts RGB (Red, Green, Blue) color values to LAB (Lightness, a*, b*) color space format.",
            "type": "Color Conversion",
            "example": [
                "// Convert a vivid red from RGB to LAB\nconst red = 255;\nconst green = 0;\nconst blue = 0;\nconst labColor = Q.RGB2LAB(red, green, blue);\nconsole.log(`L: ${labColor[0].toFixed(2)}, a*: ${labColor[1].toFixed(2)}, b*: ${labColor[2].toFixed(2)}`);",
                "// Use LAB color space for perceptual color distance calculation\nconst color1 = Q.RGB2LAB(255, 100, 50);\nconst color2 = Q.RGB2LAB(200, 150, 100);\nconst distance = Math.sqrt(\n  Math.pow(color2[0] - color1[0], 2) +\n  Math.pow(color2[1] - color1[1], 2) +\n  Math.pow(color2[2] - color1[2], 2)\n);\nconsole.log(`Perceptual color distance: ${distance.toFixed(2)}`);"
            ],
            "dependencies": [],
            "script": "Q.RGB2LAB = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n  const x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;\n  const y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;\n  const z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;\n  const xRef = 95.047;\n  const yRef = 100.0;\n  const zRef = 108.883;\n  const xNorm = x / xRef;\n  const yNorm = y / yRef;\n  const zNorm = z / zRef;\n  const fx = xNorm > 0.008856 ? Math.pow(xNorm, 1/3) : (7.787 * xNorm) + (16/116);\n  const fy = yNorm > 0.008856 ? Math.pow(yNorm, 1/3) : (7.787 * yNorm) + (16/116);\n  const fz = zNorm > 0.008856 ? Math.pow(zNorm, 1/3) : (7.787 * zNorm) + (16/116);\n  const L = (116 * fy) - 16;\n  const a = 500 * (fx - fy);\n  const b_val = 200 * (fy - fz);\n  return [L, a, b_val];\n};"
        }
    }
};
function Highlight(code) {
    // Function to escape HTML characters in code
    const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    code = escapeHTML(code);

    let patterns = [];

    let dictionary = [
        {
            find: ["Q"],
            open: "", 
            close: "", 
            className: "class",
            regex: "single",
            allowNested: false
        },
        {
            find: ["(", ")", "{", "}", "[", "]"],
            open: "", 
            close: "", 
            className: "bracket",
            regex: "single",
            allowNested: false
        },
        {
            find: ["'", '"'],
            open: "", 
            close: "", 
            className: "string",
            regex: "single",
            allowNested: false
        },
        {
            find: ["*"],
            open: "//", 
            close: "<br>", 
            className: "comment",
            regex: "between",
            allowNested: false
        },
        {
            find: ["function", "return", "if", "else", "for", "while"],
            open: "", 
            close: "", 
            className: "keyword",
            regex: "single",
            allowNested: false
        },
        {
            find: ["let", "var", "const"],
            open: "", 
            close: "", 
            className: "variable",
            regex: "single",
            allowNested: false
        }
    ];

    // Generate patterns from the dictionary
    dictionary.forEach(({ find, open, close, className, regex, allowNested }) => {
        let regexString = "";
        if (regex === "single") {
            // Join keywords with | for a single word match, using \b word boundaries
            regexString = `\\b(${find.map(item => item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join("|")})\\b`;
        } else if (regex === "between") {
            // Use non-capturing groups and lookahead/lookbehind for the between match
            regexString = `(${open})((?:(?!${close}).)*?)(${close})`;
        } else {
            regexString = regex; // Assume a custom regex is provided
        }

        patterns.push({
            regex: new RegExp(regexString, "g"),
            replace: `<span class='hl ${className}'>$&</span>`,
            allowNested
        });
    });

    // Apply patterns to the code
    patterns.forEach(({ regex, replace, allowNested }) => {
        code = code.replace(regex, (match, ...groups) => {
            // If allowNested is false, un-nest any nested spans inside
            if (!allowNested) {
                match = match.replace(/<span.*?>(.*?)<\/span>/g, '$1');
            }
            return replace.replace('$&', match);
        });
    });

    // Use a temporary container to parse and process the HTML
    let temp = document.createElement("div");
    temp.innerHTML = code;

    // Remove nested spans if necessary
    temp.querySelectorAll("span span").forEach(nested => {
        const parent = nested.parentElement;
        if (nested.classList.contains("hl")) {
            parent.replaceChild(document.createTextNode(nested.textContent), nested);
        }
    });

    return temp.innerHTML;
}

const IDS = {};

function CodeBuilder() {
    const activeBlocks = document.querySelectorAll(".block.active");


    const applyScript = (script) => {
        const sizedata = document.querySelector(".sizedata");
        let BaseScript = JSON.parse(JSON.stringify(DATA.frame));
        BaseScript = BaseScript.replace("return Q;", script + "\nreturn Q;");
        let codeBlock = document.querySelector(".codeData");
        codeBlock.innerHTML = minify(BaseScript);
        sizedata.innerHTML = "Library size: " + CalculateSizeKB(BaseScript);
    }




    if (!activeBlocks.length) {
        applyScript("");
        return;
    }

    const script = Array.from(activeBlocks)
        .map(block => {
            let blockScript = "";
            // Traverse the IDS structure to find the matching script
            for (const name in IDS) {
                const blockData = IDS[name];
                if (blockData.uuid == block.id) {
                    blockScript = blockData.script || "";
                    break;
                }
            }
            return blockScript;
        })
        .join("");

    applyScript(script);

    // console.log(script);
}


function classFormat(text) {
    return text.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");
}

function minify(code) {
    return code.replace(/^\s*/gm, "").replace(/\n/g, "");
}

function CalculateSizeKB(code) {
    return (new Blob([code]).size / 1024).toFixed(2) + " KB";
}

function createTags(tags) {
    const tagsContainer = document.createElement("div");
    tagsContainer.className = "tags";
    tags.forEach(tag => {
        const tagElement = document.createElement("span");
        tagElement.className = "tag";
        tagElement.innerHTML = tag;
        tagsContainer.appendChild(tagElement);
    });
    return tagsContainer;
}

function createCodeCategory(title) {
    const categoryContainer = document.createElement("div");
    categoryContainer.className = "code_category";
    categoryContainer.innerHTML = `<h2 class='code_category_title'>${title}</h2>`;
    const categoryContent = document.createElement("div");
    categoryContent.className = "code_content";
    categoryContent.id = classFormat(title);
    categoryContainer.appendChild(categoryContent);
    return categoryContainer;
}

function createBlock(contentData) {
    const { uuid, name, desc, example, dependencies } = contentData;
    const block = document.createElement("div");
    block.className = "block";
    block.id = uuid;
    block.innerHTML = `<h2>${name}</h2>`;

    const blockContent = document.createElement("div");
    blockContent.className = "block_content";
    block.appendChild(blockContent);

    blockContent.innerHTML = `<p>${desc}</p>`;
    const blockExample = document.createElement("div");
    blockExample.className = "block_example";
    
    if (Array.isArray(example)) {
        blockExample.innerHTML = example.map(ex => Highlight(ex.replace(/\n/g, "<br>"))).join("<br><br>");
    } else {
        blockExample.innerHTML = Highlight(example.replace(/\n/g, "<br>"));
    }

    blockContent.appendChild(blockExample);

    if (dependencies.length > 0) {
        const blockDependencies = document.createElement("div");
        blockDependencies.className = "block_dependencies";
        blockDependencies.innerHTML = "<b>Dependencies</b>";
        blockDependencies.appendChild(createTags(dependencies));
        blockContent.appendChild(blockDependencies);
    }

    block.addEventListener("click", function (event) {
        if (event.currentTarget.contains(event.target)) {
            block.classList.toggle("active");
            if (block.classList.contains("active")) {
                dependencies.forEach(dep => {
                    const depBlock = document.getElementById(IDS[dep]?.uuid);
                    if (depBlock && !depBlock.classList.contains("active")) {
                        depBlock.click();
                    }
                });
            }
            CodeBuilder();
        }
    });

    return block;
}

function createTab(name, identifier, contentData) {
    const tabHeader = document.querySelector(".tab_header");
    const tabContainer = document.querySelector(".tab_container");

    const tab = document.createElement("div");
    tab.className = "tab";
    tab.innerHTML = name;
    tab.setAttribute("data-identifier", identifier);

    const tabContent = document.createElement("div");
    tabContent.className = "tab_content";
    tabContent.setAttribute("data-identifier", identifier);

    const types = [...new Set(contentData.map(c => c.type))];
    types.forEach(type => tabContent.appendChild(createCodeCategory(type)));
    contentData.forEach(content => {
        tabContent.querySelector(`#${classFormat(content.type)}`).appendChild(createBlock(content));
    });

    tab.addEventListener("click", function () {
        document.querySelectorAll(".tab, .tab_content").forEach(el => el.classList.remove("active"));
        tab.classList.add("active");
        tabContent.classList.add("active");
    });

    tabHeader.appendChild(tab);
    tabContainer.appendChild(tabContent);

    return tab;
}

function createTabs() {
    const methods = new Set();
    Object.values(DATA).forEach(category => {
        if (typeof category === 'object') {
            console.log(category);
            const contentData = [];
            Object.values(category).forEach(({ method, uuid, desc, type, example, dependencies, script }) => {
                if (!methods.has(method)) {
                    methods.add(method);
                    Object.values(category).forEach(block => {
                        contentData.push({ ...block });
                        if (block.dependencies === undefined) {
                            block.dependencies = [];
                        }
                        IDS[block.name] = { uuid: block.uuid, script: block.script, dependencies: block.dependencies };
                    });
                    createTab(method, method, contentData);
                }
            });
        }
    });


    //choose .download button
    const downloadButton = document.querySelector(".download");
    const codeBlock = document.querySelector(".codeData");

    //add event listener to download button
    downloadButton.addEventListener("click", () => {
        const code = codeBlock.innerText;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vulpiniq.js";
        a.click();
        URL.revokeObjectURL(url);
    });


}

document.addEventListener("DOMContentLoaded", createTabs);
</script>
</head>
<body>
    <div class="container">
<div class="left_side">
<div class="header">
    <h1>VulpiniQ</h1>
    <p>Build your own VulpiniQ Library</p>
    </div>
<textarea class="codeData" placeholder="Enter your code here"></textarea>
<div class="footer">
    <div class="sizedata">No code recently</div>
    <button class="btn download">Download</button>
</div>
</div>
<div class="right_side">
    <div class="tab_header">
    </div>
    <div class="tab_container">
    </div>
</div>
    </div>
    <!-- <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>
    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div> -->
</body>
</html>