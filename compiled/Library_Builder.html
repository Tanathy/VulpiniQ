<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>
    <link rel="stylesheet" href="builder.css">
<style>*{ margin: 0; padding: 0; box-sizing: border-box; /* outline: 1px solid rgba(255, 255, 255, 0.2); */}body{ font-family: 'Arial', sans-serif; background-color: #0e0e0e; color: #a3a3a3; line-height: 1.6; font-size: 12px;}::-webkit-scrollbar{ width: 8px; height: 8px;}::-webkit-scrollbar-track{ background: #2e2e2e;}::-webkit-scrollbar-thumb{ background: #555; border-radius: 4px;}::-webkit-scrollbar-thumb:hover{ background: #777;}.container{ display: flex;}.left_side{width: 50%;background-color: #0000003d;border-right: 1px solid #ffffff15;}.right_side{ flex-shrink: 0; width: 50%;padding-left:5px}.tab_header{display:flex;}.tab{padding: 5px 15px;cursor: pointer;}.tab.active{background: rgba(255, 255, 255, 0.2);color: #c4c4c4;}.tab_container{overflow-x: hidden;height: calc(100vh - 30px);padding: 0 5px;}.tags{display: flex;flex-wrap: wrap;}.tag{ padding: 0px 9px; margin: 3px; background: #333; border-radius: 5px; cursor: default;}.block{ cursor: default;padding:10px; background: #ffffff09; border-radius: 10px; /* outline: 1px solid #ffffff10; */ width: 100%;}.block.active{ background: #ffffff18;}.block_example{ padding: 8px; background: #00000033; border-radius: 12px; width: 100%; margin-top: 10px;}.code_content{ display: grid; grid-template-columns: repeat(2, 1fr); /* Create 3 equal columns */ gap: 10px; /* Add gap between grid items */}.block_dependencies{ margin-top: 10px;}.block_title{ font-size: 16px; font-weight: bold; margin-bottom: 20px;}.code_category_title{ font-size: 20px; font-weight: bold; margin: 15px 0}.code_category{margin-bottom: 40px;}.codeData{ padding: 10px; background: #00000033; border-radius: 12px; width: calc(100% - 10px); height: 200px; margin-top: 10px; color: #a3a3a3; text-align: justify; border: 1px solid #ffffff10; box-sizing: border-box; margin: 5px; resize: vertical; max-height: 400px;}.codeData:focus{ outline: none;}.footer{display:flex;}.sizedata{ margin: 0 20px; display: flex; align-items: center;}.btn{ padding: 5px 10px; background: #333; color: #a3a3a3; border: none; border-radius: 5px; cursor: pointer;}.tab_content{ display: none;}.tab_content.active{ display: block;}.bracket{ color: #e7e192;}.bracket_inner{ color: #96a8f5;}.class,.object{ color: #bb6485; font-weight: bold;}.keyword{ color: #f78c6c;}.operator{ color: #ff5370;}.method{ color: #82aaff;}.string{ color: #d8a378; font-weight: bold;}.number{ color: #f78c6c;}.comment{ color: #428f59 !important;}</style>
<script>
var DATA = {
    "frame": "const Q = (() => {\n    'use strict';\nconst _ob = Object, _ar = Array, _ma = Math, _ac = AbortController, _as = AbortSignal, _bo = Boolean, _da = Date, _er = Error, _ev = Event, _pr = Promise, _nu = Number, _re = RegExp, _st = setTimeout, _un = undefined, _n = null, _nl = NodeList, _el = Element, _si = setInterval, _c = console, _f = fetch, _ct = clearTimeout;\n    let GLOBAL = {};\n    function Q(a, b, c) {\n        if (!(this instanceof Q)) {\n            return new Q(a, b, c);\n        }\n        else if (a?.nodeType === 1 || a?.nodeType != _n) {\n            this.nodes = [a];\n            return;\n        }\n        else if (a instanceof Q) {\n            this.nodes = a.nodes;\n            return;\n        }\n        else if (a?.constructor === _nl) {\n            this.nodes = _ar.from(a);\n            return;\n        }\n        else if (typeof a === 'string') {\n            let l = !!b || a.includes('<');\n            if (l) {\n                const e = document.createDocumentFragment();\n                const f = document.createElement('div');\n                f.innerHTML = a;\n                while (f.firstChild) {\n                    e.appendChild(f.firstChild);\n                }\n                this.nodes = _ar.from(e.childNodes);\n                if (b) {\n                    this.nodes.forEach(m => {\n                        for (const [g, h] of _ob.entries(b)) {\n                            if (g === 'class') {\n                                if (_ar.isArray(h)) {\n                                    m.classList.add(...h);\n                                }\n                                else {\n                                    m.classList.add(...h.split(/\\s+/));\n                                }\n                            }\n                            else if (g === 'style') {\n                                if (typeof h === 'object') {\n                                    for (const [i, j] of _ob.entries(h)) {\n                                        m.style[i] = j;\n                                    }\n                                }\n                                else {\n                                    m.style.cssText = h;\n                                }\n                            }\n                            else if (g === 'text') {\n                                m.textContent = h;\n                            }\n                            else if (g === 'html') {\n                                m.innerHTML = h;\n                            }\n                            else {\n                                m.setAttribute(g, h);\n                            }\n                        }\n                    });\n                }\n                if (c) {\n                    this.nodes.forEach(m => {\n                        for (const d of c) {\n                            m[d] = true;\n                        }\n                    });\n                }\n            } else {\n                let k = document.querySelectorAll(a);\n                this.nodes = _ar.from(k);\n            }\n        }\n    }\n    Q.Ext = (n, o) => (Q.prototype[n] = o, Q);\n    Q.getGLOBAL = function (i) {\n        return GLOBAL[i];\n    };\n    Q.setGLOBAL = function (h) {\n        GLOBAL = { ...GLOBAL, ...h };\n    };\n    return Q;\n})();",
    "basics": {
        "Done": {
            "uuid": "635f43f2-0076-4e15-baff-89b45938f08c",
            "name": "Done",
            "method": "Static",
            "desc": "Registers one or more callback functions to be executed once the window has completely loaded, ensuring that all resources are available. <br> Useful for executing scripts that depend on the DOM, images, or other resources being fully loaded. <br> This function allows for multiple callbacks to be registered, which will all be executed in the order they were added when the load event occurs.",
            "type": "Event Handling",
            "example": "Q.Done(() => { console.log('Window has fully loaded'); }); // Registers a callback to log a message once the window is loaded <br> Q.Done(() => { alert('Page is ready!'); }); // Adds another callback to show an alert when the window has fully loaded",
            "dependencies": [],
            "script": "Q.Done = (function () {\n    const callbacks = [];\n    window.addEventListener('load', () => {\n        callbacks.forEach(b => b());\n    });\n    return function (b) {\n        callbacks.push(b);\n    };\n})();"
        },
        "Leaving": {
            "uuid": "2b244602-ab35-4e0c-adcc-078270f63253",
            "name": "Leaving",
            "method": "Static",
            "desc": "Registers callbacks to be executed when the window is about to be unloaded, providing a chance to run cleanup tasks or warn the user about unsaved changes. <br> This can be useful for saving state, logging actions, or preventing accidental navigation away from the page. <br> Multiple callbacks can be registered, and they will be executed in the order they were added whenever the beforeunload event is triggered.",
            "type": "Event Handling",
            "example": "Q.Leaving((event) => { console.log('Window is about to be unloaded'); }); // Logs a message when the window is about to unload <br> Q.Leaving((event) => { event.returnValue = 'Are you sure you want to leave?'; }); // Prompts the user with a confirmation message before leaving",
            "dependencies": [],
            "script": "Q.Leaving = (function () {\n    const callbacks = [];\n    window.addEventListener('beforeunload', (b) => {\n        callbacks.forEach(c => c(b));\n    });\n    return function (c) {\n        callbacks.push(c);\n    };\n})();"
        },
        "Ready": {
            "uuid": "5781b52b-a679-480a-a64c-1f87035fea45",
            "name": "Ready",
            "method": "Static",
            "desc": "Registers callbacks to be executed once the DOM is fully loaded and parsed, ensuring your scripts can safely interact with the document's structure. <br> Ideal for initializing features, manipulating elements, or setting up event listeners without waiting for the entire page (images, styles) to load. <br> Multiple callbacks can be added, and they will be executed in sequence when the DOMContentLoaded event fires, or immediately if the DOM is already ready.",
            "type": "Event Handling",
            "example": "Q.Ready(() => { console.log('DOM is ready'); }); // Executes a callback when the DOM is fully loaded <br> Q.Ready(() => { document.body.style.backgroundColor = 'lightblue'; }); // Changes the background color once the DOM is ready",
            "dependencies": [],
            "script": "Q.Ready = (function () {\n    const callbacks = [];\n    document.addEventListener('DOMContentLoaded', () => {\n        callbacks.forEach(b => b());\n    }, { once: true });\n    return function (b) {\n        if (document.readyState === 'loading') {\n            callbacks.push(b);\n        } else {\n            b();\n        }\n    };\n})();"
        },
        "Resize": {
            "uuid": "a2f6a0f2-ebd4-49ea-ba5f-e164092c3702",
            "name": "Resize",
            "method": "Static",
            "desc": "Registers callbacks to be executed whenever the window is resized, providing the updated width and height. <br> This is useful for dynamic layouts, responsive design adjustments, or recalculating dimensions based on the window size. <br> Each registered callback will receive the current window width and height, and multiple callbacks can be added to handle different aspects of resizing.",
            "type": "Event Handling",
            "example": "Q.Resize((width, height) => { console.log(`Width: ${width}, Height: ${height}`); }); // Logs the new dimensions every time the window is resized <br> Q.Resize((width, height) => { document.body.style.fontSize = `${width / 100}px`; }); // Adjusts font size based on the window's width",
            "dependencies": [],
            "script": "Q.Resize = (function () {\n    const a = [];\n    window.addEventListener('resize', () => {\n        const b = window.innerWidth;\n        const c = window.innerHeight;\n        a.forEach(d => d(b, c));\n    });\n    return function (d) {\n        a.push(d);\n    };\n})();"
        }
    },
    "methods": {
        "addClass": {
            "uuid": "4e27b143-c49e-4238-b359-c997ab1f5dbf",
            "name": "addClass",
            "method": "Prototype",
            "desc": "Adds one or more classes to each node, ignoring duplicates.",
            "type": "Class Manipulation",
            "example": "Q(selector).addClass(\"class1\"); // Adds a single class <br> Q(selector).addClass(\"class1 class2\"); // Adds multiple classes",
            "dependencies": [],
            "script": "Q.Ext('addClass', function (classes) {\n    const b = classes.split(' ');\n    return this.each(c => this.nodes[c].classList.add(...b));\n});"
        },
        "animate": {
            "uuid": "4b615cef-2e48-460b-80cc-3b516cc4f2a6",
            "name": "animate",
            "method": "Prototype",
            "desc": "Animates each node using specified CSS properties over a given duration, with an optional callback when complete.",
            "type": "Animation",
            "example": "Q(selector).animate(500, { opacity: 0 }, () => { console.log('Fade out complete'); }); // Fades out over 500ms <br> Q(selector).animate(1000, { left: \"100px\", top: \"50px\" }); // Moves to new position in 1 second <br> Q(selector).animate(700, { opacity: 1, backgroundColor: \"#ff0000\" }, () => { alert('Animation finished!'); }); // Changes opacity and background color",
            "dependencies": [
                "each"
            ],
            "script": "Q.Ext('animate', function (duration, b, e) {\n    return this.each(g => {\n        const f = this.nodes[g];\n        const c = _ob.keys(b).map(d => `${d} ${duration}ms`).join(', ');\n        f.style.transition = c;\n        for (const d in b) {\n            f.style[d] = b[d];\n        }\n        if (typeof e === 'function') {\n            _st(() => {\n                if (e) e.call(f);\n            }, duration);\n        }\n    }), this;\n});"
        },
        "append": {
            "uuid": "c4986bf7-d586-442f-becd-801c2cb1a7bb",
            "name": "append",
            "method": "Prototype",
            "desc": "Appends child nodes, HTML, or multiple elements to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).append(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML <br> Q(selector).append(document.createElement(\"div\")); // Adds a div element <br> Q(selector).append(Q(otherSelector)); // Appends a Q object <br> Q(selector).append([document.createElement(\"span\"), document.createElement(\"img\")]); // Appends multiple elements <br> Q(selector).append(document.querySelectorAll(\".items\")); // Appends a NodeList of elements",
            "dependencies": [],
            "script": "Q.Ext('append', function (...allNodes) {\n    return this.each(el => {\n        const b = this.nodes[el];\n        allNodes.forEach(c => {\n            if (typeof c === 'string') {\n                b.insertAdjacentHTML('beforeend', c);\n            } else if (c?.nodeType === 1 || c instanceof Q) {\n                b.appendChild(c.nodes[0]);\n            } else if (_ar.isArray(c) || c?.constructor === _nl) {\n                _ar.from(c).forEach(d => b.appendChild(d));\n            }\n        });\n    });\n});"
        },
        "attr": {
            "uuid": "dac8a7a2-0d5c-42da-bad8-82813d20cc9f",
            "name": "attr",
            "method": "Prototype",
            "desc": "Gets or sets attributes on the nodes, supporting multiple attributes at once.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).attr(\"id\", \"newId\"); // Sets the \"id\" attribute to \"newId\" <br> Q(selector).attr({ \"src\": \"image.jpg\", \"alt\": \"An image\" }); // Sets multiple attributes <br> Q(selector).attr(\"href\"); // Gets the \"href\" attribute value",
            "dependencies": [],
            "script": "Q.Ext('attr', function (attribute, b) {\n    if (typeof attribute === 'object') {\n        return this.each(d => {\n            for (let c in attribute) {\n                if (attribute.hasOwnProperty(c)) {\n                    this.nodes[d].setAttribute(c, attribute[c]);\n                }\n            }\n        });\n    } else {\n        if (b === _un) {\n            return this.nodes[0]?.getAttribute(attribute) || _n;\n        }\n        return this.each(d => this.nodes[d].setAttribute(attribute, b));\n    }\n});"
        },
        "bind": {
            "uuid": "7a71744a-57e1-42b4-b6e7-beff42039f2d",
            "name": "bind",
            "method": "Prototype",
            "desc": "Adds an event listener to each node, allowing for event delegation to improve performance.",
            "type": "Event Handling",
            "example": "Q(selector).bind(\"click\", () => console.log(\"Clicked\")); // Logs \"Clicked\" when any matching node is clicked <br> Q(\".btn\").bind(\"mouseover\", (e) => { console.log(`Hovered over: ${e.target.tagName}`); }); // Logs the tag name of the hovered element <br> Q(\"ul\").bind(\"click\", (e) => { console.log(`Item clicked: ${e.target.textContent}`); }); // Logs the text of the clicked list item",
            "dependencies": [],
            "script": "Q.Ext('bind', function (a, b) {\n    if (!this.d) {\n        this.d = {};\n    }\n    if (!this.d[a]) {\n        document.addEventListener(a, (e) => {\n            this.each(c => {\n                if (this.nodes[c].contains(e.target)) {\n                    b.call(e.target, e);\n                }\n            });\n        });\n        this.d[a] = true;\n    }\n    return this;\n});"
        },
        "blur": {
            "uuid": "00d3b9d8-3808-43dc-b1c0-d2e81bec6091",
            "name": "blur",
            "method": "Prototype",
            "desc": "Removes focus from the first node in the selection, effectively blurring it.",
            "type": "Form Manipulation",
            "example": "Q(selector).blur(); // Removes focus from the first matched input field <br> Q(\".active\").blur(); // Blurs the first active element <br> Q(\"textarea\").blur(); // Blurs the first textarea in the selection",
            "dependencies": [],
            "script": "Q.Ext('blur', function () {\n    return this.each(a => this.nodes[a].blur());\n});"
        },
        "children": {
            "uuid": "eb46fc70-3c7d-4c14-8c5c-ddcfb28e655a",
            "name": "children",
            "method": "Prototype",
            "desc": "Retrieves the direct child nodes of the first node in the selection.",
            "type": "Traversal",
            "example": "Q(selector).children(); // Returns all child nodes of the first matched element <br> Q(\"#parent\").children(); // Gets all children of the element with id 'parent' <br> Q(\"ul\").children(); // Retrieves all child nodes of the first unordered list",
            "dependencies": [],
            "script": "Q.Ext('children', function () {\n    return new Q(this.nodes[0].children);\n});"
        },
        "click": {
            "uuid": "d4f1fb6f-c75b-426f-967e-4cf20fc98dbc",
            "name": "click",
            "method": "Prototype",
            "desc": "Simulates a click event on each node in the selection.",
            "type": "Event Handling",
            "example": "Q(selector).click(); // Triggers a click event on all matched elements <br> Q(\".button\").click(); // Simulates clicks on all elements with the class 'button' <br> Q(\"a\").click(); // Automatically clicks the first anchor element in the selection",
            "dependencies": [],
            "script": "Q.Ext('click', function () {\n    return this.each(el => this.nodes[el].click());\n});"
        },
        "clone": {
            "uuid": "3125d6f6-eaa9-4e93-8654-2545a9944c9e",
            "name": "clone",
            "method": "Prototype",
            "desc": "Creates a deep copy of the first node in the selection, including its child nodes.",
            "type": "DOM Manipulation",
            "example": "Q(selector).clone(); // Clones the first matched element <br> const newElement = Q(\".item\").clone(); // Clones the first element with the class 'item' and stores it in newElement <br> const clonedDiv = Q(\"#myDiv\").clone(); // Clones the element with the ID 'myDiv'",
            "dependencies": [],
            "script": "Q.Ext('clone', function () {\n    return new Q(this.nodes[0].cloneNode(true));\n});"
        },
        "closest": {
            "uuid": "46b990a4-72ea-4455-aabc-67cc8b649d73",
            "name": "closest",
            "method": "Prototype",
            "desc": "Finds the nearest ancestor node of the first node that matches a given selector.",
            "type": "Traversal",
            "example": "Q(selector).closest(\".parent\"); // Returns the closest parent with class 'parent' <br> const closestSection = Q(\".child\").closest(\"section\"); // Finds the closest section ancestor of the first element with the class 'child' <br> const closestForm = Q(\"#inputField\").closest(\"form\"); // Gets the nearest form ancestor of the element with ID 'inputField'",
            "dependencies": [],
            "script": "Q.Ext('closest', function (selector) {\n    let el = this.nodes[0];\n    while (el) {\n        if (el.matches && el.matches(selector)) {\n            return new Q(el);\n        }\n        el = el.parentElement;\n    }\n    return _n;\n});"
        },
        "css": {
            "uuid": "9c74db66-079a-4d0d-b1f4-4e2d9d4e28ad",
            "name": "css",
            "method": "Prototype",
            "desc": "Retrieves or sets CSS styles on the selected nodes. Supports setting multiple styles if provided as an object.",
            "type": "Style Manipulation",
            "example": "Q(selector).css('color', 'red'); // Sets the text color of the first selected element to red <br> const backgroundColor = Q(selector).css('background-color'); // Gets the background color of the first selected element <br> Q(selector).css({ margin: '10px', padding: '5px' }); // Sets multiple styles on each selected element",
            "dependencies": [],
            "script": "Q.Ext('css', function(property, b) {\n    if (typeof property === 'object') {\n        return this.each(d => {\n            for (let c in property) {\n                if (property.hasOwnProperty(c)) {\n                    this.nodes[d].style[c] = property[c];\n                }\n            }\n        });\n    } else {\n        if (b === _un) {\n            return getComputedStyle(this.nodes[0])[property];\n        }\n        return this.each(d => this.nodes[d].style[property] = b);\n    }\n});"
        },
        "data": {
            "uuid": "86e0504b-3275-4881-9f08-85da0063e431",
            "name": "data",
            "method": "Prototype",
            "desc": "Retrieves or sets data-* attributes on the selected nodes. Provides an easy way to store and access custom data associated with the elements.",
            "type": "Data Manipulation",
            "example": "Q(selector).data('userId', 123); // Sets the data-userId attribute to 123 on each selected element <br> const userId = Q(selector).data('userId'); // Retrieves the value of the data-userId attribute from the first selected element <br> const isActive = Q(selector).data('isActive'); // Retrieves the value of the data-isActive attribute, returns null if not set",
            "dependencies": [],
            "script": "Q.Ext('data', function (key, b) {\n    if (b === _un) {\n        return this.nodes[0]?.dataset[key] || _n;\n    }\n    return this.each(c => this.nodes[c].dataset[key] = b);\n});"
        },
        "each": {
            "uuid": "be78b913-75e7-424f-8e03-4748220bc9f2",
            "name": "each",
            "method": "Prototype",
            "desc": "Iterates over all nodes in the Q object and executes a callback on each node, providing access to the index and element.",
            "type": "Iteration",
            "example": "Q(selector).each((index, element) => console.log(index, element)); // Logs the index and element for each node in the selection <br> Q(selector).each((index, element) => element.style.color = 'red'); // Changes the text color to red for each selected element",
            "dependencies": [],
            "script": "Q.Ext('each', function (callback) {\n    if (!this.nodes) return this;\n    this.nodes.forEach((b, c) => callback.call(b, c, b));\n    return this;\n});"
        },
        "empty": {
            "uuid": "b368713e-38fd-45cd-ac3d-b14231e8569f",
            "name": "empty",
            "method": "Prototype",
            "desc": "Empties the innerHTML of each node.",
            "type": "Content Manipulation",
            "example": "Q(selector).empty();",
            "dependencies": [],
            "script": "Q.Ext('empty', function () {\n    return this.each(a => this.nodes[a].innerHTML = '');\n});"
        },
        "eq": {
            "uuid": "b7fe9562-121c-4af3-bc94-80d346f89971",
            "name": "eq",
            "method": "Prototype",
            "desc": "Returns a specific node by index.",
            "type": "Traversal",
            "example": "Q(selector).eq(1);",
            "dependencies": [],
            "script": "Q.Ext('eq', function (index) {\n    return new Q(this.nodes[index]);\n});"
        },
        "fadeIn": {
            "uuid": "705731b6-86ab-42f2-8c4b-fab966eb184a",
            "name": "fadeIn",
            "method": "Prototype",
            "desc": "Fades in each node.",
            "type": "Display",
            "example": "Q(selector).fadeIn(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeIn', function (a = 400, b) {\n    return this.each(c => {\n        this.nodes[c].style.display = '';\n        this.nodes[c].style.transition = `opacity ${a}ms`;\n        this.nodes[c].offsetHeight;\n        this.nodes[c].style.opacity = 1;\n        _st(() => {\n            this.nodes[c].style.transition = '';\n            if (b) b();\n        }, a);\n    });\n});"
        },
        "fadeOut": {
            "uuid": "5eaa6069-b381-41c2-9964-fc1477d02a96",
            "name": "fadeOut",
            "method": "Prototype",
            "desc": "Fades out each node.",
            "type": "Display",
            "example": "Q(selector).fadeOut(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeOut', function (a, b) {\n    return this.each(c => {\n        this.nodes[c].style.transition = `opacity ${a}ms`;\n        this.nodes[c].style.opacity = 0;\n        _st(() => {\n            this.nodes[c].style.transition = '';\n            this.nodes[c].style.display = 'none';\n            if (b) b();\n        }, a);\n    });\n});"
        },
        "fadeTo": {
            "uuid": "b44ca2ea-0c7e-4fff-8643-f8d364e34db7",
            "name": "fadeTo",
            "method": "Prototype",
            "desc": "Fades each node to a specific opacity.",
            "type": "Display",
            "example": "Q(selector).fadeTo(opacity, duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeTo', function (opacity, b, c) {\n    return this.each(d => {\n        this.nodes[d].style.transition = `opacity ${b}ms`;\n        this.nodes[d].offsetHeight;\n        this.nodes[d].style.opacity = opacity;\n        _st(() => {\n            this.nodes[d].style.transition = '';\n            if (c) c();\n        }, b);\n    });\n});"
        },
        "fadeToggle": {
            "uuid": "f8dcef4a-0da4-4491-ace8-d96d48fb0615",
            "name": "fadeToggle",
            "method": "Prototype",
            "desc": "Toggles the fade state of each node.",
            "type": "Display",
            "example": "Q(selector).fadeToggle(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeToggle', function (a, b) {\n    return this.each(c => {\n        if (window.getComputedStyle(this.nodes[c]).opacity === '0') {\n            this.fadeIn(a, b);\n        } else {\n            this.fadeOut(a, b);\n        }\n    });\n});"
        },
        "find": {
            "uuid": "e17b83ee-d814-46ef-92c4-eca54a237a75",
            "name": "find",
            "method": "Prototype",
            "desc": "Finds child nodes of the first node that match a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).find(\".child\");",
            "dependencies": [],
            "script": "Q.Ext('find', function (selector) {\n    const b = this.nodes[0].querySelectorAll(selector);\n    return b.length ? Q(b) : _n;\n});"
        },
        "first": {
            "uuid": "05348608-fb62-4958-922a-22282f890617",
            "name": "first",
            "method": "Prototype",
            "desc": "Returns the first node.",
            "type": "Traversal",
            "example": "Q(selector).first();",
            "dependencies": [],
            "script": "Q.Ext('first', function () {\n    return new Q(this.nodes[0]);\n});"
        },
        "focus": {
            "uuid": "15a8f60d-0fc9-4c54-bc82-c26cda75582b",
            "name": "focus",
            "method": "Prototype",
            "desc": "Focuses on the first node.",
            "type": "Form Manipulation",
            "example": "Q(selector).focus();",
            "dependencies": [],
            "script": "Q.Ext('focus', function () {\n    return this.each(a => this.nodes[a].focus());\n});"
        },
        "hasClass": {
            "uuid": "d1039a8c-9431-4156-9f5a-fd1b1c38dd6a",
            "name": "hasClass",
            "method": "Prototype",
            "desc": "Checks if the first node has a specific class.",
            "type": "Class Manipulation",
            "example": "Q(selector).hasClass(className);",
            "dependencies": [],
            "script": "Q.Ext('hasClass', function (className) {\n    return this.nodes[0]?.classList.contains(className) || false;\n});"
        },
        "height": {
            "uuid": "8323f664-0bd8-440f-a38a-9376e8f4c585",
            "name": "height",
            "method": "Prototype",
            "desc": "Gets or sets the height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).height(value);",
            "dependencies": [],
            "script": "Q.Ext('height', function (a) {\n    if (a === _un) {\n        return this.nodes[0].offsetHeight;\n    }\n    return this.each(b => this.nodes[b].style.height = a);\n});"
        },
        "hide": {
            "uuid": "4ed80d1c-4da6-48d1-896a-607784b89220",
            "name": "hide",
            "method": "Prototype",
            "desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).hide(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('hide', function (duration = 0, b) {\n    return this.each(e => {\n        const c = this.nodes[e];\n        if (duration === 0) {\n            c.style.display = 'none';\n            if (b) b();\n        } else {\n            c.style.transition = `opacity ${duration}ms`;\n            c.style.opacity = 1;\n            _st(() => {\n                c.style.opacity = 0;\n                c.addEventListener('transitionend', function d() {\n                    c.style.display = 'none';\n                    c.style.transition = '';\n                    c.removeEventListener('transitionend', d);\n                    if (b) b();\n                });\n            }, 0);\n        }\n    });\n});"
        },
        "html": {
            "uuid": "9a524261-a47b-4018-9055-4cc3025fac76",
            "name": "html",
            "method": "Prototype",
            "desc": "Gets or sets the innerHTML of the nodes. This method allows for easy manipulation of the content inside the selected elements.",
            "type": "Content Manipulation",
            "example": "const currentHtml = Q(selector).html(); // Retrieves the innerHTML of the first selected element <br> Q(selector).html('<div>New Content</div>'); // Sets the innerHTML of each selected element to '<div>New Content</div>' <br> Q(selector).html(['<span>First</span>', '<span>Second</span>']); // Sets the innerHTML with an array of strings <br> const newNode = Q('<p>Paragraph</p>'); Q(selector).html(newNode); // Sets the innerHTML with a Q object containing a new node <br> Q(selector).html(document.createElement('div')); // Sets the innerHTML with a new HTMLElement <br> const nodeList = document.querySelectorAll('.child'); Q(selector).html(nodeList); // Sets the innerHTML with a NodeList of child elements <br> Q(selector).html([]); // Sets the innerHTML to an empty string <br> Q(selector).html(null); // Sets the innerHTML to an empty string",
            "dependencies": [],
            "script": "Q.Ext('html', function (content) {\n    if (content === _un) {\n        return this.nodes[0]?.innerHTML || _n;\n    }\n    return this.each(c => {\n        c = this.nodes[c];\n        c.innerHTML = '';\n        content.forEach(b => {\n            if (typeof b === 'string') {\n                c.insertAdjacentHTML('beforeend', b);\n            } else if (b instanceof Q) {\n                b.nodes.forEach(d => c.appendChild(d));\n            } else if (b?.nodeType === 1) {\n                c.appendChild(b);\n            } else if (_ar.isArray(b) || b?.constructor === _nl) {\n                _ar.from(b).forEach(e => c.appendChild(e));\n            }\n        });\n    });\n});"
        },
        "id": {
            "uuid": "d858642d-282f-4085-b165-6ac45dfc7a93",
            "name": "id",
            "method": "Prototype",
            "desc": "Gets or sets the id attribute of the first node. This provides a simple way to retrieve or modify the unique identifier of an element.",
            "type": "Attributes",
            "example": "const currentId = Q(selector).id(); // Retrieves the current id of the first selected element <br> Q(selector).id('new-id'); // Sets the id of the first selected element to 'new-id'",
            "dependencies": [],
            "script": "Q.Ext('id', function (ident) {\n    if (ident === _un) {\n        return this.nodes[0].id;\n    }\n    return this.nodes[0].id = ident;\n});"
        },
        "index": {
            "uuid": "29a471bc-b2dd-43c4-b81f-f4a3e3455ff0",
            "name": "index",
            "method": "Prototype",
            "desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
            "type": "Traversal",
            "example": "const idx = Q(selector).index(); // Retrieves the index of the first selected node among its siblings <br> Q(selector).index(2); // Moves the first selected node to the index position 2 within its parent",
            "dependencies": [],
            "script": "Q.Ext('index', function (index) {\n    if (index === _un) {\n        return _ar.from(this.nodes[0].parentNode.children).indexOf(this.nodes[0]);\n    }\n    return this.each(f => {\n        const b = this.nodes[f].parentNode;\n        const c = _ar.from(b.children);\n        const d = c.indexOf(f);\n        const e = c.splice(index, 1)[0];\n        if (d < index) {\n            b.insertBefore(e, f);\n        } else {\n            b.insertBefore(e, this.nodes[f].nextSibling);\n        }\n    });\n});"
        },
        "inside": {
            "uuid": "21fc1d89-25dd-4f80-976f-866e1b66d224",
            "name": "inside",
            "method": "Prototype",
            "desc": "Checks if the first node is inside another node, determined by a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).inside(\".parent\"); // Returns true if the first selected element is within a parent matching the selector <br> const isChild = Q(selector).inside(\"#container\"); // Checks if the first node is inside the element with ID \"container\"",
            "dependencies": [],
            "script": "Q.Ext('inside', function (selector) {\n    return this.nodes[0]?.closest(selector) !== _n;\n});"
        },
        "is": {
            "uuid": "924358a1-f541-4f7a-8369-ea2bf6309f31",
            "name": "is",
            "method": "Prototype",
            "desc": "Checks if the first node matches a specific selector or condition, allowing for dynamic queries and element comparisons.",
            "type": "Utilities",
            "example": "Q(selector).is(\":visible\"); // Checks if the element is currently visible <br> Q(selector).is(\":checked\"); // Checks if a checkbox or radio button is checked <br> Q(selector).is(anotherElement); // Compares the first node with another DOM element <br> Q(selector).is(\":hover\"); // Checks if the element is currently being hovered over",
            "dependencies": [],
            "script": "Q.Ext('is', function (selector) {\n    const b = this.nodes[0];\n    if (!b) return false;\n    if (typeof selector === 'function') {\n        return selector.call(b, 0, b);\n    }\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return b.offsetWidth > 0 && b.offsetHeight > 0;\n            case ':hidden':\n                return b.offsetWidth === 0 || b.offsetHeight === 0;\n            case ':hover':\n                return b === document.querySelector(':hover');\n            case ':focus':\n                return b === document.activeElement;\n            case ':blur':\n                return b !== document.activeElement;\n            case ':checked':\n                return b.checked;\n            case ':selected':\n                return b.selected;\n            case ':disabled':\n                return b.disabled;\n            case ':enabled':\n                return !b.disabled;\n            default:\n                return b.matches(selector);\n        }\n    }\n    if (selector?.nodeType === 1 || selector?.nodeType != _n) {\n        return b === selector;\n    }\n    if (selector instanceof Q) {\n        return b === selector.nodes[0];\n    }\n    return false;\n});"
        },
        "isExists": {
            "uuid": "61b86904-45fe-411c-b37d-06af50a622be",
            "name": "isExists",
            "method": "Prototype",
            "desc": "Checks if the first node exists in the DOM.",
            "type": "Utilities",
            "example": "Q(selector).isExists(); or Q.isExists('.ok')",
            "dependencies": [],
            "script": "Q.Ext('isExists', function () {\n    return document.body.contains(this.nodes[0]);\n});\nQ.isExists = function (a) {\n    return document.querySelector(a) !== _n;\n};"
        },
        "last": {
            "uuid": "55e5c63d-194b-4c4c-a771-22c0149f16a3",
            "name": "last",
            "method": "Prototype",
            "desc": "Returns the last node.",
            "type": "Traversal",
            "example": "Q(selector).last();",
            "dependencies": [],
            "script": "Q.Ext('last', function () {\n    return new Q(this.nodes[this.nodes.length - 1]);\n});"
        },
        "map": {
            "uuid": "36ec695f-8ca6-4600-a821-ee301f44499d",
            "name": "map",
            "method": "Prototype",
            "desc": "Maps each node to a new array.",
            "type": "Array",
            "example": "Q(selector).map(el => el.innerHTML);",
            "dependencies": [],
            "script": "Q.Ext('map', function (callback) {\n    let b = [];\n    this.each(c => b.push(callback(Q(c))));\n    return b;\n});"
        },
        "off": {
            "uuid": "4f4220d7-b8db-4bf0-b922-e2c116206c4d",
            "name": "off",
            "method": "Prototype",
            "desc": "Removes an event listener from each node.",
            "type": "Event Handling",
            "example": "Q(selector).off(\"click\", handler);",
            "dependencies": [],
            "script": "Q.Ext('off', function (a, b, c) {\n    const d = {\n        capture: false,\n        once: false,\n        passive: false\n    };\n    c = { ...d, ...c };\n    return this.each(f => {\n        a.split(' ').forEach(e => this.nodes[f].removeEventListener(e, b, c));\n    });\n});"
        },
        "offset": {
            "uuid": "26ba98c8-6379-4bb6-8f96-d7cabd54530e",
            "name": "offset",
            "method": "Prototype",
            "desc": "Returns the top and left offset of the first node relative to the document.",
            "type": "Dimensions",
            "example": "Q(selector).offset();",
            "dependencies": [],
            "script": "Q.Ext('offset', function () {\n    const a = this.nodes[0].getBoundingClientRect();\n    return {\n        top: a.top + window.scrollY,\n        left: a.left + window.scrollX\n    };\n});"
        },
        "on": {
            "uuid": "8811e6ad-7ef0-4678-a3db-bc80dc00fbee",
            "name": "on",
            "method": "Prototype",
            "desc": "Adds an event listener to each node.",
            "type": "Event Handling",
            "example": "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
            "dependencies": [],
            "script": "Q.Ext('on', function (a, b, c) {\n    const d = {\n        capture: false,\n        once: false,\n        passive: false\n    };\n    c = { ...d, ...c };\n    return this.each(e => {\n        a.split(' ').forEach(f => {\n            this.nodes[e].addEventListener(f, b, c);\n        });\n    });\n});"
        },
        "parent": {
            "uuid": "208fc6d6-a4eb-4fa9-82c0-9d494919e9d6",
            "name": "parent",
            "method": "Prototype",
            "desc": "Returns the parent node of the first node.",
            "type": "Traversal",
            "example": "Q(selector).parent();",
            "dependencies": [],
            "script": "Q.Ext('parent', function () {\n    return new Q(this.nodes[0].parentNode);\n});"
        },
        "position": {
            "uuid": "3d3790d8-3ba3-4091-ad2d-1afe463cd2a2",
            "name": "position",
            "method": "Prototype",
            "desc": "Returns the top and left position of the first node relative to its offset parent.",
            "type": "Dimension/Position",
            "example": "Q(selector).position();",
            "dependencies": [],
            "script": "Q.Ext('position', function () {\n    return {\n        top: this.nodes[0].offsetTop,\n        left: this.nodes[0].offsetLeft\n    };\n});"
        },
        "prepend": {
            "uuid": "96b88c7f-b052-44fc-947a-359887774e1a",
            "name": "prepend",
            "method": "Prototype",
            "desc": "Prepends child nodes or HTML to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).prepend(\"<div>Prepended</div>\");",
            "dependencies": [],
            "script": "Q.Ext('prepend', function (...a) {\n    return this.each(e => {\n        const b = this.a[e];\n        a.forEach(c => {\n            if (typeof c === 'string') {\n                b.insertAdjacentHTML('afterbegin', c);\n            } else if (c?.nodeType === 1 || c instanceof Q) {\n                b.insertBefore(c.a[0], b.firstChild);\n            } else if (_ar.isArray(c) || c?.constructor === _nl) {\n                _ar.from(c).forEach(d => b.insertBefore(d, b.firstChild));\n            }\n        });\n    });\n});"
        },
        "prop": {
            "uuid": "aab494c1-49e6-4b12-aadf-c2545d98a2a3",
            "name": "prop",
            "method": "Prototype",
            "desc": "Gets or sets a property on the nodes.",
            "type": "Property Manipulation",
            "example": "Q(selector).prop(property, value);",
            "dependencies": [],
            "script": "Q.Ext('prop', function (property, b) {\n    if (b === _un) {\n        return this.nodes[0]?.[property] || _n;\n    }\n    return this.each(function (d, c) {\n        c[property] = b;\n    });\n});"
        },
        "remove": {
            "uuid": "d7eb539d-3254-498a-9737-c65f3d3d1828",
            "name": "remove",
            "method": "Prototype",
            "desc": "Removes each node from the DOM.",
            "type": "DOM Manipulation",
            "example": "Q(selector).remove();",
            "dependencies": [],
            "script": "Q.Ext('remove', function() {\n    return this.each(a => this.nodes[a].remove());\n});"
        },
        "removeAttr": {
            "uuid": "a5ce36f0-ac41-44bd-a20c-7e0cf3e3c18f",
            "name": "removeAttr",
            "method": "Prototype",
            "desc": "Removes an attribute from each node.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).removeAttr(attribute);",
            "dependencies": [],
            "script": "Q.Ext('removeAttr', function (a) {\n    return this.each(b => this.nodes[b].removeAttribute(a));\n});"
        },
        "removeClass": {
            "uuid": "b25c53ea-16aa-463c-83b7-80e2192013c6",
            "name": "removeClass",
            "method": "Prototype",
            "desc": "Removes one or more classes from each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).removeClass(\"class1 class2\");",
            "dependencies": [],
            "script": "Q.Ext('removeClass', function (a) {\n    const b = a.split(' ');\n    return this.each(c => this.nodes[c].classList.remove(...b));\n});"
        },
        "removeData": {
            "uuid": "38444a80-0bbe-4a36-bdc1-df1eea435f28",
            "name": "removeData",
            "method": "Prototype",
            "desc": "Removes a data-* attribute from each node.",
            "type": "Data Manipulation",
            "example": "Q(selector).removeData(key);",
            "dependencies": [],
            "script": "Q.Ext('removeData', function (key) {\n    return this.each(b => delete this.nodes[b].dataset[key]);\n});"
        },
        "removeProp": {
            "uuid": "121a3233-2466-4820-9bef-1e18a3b2e384",
            "name": "removeProp",
            "method": "Prototype",
            "desc": "Removes a property from each node.",
            "type": "Property Manipulation",
            "example": "Q(selector).removeProp(property);",
            "dependencies": [],
            "script": "Q.Ext('removeProp', function (property) {\n    return this.each(b => delete this.nodes[b][property]);\n});"
        },
        "removeTransition": {
            "uuid": "8d4c6695-ed3b-484b-86cd-cf3388d0cdd6",
            "name": "removeTransition",
            "method": "Prototype",
            "desc": "Removes the transition from each node.",
            "type": "Display",
            "example": "Q(selector).removeTransition();",
            "dependencies": [],
            "script": "Q.Ext('removeTransition', function () {\n    return this.each(a => this.nodes[a].style.transition = '');\n});"
        },
        "scrollHeight": {
            "uuid": "8d88b5e4-cfff-4130-837d-a3ee24c0181a",
            "name": "scrollHeight",
            "method": "Prototype",
            "desc": "Returns the scroll height of the first node.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollHeight();",
            "dependencies": [],
            "script": "Q.Ext('scrollHeight', function () {\n    return this.nodes[0].scrollHeight;\n});"
        },
        "scrollLeft": {
            "uuid": "2432f795-33bd-42b8-8e32-6f564a32c5a6",
            "name": "scrollLeft",
            "method": "Prototype",
            "desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollLeft(value, increment);",
            "dependencies": [],
            "script": "Q.Ext('scrollLeft', function (a, b) {\n    if (a === _un) {\n        return this.nodes[0].scrollLeft;\n    }\n    return this.each(d => {\n        const c = this.nodes[d].scrollWidth - this.nodes[d].clientWidth;\n        if (b) {\n            this.nodes[d].scrollLeft = _ma.min(this.nodes[d].scrollLeft + a, c);\n        } else {\n            this.nodes[d].scrollLeft = _ma.min(a, c);\n        }\n    });\n});"
        },
        "scrollTop": {
            "uuid": "effa8409-4c01-4813-9405-61b67b9f52ed",
            "name": "scrollTop",
            "method": "Prototype",
            "desc": "Gets or sets the vertical scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollTop(value, increment);",
            "dependencies": [],
            "script": "Q.Ext('scrollTop', function (a, b) {\n    if (a === _un) {\n        return this.nodes[0].scrollTop;\n    }\n    return this.each(d => {\n        const c = this.nodes[d].scrollHeight - this.nodes[d].clientHeight;\n        if (b) {\n            this.nodes[d].scrollTop = _ma.min(this.nodes[d].scrollTop + a, c);\n        } else {\n            this.nodes[d].scrollTop = _ma.min(a, c);\n        }\n    });\n});"
        },
        "scrollWidth": {
            "uuid": "1b29b5ea-8c00-429c-936e-f4fdeb0db37e",
            "name": "scrollWidth",
            "method": "Prototype",
            "desc": "Returns the scroll width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).scrollWidth();",
            "dependencies": [],
            "script": "Q.Ext('scrollWidth', function () {\n    return this.nodes[0].scrollWidth;\n});"
        },
        "show": {
            "uuid": "48d38710-b304-4423-9e2b-79063b7d3baa",
            "name": "show",
            "method": "Prototype",
            "desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).show(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('show', function (duration = 0, b) {\n    return this.each(e => {\n        const c = this.nodes[e];\n        if (duration === 0) {\n            c.style.display = '';\n            if (b) b();\n        } else {\n            c.style.transition = `opacity ${duration}ms`;\n            c.style.opacity = 0;\n            c.style.display = '';\n            _st(() => {\n                c.style.opacity = 1;\n                c.addEventListener('transitionend', function d() {\n                    c.style.transition = '';\n                    c.removeEventListener('transitionend', d);\n                    if (b) b();\n                });\n            }, 0);\n        }\n    });\n});"
        },
        "size": {
            "uuid": "50f7c3c2-2653-48c9-8ad6-cccc882e94cb",
            "name": "size",
            "method": "Prototype",
            "desc": "Returns the width and height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).size();",
            "dependencies": [],
            "script": "Q.Ext('size', function () {\n    return {\n        width: this.nodes[0].offsetWidth,\n        height: this.nodes[0].offsetHeight\n    };\n});"
        },
        "text": {
            "uuid": "a79fedc1-3f45-44cf-9397-c68338ce6da8",
            "name": "text",
            "method": "Prototype",
            "desc": "Gets or sets the text content of the nodes.",
            "type": "Content Manipulation",
            "example": "Q(selector).text(string);",
            "dependencies": [],
            "script": "Q.Ext('text', function (a) {\n    if (a === _un) {\n        return this.nodes[0]?.textContent || _n;\n    }\n    return this.each(b => this.nodes[b].textContent = a);\n});"
        },
        "toggle": {
            "uuid": "caff36c4-10ba-4c6b-a117-675ace05569c",
            "name": "toggle",
            "method": "Prototype",
            "desc": "Toggles the display of each node.",
            "type": "Utilities",
            "example": "Q(selector).toggle();",
            "dependencies": [],
            "script": "Q.Ext('toggle', function () {\n    return this.each(a => this.nodes[a].style.display = this.nodes[a].style.display === 'none' ? '' : 'none');\n});"
        },
        "toggleClass": {
            "uuid": "efb3848d-e2e7-4f66-b31d-f55ba5d797bf",
            "name": "toggleClass",
            "method": "Prototype",
            "desc": "Toggles a class on each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).toggleClass(className);",
            "dependencies": [],
            "script": "Q.Ext('toggleClass', function (className) {\n    return this.each(b => this.nodes[b].classList.toggle(className));\n});"
        },
        "trigger": {
            "uuid": "65eb27ed-22a9-4e7b-b03b-687b9eb4e1ed",
            "name": "trigger",
            "method": "Prototype",
            "desc": "Triggers a specific event on each node.",
            "type": "Event Handling",
            "example": "Q(selector).trigger(\"click\");",
            "dependencies": [],
            "script": "Q.Ext('trigger', function (event) {\n    return this.each(function (c, b) {\n        b.dispatchEvent(new _ev(event));\n    });\n});"
        },
        "unwrap": {
            "uuid": "ccef835d-478d-4d17-aec0-bd1f1ca01a61",
            "name": "unwrap",
            "method": "Prototype",
            "desc": "Removes the parent wrapper of each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).unwrap();",
            "dependencies": [],
            "script": "Q.Ext('unwrap', function () {\n    return this.each(b => {\n        const a = this.nodes[b].parentNode;\n        if (a !== document.body) {\n            a.replaceWith(...this.nodes);\n        }\n    });\n});"
        },
        "val": {
            "uuid": "fb2b1f31-34ff-4bf1-b99f-15ac877f878c",
            "name": "val",
            "method": "Prototype",
            "desc": "Gets or sets the value of form elements in the nodes.",
            "type": "Form Manipulation",
            "example": "Q(selector).val(value);",
            "dependencies": [],
            "script": "Q.Ext('val', function (a) {\n    if (a === _un) {\n        return this.nodes[0]?.value || _n;\n    }\n    return this.each(b => this.nodes[b].value = a);\n});"
        },
        "wait": {
            "uuid": "7f72449e-da33-40db-b7a4-a49986e33fb8",
            "name": "wait",
            "method": "Prototype",
            "desc": "Returns a promise that resolves after a given time. Useful for delaying actions.",
            "type": "Utility",
            "example": "Q('.text').wait(1000).text('Hello, World!');",
            "dependencies": [],
            "script": "Q.Ext('wait', function (ms) {\n    const b = this;\n    return new _pr((resolve) => {\n        _st(() => {\n            resolve(b);\n        }, ms);\n    });\n});"
        },
        "walk": {
            "uuid": "a9783622-b783-40b5-87b9-daca975c129c",
            "name": "walk",
            "method": "Prototype",
            "desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter.",
            "type": "Iteration",
            "example": "Q(selector).walk((node) => console.log(node), true); // Passes Q object",
            "dependencies": [],
            "script": "Q.Ext('walk', function (callback, b = false) {\n    this.nodes.forEach((e, d) => {\n        const c = b ? Q(e) : e;\n        callback.call(e, c, d);\n    });\n    return this;\n});"
        },
        "width": {
            "uuid": "b1299180-9c5a-4b52-abf9-996b7fb8a255",
            "name": "width",
            "method": "Prototype",
            "desc": "Gets or sets the width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).width(value);",
            "dependencies": [],
            "script": "Q.Ext('width', function (value) {\n    if (value === _un) {\n        return this.nodes[0].offsetWidth;\n    }\n    return this.each(b => this.nodes[b].style.width = value);\n});"
        },
        "wrap": {
            "uuid": "790ea606-46d8-4c21-9910-3bba1647a451",
            "name": "wrap",
            "method": "Prototype",
            "desc": "Wraps each node with the specified wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrap(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrap', function (c) {\n    return this.each(d => {\n        const a = this.nodes[d].parentNode;\n        let b;\n        if (typeof c === 'string') {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = c.trim();\n            b = tempDiv.firstElementChild;\n        } else {\n            b = c;\n        }\n        a.insertBefore(b, this.nodes[d]);\n        b.appendChild(this.nodes[d]);\n    });\n});"
        },
        "wrapAll": {
            "uuid": "58090150-856b-49e4-a3b5-6fb18e84f8da",
            "name": "wrapAll",
            "method": "Prototype",
            "desc": "Wraps all nodes together in a single wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrapAll(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrapAll', function (wrapper) {\n    return this.each(e => {\n        const b = this.nodes[e].parentNode;\n        let c;\n        if (typeof wrapper === 'string') {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = wrapper.trim();\n            c = tempDiv.firstElementChild;\n        } else {\n            c = wrapper;\n        }\n        b.insertBefore(c, this.nodes[0]);\n        this.nodes.forEach(d => c.appendChild(d));\n    });\n});"
        },
        "zIndex": {
            "uuid": "6f1814c7-b7e6-4871-854d-7e4b595c71d0",
            "name": "zIndex",
            "method": "Prototype",
            "desc": "Gets or sets the z-index of the first node.",
            "type": "Display",
            "example": "Q(selector).zIndex(value);",
            "dependencies": [],
            "script": "Q.Ext('zIndex', function (value) {\n    if (value === _un) {\n        let b = this.nodes[0].style.zIndex;\n        if (!b) {\n            b = window.getComputedStyle(this.nodes[0]).zIndex;\n        }\n        return b;\n    }\n    return this.each(c => this.nodes[c].style.zIndex = value);\n});"
        }
    },
    "plugins": {
        "Container": {
            "uuid": "b4167b5f-cbb2-4980-a72f-acc83973c6d5",
            "name": "Container",
            "method": "Plugin",
            "desc": "Useful to create tabbed containers.",
            "type": "Plugin",
            "example": "var containers = Q.Container();",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "Icons"
            ],
            "script": "Q.Container = function (options = {}) {\n    let Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' container_icon');\n        return iconElement;\n    };\n    Q.Icons();\n    let classes = Q.style(` \n         .container_icon {\n             width: 100%;\n             height: 100%;\n             color: #777; /* Default color */\n             pointer-events: none;\n             z-index: 1;\n         }\n          .tab_navigation_buttons {\n         box-sizing: border-box;\n            width: 20px;\n            background-color: #333;\n            display: flex;\n            justify-content: center;\n            padding: 4px;\n        }\n        .tab_navigation_buttons_vertical {\n            width: auto;\n            height: 20px;\n        }\n        .tab_navigation_buttons:hover {\n            background-color: #555;\n        }\n        .tab_container {\n            width: 100%;\n            height: 300px;\n        }\n        .tab_container_vertical {\n        display: flex;\n                }\n        .tab_navigation_header {\n            background-color: #333;\n            display: flex;\n        }\n        .tab_navigation_header_vertical {\n            flex-direction: column;\n                width: auto;\n        }\n        .tab_navigation_tabs {\n        user-select: none;\n            display: flex;\n            flex-direction: row;\n            width: 100%;\n            overflow: hidden;\n        }\n        .tab_navigation_tabs_vertical {\n            flex-direction: column;\n        }\n        .tab_active {\n            background-color: #555;\n            color: #fff;\n        }\n        .tab {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            cursor: default;\n            padding: 5px 25px;\n        }\n        .tab_disabled {\n            background-color: #333;\n            color: #555;\n        }\n `,\n        {\n            'tab_navigation_buttons': 'tab_navigation_buttons',\n            'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n            'tab_container': 'tab_container',\n            'tab_container_vertical': 'tab_container_vertical',\n            'tab_navigation_header': 'tab_navigation_header',\n            'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n            'tab_navigation_tabs': 'tab_navigation_tabs',\n            'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n            'tab_active': 'tab_active',\n            'tab': 'tab',\n            'tab_disabled': 'tab_disabled'\n        });\n    return {\n        Tab: function (data, horizontal = true) {\n            let wrapper = Q('<div>', { class: classes.tab_container });\n            let tabs_wrapper = Q('<div>', { class: classes.tab_navigation_header });\n            let tabs_nav_left = Q('<div>', { class: classes.tab_navigation_buttons });\n            let tabs_nav_right = Q('<div>', { class: classes.tab_navigation_buttons });\n            let tabs = Q('<div>', { class: classes.tab_navigation_tabs });\n            tabs_wrapper.append(tabs_nav_left, tabs, tabs_nav_right);\n            let content = Q('<div>');\n            wrapper.append(tabs_wrapper, content);\n            if (!horizontal) {\n                wrapper.addClass(classes.tab_container_vertical);\n                tabs.addClass(classes.tab_navigation_tabs_vertical);\n                tabs_wrapper.addClass(classes.tab_navigation_header_vertical);\n                tabs_nav_left.addClass(classes.tab_navigation_buttons_vertical);\n                tabs_nav_right.addClass(classes.tab_navigation_buttons_vertical);\n                tabs_nav_left.append(Icon('arrow-up'));\n                tabs_nav_right.append(Icon('arrow-down'));\n            }\n            else {\n                tabs_nav_left.append(Icon('arrow-left'));\n                tabs_nav_right.append(Icon('arrow-right'));\n            }\n            let data_tabs = {};\n            let data_contents = {};\n            data.forEach((item) => {\n                const tab = Q('<div>', { class: classes.tab, 'data-value': item.value }).text(item.title);\n                if (item.disabled) {\n                    tab.addClass(classes.tab_disabled);\n                }\n                data_tabs[item.value] = tab;\n                data_contents[item.value] = item.content;\n                tab.on('click', function () {\n                    if (item.disabled) {\n                        return;\n                    }\n                    let foundTabs = tabs.find('.' + classes.tab_active);\n                    if (foundTabs) {\n                        foundTabs.removeClass(classes.tab_active);\n                    }\n                    tab.addClass(classes.tab_active);\n                    content.html(data_contents[item.value]);\n                });\n                tabs.append(tab);\n            });\n            tabs_nav_left.on('click', function () {\n                if (!horizontal) {\n                    tabs.scrollTop(-tabs.height(), true);\n                } else {\n                    tabs.scrollLeft(-tabs.width(), true);\n                }\n            });\n            tabs_nav_right.on('click', function () {\n                if (!horizontal) {\n                    tabs.scrollTop(tabs.height(), true);\n                } else {\n                    tabs.scrollLeft(tabs.width(), true);\n                }\n            });\n            wrapper.select = function (value) {\n                data_tabs.forEach(tab => {\n                    if (tab.data('value') === value) {\n                        tab.click();\n                    }\n                });\n            };\n            wrapper.disabled = function (value, state) {\n                if (data_tabs[value]) {\n                    if (state) {\n                        data_tabs[value].addClass(classes.tab_disabled);\n                    } else {\n                        data_tabs[value].removeClass(classes.tab_disabled);\n                    }\n                }\n            };\n            return wrapper;\n        }\n    };\n};"
        },
        "Cookie": {
            "uuid": "ba6286fd-b377-42ca-9096-96ea39f393b6",
            "name": "Cookie",
            "method": "Plugin",
            "desc": "Provides methods to store and retrieve data from the browser cookies.",
            "type": "Plugin",
            "example": "Q.Cookie('key', 'value to store'); Q.Cookie('key'); // returns 'value to store'",
            "dependencies": [],
            "script": "Q.Cookie = function (a, b, options = {}) { \n    function h(options) {\n        const { d, e, f, g } = options;\n        let j = '';\n        if (d) {\n            const k = new _da();\n            k.setTime(k.getTime() + (d * 24 * 60 * 60 * 1000));\n            j += `expires=${k.toUTCString()}; `;\n        }\n        if (e) {\n            j += `e=${e}; `;\n        }\n        if (f) {\n            j += `f=${f}; `;\n        }\n        if (g) {\n            j += 'g; ';\n        }\n        return j;\n    }\n    function i(j) {\n        return j.split(';').reduce((o, n) => {\n            const [l, b] = n.split('=').map(c => c.trim());\n            o[l] = b;\n            return o;\n        }, {});\n    }\n    if (arguments.length === 2) { \n        if (b === _n || b === '') { \n            b = ''; \n            options = { ...options, d: -1 }; \n        }\n        return document.cookie = `${a}=${b}; ${h(options)}`; \n    } else if (arguments.length === 1) { \n        return i(document.cookie)[a]; \n    }\n};"
        },
        "Fetch": {
            "uuid": "a921eda6-982b-44c3-b249-9e17fea83fac",
            "name": "Fetch",
            "method": "Plugin",
            "desc": "Fetches data from a URL and returns it to a callback function. Supports retries, timeouts, and custom response validation.",
            "type": "Plugin",
            "example": "Q.fetch('https://api.example.com/data', (error, data) => console.log(error, data));",
            "dependencies": [],
            "script": "Q.Fetch = function (url, b, c = {}) {\n    const { \n        method = 'GET',\n        headers = {},\n        body,\n        contentType = 'application/json',\n        responseType = 'json',\n        credentials = 'same-origin',\n        retries = 3,\n        retryDelay = 1000, \n        timeout = 0, \n        validateResponse = (j) => j\n    } = c;\n    headers['Content-Type'] = headers['Content-Type'] || contentType;\n    const d = new _ac();\n    const { e } = d;\n    const g = (f) => {\n        const h = timeout ? _st(() => d.abort(), timeout) : _n;\n        _f(url, { method, headers, body, credentials, e })\n            .then(i => {\n                if (!i.ok) {\n                    throw new _er(`Network i was not ok: ${i.statusText}`);\n                }\n                switch (responseType) {\n                    case 'json': return i.json();\n                    case 'text': return i.text();\n                    case 'blob': return i.blob();\n                    case 'arrayBuffer': return i.arrayBuffer();\n                    default: throw new _er('Unsupported i type');\n                }\n            })\n            .then(j => {\n                if (h) _ct(h);\n                return validateResponse(j);\n            })\n            .then(j => b(_n, j))\n            .catch(k => {\n                if (h) _ct(h);\n                if (k.name === 'AbortError') {\n                    b(new _er('Fetch request was aborted'), _n);\n                } else if (f < retries) {\n                    _c.warn(`Retrying _f (${f + 1}/${retries}):`, k);\n                    _st(() => g(f + 1), retryDelay);\n                } else {\n                    b(k, _n);\n                }\n            });\n    };\n    g(0);\n    return {\n        abort: () => d.abort()\n    };\n};"
        },
        "Form": {
            "uuid": "e27db7d7-0144-421d-b02e-ecec964a6e1e",
            "name": "Form",
            "method": "Plugin",
            "desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
            "type": "Plugin",
            "example": "var containers = Q.Form()",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "hasClass",
                "text",
                "html",
                "val",
                "click",
                "closest",
                "empty",
                "show",
                "hide",
                "css",
                "attr",
                "prop",
                "remove",
                "add"
            ],
            "script": "Q.Form = function (options = {}) {\n    let Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' form_icon');\n        return iconElement;\n    };\n    let classes = Q.style(`\n           .form_icon {\n               width: 100%;\n               height: 100%;\n               color: #fff;\n               /* Default color */\n               pointer-events: none;\n           }\n           .q_form {\n               box-sizing: border-box;\n               font-family: inherit;\n               font-size: inherit;\n               color: inherit;\n               margin: 1px;\n           }\n           .q_form_disabled {\n               opacity: 0.5;\n           }\n           .q_form_checkbox,\n           .q_form_radio {\n               display: flex;\n               width: fit-content;\n               align-items: center;\n           }\n           .q_form_checkbox .label:empty,\n           .q_form_radio .label:empty {\n               display: none;\n           }\n           .q_form_checkbox .label,\n           .q_form_radio .label {\n               padding-left: 5px;\n               user-select: none;\n           }\n           .q_form_cb {\n               position: relative;\n               width: 20px;\n               height: 20px;\n               background-color: #555555;\n           }\n           .q_form_cb input[type=\"checkbox\"] {\n               opacity: 0;\n               top: 0;\n               left: 0;\n               padding: 0;\n               margin: 0;\n               width: 100%;\n               height: 100%;\n               position: absolute;\n           }\n           .q_form_cb input[type=\"checkbox\"]:checked+label:before {\n               content: \"\";\n               position: absolute;\n               display: block;\n               top: 0;\n               left: 0;\n               width: 100%;\n               height: 100%;\n               background-color: #1DA1F2;\n           }\n           .q_form_r {\n               position: relative;\n               width: 20px;\n               height: 20px;\n               background-color: #555555;\n               border-radius: 50%;\n               overflow: hidden;\n           }\n           .q_form_r input[type=\"radio\"] {\n               opacity: 0;\n               top: 0;\n               left: 0;\n               padding: 0;\n               margin: 0;\n               width: 100%;\n               height: 100%;\n               position: absolute;\n               border-radius: 50%;\n           }\n           .q_form_r input[type=\"radio\"]:checked+label:before {\n               content: \"\";\n               position: absolute;\n               display: block;\n               top: 0;\n               left: 0;\n               width: 100%;\n               height: 100%;\n               background-color: #1DA1F2;\n               border-radius: 50%;\n           }\n           .q_form_input {\n               width: calc(100% - 2px);\n               padding: 5px;\n               outline: none;\n               border: 0;\n           }\n           .q_form_input:focus,\n           .q_form_textarea:focus {\n               outline: 1px solid #1DA1F2;\n           }\n           .q_form_textarea {\n               width: calc(100% - 2px);\n               padding: 5px;\n               outline: none;\n               border: 0;\n           }\n           .q_window {\n               position: fixed;\n               background-color: #333;\n               z-index: 1000;\n               box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);\n               border: 1px solid rgba(255, 255, 255, 0.01);\n               border-radius: 5px;\n               overflow: hidden;\n               display: flex;\n               flex-direction: column;\n           }\n           .q_window_titlebar {\n               user-select: none;\n               display: flex;\n               background-color: #222;\n               width: 100%;\n               flex-shrink: 0;\n           }\n           .q_window_buttons {\n               display: flex;\n           }\n           .q_window_button {\n               box-sizing: border-box;\n               display: flex;\n               justify-content: center;\n               align-items: center;\n               cursor: pointer;\n               width: 30px;\n               height: 30px;\n               padding: 10px;\n               background-color: rgba(255, 255, 255, 0.01);\n               margin-left: 1px;\n           }\n           .q_window_button:hover {\n               background-color: #424242;\n           }\n           .q_window_close:hover {\n               background-color: #e81123;\n           }\n           .q_window_titletext {\n               flex-grow: 1;\n               color: #fff;\n               align-content: center;\n               white-space: nowrap;\n               overflow: hidden;\n               text-overflow: ellipsis;\n               padding: 0 5px\n           }\n           .q_window_content {\n               width: 100%;\n               overflow-y: auto;\n               flex: 1;\n           }\n           .q_slider_wrapper {\n               position: relative;\n               height: 20px;\n               overflow: hidden;\n               background-color: #333;\n           }\n           .q_slider_pos {\n               position: absolute;\n               top: 0;\n               left: 0;\n               width: 0;\n               height: 100%;\n               background-color: #1473e6;\n           }\n           .q_form_slider {\n               width: 100%;\n               opacity: 0;\n               height: 100%;\n               position: absolute;\n           }\n           .q_form_dropdown {\n               user-select: none;\n               position: relative;\n               background-color: #333;\n           }\n           .q_form_dropdown_options {\n               position: absolute;\n               width: 100%;\n               background-color: #333;\n               z-index: 1;\n           }\n           .q_form_dropdown_option,\n           .q_form_dropdown_selected {\n               padding: 5px 0px;\n           }\n           .q_form_button {\n               user-select: none;\n               padding: 5px 10px;\n               cursor: pointer;\n           }\n           .q_form_button:hover {\n               background-color: #555;\n           }\n           .q_form_button:active {\n               background-color: #777;\n           }\n           .q_form_file {\n               user-select: none;\n               position: relative;\n               overflow: hidden;\n           }\n           .q_form_file input[type=\"file\"] {\n               position: absolute;\n               width: 100%;\n               height: 100%;\n               opacity: 0;\n           }\n           .datepicker_wrapper {\n               user-select: none;\n               width: 100%;\n               height: 100%;\n               display: flex;\n               flex-direction: column;\n           }\n           .datepicker_header {\n               display: flex;\n               align-items: center;\n               color: #fff;\n               justify-content: center;\n           }\n           .datepicker_header div {\n               padding: 15px 5px;\n           }\n           .datepicker_weekdays {\n               display: grid;\n               grid-template-columns: repeat(7, 1fr);\n           }\n           .datepicker_weekdays div {\n               display: flex;\n               align-items: center;\n               justify-content: center;\n           }\n           .datepicker_days {\n               display: grid;\n               grid-template-columns: repeat(7, 1fr);\n               flex: 1;\n           }\n           .prev_month,\n           .next_month {\n               opacity: 0.5;\n           }\n           .datepicker_body {\n               display: flex;\n               flex-direction: column;\n               flex: 1;\n           }\n           .days {\n               cursor: default;\n               display: flex;\n               align-items: center;\n               justify-content: center;\n           }\n           .day_selected {\n               background-color: #1473e6;\n               color: #fff;\n           }\n           .datepicker_footer {\n               display: flex;\n               justify-content: flex-end;\n           }\n           .tag_container {\n                display: flex;\n                flex-wrap: wrap;\n}\n.tag_tag {\n    display: flex;\n    align-items: center;\n    border: 1px solid #333;\n    color: #fff;\noverflow: hidden;\n    margin: 2px;\n    border-radius: 5px;\n}\n        .tag_rating {\n    display: flex;\n    background-color: #333;\n    padding: 2px 5px;\n    align-items: center;\n            }\n            .tag_icon {\n                width: 10px;\n                height: 10px;\n}\n.tag_icon_small {\n    width: 5px;\n    height: 5px;\n}\n.tag_name {\n    padding: 2px 8px;\n}\n.tag_value {\n    padding: 0 5px;\n    user-select: none;   \n}\n.tag_close {\n    cursor: pointer;\n    background-color: #333;\n    height: auto;\n    width: 20px;\n}\n.tag_input {\nwidth: content;\n    border: 0;\n    margin:0;\n    background-color: transparent;\n    color: #fff;\n}\n.tag_name[contenteditable=\"true\"] {\n    cursor: text;\n}\n.tag_name[contenteditable=\"true\"]:focus {\n    outline: 0;\n}\n    `, {\n        'q_form': 'q_form',\n        'q_form_disabled': 'q_form_disabled',\n        'q_form_checkbox': 'q_form_checkbox',\n        'q_form_radio': 'q_form_radio',\n        'q_form_cb': 'q_form_cb',\n        'q_form_r': 'q_form_r',\n        'q_form_input': 'q_form_input',\n        'q_form_textarea': 'q_form_textarea',\n        'q_window': 'q_window',\n        'q_window_titlebar': 'q_window_titlebar',\n        'q_window_buttons': 'q_window_buttons',\n        'q_window_button': 'q_window_button',\n        'q_window_titletext': 'q_window_titletext',\n        'q_window_content': 'q_window_content',\n        'q_slider_wrapper': 'q_slider_wrapper',\n        'q_slider_pos': 'q_slider_pos',\n        'q_form_slider': 'q_form_slider',\n        'q_form_dropdown': 'q_form_dropdown',\n        'q_form_dropdown_options': 'q_form_dropdown_options',\n        'q_form_dropdown_option': 'q_form_dropdown_option',\n        'q_form_dropdown_selected': 'q_form_dropdown_selected',\n        'q_form_button': 'q_form_button',\n        'q_form_progress_bar': 'q_form_progress_bar',\n        'q_form_file': 'q_form_file',\n        'q_form_progress': 'q_form_progress',\n        'q_form_dropdown_active': 'q_form_dropdown_active',\n        'q_window_close': 'q_window_close',\n        'q_window_minimize': 'q_window_minimize',\n        'q_window_maximize': 'q_window_maximize',\n        'tag_name': 'tag_name',\n        'tag_input': 'tag_input',\n        'tag_close': 'tag_close',\n        'tag_value': 'tag_value',\n        'tag_icon_small': 'tag_icon_small',\n        'tag_rating': 'tag_rating',\n        'tag_container': 'tag_container',\n        'tag_tag': 'tag_tag',\n        'tag_icon': 'tag_icon',\n        'tag_up': 'tag_up',\n        'tag_down': 'tag_down',\n    });\n    return {\n        Tag: function (options = {}) {\n            const defaultOptions = {\n                min: 0,\n                max: 10,\n                step: 1,\n                value: 0,\n                digit: 3,\n                flood: 500,\n                disabled: false,\n                removable: true,\n                votes: true,\n                readonly: false,\n                placeholder: ''\n            };\n            let { min, max, step, digit, votes, removable, flood } = { ...defaultOptions, ...options };\n            if (step.toString().includes('.')) {\n                digit = step.toString().split('.')[1].length;\n            }\n            let data = [];\n            let changeCallback = _n;\n            const tagContainer = Q('<div>', { class: classes.tag_container });\n            const input = Q('<input>', { class: classes.tag_input });\n            const malformFix = Q('<input>', { class: classes.tag_input });\n            let ID = Q.ID(5, '_');\n            const changeTagValue = (tag, delta, currentValue) => {\n                let newValue = tag.value + delta;\n                newValue = _ma.min(_ma.max(newValue, min), max);\n                tag.value = parseFloat(newValue.toFixed(digit));\n                currentValue.text(tag.value);\n                data = data.map(t => (t.tag === tag.tag ? { ...t, value: tag.value } : t));\n                if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n            };\n            const appendTags = tags => {\n                tags.forEach(tag => {\n                    const tagElement = Q('<div>', { class: classes.tag_tag });\n                    let tagValue = Q('<div>', { class: classes.tag_name }).text(tag.tag);\n                    if (votes) {\n                        const tagRate = Q('<div>', { class: classes.tag_rating });\n                        const upvote = Q('<div>', { class: [classes.tag_icon, classes.tag_up] }).html(Icon('arrow-up'));\n                        const currentValue = Q('<div>', { class: classes.tag_value }).text(tag.value);\n                        const downvote = Q('<div>', { class: [classes.tag_icon, classes.tag_down] }).html(Icon('arrow-down'));\n                        tagRate.append(downvote, currentValue, upvote);\n                        tagElement.append(tagRate);\n                        upvote.on('click', () => changeTagValue(tag, step, currentValue));\n                        downvote.on('click', () => changeTagValue(tag, -step, currentValue));\n                    }\n                    if (!defaultOptions.readonly) {\n                        tagValue.attr('contenteditable', true);\n                        tagValue.on('input', function () {\n                            malformFix.val(tagValue.text());\n                            tagValue.text(malformFix.val());\n                            tag.tag = malformFix.val();\n                            if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n                        });\n                    }\n                    tagElement.append(tagValue);\n                    if (removable) {\n                        const close = Q('<div>', { class: [classes.tag_icon_small, classes.tag_close] }).html(Icon('window-close'));\n                        close.on('click', () => {\n                            data = data.filter(t => t.tag !== tag.tag);\n                            tagElement.remove();\n                            if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n                        });\n                        tagElement.append(close);\n                    }\n                    tagContainer.append(tagElement);\n                });\n            };\n            tagContainer.add = function (taglist) {\n                tagContainer.empty();\n                if (!_ar.isArray(taglist)) {\n                    taglist = [taglist];\n                }\n                taglist = taglist.map(tag => (typeof tag === 'string' ? { tag, value: 0 } : tag));\n                data = [...data, ...taglist];\n                appendTags(data);\n            };\n            tagContainer.get = function () {\n                return data;\n            };\n            tagContainer.change = function (callback) {\n                changeCallback = callback;\n            };\n            return tagContainer;\n        },\n        DatePicker: function (value = '', locale = window.navigator.language, range = false) {\n            let getFirstDayOfWeek = () => {\n                let startDate = new _da();\n                let dayOfWeek = startDate.getDay();\n                startDate.setDate(startDate.getDate() - dayOfWeek);\n                return startDate.toLocaleDateString(locale, { weekday: 'short' });\n            };\n            let daysLocale = (short = true) => {\n                let days = [];\n                let baseDate = new _da(2021, 0, 4);\n                const options = { weekday: short ? 'short' : 'long' };\n                let firstDayOfWeek = getFirstDayOfWeek();\n                while (baseDate.toLocaleDateString(locale, options) !== firstDayOfWeek) {\n                    baseDate.setDate(baseDate.getDate() - 1);\n                }\n                for (let i = 0; i < 7; i++) {\n                    let date = new _da(baseDate);\n                    date.setDate(date.getDate() + i);\n                    days.push(date.toLocaleDateString(locale, options));\n                }\n                return days;\n            };\n            let monthsLocale = (short = true) => {\n                let months = [];\n                for (let i = 0; i < 12; i++) {\n                    let date = new _da(2021, i, 1);\n                    months.push(date.toLocaleDateString(locale, { month: short ? 'short' : 'long' }));\n                }\n                return months;\n            };\n            let date = value ? new _da(value) : new _da();\n            let day = date.getDate();\n            let month = date.getMonth() + 1;\n            let year = date.getFullYear();\n            let daysInMonth = new _da(year, month, 0).getDate();\n            let firstDay = new _da(year, month - 1, 1).getDay();\n            let lastDay = new _da(year, month - 1, daysInMonth).getDay();\n            let days = daysLocale(true);\n            let dayNames = days.map((dayName, i) => {\n                let dayElement = Q('<div>');\n                dayElement.text(dayName);\n                return dayElement;\n            });\n            let wrapper = Q('<div class=\"datepicker_wrapper\">');\n            let header = Q('<div class=\"datepicker_header\">');\n            let body = Q('<div class=\"datepicker_body\">');\n            let footer = Q('<div class=\"datepicker_footer\">');\n            let weekdays = Q('<div class=\"datepicker_weekdays\">');\n            let days_wrapper = Q('<div class=\"datepicker_days\">');\n            let dateInput = Q('<input type=\"date\">');\n            let button_ok = this.Button('OK');\n            let button_today = this.Button('Today');\n            footer.append(button_today, button_ok);\n            body.append(weekdays, days_wrapper);\n            wrapper.append(header, body, footer);\n            let container_months = Q('<div>');\n            let container_years = Q('<div>');\n            header.append(container_months, container_years);\n            if (wrapper.inside(classes.q_window)) {\n                let button_cancel = this.Button('Cancel');\n                footer.append(button_cancel);\n                button_cancel.click(function () {\n                    wrapper.closest('.' + classes.q_window).hide(200);\n                });\n            }\n            container_months.on('click', function () {\n            });\n            button_today.click(function () {\n                date = new _da();\n                day = date.getDate();\n                month = date.getMonth() + 1;\n                year = date.getFullYear();\n                daysInMonth = new _da(year, month, 0).getDate();\n                firstDay = new _da(year, month - 1, 1).getDay();\n                lastDay = new _da(year, month - 1, daysInMonth).getDay();\n                populateDays(month, year, day);\n                populateHeader(month, year, day);\n            });\n            const populateHeader = function (month, year, day) {\n                let months = monthsLocale(false);\n                container_months.text(months[month - 1]);\n                container_years.text(year);\n            }\n            let populateDays = function (month, year, day) {\n                days_wrapper.empty();\n                let daysInPrevMonth = new _da(year, month - 1, 0).getDate();\n                let prevMonthDays = [];\n                for (let i = daysInPrevMonth - firstDay + 1; i <= daysInPrevMonth; i++) {\n                    let dayElement = Q('<div>');\n                    dayElement.text(i);\n                    dayElement.addClass('days prev_month');\n                    prevMonthDays.push(dayElement);\n                }\n                let currentMonthDays = [];\n                for (let i = 1; i <= daysInMonth; i++) {\n                    let dayElement = Q('<div>');\n                    dayElement.text(i);\n                    dayElement.addClass('days current_month');\n                    if (i === day) {\n                        dayElement.addClass('day_selected');\n                    }\n                    currentMonthDays.push(dayElement);\n                }\n                let nextMonthDays = [];\n                for (let i = 1; i <= 7 - lastDay; i++) {\n                    let dayElement = Q('<div>');\n                    dayElement.text(i);\n                    dayElement.addClass('days next_month');\n                    nextMonthDays.push(dayElement);\n                }\n                days_wrapper.append(...prevMonthDays, ...currentMonthDays, ...nextMonthDays);\n            };\n            weekdays.append(...dayNames);\n            populateDays(month, year, day);\n            populateHeader(month, year, day);\n            days_wrapper.on('click', function (e) {\n                let target = Q(e.target);\n                if (target.hasClass('days')) {\n                    let day = parseInt(target.text());\n                    if (target.hasClass('prev_month')) {\n                        if (month === 1) {\n                            month = 12;\n                            year--;\n                        } else {\n                            month--;\n                        }\n                    } else if (target.hasClass('next_month')) {\n                        if (month === 12) {\n                            month = 1;\n                            year++;\n                        } else {\n                            month++;\n                        }\n                    }\n                    date = new _da(year, month - 1, day);\n                    populateDays(month, year, day);\n                    populateHeader(month, year, day);\n                }\n            });\n            return wrapper;\n        },\n        ProgressBar: function (value = 0, min = 0, max = 100, autoKill = 0) {\n            let timer = _n;\n            const progress = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_progress + '\">');\n            const bar = Q('<div class=\"' + classes.q_form_progress_bar + '\">');\n            progress.append(bar);\n            function clearAutoKillTimer() {\n                if (timer) {\n                    _ct(timer);\n                    timer = _n;\n                }\n            }\n            function setAutoKillTimer() {\n                if (autoKill > 0) {\n                    clearAutoKillTimer();\n                    timer = _st(() => {\n                        progress.hide();\n                    }, autoKill);\n                }\n            }\n            progress.value = function (value) {\n                const range = max - min;\n                const newWidth = ((value - min) / range) * 100 + '%';\n                if (bar.css('width') !== newWidth) {\n                    bar.css({ width: newWidth });\n                }\n                progress.show();\n                clearAutoKillTimer();\n                setAutoKillTimer();\n            };\n            progress.min = function (value) {\n                min = value;\n                progress.value(value);\n            };\n            progress.max = function (value) {\n                max = value;\n                progress.value(value);\n            };\n            progress.autoKill = function (delay) {\n                autoKill = delay;\n                setAutoKillTimer();\n            };\n            progress.value(value);\n            return progress;\n        },\n        Button: function (text = '') {\n            const button = Q(`<div class=\"${classes.q_form} ${classes.q_form_button}\">${text}</div>`);\n            button.click = function (callback) {\n                button.on('click', callback);\n            };\n            button.disabled = function (state) {\n                if (state) {\n                    button.addClass(classes.q_form_disabled);\n                }\n                else {\n                    button.removeClass(classes.q_form_disabled);\n                }\n            };\n            button.text = function (text) {\n                button.text(text);\n            };\n            button.remove = function () {\n                button.remove();\n            };\n            return button;\n        },\n        File: function (text = '', accept = '*', multiple = false) {\n            const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_file + ' ' + classes.q_form_button + '\">');\n            const input = Q(`<input type=\"file\" accept=\"${accept}\" ${multiple ? 'multiple' : ''}>`);\n            const label = Q(`<div>${text}</div>`);\n            container.append(input, label);\n            input.disabled = function (state) {\n                input.prop('disabled', state);\n                if (state) {\n                    container.addClass(classes.q_form_disabled);\n                } else {\n                    container.removeClass(classes.q_form_disabled);\n                }\n            };\n            container.change = function (callback) {\n                input.on('change', function () {\n                    callback(this.files);\n                });\n            };\n            container.image = function (processText = '', size, callback) {\n                input.on('change', function () {\n                    label.text(processText);\n                    let files = this.files;\n                    let fileReaders = [];\n                    let images = [];\n                    for (let i = 0; i < files.length; i++) {\n                        if (!files[i].type.startsWith('image/')) {\n                            continue;\n                        }\n                        fileReaders[i] = new FileReader();\n                        fileReaders[i].onload = function (e) {\n                            let img = new Image();\n                            img.onload = function () {\n                                if (size !== 'original') {\n                                    let canvas = document.createElement('canvas');\n                                    let ctx = canvas.getContext('2d');\n                                    let width = size;\n                                    let height = (img.height / img.width) * width;\n                                    canvas.width = width;\n                                    canvas.height = height;\n                                    ctx.drawImage(img, 0, 0, width, height);\n                                    images.push(canvas.toDataURL('image/png'));\n                                } else {\n                                    images.push(e.target.result);\n                                }\n                                if (images.length === files.length) {\n                                    label.text(text);\n                                    callback(images);\n                                }\n                            };\n                            img.src = e.target.result;\n                        };\n                        fileReaders[i].readAsDataURL(files[i]);\n                    }\n                });\n            };\n            return container;\n        },\n        DropDown: function (data) {\n            let wrapper = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_dropdown + '\">');\n            let selected = Q('<div class=\"' + classes.q_form_dropdown_selected + '\">');\n            let options = Q('<div class=\"' + classes.q_form_dropdown_options + '\">');\n            options.hide();\n            wrapper.append(selected, options);\n            let valueMap = new Map();\n            data.forEach((item, index) => {\n                let option = Q('<div class=\"' + classes.q_form_dropdown_option + '\">');\n                option.html(item.content);\n                if (item.disabled) {\n                    option.addClass(classes.q_form_disabled);\n                }\n                options.append(option);\n                valueMap.set(option, item.value);\n            });\n            selected.html(data[0].content);\n            let selectedValue = data[0].value;\n            function deselect() {\n                options.hide();\n                document.removeEventListener('click', deselect);\n            }\n            options.find('.' + classes.q_form_dropdown_option).first().addClass(classes.q_form_dropdown_active);\n            options.on('click', function (e) {\n                let target = Q(e.target);\n                if (target.hasClass(classes.q_form_dropdown_option) && !target.hasClass(classes.q_form_disabled)) {\n                    selected.html(target.html());\n                    selectedValue = valueMap.get(target);\n                    deselect();\n                    options.find('.' + classes.q_form_dropdown_option).removeClass(classes.q_form_dropdown_active);\n                    target.addClass(classes.q_form_dropdown_active);\n                }\n            });\n            selected.on('click', function (e) {\n                e.stopPropagation();\n                options.toggle();\n                if (options.is(':visible')) {\n                    document.addEventListener('click', deselect);\n                } else {\n                    document.removeEventListener('click', deselect);\n                }\n            });\n            wrapper.change = function (callback) {\n                options.on('click', function (e) {\n                    let target = Q(e.target);\n                    if (target.hasClass(classes.q_form_dropdown_option) && !target.hasClass(classes.q_form_disabled)) {\n                        callback(valueMap.get(target));\n                    }\n                });\n            };\n            wrapper.select = function (value) {\n                options.find('.' + classes.q_form_dropdown_option).each(function () {\n                    let option = Q(this);\n                    if (valueMap.get(option) === value) {\n                        selected.html(option.html());\n                        selectedValue = value;\n                        deselect();\n                        options.find('.' + classes.q_form_dropdown_option).removeClass(classes.q_form_dropdown_active);\n                        option.addClass(classes.q_form_dropdown_active);\n                    }\n                });\n            };\n            wrapper.disabled = function (value, state) {\n                options.find('.' + classes.q_form_dropdown_option).each(function () {\n                    let option = Q(this);\n                    if (valueMap.get(option) === value) {\n                        option.prop('disabled', state);\n                        if (state) {\n                            option.addClass(classes.q_form_disabled);\n                        } else {\n                            option.removeClass(classes.q_form_disabled);\n                        }\n                    }\n                });\n            };\n            wrapper.remove = function (value) {\n                options.find('.' + classes.q_form_dropdown_option).each(function () {\n                    let option = Q(this);\n                    if (valueMap.get(option) === value) {\n                        option.remove();\n                        valueMap.delete(option);\n                    }\n                });\n            };\n            wrapper.value = function () {\n                return selectedValue;\n            };\n            return wrapper;\n        },\n        Slider: function (min = 0, max = 100, value = 50) {\n            const slider = Q('<input type=\"range\" class=\"' + classes.q_form_slider + '\">');\n            slider.attr('min', min);\n            slider.attr('max', max);\n            slider.attr('value', value);\n            let slider_wrapper = Q('<div class=\"' + classes.q_form + ' ' + classes.q_slider_wrapper + '\">');\n            let slider_value = Q('<div class=\"' + classes.q_slider_pos + '\">');\n            slider_wrapper.append(slider_value, slider);\n            const slider_width = () => {\n                let percent = (slider.val() - slider.attr('min')) / (slider.attr('max') - slider.attr('min')) * 100;\n                slider_value.css({\n                    width: percent + '%'\n                });\n            };\n            slider.on('input', function () {\n                slider_width();\n            });\n            slider_width();\n            slider_wrapper.change = function (callback) {\n                slider.on('input', function () {\n                    callback(this.value);\n                });\n            };\n            slider_wrapper.value = function (value) {\n                if (value !== _un) {\n                    slider.val(value);\n                    slider.trigger('input');\n                }\n                return slider.val();\n            };\n            slider_wrapper.disabled = function (state) {\n                slider.prop('disabled', state);\n                if (state) {\n                    slider_wrapper.addClass(classes.q_form_disabled);\n                } else {\n                    slider_wrapper.removeClass(classes.q_form_disabled);\n                }\n            };\n            slider_wrapper.min = function (value) {\n                if (value !== _un) {\n                    slider.attr('min', value);\n                    slider.trigger('input');\n                }\n                return slider.attr('min');\n            };\n            slider_wrapper.max = function (value) {\n                if (value !== _un) {\n                    slider.attr('max', value);\n                    slider.trigger('input');\n                }\n                return slider.attr('max');\n            };\n            slider_wrapper.remove = function () {\n                slider_wrapper.remove();\n            };\n            return slider_wrapper;\n        },\n        Window: function (title = '', data, width = 300, height = 300, x = 100, y = 10) {\n            let dimensions = { width, height, x, y };\n            let minimized = false;\n            let maximized = false;\n            let animation_speed = 200;\n            let window_wrapper = Q('<div class=\"' + classes.q_window + '\">');\n            let titlebar = Q('<div class=\"' + classes.q_window_titlebar + '\">');\n            let titletext = Q('<div class=\"' + classes.q_window_titletext + '\">');\n            let uniqueButtons = Q('<div class=\"' + classes.q_window_unique_buttons + '\">');\n            let default_buttons = Q('<div class=\"' + classes.q_window_buttons + '\">');\n            let content = Q('<div class=\"' + classes.q_window_content + '\">');\n            let close = Q('<div class=\"' + classes.q_window_button + ' ' + classes.q_window_close + '\">');\n            let minimize = Q('<div class=\"' + classes.q_window_button + ' ' + classes.q_window_minimize + '\">');\n            let maximize = Q('<div class=\"' + classes.q_window_button + ' ' + classes.q_window_maximize + '\">');\n            close.append(Icon('window-close'));\n            minimize.html(Icon('window-minimize'));\n            maximize.html(Icon('window-full'));\n            content.append(data);\n            titletext.text(title);\n            titletext.attr('title', title);\n            titlebar.append(titletext, uniqueButtons, default_buttons);\n            default_buttons.append(minimize, maximize, close);\n            window_wrapper.append(titlebar, content);\n            dimensions.width = dimensions.width > window_wrapper.parent().width() ? window_wrapper.parent().width() : dimensions.width;\n            dimensions.height = dimensions.height > window_wrapper.parent().height() ? window_wrapper.parent().height() : dimensions.height;\n            dimensions.x = dimensions.x + dimensions.width > window_wrapper.parent().width() ? window_wrapper.parent().width() - dimensions.width : dimensions.x;\n            dimensions.y = dimensions.y + dimensions.height > window_wrapper.parent().height() ? window_wrapper.parent().height() - dimensions.height : dimensions.y;\n            window_wrapper.css({\n                width: dimensions.width + 'px',\n                height: dimensions.height + 'px',\n                left: dimensions.x + 'px',\n                top: dimensions.y + 'px'\n            });\n            function debounce(func, wait) {\n                let timeout;\n                return function (...args) {\n                    _ct(timeout);\n                    timeout = _st(() => func.apply(this, args), wait);\n                };\n            }\n            function handleResize() {\n                const browserWidth = window.innerWidth;\n                const browserHeight = window.innerHeight;\n                const { left: currentX, top: currentY } = window_wrapper.position();\n                let { width: currentWidth, height: currentHeight } = window_wrapper.size();\n                currentWidth = _ma.min(currentWidth, browserWidth);\n                currentHeight = _ma.min(currentHeight, browserHeight);\n                const newX = _ma.min(currentX, browserWidth - currentWidth);\n                const newY = _ma.min(currentY, browserHeight - currentHeight);\n                window_wrapper.css({\n                    width: `${currentWidth}px`,\n                    height: `${currentHeight}px`,\n                    left: `${newX}px`,\n                    top: `${newY}px`\n                });\n            }\n            window.addEventListener('resize', debounce(handleResize, 300));\n            close.on('click', function () {\n                window_wrapper.animate(200, {\n                    opacity: 0,\n                    transform: 'scale(0.8)'\n                }, function () {\n                    window_wrapper.hide();\n                });\n            });\n            minimize.on('click', function () {\n                content.toggle();\n                if (maximized) {\n                    maximized = false;\n                    maximize.html(Icon('window-full'));\n                    window_wrapper.animate(animation_speed, {\n                        width: dimensions.width + 'px',\n                        height: dimensions.height + 'px',\n                        left: dimensions.x + 'px',\n                        top: dimensions.y + 'px'\n                    }, function () {\n                        window_wrapper.removeTransition();\n                    });\n                }\n                if (minimized) {\n                    minimize.html(Icon('window-minimize'));\n                    window_wrapper.css({\n                        height: dimensions.height + 'px'\n                    });\n                    minimized = false;\n                    handleResize();\n                } else {\n                    minimize.html(Icon('window-windowed'));\n                    window_wrapper.css({\n                        height: titlebar.height() + 'px'\n                    });\n                    minimized = true;\n                }\n            });\n            maximize.on('click', function () {\n                if (minimized) {\n                    minimize.html(Icon('window-minimize'));\n                    minimized = false;\n                    if (!content.is(':visible')) {\n                        content.toggle();\n                    }\n                }\n                if (maximized) {\n                    maximized = false;\n                    maximize.html(Icon('window-full'));\n                    window_wrapper.animate(animation_speed, {\n                        width: dimensions.width + 'px',\n                        height: dimensions.height + 'px',\n                        left: dimensions.x + 'px',\n                        top: dimensions.y + 'px'\n                    }, function () {\n                        window_wrapper.removeTransition();\n                        handleResize();\n                    });\n                } else {\n                    maximized = true;\n                    maximize.html(Icon('window-windowed'));\n                    window_wrapper.animate(animation_speed, {\n                        width: '100%',\n                        height: '100%',\n                        left: 0,\n                        top: 0,\n                        borderRadius: 0\n                    }, function () {\n                        window_wrapper.removeTransition();\n                    });\n                }\n            });\n            const zindex = () => {\n                let highestZIndex = 0;\n                Q('.q_window').each(function () {\n                    let zIndex = parseInt(Q(this).css('z-index'));\n                    if (zIndex > highestZIndex) {\n                        highestZIndex = zIndex;\n                    }\n                });\n                return highestZIndex + 1;\n            };\n            titlebar.on('pointerdown', function (e) {\n                let offset = window_wrapper.position();\n                let x = e.clientX - offset.left;\n                let y = e.clientY - offset.top;\n                window_wrapper.css({\n                    'z-index': zindex()\n                });\n                const pointerMoveHandler = function (e) {\n                    let left = e.clientX - x;\n                    let top = e.clientY - y;\n                    left = _ma.max(0, left);\n                    top = _ma.max(0, top);\n                    let currentWidth = window_wrapper.width();\n                    let currentHeight = window_wrapper.height();\n                    left = _ma.min(window.innerWidth - currentWidth, left);\n                    top = _ma.min(window.innerHeight - currentHeight, top);\n                    dimensions.x = left;\n                    dimensions.y = top;\n                    window_wrapper.css({\n                        left: dimensions.x + 'px',\n                        top: dimensions.y + 'px'\n                    });\n                };\n                const pointerUpHandler = function () {\n                    Q(document).off('pointermove', pointerMoveHandler);\n                    Q(document).off('pointerup', pointerUpHandler);\n                };\n                Q(document).on('pointermove', pointerMoveHandler);\n                Q(document).on('pointerup', pointerUpHandler);\n            });\n            window_wrapper.show = function () {\n                if (window_wrapper.isExists()) {\n                    window_wrapper.fadeIn(200);\n                }\n                else {\n                    Q('body').append(window_wrapper);\n                }\n            };\n            window_wrapper.hide = function () {\n                window_wrapper.fadeOut(200);\n            };\n            window_wrapper.title = function (newTitle) {\n                if (newTitle !== _un) {\n                    titletext.text(newTitle);\n                }\n                return titletext.text();\n            };\n            window_wrapper.content = function (newContent) {\n                if (newContent !== _un) {\n                    content.html(newContent);\n                }\n            };\n            window_wrapper.close = function () {\n                close.click();\n            };\n            window_wrapper.minimize = function () {\n                minimize.click();\n            };\n            window_wrapper.maximize = function () {\n                maximize.click();\n            };\n            window_wrapper.remove = function () {\n                window_wrapper.remove();\n            };\n            return window_wrapper;\n        },\n        CheckBox: function (checked = false, text = '') {\n            let ID = '_' + Q.ID();\n            const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_checkbox + '\">');\n            const checkbox_container = Q('<div class=\"' + classes.q_form_cb + '\">');\n            const input = Q(`<input type=\"checkbox\" id=\"${ID}\">`);\n            const label = Q(`<label for=\"${ID}\">${text}</label>`);\n            const labeltext = Q(`<div class=\"label\">${text}</div>`);\n            checkbox_container.append(input, label);\n            container.append(checkbox_container, labeltext);\n            container.checked = function (state) {\n                input.prop('checked', state);\n                if (state) {\n                    input.trigger('change');\n                }\n            };\n            container.change = function (callback) {\n                input.on('change', function () {\n                    callback(this.checked);\n                });\n            };\n            container.disabled = function (state) {\n                input.prop('disabled', state);\n                if (state) {\n                    container.addClass(classes.q_form_disabled);\n                } else {\n                    container.removeClass(classes.q_form_disabled);\n                }\n            };\n            container.text = function (text) {\n                labeltext.text(text);\n            };\n            return container;\n        },\n        TextBox: function (type = 'text', value = '', placeholder = '') {\n            const input = Q(`<input class=\"${classes.q_form} ${classes.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n            input.placeholder = function (text) {\n                input.attr('placeholder', text);\n            };\n            input.disabled = function (state) {\n                input.prop('disabled', state);\n                if (state) {\n                    input.addClass(classes.q_form_disabled);\n                } else {\n                    input.removeClass(classes.q_form_disabled);\n                }\n            };\n            input.reset = function () {\n                input.val('');\n            };\n            input.change = function (callback) {\n                input.on('change', function () {\n                    callback(this.value);\n                });\n            };\n            return input;\n        },\n        TextArea: function (value = '', placeholder = '') {\n            const textarea = Q(`<textarea class=\"${classes.q_form} ${classes.q_form_textarea}\" placeholder=\"${placeholder}\">${value}</textarea>`);\n            textarea.placeholder = function (text) {\n                textarea.attr('placeholder', text);\n            };\n            textarea.disabled = function (state) {\n                textarea.prop('disabled', state);\n                if (state) {\n                    textarea.addClass(classes.q_form_disabled);\n                } else {\n                    textarea.removeClass(classes.q_form_disabled);\n                }\n            };\n            textarea.reset = function () {\n                textarea.val('');\n            };\n            textarea.change = function (callback) {\n                textarea.on('change', function () {\n                    callback(this.value);\n                });\n            };\n            return textarea;\n        },\n        Radio: function (data) {\n            let wrapper = Q('<div class=\"q_form q_form_radio_wrapper\">');\n            let radios = [];\n            data.forEach((item, index) => {\n                let ID = '_' + Q.ID();\n                const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_radio + '\">');\n                const radio_container = Q('<div class=\"' + classes.q_form_r + '\">');\n                const input = Q(`<input type=\"radio\" id=\"${ID}\" name=\"${item.name}\" value=\"${item.value}\">`);\n                const label = Q(`<label for=\"${ID}\"></label>`);\n                const labeltext = Q(`<div class=\"label\">${item.text}</div>`);\n                if (item.disabled) {\n                    input.prop('disabled', true);\n                    container.addClass(classes.q_form_disabled);\n                }\n                radios.push({ container, input, labeltext });\n                radio_container.append(input, label);\n                container.append(radio_container, labeltext);\n                wrapper.append(container);\n            });\n            wrapper.change = function (callback) {\n                radios.forEach(radio => {\n                    radio.input.on('change', function () {\n                        if (this.checked) {\n                            callback(this.value);\n                        }\n                    });\n                });\n            };\n            wrapper.select = function (value) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.input.prop('checked', true).trigger('click');\n                    }\n                });\n            };\n            wrapper.disabled = function (value, state) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.input.prop('disabled', state);\n                        if (state) {\n                            radio.container.addClass(classes.q_form_disabled);\n                        } else {\n                            radio.container.removeClass(classes.q_form_disabled);\n                        }\n                    }\n                });\n            };\n            wrapper.text = function (value, text) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.labeltext.text(text);\n                    }\n                });\n            };\n            wrapper.remove = function (value) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.container.remove();\n                    }\n                });\n            };\n            wrapper.reset = function () {\n                radios.forEach(radio => radio.input.prop('checked', false));\n            };\n            wrapper.checked = function (value, state) {\n                radios.forEach(radio => {\n                    if (radio.input.val() === value) {\n                        radio.input.prop('checked', state);\n                    }\n                });\n            };\n            return wrapper;\n        }\n    };\n};"
        },
        "Icons": {
            "uuid": "3682285e-9cde-41df-a01b-e7351950b5dc",
            "name": "Icons",
            "method": "Plugin",
            "desc": "Additional icons for the VulpiniQ library.",
            "type": "Plugin",
            "example": "Q.Icons();",
            "dependencies": [
                "style"
            ],
            "script": "Q.Icons = function () {\n  let glob = Q.getGLOBAL('icons');\n  let classes = {};\n  if (glob && glob.icons) {\n    classes = glob.icons;\n  }\n  else {\n    classes = Q.style(`:root {\n\t--icon_arrow-down: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 100.93685,31.353867 C 82.480099,48.598492 67.319803,62.707709 67.247301,62.707709 c -0.0725,0 -15.232809,-14.109215 -33.689561,-31.353842 L 3.5365448e-8,6.6845858e-7 H 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"M 31.353844,100.93685 C 14.109219,82.480099 1.6018623e-6,67.319803 1.6018623e-6,67.247301 1.6018623e-6,67.174801 14.109217,52.014492 31.353844,33.55774 L 62.70771,0 V 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"m 31.353868,33.55775 c 17.244625,18.456749 31.353842,33.617045 31.353842,33.689547 0,0.0725 -14.109215,15.232809 -31.353842,33.689563 L 1.6018623e-6,134.4946 V 67.247297 0 Z\"/></svg>');\n\t--icon_arrow-up: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 33.55775,31.353843 C 52.014499,14.109218 67.174795,6.6845858e-7 67.247297,6.6845858e-7 67.319797,6.6845858e-7 82.480106,14.109216 100.93686,31.353843 L 134.4946,62.707709 H 67.247297 3.5365448e-8 Z\"/></svg>');\n\t--icon_navigation-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2666.6667 2666.6667\"><path d=\"M 1276.6667,2434.5485 C 950.24325,2418.4963 647.60291,2257.2797 449.65648,1994.0001 360.09366,1874.8766 294.54616,1735.7649 260.06678,1591.6333 c -40.82486,-170.6571 -40.82486,-347.2761 0,-517.9332 71.52438,-298.98806 268.8554,-557.46223 540.12266,-707.48002 258.68606,-143.06006 568.06486,-175.54075 852.57376,-89.50899 276.927,83.73908 511.1437,274.85672 650.2832,530.62227 168.8614,310.40014 177.2264,688.09064 22.2995,1006.84964 -77.0037,158.4335 -189.7203,295.013 -331.3458,401.4939 -205.303,154.3568 -458.4668,231.6017 -717.3334,218.8716 z m 130.2294,-151.2014 c 229.6976,-18.6692 437.2639,-114.273 599.1754,-275.9766 47.6541,-47.593 83.7471,-91.4686 120.133,-146.0371 91.2885,-136.9067 142.8941,-286.0616 157.3086,-454.6667 3.0513,-35.6912 3.0513,-112.3088 0,-148 -9.7543,-114.0948 -35.6813,-216.2096 -79.956,-314.91095 C 2140.8657,803.99837 2044.7703,680.42081 1924.6667,585.10582 1705.8186,411.42656 1421.4281,342.88551 1146,397.43913 961.28159,434.02604 793.07082,524.16769 658.61926,658.61926 508.15954,809.07897 413.50356,1001.5246 386.76219,1211.3334 c -5.50464,43.1886 -7.16468,71.3013 -7.16468,121.3333 0,50.0321 1.66004,78.1448 7.16468,121.3333 31.40785,246.4213 158.34097,471.0271 353.9045,626.2276 118.14734,93.7625 258.15376,158.5796 405.33331,187.6524 50.7995,10.0346 91.5353,14.8142 153.3334,17.9909 18.4799,0.95 83.6306,-0.5787 107.5627,-2.5238 z m 134.7679,-630.3487 -208.3296,-208.3296 -207.9982,207.9951 -207.99834,207.9951 -54.66892,-54.6567 c -30.0679,-30.0612 -54.66892,-55.2602 -54.66892,-55.9978 0,-0.7375 93.30001,-94.6396 207.33338,-208.6711 l 207.3333,-207.3301 -206.6689,-206.6721 -206.66886,-206.67213 55.00599,-54.99402 55.006,-54.99402 206.66127,206.66447 206.6613,206.6646 207.6661,-207.6629 207.666,-207.66288 55.3378,55.32571 55.3378,55.32571 -207.6673,207.67046 -207.6673,207.6705 208.3339,208.3372 208.334,208.3371 -55.0055,54.9935 -55.0054,54.9935 z\"/></svg>');\n\t--icon_navigation-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 282.12556,619.5403 247.03663,609.52248 218.00001,595.4014 129.37889,552.30321 70.013661,466.90205 60.059145,368.19207 51.577814,284.09034 83.346262,198.0417 144.85111,138.52292 212.10881,73.437059 306.81846,45.865772 398.4674,64.691724 519.45153,89.543525 610.11296,190.57708 622.60754,314.47462 c 8.48133,84.10173 -23.28712,170.15036 -84.79196,229.66914 -59.89864,57.96444 -141.4913,86.4009 -224.85943,78.36742 z m 71.04386,-40.49085 c 101.01231,-18.37977 179.6848,-97.26565 198.14953,-198.68699 3.46591,-19.0372 3.48193,-65.25956 0.0291,-84 -18.78642,-101.96514 -96.94357,-180.11939 -198.8453,-198.83796 -18.89894,-3.471598 -65.10105,-3.471598 -84,0 C 197.45585,119.2095 119.27,197.39245 100.48802,299.33334 c -3.452807,18.74044 -3.436783,64.9628 0.0291,84 16.64224,91.4109 82.13775,165.12641 170.46427,191.85833 8.26023,2.49995 21.0186,5.49414 28.35193,6.65376 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 320.66668,412.53122 c -36.66667,-38.4534 -66.66667,-70.49248 -66.66667,-71.19795 0,-0.70547 30.15,-32.79758 67,-71.31579 l 67,-70.03311 v 141.34115 c 0,77.73764 -0.15,141.29162 -0.33333,141.23108 -0.18334,-0.0605 -30.33334,-31.57197 -67,-70.02538 z\"/></svg>');\n\t--icon_navigation-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 103.83077,602.35954 -10.876679,362.01744 104.94177,186.66667 225.81958,3.6559506 499.6699,21.151057 595.4014,218.00001 691.73222,416.0813 532.80292,643.69595 312.95615,622.51118 Z m 71.04386,-40.49085 C 527.6749,555.87785 617.23885,410.16562 575.1842,270.98141 536.24285,142.10102 399.55264,68.634561 270.98141,107.48249 119.67709,153.19925 50.784795,329.22352 130.9177,465.35432 c 35.94209,61.05887 100.57273,105.76313 168.41564,116.49111 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 294.66668,341.34179 V 199.98437 l 67,70.03311 c 36.85,38.51821 67,70.60056 67,71.2941 0,0.69354 -30.15,32.78948 -67,71.32431 l -67,70.06332 z\"/></svg>');\n\t--icon_window-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 2.8176856,98.903421 -4.0360052e-7,96.085741 22.611458,73.473146 45.222917,50.860554 22.611458,28.247962 -4.0360052e-7,5.6353711 2.8176856,2.8176851 5.6353716,-9.1835591e-7 28.247963,22.611458 50.860555,45.222916 73.473147,22.611458 96.085743,-9.1835591e-7 98.903423,2.8176851 101.72111,5.6353711 79.109651,28.247962 56.498193,50.860554 79.109651,73.473146 101.72111,96.085741 98.903423,98.903421 96.085743,101.72111 73.473147,79.109651 50.860555,56.498192 28.247963,79.109651 5.6353716,101.72111 Z\"/></svg>');\n\t--icon_window-full: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 H 50.860555 84.417403 V 50.860554 84.417401 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z\"/></svg>');\n\t--icon_window-minimize: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 0.5252846,83.893071 V 79.698469 H 50.860555 101.19582 v 4.194602 4.19461 H 50.860555 0.5252846 Z\"/></svg>');\n\t--icon_window-windowed: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 h 8.389212 8.389212 V 8.9144961 0.52528408 H 67.638978 101.19582 V 34.082131 67.638977 h -8.389207 -8.38921 v 8.389212 8.389212 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z M 92.806613,34.082131 V 8.9144961 H 67.638978 42.471343 v 4.1946059 4.194606 h 20.973029 20.973031 v 20.973029 20.973029 h 4.1946 4.19461 z\"/></svg>');\n\t--icon_zoom-in: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n\t--icon_zoom-out: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n}\n.svg_icon {-webkit-mask-size: cover;mask-size: cover;-webkit-mask-repeat: no-repeat;mask-repeat: no-repeat;-webkit-mask-position: center;mask-position: center;background-color: currentColor;}\n.svg_iconsize { width:100%;height:100%; }\n.arrow-down { mask-image: var(--icon_arrow-down);}\n.arrow-left { mask-image: var(--icon_arrow-left);}\n.arrow-right { mask-image: var(--icon_arrow-right);}\n.arrow-up { mask-image: var(--icon_arrow-up);}\n.navigation-close { mask-image: var(--icon_navigation-close);}\n.navigation-left { mask-image: var(--icon_navigation-left);}\n.navigation-right { mask-image: var(--icon_navigation-right);}\n.window-close { mask-image: var(--icon_window-close);}\n.window-full { mask-image: var(--icon_window-full);}\n.window-minimize { mask-image: var(--icon_window-minimize);}\n.window-windowed { mask-image: var(--icon_window-windowed);}\n.zoom-in { mask-image: var(--icon_zoom-in);}\n.zoom-out { mask-image: var(--icon_zoom-out);}\n`\n,{\n  \"arrow-down\": \"arrow-down\",\n  \"arrow-left\": \"arrow-left\",\n  \"arrow-right\": \"arrow-right\",\n  \"arrow-up\": \"arrow-up\",\n  \"navigation-close\": \"navigation-close\",\n  \"navigation-left\": \"navigation-left\",\n  \"navigation-right\": \"navigation-right\",\n  \"window-close\": \"window-close\",\n  \"window-full\": \"window-full\",\n  \"window-minimize\": \"window-minimize\",\n  \"window-windowed\": \"window-windowed\",\n  \"zoom-in\": \"zoom-in\",\n  \"zoom-out\": \"zoom-out\",\n  \"svg_icon\": \"svg_icon\",\n  \"svg_iconsize\": \"svg_iconsize\"\n}, true);\n  }\n  return {\n    get: function (name, additional = '') {\n      if (additional === '') {\n        additional = classes['svg_iconsize'];\n      }\n      return Q('<div>', {class: classes['svg_icon'] + ' ' + classes[name] + ' ' + additional});\n    }\n  }\n};"
        },
        "Image": {
            "uuid": "dc62fc24-9974-46dc-b44f-368648207071",
            "name": "Image",
            "method": "Plugin",
            "desc": "Useful to manipulate images.",
            "type": "Plugin",
            "example": "var image = Q.Image();",
            "dependencies": [
                "RGB2HSL",
                "HSL2RGB"
            ],
            "script": "Q.Image = function (options) {\n    let Canvas = Q('<canvas>');\n    let canvas_node = Canvas.nodes[0];\n    let defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        size: 'auto',\n        quality: 1\n    }\n    options = _ob.assign(defaultOptions, options);\n    Canvas.Load = function (src, callback) {\n        let img = new Image();\n        img.src = src;\n        img.onload = function () {\n            canvas_node.width = img.width;\n            canvas_node.height = img.height;\n            canvas_node.getContext('2d').drawImage(img, 0, 0);\n            if (callback) callback();\n        };\n    }\n    Canvas.Get = function (format = options.format, quality = options.quality) {\n        if (format === 'jpeg' || format === 'webp') {\n            return canvas_node.toDataURL('image/' + format, quality);\n        } else {\n            return canvas_node.toDataURL('image/' + format);\n        }\n    }\n    Canvas.Save = function (filename, format = options.format, quality = options.quality) {\n        let href = Canvas.Get(format, quality);\n        let a = Q('<a>', { download: filename, href: href });\n        a.click();\n    }\n    Canvas.Clear = function (fill = options.fill) {\n        let ctx = canvas_node.getContext('2d');\n        ctx.fillStyle = fill;\n        ctx.fillRect(0, 0, canvas_node.width, canvas_node.height);\n    }\n    Canvas.Resize = function (width, height, size = options.size, keepDimensions = false) {\n        options.width = width;\n        options.height = height;\n        options.size = size;\n        _c.log(keepDimensions);\n        let temp = Q('<canvas>', { width: width, height: height }).nodes[0];\n        let ctx = temp.getContext('2d');\n        let ratio = 1;\n        let canvasWidth = canvas_node.width;\n        let canvasHeight = canvas_node.height;\n        if (size === 'contain') {\n            if (keepDimensions) {\n                let widthRatio = width / canvasWidth;\n                let heightRatio = height / canvasHeight;\n                ratio = _ma.min(widthRatio, heightRatio);\n                let newWidth = canvasWidth * ratio;\n                let newHeight = canvasHeight * ratio;\n                let xOffset = (width - newWidth) / 2;\n                let yOffset = (height - newHeight) / 2;\n                ctx.fillStyle = options.fill;\n                ctx.fillRect(0, 0, width, height);\n                ctx.drawImage(canvas_node, xOffset, yOffset, newWidth, newHeight);\n            } else {\n                let widthRatio = width / canvasWidth;\n                let heightRatio = height / canvasHeight;\n                ratio = _ma.min(widthRatio, heightRatio);\n                let newWidth = canvasWidth * ratio;\n                let newHeight = canvasHeight * ratio;\n                ctx.imageSmoothingEnabled = true;\n                ctx.imageSmoothingQuality = 'high';\n                ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n            }\n        } else if (size === 'cover') {\n            let widthRatio = width / canvasWidth;\n            let heightRatio = height / canvasHeight;\n            ratio = _ma.max(widthRatio, heightRatio);\n            let newWidth = canvasWidth * ratio;\n            let newHeight = canvasHeight * ratio;\n            let xOffset = (newWidth - width) / 2;\n            let yOffset = (newHeight - height) / 2;\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = 'high';\n            ctx.drawImage(canvas_node, -xOffset, -yOffset, newWidth, newHeight);\n        } else if (size === 'auto') {\n            ratio = _ma.min(width / canvasWidth, height / canvasHeight);\n            let newWidth = canvasWidth * ratio;\n            let newHeight = canvasHeight * ratio;\n            ctx.fillStyle = options.fill;\n            ctx.fillRect(0, 0, width, height);\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = 'high';\n            ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n        }\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Crop = function (x, y, width, height) {\n        let temp = Q('<canvas>', { width: width, height: height });\n        temp.getContext('2d').drawImage(canvas_node, x, y, width, height, 0, 0, width, height);\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Rotate = function (degrees) {\n        let temp = Q('<canvas>', { width: canvas_node.height, height: canvas_node.width });\n        let ctx = temp.getContext('2d');\n        ctx.translate(canvas_node.height / 2, canvas_node.width / 2);\n        ctx.rotate(degrees * _ma.PI / 180);\n        ctx.drawImage(canvas_node, -canvas_node.width / 2, -canvas_node.height / 2);\n        canvas_node.width = temp.width;\n        canvas_node.height = temp.height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Flip = function (direction = 'horizontal')\n    {\n        let temp = Q('<canvas>', { width: canvas_node.width, height: canvas_node.height });\n        let ctx = temp.getContext('2d');\n        ctx.translate(canvas_node.width, 0);\n        ctx.scale(direction == 'horizontal' ? -1 : 1, direction == 'vertical' ? -1 : 1);\n        ctx.drawImage(canvas_node, 0, 0);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Grayscale = function () {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;\n            pixels[i] = avg;\n            pixels[i + 1] = avg;\n            pixels[i + 2] = avg;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Brightness = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] += value;\n            pixels[i + 1] += value;\n            pixels[i + 2] += value;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Contrast = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let factor = (259 * (value + 255)) / (255 * (259 - value));\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = factor * (pixels[i] - 128) + 128;\n            pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n            pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Vivid = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = _ma.min(255, pixels[i] * value);\n            pixels[i + 1] = _ma.min(255, pixels[i + 1] * value);\n            pixels[i + 2] = _ma.min(255, pixels[i + 2] * value);\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Hue = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let r = pixels[i];\n            let g = pixels[i + 1];\n            let b = pixels[i + 2];\n            let hsl = Q.RGB2HSL(r, g, b);\n            hsl[0] += value;\n            let rgb = Q.HSL2RGB(hsl[0], hsl[1], hsl[2]);\n            pixels[i] = rgb[0];\n            pixels[i + 1] = rgb[1];\n            pixels[i + 2] = rgb[2];\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Sharpen = function (options) {\n        let defaults = {\n            amount: 1,\n            threshold: 0,\n            radius: 1,\n            quality: 1\n        };\n        options = _ob.assign(defaults, options);\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let weights = [-1, -1, -1, -1, 9, -1, -1, -1, -1];\n        let katet = _ma.round(_ma.sqrt(weights.length));\n        let half = _ma.floor(katet / 2);\n        let divisor = weights.reduce((sum, weight) => sum + weight, 0) || 1;\n        let offset = 0;\n        let dataCopy = new Uint8ClampedArray(pixels);\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        let iterations = _ma.round(options.quality);\n        let iteration = 0;\n        while (iteration < iterations) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n                    let dstOff = (y * width + x) * 4;\n                    for (let cy = 0; cy < katet; cy++) {\n                        for (let cx = 0; cx < katet; cx++) {\n                            let scy = y + cy - half;\n                            let scx = x + cx - half;\n                            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                                let srcOff = (scy * width + scx) * 4;\n                                let wt = weights[cy * katet + cx];\n                                r += dataCopy[srcOff] * wt;\n                                g += dataCopy[srcOff + 1] * wt;\n                                b += dataCopy[srcOff + 2] * wt;\n                            }\n                        }\n                    }\n                    r = _ma.min(_ma.max((r / divisor) + offset, 0), 255);\n                    g = _ma.min(_ma.max((g / divisor) + offset, 0), 255);\n                    b = _ma.min(_ma.max((b / divisor) + offset, 0), 255);\n                    if (_ma.abs(dataCopy[dstOff] - r) > options.threshold) {\n                        pixels[dstOff] = r;\n                        pixels[dstOff + 1] = g;\n                        pixels[dstOff + 2] = b;\n                    }\n                }\n            }\n            iteration++;\n        }\n        ctx.putImageData(data, 0, 0);\n    }\n    Canvas.Emboss = function (options) {\n        let defaults = {\n            strength: 1,\n            direction: 'top-left',\n            blend: true,    \n            grayscale: true  \n        };\n        options = _ob.assign(defaults, options);\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        let dataCopy = new Uint8ClampedArray(pixels);\n        let kernels = {\n            'top-left': [-2, -1, 0, -1, 1, 1, 0, 1, 2],\n            'top-right': [0, -1, -2, 1, 1, -1, 2, 1, 0],\n            'bottom-left': [0, 1, 2, -1, 1, 1, -2, -1, 0],\n            'bottom-right': [2, 1, 0, 1, 1, -1, 0, -1, -2]\n        };\n        let kernel = kernels[options.direction] || kernels['top-left'];\n        let katet = _ma.sqrt(kernel.length); \n        let half = _ma.floor(katet / 2);\n        let strength = options.strength;\n        let divisor = 1; \n        let offset = 128; \n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0;\n                let dstOff = (y * width + x) * 4;\n                for (let cy = 0; cy < katet; cy++) {\n                    for (let cx = 0; cx < katet; cx++) {\n                        let scy = y + cy - half;\n                        let scx = x + cx - half;\n                        if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                            let srcOff = (scy * width + scx) * 4; \n                            let wt = kernel[cy * katet + cx];\n                            r += dataCopy[srcOff] * wt;\n                            g += dataCopy[srcOff + 1] * wt;\n                            b += dataCopy[srcOff + 2] * wt;\n                        }\n                    }\n                }\n                r = (r / divisor) * strength + offset;\n                g = (g / divisor) * strength + offset;\n                b = (b / divisor) * strength + offset;\n                if (options.grayscale) {\n                    let avg = (r + g + b) / 3;\n                    r = g = b = avg;\n                }\n                r = _ma.min(_ma.max(r, 0), 255);\n                g = _ma.min(_ma.max(g, 0), 255);\n                b = _ma.min(_ma.max(b, 0), 255);\n                if (options.blend) {\n                    pixels[dstOff] = (pixels[dstOff] + r) / 2;\n                    pixels[dstOff + 1] = (pixels[dstOff + 1] + g) / 2;\n                    pixels[dstOff + 2] = (pixels[dstOff + 2] + b) / 2;\n                } else {\n                    pixels[dstOff] = r;\n                    pixels[dstOff + 1] = g;\n                    pixels[dstOff + 2] = b;\n                }\n            }\n        }\n        ctx.putImageData(data, 0, 0);\n    }\n    Canvas.Blur = function (options) {\n        let defaults = {\n            radius: 5, \n            quality: 1 \n        };\n        options = _ob.assign(defaults, options);\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        function gaussianKernel(radius) {\n            let size = 2 * radius + 1;\n            let kernel = new Float32Array(size * size);\n            let sigma = radius / 3;\n            let sum = 0;\n            let center = radius;\n            for (let y = 0; y < size; y++) {\n                for (let x = 0; x < size; x++) {\n                    let dx = x - center;\n                    let dy = y - center;\n                    let weight = _ma.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));\n                    kernel[y * size + x] = weight;\n                    sum += weight;\n                }\n            }\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= sum;\n            }\n            return {\n                kernel: kernel,\n                size: size\n            };\n        }\n        let { kernel, size } = gaussianKernel(options.radius);\n        let half = _ma.floor(size / 2);\n        let iterations = _ma.round(options.quality);\n        function applyBlur() {\n            let output = new Uint8ClampedArray(pixels);\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n                    let dstOff = (y * width + x) * 4;\n                    for (let ky = 0; ky < size; ky++) {\n                        for (let kx = 0; kx < size; kx++) {\n                            let ny = y + ky - half;\n                            let nx = x + kx - half;\n                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                                let srcOff = (ny * width + nx) * 4;\n                                let weight = kernel[ky * size + kx];\n                                r += pixels[srcOff] * weight;\n                                g += pixels[srcOff + 1] * weight;\n                                b += pixels[srcOff + 2] * weight;\n                            }\n                        }\n                    }\n                    output[dstOff] = r;\n                    output[dstOff + 1] = g;\n                    output[dstOff + 2] = b;\n                }\n            }\n            return output;\n        }\n        for (let i = 0; i < iterations; i++) {\n            pixels = applyBlur();\n        }\n        ctx.putImageData(new ImageData(pixels, width, height), 0, 0);\n    }\n    return Canvas;\n}"
        },
        "ImageViewer": {
            "uuid": "f5354ad2-0e58-4885-beaa-db727c38590e",
            "name": "ImageViewer",
            "method": "Plugin",
            "desc": "A simple image viewer plugin",
            "type": "Plugin",
            "example": "Q.ImageViewer().selector('.image').open(['image1.jpg', 'image2.jpg']);",
            "dependencies": [
                "Style",
                "Icons"
            ],
            "script": "Q.ImageViewer = function () {\n    let classes = Q.style(`\n.image_viewer_wrapper {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    background: rgba(0, 0, 0, 0.77);\n    transition: background 10s;\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n    color: #fff;\n}\n.image_panel {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n.image_wrapper {\n    width: 100%;\n    height: 100%;\n    opacity: 0;\n    transition: all 0.15s;\n    margin: 0 1px;\n    display: flex;\n    flex-direction: column;\n    animation: fadeInScale 0.3s forwards;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n}\n.image_canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    transition: width 0.3s, height 0.3s;\n}\n.image_ambient {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    filter: blur(25px);\n    opacity: 0.75;\n    z-index: 0;\n}\n@keyframes fadeInScale {\n    to {\n        opacity: 1;\n    }\n}\n.image_viewer_wrapper .image_panel {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.image_top, .image_bottom {\n    width: 100%;\n    z-index: 1;\n    position: absolute;\n}\n.image_top {\n    top: 0;\n    text-align: left;\n    background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);\n}\n.image_bottom {\n    bottom: 0;\n}\n.side_left, .side_right {\n    height: 100%;\n    width: 80px;\n}\n.image_info {\n    max-width: 500px;\n    padding: 10px;\n    text-shadow: 0 1px 3px #000;\n}\n.image_title {\n    font-size: 18px;\n    font-weight: bold;\n    padding-bottom: 5px;\n}\n.image_desc {\n    font-size: 14px;\n}\n.side_left:hover, .side_right:hover {\n    background: rgba(255,255,255,0.05);\n}\n.viewer_left_button, .viewer_right_button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n.viewer_navicon {\n    width: 40px;\n    height: 40px;\n}\n.viewer_left_button:hover, .viewer_right_button:hover, .viewer_close_button:hover {\n    opacity: 1;\n}\n.viewer_button_container {\n    z-index: 10000;\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    display: flex;\n}\n.viewer_close_button, .viewer_zoom_in_button, .viewer_zoom_out_button {\n    width: 30px;\n    height: 30px;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n    `, {\n        'image_viewer_wrapper': 'image_viewer_wrapper',\n        'image_panel': 'image_panel',\n        'image_wrapper': 'image_wrapper',\n        'image_canvas': 'image_canvas',\n        'image_ambient': 'image_ambient',\n        'image_top': 'image_top',\n        'image_bottom': 'image_bottom',\n        'image_info': 'image_info',\n        'viewer_button_container': 'viewer_button_container',\n        'side_left': 'side_left',\n        'side_right': 'side_right',\n        'viewer_left_button': 'viewer_left_button',\n        'viewer_right_button': 'viewer_right_button',\n        'viewer_close_button': 'viewer_close_button',\n        'viewer_zoom_in_button': 'viewer_zoom_in_button',\n        'viewer_zoom_out_button': 'viewer_zoom_out_button',\n        'image_title': 'image_title',\n        'image_desc': 'image_desc',\n        'viewer_navicon': 'viewer_navicon'\n    }, false);\n    class Viewer {\n        constructor() {\n            this.selector = _n;\n            this.images = [];\n            this.currentIndex = 0;\n            this.eventHandler = this.handleClick.bind(this);\n            this.addEventListener();\n            this.icons = Q.Icons();\n            this.eventListenerActive = false;\n            this.loaded = false;\n            this.resizing = false;\n            this.thumbs = false;\n            this.scale = 1;\n            this.panX = 0;\n            this.panY = 0;\n            this.isPanning = false;\n            this.startX = 0;\n            this.startY = 0;\n            this.imageCache = {};\n            this.config = {\n                panAndZoom: true,\n                ambient: true,\n                ambientSize: 1.2,\n                dynamicBackground: true\n            };\n        }\n        construct() {\n            this.image_viewer = Q('<div>', { class: classes.image_viewer_wrapper });\n            this.image_panel = Q('<div>', { class: classes.image_panel });\n            this.image_wrapper = Q('<div>', { class: classes.image_wrapper });\n            this.image_canvas = Q('<canvas>', { class: classes.image_canvas });\n            this.image_ambient = Q('<canvas>', { class: classes.image_ambient });\n            this.image_top = Q('<div>', { class: classes.image_top });\n            this.image_bottom = Q('<div>', { class: classes.image_bottom });\n            this.image_info = Q('<div>', { class: classes.image_info });\n            this.button_container = Q('<div>', { class: classes.viewer_button_container });\n            this.side_left = Q('<div>', { class: classes.side_left });\n            this.side_right = Q('<div>', { class: classes.side_right });\n            this.left_button = Q('<div>', { class: classes.viewer_left_button });\n            this.right_button = Q('<div>', { class: classes.viewer_right_button });\n            this.close_button = Q('<div>', { class: classes.viewer_close_button });\n            this.zoom_in_button = Q('<div>', { class: classes.viewer_zoom_in_button });\n            this.zoom_out_button = Q('<div>', { class: classes.viewer_zoom_out_button });\n            this.left_button.append(this.icons.get('navigation-left', classes.viewer_navicon));\n            this.right_button.append(this.icons.get('navigation-right', classes.viewer_navicon));\n            this.close_button.append(this.icons.get('navigation-close'));\n            this.zoom_in_button.append(this.icons.get('zoom-in'));\n            this.zoom_out_button.append(this.icons.get('zoom-out'));\n            this.side_left.append(this.left_button);\n            this.side_right.append(this.right_button);\n            this.image_top.append(this.image_info);\n            this.button_container.append(this.zoom_in_button, this.zoom_out_button, this.close_button);\n            this.image_wrapper.append(this.image_ambient, this.image_canvas, this.image_top, this.image_bottom);\n            this.image_panel.append(this.side_left, this.image_wrapper, this.side_right);\n            this.image_viewer.append(this.image_panel, this.button_container);\n            this.left_button.on('click', () => this.prev());\n            this.right_button.on('click', () => this.next());\n            this.close_button.on('click', () => this.close());\n            this.image_top.on('mouseenter', () => {\n                this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            });\n            this.image_top.on('mouseleave', () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s', 'transition-delay': '3s' });\n            });\n            this.image_canvas.on('wheel', (e) => this.handleZoom(e));\n            this.image_canvas.on('mousedown', (e) => this.startPan(e));\n            this.image_canvas.on('mousemove', (e) => this.pan(e));\n            this.image_canvas.on('mouseup', () => this.endPan());\n            this.image_canvas.on('mouseleave', () => this.endPan());\n            this.image_canvas.on('touchstart', (e) => this.startTouch(e));\n            this.image_canvas.on('touchmove', (e) => this.touchPanZoom(e));\n            this.image_canvas.on('touchend', () => this.endTouch());\n        }\n        handleClick(e) {\n            if (e.target.closest(this.selector)) {\n                const images = Q(this.selector).find('img');\n                if (!images.nodes.length) {\n                    return;\n                }\n                images.each((index, el) => {\n                    let title, desc, src;\n                    if (el.hasAttribute('data-title')) {\n                        title = el.getAttribute('data-title');\n                    }\n                    if (el.hasAttribute('data-desc')) {\n                        desc = el.getAttribute('data-desc');\n                    }\n                    if (el.hasAttribute('data-source')) {\n                        src = el.getAttribute('data-source');\n                    } else {\n                        src = el.src;\n                    }\n                    this.images[index] = {\n                        src: src,\n                        title: title,\n                        desc: desc\n                    }\n                });\n                this.currentIndex = images.nodes.indexOf(e.target);\n                this.open();\n            }\n        }\n        handleResize() {\n            if (!this.resizing) {\n                this.resizing = true;\n                this.image_canvas.css({ filter: 'blur(10px)', transition: 'all 0.1s ease-in-out' });\n            }\n            Q.Debounce('img_viewer', 500, () => {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.updateImage();\n                this.resizing = false;\n                this.image_canvas.css({ filter: 'none', transition: '' });\n            });\n        }\n        handleZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            const rect = this.image_canvas.nodes[0].getBoundingClientRect();\n            const offsetX = (e.clientX - rect.left - this.panX) / this.scale;\n            const offsetY = (e.clientY - rect.top - this.panY) / this.scale;\n            const scaleAmount = e.deltaY > 0 ? 0.9 : 1.1;\n            const newScale = _ma.min(_ma.max(this.scale * scaleAmount, 0.5), 2.5);\n            const deltaScale = newScale - this.scale;\n            this.panX -= offsetX * deltaScale;\n            this.panY -= offsetY * deltaScale;\n            this.scale = newScale;\n            this.updateImage();\n        }\n        startPan(e) {\n            if (!this.config.panAndZoom) return;\n            this.isPanning = true;\n            this.startX = e.clientX - this.panX;\n            this.startY = e.clientY - this.panY;\n        }\n        pan(e) {\n            if (!this.config.panAndZoom) return;\n            if (!this.isPanning) return;\n            this.panX = e.clientX - this.startX;\n            this.panY = e.clientY - this.startY;\n            this.updateImage();\n        }\n        endPan() {\n            this.isPanning = false;\n        }\n        startTouch(e) {\n            if (!this.config.panAndZoom) return;\n            if (e.touches.length === 1) {\n                this.isPanning = true;\n                this.startX = e.touches[0].clientX - this.panX;\n                this.startY = e.touches[0].clientY - this.panY;\n            } else if (e.touches.length === 2) {\n                this.isPanning = false;\n                this.initialDistance = _ma.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                this.initialScale = this.scale;\n            }\n        }\n        touchPanZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            if (e.touches.length === 1 && this.isPanning) {\n                this.panX = e.touches[0].clientX - this.startX;\n                this.panY = e.touches[0].clientY - this.startY;\n                this.updateImage();\n            } else if (e.touches.length === 2) {\n                const currentDistance = _ma.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                const scaleAmount = currentDistance / this.initialDistance;\n                this.scale = _ma.min(_ma.max(this.initialScale * scaleAmount, 0.5), 2.5);\n                this.updateImage();\n            }\n        }\n        endTouch() {\n            this.isPanning = false;\n        }\n        addEventListener() {\n            if (!this.eventListenerActive) {\n                document.addEventListener('click', this.eventHandler);\n                this.eventListenerActive = true;\n            }\n        }\n        removeEventListener() {\n            if (this.eventListenerActive) {\n                document.removeEventListener('click', this.eventHandler);\n                this.eventListenerActive = false;\n            }\n        }\n        fadeTitle() {\n            this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            Q.Debounce('fade_title', 2000, () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s' });\n            });\n        }\n        open() {\n            this.construct();\n            this.updateImage();\n            this.updateNavigation();\n            Q('body').append(this.image_viewer);\n            window.addEventListener('resize', this.handleResize.bind(this));\n        }\n        close() {\n            this.thumbs = false;\n            window.removeEventListener('resize', this.handleResize.bind(this));\n            this.image_viewer.remove();\n        }\n        prev() {\n            if (this.currentIndex > 0) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex--;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        next() {\n            if (this.currentIndex < this.images.length - 1) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex++;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        updateImage() {\n            this.window_width = window.innerWidth;\n            this.window_height = window.innerHeight;\n            this.image_info.empty();\n            if (this.images[this.currentIndex].title) {\n                this.image_info.append(Q('<div>', { class: classes.image_title, text: this.images[this.currentIndex].title }));\n            }\n            if (this.images[this.currentIndex].desc) {\n                this.image_info.append(Q('<div>', { class: classes.image_desc, text: this.images[this.currentIndex].desc }));\n            }\n            const src = this.images[this.currentIndex];\n            const img = this.imageCache[src.src] || new Image();\n            if (!this.imageCache[src.src]) {\n                img.src = src.src;\n                this.imageCache[src.src] = img;\n            }\n            const isAnimated = /\\.(webm|apng|gif)$/i.test(src.src);\n            img.onload = () => {\n                const canvas = this.image_canvas.nodes[0];\n                const ambientCanvas = this.image_ambient.nodes[0];\n                const ctx = canvas.getContext('2d');\n                const ambientCtx = ambientCanvas.getContext('2d');\n                canvas.width = this.image_wrapper.nodes[0].clientWidth;\n                canvas.height = this.image_wrapper.nodes[0].clientHeight;\n                ambientCanvas.width = canvas.width * 1.2;\n                ambientCanvas.height = canvas.height * 1.2;\n                if (isAnimated) {\n                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n                    if (this.config.ambient) {\n                        ambientCtx.drawImage(img, (ambientCanvas.width - canvas.width) / 2, (ambientCanvas.height - canvas.height) / 2, canvas.width, canvas.height);\n                    }\n                    return;\n                }\n                const aspectRatio = img.width / img.height;\n                let width = this.window_width * this.scale;\n                let height = this.window_height * this.scale;\n                if (width / height > aspectRatio) {\n                    width = height * aspectRatio;\n                } else {\n                    height = width / aspectRatio;\n                }\n                const offsetX = (canvas.width - width) / 2;\n                const offsetY = (canvas.height - height) / 2;\n                ctx.setTransform(this.scale, 0, 0, this.scale, this.panX + offsetX, this.panY + offsetY);\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.drawImage(img, 0, 0, width, height);\n                if (this.config.ambient) {\n                    const ambientOffsetX = (ambientCanvas.width - width * this.config.ambientSize) / 2;\n                    const ambientOffsetY = (ambientCanvas.height - height * this.config.ambientSize) / 2;\n                    ambientCtx.setTransform(this.scale * this.config.ambientSize, 0, 0, this.scale * this.config.ambientSize, this.panX * this.config.ambientSize + ambientOffsetX, this.panY * this.config.ambientSize + ambientOffsetY);\n                    ambientCtx.clearRect(0, 0, ambientCanvas.width, ambientCanvas.height);\n                    ambientCtx.drawImage(img, 0, 0, width, height);\n                }\n                if (this.config.dynamicBackground) {\n                    Q.Debounce('update_ambient', 1000, () => {\n                        Q.AvgColor(canvas, 10, (color) => {\n                            this.image_viewer.css('background', `rgba(${color.r}, ${color.g}, ${color.b}, 0.77)`);\n                        });\n                    });\n                }\n            };\n            if (img.complete) {\n                img.onload();\n            }\n        }\n        updateNavigation() {\n            if (this.images.length > 1) {\n                if (this.currentIndex > 0) {\n                    this.left_button.show();\n                } else {\n                    this.left_button.hide();\n                }\n                if (this.currentIndex < this.images.length - 1) {\n                    this.right_button.show();\n                } else {\n                    this.right_button.hide();\n                }\n            } else {\n                this.left_button.hide();\n                this.right_button.hide();\n            }\n        }\n        setSelector(selector) {\n            this.selector = selector;\n            this.addEventListener();\n        }\n        remove() {\n            this.removeEventListener();\n            this.image_viewer.remove();\n        }\n        source(images) {\n            this.images = images.map((img, index) => ({\n                src: img.source,\n                title: img.title,\n                desc: img.desc\n            }));\n            this.currentIndex = 0;\n        }\n    }\n    let viewer = new Viewer();\n    return {\n        selector: function (selector) {\n            viewer.setSelector(selector);\n            return this;\n        },\n        open: function (images) {\n            viewer.open(images);\n            return this;\n        },\n        close: function () {\n            viewer.close();\n            return this;\n        },\n        remove: function () {\n            viewer.remove();\n            return this;\n        },\n        config: function (options) {\n            _ob.assign(viewer.config, options);\n            return this;\n        },\n        source: function (images) {\n            viewer.source(images);\n            return this;\n        }\n    };\n}"
        },
        "JSON": {
            "uuid": "856ff6ad-315c-408e-8171-f5183d92f3a5",
            "name": "JSON",
            "method": "Plugin",
            "desc": "Provides methods to parse, deflate, and inflate, modify JSON objects.",
            "type": "Plugin",
            "example": "var json = Q.JSON({ key: 'value' }); json.Parse({ modify: true, recursive: true }, (key, value) => value + ' modified');",
            "dependencies": [],
            "script": "Q.JSON = function (a) {\n    if (!(this instanceof Q.JSON)) {\n        return new Q.JSON(a);\n    }\n    this.json = a;\n};\nQ.JSON.prototype.Parse = function (options = { modify: false, recursive: false }, e) {\n    const process = (b) => {\n        if (typeof b === 'object' && b !== _n && !_ar.isArray(b)) {\n            for (const c in b) {\n                if (b.hasOwnProperty(c)) {\n                    const d = e(c, b[c]);\n                    if (modify) {\n                        b[c] = d;\n                    }\n                    if (recursive && typeof b[c] === 'object' && b[c] !== _n) {\n                        process(b[c]);\n                    }\n                }\n            }\n        }\n    };\n    process(this.json);\n    return this.json;\n};\nQ.JSON.prototype.deflate = function (level) {\n    const f = {};\n    let g = 1;\n    function j(h) {\n        if (typeof h === 'object' && h !== _n) {\n            for (let c in h) {\n                if (typeof h[c] === 'object') {\n                    j(h[c]);\n                }\n                if (c.length >= level) {\n                    if (!f[c]) {\n                        f[c] = `[${g}]`;\n                        g++;\n                    }\n                    const newKey = f[c];\n                    h[newKey] = h[c];\n                    delete h[c];\n                }\n                if (typeof h[c] === 'string' && h[c].length >= level) {\n                    if (!f[h[c]]) {\n                        f[h[c]] = `[${g}]`;\n                        g++;\n                    }\n                    h[c] = f[h[c]];\n                }\n            }\n        }\n    }\n    const i = JSON.parse(JSON.stringify(this.json));\n    j(i);\n    return { b: i, f: f };\n};\nQ.JSON.prototype.inflate = function (l) {\n    const { b, f } = l;\n    const m = _ob.fromEntries(_ob.entries(f).f(([k, v]) => [v, k]));\n    function p(h) {\n        if (typeof h === 'object' && h !== _n) {\n            for (let c in h) {\n                const n = m[c] || c;\n                const o = h[c];\n                delete h[c];\n                h[n] = o;\n                if (typeof h[n] === 'object') {\n                    p(h[n]);\n                } else if (m[h[n]]) {\n                    h[n] = m[h[n]];\n                }\n            }\n        }\n    }\n    const q = JSON.parse(JSON.stringify(b));\n    p(q);\n    return q;\n};"
        },
        "NodeBlock": {
            "uuid": "235220e8-a8f3-485c-a18f-65fcecbdf730",
            "name": "NodeBlock",
            "method": "Plugin",
            "desc": "A plugin for creating UML blocks and connections.",
            "type": "Plugin",
            "example": "var uml = Q.NodeBlock('#canvas', 800, 600); // Create a new UML canvas",
            "dependencies": [
                "ColorBrightness",
                "isDarkColor",
                "Style"
            ],
            "script": "Q.NodeBlock = function (selector, width, height, options) {\n    let classes = Q.style(`\n.node_preferences {\n    position: absolute;\n    background: #181818;\n    overflow: hidden;\n    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);\n}\n.node_preferences_big {\n    width: 350px;\n    max-height: 350px;\n    overflow-y: scroll;\n}\n.node_preferences_small {\nwidth: 200px;\noverflow-y: auto;\n    }\n.pref_content h1, .pref_content h2, .pref_content h3, .pref_content h4, .pref_content h5, .pref_content h6 {\nline-break: anywhere;\nmargin: 0 0 2px 0;\npadding: 0;\n}\n.pref_content h1 { font-size: 150%; }\n.pref_content h2 { font-size: 140%; }\n.pref_content h3 { font-size: 130%; }\n.pref_content h4 { font-size: 120%; }\n.pref_content h5 { font-size: 110%; }\n.pref_content h6 { font-size: 100%; }\n.pref_content p { margin: 0; padding: 0; color: #7a7a7a; }\n.pref_content ul { margin: 5px 5px; padding-left: 15px; color: #7a7a7a; }\n.pref_content li { padding: 0px; margin: 0px; }\n.pref_content table { border-collapse: collapse; width: 100%; }\n.pref_content table, th, td { padding: 0; margin: 0; font-size: 90%; line-break: anywhere; border: 1px solid #222; }\n.pref_content th, td { padding: 1px; text-align: left; }\n.pref_content th { background-color: #222; }\n.pref_content tfoot { background-color: #222; }\n.pref_title {\n    font-size: 12px;\n    margin: 5px;\n    color: #7a7a7a;\n    text-align: center;\n}\n.node_preferences::-webkit-scrollbar {\n    width: 10px;\n}\n.node_preferences::-webkit-scrollbar-track {\n    background: #3a3a3a;\n}\n.node_preferences::-webkit-scrollbar-thumb {\n    background: #242424;\n}\n.node_preferences::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n.pref_content {\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n    padding: 5px 5px;\n}\n.pref_content img {\n    width: 100%;\n    height: auto;\n}\n.connection_content {\n    display: flex;\n    justify-content: space-between;\n}\n.left,\n.right {\n    width: 50%;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin: 5px;\n}\n.connection_wrapper {\n    display: flex;\n    justify-content: space-between;\n    margin: 1px;\n}\n.color_wrapper {\n    position: relative;\n    width: 20px;\n    height: 20px;\n    overflow: hidden;\n    flex-shrink: 0;\n}\n.color {\n    position: absolute;\n    width: 100px;\n    top: -20px;\n    left: -20px;\n    height: 100px;\n}\n.connection {\n    font-size: 12px;\npadding: 0 5px;\n    width: 100%;\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n}\n.button_nodes {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 8px;\n    width: 15px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_nodes_big {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 12px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_add\n{\n    margin:1px;\n    width: 20px;\n    height: 20px;\n}\n        `, {\n        \"node_preferences\": \"node_preferences\",\n        \"node_preferences_small\": \"node_preferences_small\",\n        \"node_preferences_big\": \"node_preferences_big\",\n        \"pref_title\": \"pref_title\",\n        \"pref_content\": \"pref_content\",\n        \"connection_content\": \"connection_content\",\n        \"left\": \"left\",\n        \"right\": \"right\",\n        \"connection_wrapper\": \"connection_wrapper\",\n        \"color_wrapper\": \"color_wrapper\",\n        \"connection\": \"connection\",\n        \"button_nodes\": \"button_nodes\",\n        \"button_nodes_big\": \"button_nodes_big\",\n        \"button_add\": \"button_add\",\n        \"name\": \"_name\",\n        \"content\": \"_content\",\n        \"manipulation\": \"manipulation\",\n        \"color\": \"color\",\n        \"pref_section\": \"pref_section\",\n    }, false);\n    class UMLBlock {\n        constructor(custom_style, appearance, id, name, text, x, y, width, connLeft = [], connRight = [], connections = []) {\n            this.name = name;\n            this.text = text;\n            this.t_text = \"\";\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.connections = connections;\n            this.connLeft = connLeft;\n            this.connRight = connRight;\n            this.height = 0;\n            this.isDragging = false;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            this.img = _n;\n            this.content = _n;\n            this.contentHeight = 0;\n            this.unescapedBase64Data = _n;\n            this.appearance = appearance;\n            this.custom_style = custom_style;\n            this.appearance = _ob.assign({}, this.appearance, custom_style);\n            this.darkText = '#ffffff';\n            this.lightText = '#000000';\n            this.update = true;\n            this.compiled_render = document.createElement('canvas');\n            this.block_context = this.compiled_render.getContext('2d');\n            this._processColors();\n        }\n        _restyle(object) {\n            this.custom_style = object;\n            this.appearance = _ob.assign({}, this.appearance, object);\n            this._processColors();\n            this.t_text = '';\n        }\n        _processColors() {\n            const {\n                background,\n                factorTitleBackground,\n                factorDarkColorMargin,\n                factorDarkColorThreshold,\n                factorLightColors,\n                factorDarkColors,\n                darkTextColor,\n                lightTextColor\n            } = this.appearance;\n            const titleBg = Q.ColorBrightness(background, factorTitleBackground);\n            const isDark = Q.isDarkColor(background, factorDarkColorMargin, factorDarkColorThreshold);\n            const textColor = isDark ? darkTextColor : lightTextColor;\n            const borderColor = Q.ColorBrightness(background, isDark ? factorLightColors : factorDarkColors);\n            _ob.assign(this.appearance, {\n                titleBackground: titleBg,\n                titleColor: textColor,\n                connectionTextColor: textColor,\n                textColor: textColor,\n                node_table_color: borderColor\n            });\n        }\n        _drawContainer(ctx, x, y, width, height) {\n            const { shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, background, radius, connectionPointSize } = this.appearance;\n            ctx.save();\n            _ob.assign(ctx, {\n                fillStyle: background,\n                shadowColor,\n                shadowBlur,\n                shadowOffsetX,\n                shadowOffsetY\n            });\n            ctx.beginPath();\n            ctx.moveTo(x + radius, y);\n            ctx.lineTo(x + width - radius, y);\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n            ctx.lineTo(x + width, y + height - radius);\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n            ctx.lineTo(x + radius, y + height);\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n            ctx.lineTo(x, y + radius);\n            ctx.quadraticCurveTo(x, y, x + radius, y);\n            ctx.fill();\n            ctx.restore();\n        }\n        _drawTitle(ctx, x, y, width, height, title) {\n            ctx.fillStyle = this.appearance.titleBackground;\n            ctx.beginPath();\n            ctx.moveTo(x + this.appearance.radius, y);\n            ctx.arcTo(x + width, y, x + width, y + height, this.appearance.radius);\n            ctx.arcTo(x + width, y + height, x, y + height, 0);\n            ctx.arcTo(x, y + height, x, y, 0);\n            ctx.arcTo(x, y, x + width, y, this.appearance.radius);\n            ctx.closePath();\n            ctx.fill();\n            ctx.fillStyle = this.appearance.titleColor;\n            ctx.font = 'bold ' + this.appearance.fontSizeTitle + 'px ' + this.appearance.font;\n            const titleX = x + (width - ctx.measureText(title).width) / 2;\n            const titleY = y + (height + this.appearance.fontSizeTitle) / 2;\n            ctx.fillText(title, titleX, titleY);\n        }\n        parseHTML2Canvas(html, callback) {\n            const renderElements = () => {\n                if (this.t_text == html) {\n                    callback(this.content, this.contentHeight);\n                    return;\n                }\n                this.t_text = html;\n                let tempContainer = document.createElement('div');\n                tempContainer.style.position = 'absolute';\n                tempContainer.style.visibility = 'hidden';\n                tempContainer.style.width = (this.width - this.appearance.fontSize) + 'px';\n                document.body.appendChild(tempContainer);\n                let style = document.createElement('style');\n                let st = `\n        table {border-collapse: collapse; width: 100%;}\n        table, th, td {padding: 0; margin: 0; font-size: ${(this.appearance.fontSize * 0.9)}px; line-break: anywhere;border: 1px solid ${this.appearance.node_table_color};}\n        th, td {padding: 1px; text-align: left;}\n        th {background-color: ${this.appearance.node_table_color};}\n        tfoot {background-color: ${this.appearance.node_table_color};}\n        h1, h2, h3, h4, h5, h6 {line-break: anywhere; margin: 0 0 2px 0; padding: 0;}\n        h1 {font-size: ${(this.appearance.fontSize * 1.5)}px;}\n        h2 {font-size: ${(this.appearance.fontSize * 1.4)}px;}\n        h3 {font-size: ${(this.appearance.fontSize * 1.3)}px;}\n        h4 {font-size: ${(this.appearance.fontSize * 1.2)}px;}\n        h5 {font-size: ${(this.appearance.fontSize * 1.1)}px;}\n        h6 {font-size: ${(this.appearance.fontSize * 1.0)}px;}\n                        p { margin: 0; padding: 0; color: ${this.appearance.textColor}; }\n                        ul { margin: 5px 5px; padding-left: 15px; color: ${this.appearance.textColor}; }\n                        li { padding: 0px; margin: 0px; }\n                        div {font-family: ${this.appearance.font}, sans-serif; font-size: ${this.appearance.fontSize}px; color: ${this.appearance.textColor}; }\n                    `;\n                style.innerHTML = st;\n                document.head.appendChild(style);\n                tempContainer.innerHTML = html;\n                this.contentHeight = tempContainer.offsetHeight + this.appearance.padding;\n                document.body.removeChild(tempContainer);\n                document.head.removeChild(style);\n                this.content = document.createElement('canvas');\n                this.content.width = this.width;\n                this.content.height = this.contentHeight;\n                let ctx = this.content.getContext('2d');\n                let data = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + (this.width - (this.appearance.padding * 2)) + '\" height=\"' + this.contentHeight + '\">' + // Update SVG height\n                    '<foreignObject width=\"100%\" height=\"100%\">' +\n                    '<style>' +\n                    st +\n                    '</style>' +\n                    '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +\n                    html +\n                    '</div>' +\n                    '</foreignObject>' +\n                    '</svg>';\n                let DOMURL = window.URL || window.webkitURL || window;\n                let img = new Image();\n                let svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });\n                let url = DOMURL.createObjectURL(svg);\n                img.onload = () => {\n                    ctx.drawImage(img, 0, 0);\n                    DOMURL.revokeObjectURL(url);\n                    callback(this.content, this.contentHeight);\n                };\n                img.src = url;\n            };\n            html = html.replace(/style=\"[^\"]*\"/g, '');\n            let images = [];\n            html = html.replace(/<br>/g, '');\n            if (html.includes('<img')) {\n                let imgTags = html.match(/<img[^>]+>/g);\n                imgTags.forEach((imgTag, index) => {\n                    let src = imgTag.match(/src=\"([^\"]*)\"/)[1];\n                    let img = new Image();\n                    img.src = src;\n                    img.onload = () => {\n                        images[index] = img;\n                        if (images.length === imgTags.length) {\n                            renderElements();\n                        }\n                    };\n                });\n            }\n            else {\n                renderElements();\n            }\n        }\n        draw(main_context) {\n            const TITLE_HEIGHT = this.appearance.fontSizeTitle + (this.appearance.padding * 2);\n            const CONNECTION_HEIGHT = this.appearance.padding + TITLE_HEIGHT;\n            const CONNECTION_PADDING = (this.appearance.connectionPointSize * 2) + this.appearance.connectionPointPadding;\n            const maxConnectionsHeight = _ma.max(this.connLeft.length, this.connRight.length) * CONNECTION_PADDING;\n            if (this.update) {\n                const updateContainerHeight = (contentHeight) => {\n                    this.height = TITLE_HEIGHT + (this.appearance.padding * 2) + maxConnectionsHeight + contentHeight + this.appearance.padding;\n                    this.block_context.canvas.height = this.height;\n                    this.block_context.canvas.width = this.width + (this.appearance.connectionPointSize * 2);\n                };\n                this.parseHTML2Canvas(this.text, (canvas, contentHeight) => {\n                    updateContainerHeight(contentHeight);\n                    this._drawContainer(this.block_context, this.appearance.connectionPointSize, 0, this.width - 5, this.height, this.appearance.radius);\n                    this._drawTitle(this.block_context, this.appearance.connectionPointSize, 0, this.width - this.appearance.connectionPointSize, TITLE_HEIGHT, this.name);\n                    this.block_context.drawImage(canvas, this.appearance.padding, TITLE_HEIGHT + this.appearance.padding + maxConnectionsHeight);\n                    this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                    main_context.drawImage(this.compiled_render, this.x, this.y);\n                });\n                this.update = false;\n            }\n            else {\n                this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                main_context.drawImage(this.compiled_render, this.x, this.y);\n            }\n            return;\n        }\n        drawConnectionPoints(ctx, paddingTop, height) {\n            const connectionY = paddingTop;\n            const font = `bold ${this.appearance.fontSizeConnection}px ${this.appearance.font}`;\n            const pointSize = this.appearance.connectionPointSize;\n            const connectionPaddingX = this.appearance.connectionTextPaddingX;\n            const middleYOffset = ((pointSize / 2) + (this.appearance.fontSizeConnection / 2)) - this.appearance.connectionTextPaddingY;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            ctx.font = font;\n            const drawConnectionPoints = (connList, coordsArray, baseX, getTextX) => {\n                connList.forEach((conn, index) => {\n                    const connY = connectionY + index * height;\n                    coordsArray.push({ x: baseX, y: connY });\n                    ctx.fillStyle = conn.color || this.appearance.connectionColor;\n                    ctx.beginPath();\n                    ctx.arc(baseX, connY, pointSize, 0, 2 * _ma.PI);\n                    ctx.fill();\n                    ctx.fillStyle = this.appearance.connectionTextColor;\n                    ctx.fillText(conn.title, getTextX(conn.title, baseX), connY + middleYOffset);\n                });\n            };\n            if (_ar.isArray(this.connLeft)) {\n                drawConnectionPoints(this.connLeft, this.leftConnCoords, this.appearance.connectionPointSize, (title, baseX) => baseX + connectionPaddingX * 2);\n            }\n            if (_ar.isArray(this.connRight)) {\n                drawConnectionPoints(this.connRight, this.rightConnCoords, this.width, (title, baseX) => baseX - ctx.measureText(title).width - connectionPaddingX * 2);\n            }\n        }\n        addConnection(conn) {\n            this.connections.push(conn);\n        }\n        removeConnection(conn) {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n        }\n        isMouseOver(mouseX, mouseY) {\n            return mouseX >= this.x && mouseX <= this.x + this.width && mouseY >= this.y && mouseY <= this.y + this.height;\n        }\n        getAllConnectionCoords() {\n            return [\n                ...this.leftConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y })),\n                ...this.rightConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y }))\n            ];\n        }\n        getConnectionCoord(point, index) {\n            return point === 'left' ? this.leftConnCoords[index] : this.rightConnCoords[index];\n        }\n    }\n    class UMLCanvas {\n        constructor(selector, width, height, appearance, classes) {\n            this.element_parent = Q(selector);\n            this.canvas = Q('<canvas>', { width: width, height: height });\n            this.width = width;\n            this.height = height;\n            this.element_parent.append(this.canvas);\n            this.canvas_context = this.canvas.nodes[0].getContext('2d');\n            this.blocks = [];\n            this.connections = [];\n            this.draggingBlock = _n;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.connection_start = _n;\n            this.connection_end = _n;\n            this.mouseX = 0;\n            this.mouseY = 0;\n            this.isMenuPreferences = false;\n            this.isDraggingBlock = false;\n            this.isOverConnection = false;\n            this.appearance = appearance;\n            this.classes = classes;\n            this.canvas.on('click', this._event_click.bind(this));\n            this.canvas.on('mousedown', this._event_pointer_down.bind(this));\n            this.canvas.on('mousemove', this._event_pointer_move.bind(this));\n            this.canvas.on('mouseup', this._event_pointer_up.bind(this));\n            this.canvas.on('contextmenu', this._event_click_right.bind(this), false);\n        }\n        import(uml) {\n            const blockCreationPromises = uml.blocks.map(async (block) => {\n                const newBlock = new UMLBlock(\n                    block.custom_style,\n                    this.appearance,\n                    block.id, block.name, block.text, block.x, block.y, block.width,\n                    block.connLeft.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connRight.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connections\n                );\n                this.addBlock(newBlock);\n            });\n            _pr.all(blockCreationPromises).then(() => {\n                uml.connections.forEach(conn => {\n                    const startBlock = this.blocks.find(b => b.id === conn.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.target);\n                    const startCoords = this._point_coords(startBlock, conn.point);\n                    const endCoords = this._point_coords(endBlock, conn.targetPoint);\n                    if (startCoords && endCoords) {\n                        this._connection_create(\n                            { block: startBlock, point: conn.point, x: startCoords.x, y: startCoords.y },\n                            { block: endBlock, point: conn.targetPoint, x: endCoords.x, y: endCoords.y }\n                        );\n                    } else {\n                        _c.error('Connection failed to initialize:', startBlock, endBlock);\n                    }\n                });\n            }).catch(err => {\n                _c.error('_er during block initialization:', err);\n            });\n        }\n        export() {\n            return {\n                blocks: this.blocks.map(block => ({\n                    custom_style: block.custom_style,\n                    id: block.id,\n                    name: block.name,\n                    text: block.text,\n                    x: block.x,\n                    y: block.y,\n                    width: block.width,\n                    connLeft: block.connLeft,\n                    connRight: block.connRight,\n                    connections: block.connections\n                })),\n                connections: this.connections.map(conn => ({\n                    id: conn.start.block.id,\n                    point: conn.start.point,\n                    target: conn.end.block.id,\n                    targetPoint: conn.end.point\n                }))\n            };\n        }\n        async addBlock(block) {\n            this.blocks.push(block);\n            await this._connections_init(block);\n            this.render();\n        }\n        removeBlock(block) {\n            this.blocks = this.blocks.filter(b => b.id !== block.id);\n            this.connections = this.connections.filter(conn =>\n                conn.start.block.id !== block.id && conn.end.block.id !== block.id\n            );\n            this.render();\n        }\n        getJointContent() {\n            let block = this.blocks[0];\n            let content = block.text;\n            let connections = block.connections;\n            let nextBlock = _n;\n            while (connections.length > 0) {\n                let conn = connections[0];\n                nextBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                content += nextBlock.text;\n                connections = nextBlock.connections;\n            }\n            return content;\n        }\n        duplicateBlock(block) {\n            let id = this._id();\n            const newBlock = new UMLBlock(\n                block.custom_style,\n                this.appearance,\n                id, block.name, block.text, block.x + 50, block.y + 50, block.width,\n                block.connLeft, block.connRight, []\n            );\n            this.addBlock(newBlock);\n        }\n        render_grid() {\n            let ctx = this.canvas_context;\n            let w = this.width;\n            let h = this.height;\n            let grid_size = this.appearance.gridSize;\n            let grid_color = this.appearance.gridColor;\n            ctx.strokeStyle = grid_color;\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            for (let x = 0; x <= w; x += grid_size) {\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, h);\n            }\n            for (let y = 0; y <= h; y += grid_size) {\n                ctx.moveTo(0, y);\n                ctx.lineTo(w, y);\n            }\n            ctx.stroke();\n        }\n        render() {\n            this.canvas_context.clearRect(0, 0, this.width, this.height);\n            this.render_grid();\n            this.connections.forEach(conn => {\n                let startBlock = conn.start.block;\n                let endBlock = conn.end.block;\n                let startColor = this._getConnectionColor(startBlock, conn.start.point);\n                let endColor = this._getConnectionColor(endBlock, conn.end.point);\n                this.canvas_context.strokeStyle = 'rgb(150, 150, 150)';\n                this.canvas_context.beginPath();\n                this.canvas_context.lineWidth = 2;\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + conn.start.x, startBlock.y + conn.start.y,\n                    endBlock.x + conn.end.x, endBlock.y + conn.end.y\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, endColor);\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.moveTo(startBlock.x + conn.start.x, startBlock.y + conn.start.y);\n                this.canvas_context.lineTo(endBlock.x + conn.end.x, endBlock.y + conn.end.y);\n                this.canvas_context.stroke();\n                let dx = (endBlock.x + conn.end.x) - (startBlock.x + conn.start.x);\n                let dy = (endBlock.y + conn.end.y) - (startBlock.y + conn.start.y);\n                let length = _ma.sqrt(dx * dx + dy * dy);\n                let unitDx = dx / length;\n                let unitDy = dy / length;\n                let arrowLength = 10;\n                let arrowWidth = 5;\n                for (let i = 100; i < length; i += 200) {\n                    let x = (startBlock.x + conn.start.x) + unitDx * i;\n                    let y = (startBlock.y + conn.start.y) + unitDy * i;\n                    this.canvas_context.beginPath();\n                    this.canvas_context.moveTo(x, y);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx + arrowWidth * unitDy, y - arrowLength * unitDy - arrowWidth * unitDx);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx - arrowWidth * unitDy, y - arrowLength * unitDy + arrowWidth * unitDx);\n                    this.canvas_context.closePath();\n                    this.canvas_context.fillStyle = gradient;\n                    this.canvas_context.fill();\n                }\n            });\n            if (this.connection_start && this.connection_end === _n) {\n                let startBlock = this.connection_start.block;\n                let startColor = this._getConnectionColor(startBlock, this.connection_start.point);\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y,\n                    this.mouseX, this.mouseY\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, \"rgb(150, 150, 150)\");\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.beginPath();\n                this.canvas_context.moveTo(startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y);\n                this.canvas_context.lineTo(this.mouseX, this.mouseY);\n                this.canvas_context.stroke();\n            }\n            this.blocks.forEach(block => {\n                block.draw(this.canvas_context);\n            });\n            this._connection_update();\n        }\n        _getConnectionColor(block, pointId) {\n            const connection = [...block.connLeft, ...block.connRight]\n                .find(conn => conn.id === pointId);\n            return connection ? connection.color : _n;\n        }\n        updateConnections(block) {\n            const preferences = Q('.' + classes.node_preferences);\n            const collectConnections = (sideClass) => {\n                const side = preferences.find('.' + sideClass);\n                const connections = [];\n                side.find('.' + classes.connection_wrapper).walk((element) => {\n                    const id = element.id();\n                    const title = element.find('.' + classes.connection).val() || '';\n                    const color = element.find('.' + classes.color).val();\n                    connections.push({ id, title, color });\n                }, true);\n                return connections;\n            };\n            const newLeftConnections = collectConnections(classes.left);\n            const newRightConnections = collectConnections(classes.right);\n            const newConnections = [...newLeftConnections, ...newRightConnections];\n            const existingConnections = [...block.connLeft, ...block.connRight];\n            newConnections.forEach(newConn => {\n                const existingConn = existingConnections.find(conn => conn.id === newConn.id);\n                if (existingConn) {\n                    existingConn.title = newConn.title;\n                    existingConn.color = newConn.color;\n                } else {\n                    existingConnections.push(newConn);\n                }\n            });\n        }\n        updateBlock(selectedblock = _n, callback) {\n            let preferences = Q('.' + classes.node_preferences);\n            let block;\n            if (selectedblock) {\n                block = selectedblock;\n            }\n            else {\n                block = this.blocks.find(b => b.id === preferences.id());\n            }\n            let name = preferences.find('#' + classes.name).text();\n            let content = preferences.find('#' + classes.content).html();\n            block.name = name;\n            block.text = content;\n            block.update = true;\n            if (callback) callback(block);\n        }\n        _event_pointer_down(event) {\n            if (event.button === 2) return;\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                let block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this.isDraggingBlock = true;\n                    this.draggingBlock = block;\n                    this.offsetX = mouseX - block.x;\n                    this.offsetY = mouseY - block.y;\n                    block.isDragging = true;\n                    break;\n                }\n            }\n        }\n        _event_pointer_move(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.draggingBlock) {\n                if (this.appearance.snapToGrid) {\n                    this.draggingBlock.x = _ma.round(this.draggingBlock.x / this.appearance.gridSize) * this.appearance.gridSize;\n                    this.draggingBlock.y = _ma.round(this.draggingBlock.y / this.appearance.gridSize) * this.appearance.gridSize;\n                    if (!this.lastMouseX || _ma.abs(mouseX - this.lastMouseX) >= this.appearance.gridSize || _ma.abs(mouseY - this.lastMouseY) >= this.appearance.gridSize) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                } else {\n                    if (!this.lastMouseX || _ma.abs(mouseX - this.lastMouseX) >= this.appearance.movementResolution || _ma.abs(mouseY - this.lastMouseY) >= this.appearance.movementResolution) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                }\n                return;\n            }\n            if (this.connection_start && this.connection_end === _n) {\n                this.mouseX = mouseX;\n                this.mouseY = mouseY;\n                this.render();\n                return;\n            }\n            if (this.isOverConnection) {\n                this.isOverConnection = false;\n                this.render();\n            }\n            this.connections.forEach(conn => {\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    if (!this.isOverConnection) {\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y, this.appearance.connectionPointSize + 2, 0, 2 * _ma.PI);\n                        let startColor = this._getConnectionColor(conn.start.block, conn.start.point);\n                        this.canvas_context.strokeStyle = startColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y, this.appearance.connectionPointSize + 2, 0, 2 * _ma.PI);\n                        let endColor = this._getConnectionColor(conn.end.block, conn.end.point);\n                        this.canvas_context.strokeStyle = endColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.isOverConnection = true;\n                    }\n                }\n            });\n        }\n        _event_pointer_up(event) {\n            if (this.draggingBlock) {\n                this.isDraggingBlock = false;\n                this.draggingBlock.isDragging = false;\n                this.draggingBlock = _n;\n                this.render();\n            }\n            if (this.connection_start && this.connection_end === _n) {\n                _st(() => {\n                    this.connection_start = _n;\n                    this.mouseX = 0;\n                    this.mouseY = 0;\n                    this.render();\n                }, 100);\n            }\n        }\n        _event_click(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            for (let block of this.blocks) {\n                if (this._connection_over_point(block, mouseX, mouseY)) {\n                    if (this.connection_start === _n) {\n                        this.connection_start = this._point_details(block, mouseX, mouseY);\n                    }\n                    else if (this.connection_end === _n) {\n                        this.connection_end = this._point_details(block, mouseX, mouseY);\n                        if (this.connection_start.block !== this.connection_end.block &&\n                            !this._connection_exists(this.connection_start, this.connection_end)) {\n                            this._connection_create(this.connection_start, this.connection_end);\n                            block.addConnection({ id: this.connection_start.block.id, point: this.connection_start.point });\n                        } else {\n                            this.connection_start = _n;\n                            this.connection_end = _n;\n                            this.render();\n                        }\n                        this.connection_start = _n;\n                        this.connection_end = _n;\n                    }\n                    return;\n                }\n            }\n        }\n        _menu_context(x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_small], style: { position: 'absolute', left: x + 'px', top: y + 'px' } });\n            this.isMenuPreferences = true;\n            let add = Q('<div>', { class: ['button_nodes_big'], text: 'Create Block' });\n            add.on('click', () => {\n                let id = this._id();\n                let nodes = this.blocks.length + 1;\n                let block = new UMLBlock({}, this.appearance, id, 'Node ' + nodes, 'Content', x, y, this.appearance.blockWidth, [{ id: this._id(), title: '', color: this.appearance.connectionColor }], [{ id: this._id(), title: '', color: this.appearance.connectionColor }]);\n                this.addBlock(block);\n                this._menu_remove();\n            });\n            div.append(add);\n            this.element_parent.append(div);\n        }\n        _event_click_right(event) {\n            event.preventDefault();\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                const block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this._menu_remove();\n                    this._menu_preferences(block, mouseX, mouseY);\n                    return;\n                }\n            }\n            for (let i = 0; i < this.connections.length; i++) {\n                const conn = this.connections[i];\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    const startBlock = this.blocks.find(b => b.id === conn.start.block.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                    if (startBlock && endBlock) {\n                        startBlock.removeConnection({ id: endBlock.id, point: conn.start.point });\n                    }\n                    this.connections.splice(i, 1);\n                    this.render();\n                    return;\n                }\n            }\n            this._menu_context(mouseX, mouseY);\n            this.render();\n        }\n        _id() {\n            return '_' + _ma.random().toString(36).substr(2, 9);\n        }\n        _menu_remove() {\n            Q('.' + classes.node_preferences).remove();\n            this.isMenuPreferences = false;\n        }\n        _menu_item_section(title, content) {\n            let div = Q('<div>', { class: [classes.pref_section] });\n            let titleDiv = Q('<div>', { class: [classes.pref_title], text: title });\n            div.append(titleDiv, content);\n            return div;\n        }\n        _menu_item_input(id, content, placeholder) {\n            let input = Q('<div>', { class: [classes.pref_content], id: id, contentEditable: true, html: content, placeholder: placeholder });\n            return input;\n        }\n        _menu_item_connections(block) {\n            let div = Q('<div>', { class: [classes.connection_content] });\n            let left = Q('<div>', { class: [classes.left] });\n            let right = Q('<div>', { class: [classes.right] });\n            const connItem = (pos, conn) => {\n                let connection_wrapper = Q('<div>', { class: [classes.connection_wrapper], id: conn.id });\n                let connection = Q('<input>', { class: [classes.connection], type: 'text', value: conn.title, placeholder: 'Point...', maxLength: 10 });\n                let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n                let color = Q('<input>', { class: [classes.color], type: 'color', value: conn.color });\n                color_wrapper.append(color);\n                color.on('change', () => {\n                    conn.color = color.val();\n                    this.render();\n                });\n                connection.on('input', () => {\n                    let contitle = connection.val();\n                    conn.title = (conn.title && contitle !== _n) ? contitle : '';\n                    this.updateConnections(block);\n                    this.render();\n                });\n                connection_wrapper.append(color_wrapper, connection);\n                let remove = Q('<div>', { class: [classes.button_nodes], text: 'X' });\n                remove.on('click', () => {\n                    connection_wrapper.remove();\n                    this.connections = this.connections.filter(c => {\n                        if (c.start.block.id === block.id && c.start.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.end.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.end.point });\n                            return false;\n                        }\n                        if (c.end.block.id === block.id && c.end.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.start.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.start.point });\n                            return false;\n                        }\n                        return true;\n                    });\n                    if (pos === 'left') { block.connLeft = block.connLeft.filter(c => c.id !== conn.id); }\n                    if (pos === 'right') { block.connRight = block.connRight.filter(c => c.id !== conn.id); }\n                    this.render();\n                });\n                connection_wrapper.append(remove);\n                return connection_wrapper;\n            };\n            block.connLeft.forEach(conn => {\n                let connection_wrapper = connItem('left', conn);\n                left.append(connection_wrapper);\n            });\n            block.connRight.forEach(conn => {\n                let connection_wrapper = connItem('right', conn);\n                right.append(connection_wrapper);\n            });\n            let add = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            add.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connLeft.push(connection);\n                left.append(connItem('left', connection));\n                left.append(add);\n                this.render();\n            });\n            left.append(add);\n            let addRight = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            addRight.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connRight.push(connection);\n                right.append(connItem('right', connection));\n                right.append(addRight);\n                this.render();\n            });\n            right.append(addRight);\n            div.append(left, right);\n            return div;\n        }\n        _menu_manipulation(block) {\n            let div = Q('<div>', { class: [classes.manipulation] });\n            let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n            let color = Q('<input>', { class: [classes.color], type: 'color', value: block.appearance.background });\n            color_wrapper.append(color);\n            color.on('change', () => {\n                block._restyle({ background: color.val() });\n                this.render();\n            });\n            div.append(color_wrapper);\n            let delete_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Delete Block' });\n            delete_button.on('click', () => {\n                this.removeBlock(block);\n                this._menu_remove();\n            });\n            let duplicate_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Duplicate Block' });\n            duplicate_button.on('click', () => {\n                this.duplicateBlock(block);\n                this._menu_remove();\n            });\n            div.append(color_wrapper, delete_button, duplicate_button);\n            return div;\n        }\n        _menu_preferences(block, x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_big], id: block.id });\n            div.css({ position: 'absolute', left: x + 'px', top: y + 'px' });\n            let title = this._menu_item_section('Class', this._menu_item_input(classes.name, block.name, 'Class name...'));\n            let content = this._menu_item_section('Content', this._menu_item_input(classes.content, block.text, 'Content...'));\n            let connections = this._menu_item_section('Connections', this._menu_item_connections(block));\n            let manipulation = this._menu_item_section('Manipulation', this._menu_manipulation(block));\n            div.append(title, content, connections, manipulation);\n            this.element_parent.append(div);\n            this.isMenuPreferences = true;\n        }\n        _connections_init(block) {\n            block.connections.forEach(conn => {\n                const targetBlock = this.blocks.find(b => b.id === conn.id);\n                if (targetBlock) {\n                    const startCoords = this._point_coords(block, 'right');\n                    const endCoords = this._point_coords(targetBlock, 'left');\n                    this._connection_create(\n                        { block: block, point: 'right', x: startCoords.x, y: startCoords.y },\n                        { block: targetBlock, point: conn.point, x: endCoords.x, y: endCoords.y }\n                    );\n                }\n            });\n        }\n        _blocks_connected(block1, block2) {\n            return this.connections.some(connection =>\n                (connection.start.block === block1 && connection.end.block === block2) ||\n                (connection.start.block === block2 && connection.end.block === block1)\n            );\n        }\n        _connection_exists(startConn, endConn) {\n            return this.connections.some(conn => {\n                const isDirectMatch =\n                    conn.start.block === startConn.block && conn.start.point === startConn.point &&\n                    conn.end.block === endConn.block && conn.end.point === endConn.point;\n                const isReverseMatch =\n                    conn.start.block === endConn.block && conn.start.point === endConn.point &&\n                    conn.end.block === startConn.block && conn.end.point === startConn.point;\n                return isDirectMatch || isReverseMatch;\n            });\n        }\n        _connection_create(startConn, endConn) {\n            this.connections.push({\n                start: { block: startConn.block, point: startConn.point, x: startConn.x, y: startConn.y },\n                end: { block: endConn.block, point: endConn.point, x: endConn.x, y: endConn.y }\n            });\n            startConn.block.addConnection({ id: endConn.block.id, point: startConn.point });\n            endConn.block.addConnection({ id: startConn.block.id, point: endConn.point });\n            this.render();\n        }\n        _connection_update() {\n            this.connections.forEach(conn => {\n                _ob.assign(conn.start, this._point_coords(conn.start.block, conn.start.point));\n                _ob.assign(conn.end, this._point_coords(conn.end.block, conn.end.point));\n            });\n        }\n        _point_coords(block, pointId) {\n            const connections = [\n                { coords: block.leftConnCoords, conns: block.connLeft },\n                { coords: block.rightConnCoords, conns: block.connRight }\n            ];\n            for (const { coords, conns } of connections) {\n                const index = conns.findIndex(conn => conn.id === pointId);\n                if (index !== -1) {\n                    return { x: coords[index].x, y: coords[index].y };\n                }\n            }\n            return { x: block.x, y: block.y };\n        }\n        _connection_over_point(block, x, y) {\n            const radius = 5;\n            return block.getAllConnectionCoords().some(coord => _ma.abs(x - coord.x) < radius && _ma.abs(y - coord.y) < radius);\n        }\n        _point_details(block, x, y) {\n            x -= block.x;\n            y -= block.y;\n            const radius = 5;\n            let matchedPoint = _n;\n            block.leftConnCoords.forEach((coord, index) => {\n                if (_ma.abs(x - coord.x) < radius && _ma.abs(y - coord.y) < radius) {\n                    matchedPoint = { block: block, point: block.connLeft[index].id, x: coord.x, y: coord.y, index: index };\n                }\n            });\n            if (!matchedPoint) {\n                block.rightConnCoords.forEach((coord, index) => {\n                    if (_ma.abs(x - coord.x) < radius && _ma.abs(y - coord.y) < radius) {\n                        matchedPoint = { block: block, point: block.connRight[index].id, x: coord.x, y: coord.y, index: index };\n                    }\n                });\n            }\n            return matchedPoint;\n        }\n        _point_line_segment(px, py, x1, y1, x2, y2) {\n            const d1 = _ma.hypot(px - x1, py - y1);\n            const d2 = _ma.hypot(px - x2, py - y2);\n            const lineLen = _ma.hypot(x2 - x1, y2 - y1);\n            return d1 + d2 >= lineLen - 0.1 && d1 + d2 <= lineLen + 0.1;\n        }\n        _point_line_distance(px, py, x1, y1, x2, y2) {\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            const lenSq = dx * dx + dy * dy;\n            let t = 0;\n            if (lenSq !== 0) {\n                t = ((px - x1) * dx + (py - y1) * dy) / lenSq;\n                t = _ma.max(0, _ma.min(1, t));\n            }\n            const projX = x1 + t * dx;\n            const projY = y1 + t * dy;\n            return _ma.hypot(px - projX, py - projY);\n        }\n    }\n    let appearance = {\n        darkTextColor: '#888',\n        lightTextColor: '#222',\n        background: '#181818',\n        grid: true,\n        gridColor: '#161616',\n        gridSize: 20,\n        snapToGrid: false,\n        movementResolution: 3,\n        factorTitleBackground: -20,\n        factorDarkColors: -30,\n        factorLightColors: 80,\n        factorDarkColorMargin: 20,\n        factorDarkColorThreshold: 127,\n        blockWidth: 200,\n        connectionColor: '#333333',\n        connectionPointSize: 5,\n        connectionPointPadding: 5,\n        connectionTextPaddingX: 5,\n        connectionTextPaddingY: 5,\n        shadowBlur: 10,\n        shadowColor: 'rgba(0, 0, 0, 0.2)',\n        shadowOffsetX: 0,\n        shadowOffsetY: 5,\n        font: 'Arial',\n        fontSize: 12,\n        fontSizeTitle: 12,\n        fontSizeConnection: 10,\n        padding: 5,\n        radius: 10\n    };\n    appearance = _ob.assign(appearance, options);\n    let uml = new UMLCanvas(selector, width, height, appearance, classes);\n    return {\n        import: function (data) {\n            uml.import(data);\n        },\n        export: function () {\n            return uml.export();\n        },\n        addBlock: function (block) {\n            uml.addBlock(block);\n        },\n        removeBlock: function (block) {\n            uml.removeBlock(block);\n        }\n    };\n}"
        },
        "Socket": {
            "uuid": "694c71d8-9d09-447b-897a-eae11cb7326b",
            "name": "Socket",
            "method": "Plugin",
            "desc": "Provides a WebSocket implementation with automatic reconnection and status callbacks.",
            "type": "Plugin",
            "example": "var socket = Q.Socket('ws://localhost:8080', console.log, console.log);",
            "dependencies": [],
            "script": "Q.Socket = function (url, onMessage, onStatus, options = {}) {\n    const { retries = 5, delay = 1000, protocols = [] } = options;\n    let socket, attempts = 0;\n    const connect = () => {\n        socket = new WebSocket(url, protocols);\n        socket.onopen = () => { onStatus?.('connected'); attempts = 0; };\n        socket.onmessage = event => onMessage?.(event.data);\n        socket.onerror = error => onStatus?.('error', error);\n        socket.onclose = () => {\n            if (++attempts <= retries) {\n                onStatus?.('closed');\n                _st(connect, delay);\n            } else {\n                onStatus?.('Max retries exceeded');\n            }\n        };\n    };\n    connect();\n    return {\n        send: msg => socket.readyState === WebSocket.OPEN && socket.send(msg),\n        reconnect: () => connect(),\n        close: () => socket.close()\n    };\n};"
        },
        "Storage": {
            "uuid": "c123a368-ae91-4441-ba08-8af9d7ac7222",
            "name": "Storage",
            "method": "Plugin",
            "desc": "Provides methods to store and retrieve data from the local storage.",
            "type": "Plugin",
            "example": "Q.Storage('key', 'value to store'); Q.Storage('key'); // returns 'value to store'",
            "dependencies": [],
            "script": "Q.Storage = function (key, value) {\n    if (arguments.length === 2) { \n        if (value === _n || value === '') { \n            localStorage.removeItem(key); \n        } else {\n            localStorage.setItem(key, JSON.stringify(value)); \n        }\n    } else if (arguments.length === 1) { \n        let storedValue = localStorage.getItem(key); \n        try {\n            return JSON.parse(storedValue); \n        } catch (e) {\n            return storedValue; \n        }\n    }\n};"
        },
        "String": {
            "uuid": "5dbab2a6-e049-46d7-9e83-f53010377194",
            "name": "String",
            "method": "Plugin",
            "desc": "Provides methods to manipulate strings.",
            "type": "Plugin",
            "example": "Q.String('hello').capitalize(); // returns 'Hello'",
            "dependencies": [],
            "script": "Q.String = function (string) {\n    if (!(this instanceof Q.String)) {\n        return new Q.String(string);\n    }\n    this.string = string;\n};\nQ.String.prototype.capitalize = function () {\n    return this.string.charAt(0).toUpperCase() + this.string.slice(1);\n};\nQ.String.prototype.levenshtein = function (string) {\n    const a = this.string, b = string;\n    const matrix = _ar.from({ length: a.length + 1 }, (_, i) => _ar.from({ length: b.length + 1 }, (_, j) => i || j));\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            matrix[i][j] = _ma.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\nQ.String.prototype.find = function (stringOrRegex) {\n    return this.string.match(stringOrRegex);\n};\nQ.String.prototype.replaceAll = function (stringOrRegex, replacement) {\n    return this.string.replace(new _re(stringOrRegex, 'g'), replacement);\n};"
        },
        "Style": {
            "uuid": "7a5fa781-9146-413c-8244-ef5a8fe56b9e",
            "name": "Style",
            "method": "Plugin",
            "desc": "Provides methods to apply global styles to the document. It's useful for applying CSS variables from JavaScript. Q.style will be removed after the styles are applied on the document ready event.",
            "type": "Plugin",
            "example": "Q.style(':root { --color: red; } body { background-color: var(--color); }');",
            "dependencies": [
                "ID"
            ],
            "script": "Q.style = (function () {\n    let styleData = {\n        gen: \"\",\n        root: '',\n        element: _n,\n        checked: false,\n    };\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib-root-styles') || createStyleElement();\n            styleData.init = true;\n        }\n        let finalStyles = '';\n        if (styleData.root) {\n            finalStyles = `:root {${styleData.root}}\\n`;\n        }\n        finalStyles += styleData.gen;\n        styleData.element.textContent = finalStyles;\n    }\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib-root-styles';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n    window.addEventListener('load', () => {\n        _c.log('Styles plugin loaded.');\n        delete Q.style;\n    }, { once: true });\n    return function (styles, mapping = _n) {\n        if (typeof styles === 'string') {\n            const rootContentMatch = styles.match(/:root\\s*{([^}]*)}/);\n            if (rootContentMatch) {\n                styles = styles.replace(rootContentMatch[0], '');\n                const rootContent = rootContentMatch[1].split(';').map(item => item.trim()).filter(item => item);\n                styleData.root += rootContent.join(';') + ';';\n            }\n            if (mapping) {\n                const keys = _ob.keys(mapping);\n                keys.forEach((key) => {\n                    let newKey = Q.ID(5, '_');\n                    styles = styles.replace(new _re(`\\\\b${key}\\\\b`, 'gm'), newKey);\n                    mapping[key] = mapping[key].replace(key, newKey);\n                });\n                _c.log(mapping);\n            }\n            styleData.gen += styles;\n            applyStyles();\n            return mapping;\n        } else {\n            _c.error('Invalid styles parameter. Expected a string.');\n        }\n    };\n})();"
        },
        "Task": {
            "uuid": "a6288883-4d61-4b66-b25e-196e6e4cb9de",
            "name": "Task",
            "method": "Plugin",
            "desc": "Provides methods to run tasks asynchronously and handle their completion or failure. Basically a Promise wrapper, but with more control.",
            "type": "Plugin",
            "example": "var task = Q.Task('task1', () => console.log('Task 1'), () => console.log('Task 2')); task.Run();",
            "dependencies": [],
            "script": "Q.Task = (function () {\n    const tasks = {};\n    const runningTasks = {};\n    function createTask(id) {\n        if (!tasks[id]) {\n            tasks[id] = [];\n        }\n    }\n    function addTask(id, ...functions) {\n        if (!tasks[id]) {\n            createTask(id);\n        }\n        tasks[id].push(...functions);\n    }\n    async function runTask(id) {\n        if (!tasks[id] || tasks[id].length === 0) {\n            _c.error(`No tasks found with ID: ${id}`);\n            return;\n        }\n        runningTasks[id] = {\n            doneCallback: _n,\n            failCallback: _n,\n            timeout: 20000, \n            timeoutCallback: _n,\n        };\n        const { timeout, timeoutCallback } = runningTasks[id];\n        const timeoutPromise = new _pr((_, reject) => {\n            const timer = _st(() => {\n                abortTask(id);\n                reject(new _er(`Task with ID: ${id} timed out after ${timeout / 1000} seconds`));\n            }, timeout);\n            runningTasks[id].timeoutClear = () => _ct(timer);\n        });\n        try {\n            await _pr.race([\n                (async () => {\n                    for (const task of tasks[id]) {\n                        await new _pr((resolve, reject) => {\n                            try {\n                                const result = task();\n                                if (result instanceof _pr) {\n                                    result.then(resolve).catch(reject);\n                                } else {\n                                    resolve();\n                                }\n                            } catch (error) {\n                                reject(error);\n                            }\n                        });\n                    }\n                })(),\n                timeoutPromise\n            ]);\n            if (runningTasks[id]?.doneCallback) {\n                runningTasks[id].doneCallback();\n            }\n        } catch (error) {\n            _c.error(`Task with ID: ${id} failed with error:`, error);\n            if (runningTasks[id]?.failCallback) {\n                runningTasks[id].failCallback(error);\n            }\n        } finally {\n            if (runningTasks[id]?.timeoutClear) {\n                runningTasks[id].timeoutClear();\n            }\n            delete runningTasks[id];\n        }\n    }\n    function abortTask(id) {\n        if (runningTasks[id]) {\n            delete runningTasks[id];\n            _c.log(`Task with ID: ${id} has been aborted.`);\n        }\n    }\n    function taskDone(id, callback) {\n        if (runningTasks[id]) {\n            runningTasks[id].doneCallback = callback;\n        }\n    }\n    function taskFail(id, callback) {\n        if (runningTasks[id]) {\n            runningTasks[id].failCallback = callback;\n        }\n    }\n    function setTimeoutForTask(id, seconds) {\n        if (runningTasks[id]) {\n            runningTasks[id].timeout = seconds * 1000;\n        }\n    }\n    function setTimeoutCallback(id, callback) {\n        if (runningTasks[id]) {\n            runningTasks[id].timeoutCallback = callback;\n        }\n    }\n    return function (id, ...functions) {\n        if (functions.length > 0) {\n            addTask(id, ...functions);\n        }\n        return {\n            Run: () => runTask(id),\n            Abort: () => abortTask(id),\n            Done: callback => taskDone(id, callback),\n            Fail: callback => taskFail(id, callback),\n            Timeout: (seconds) => setTimeoutForTask(id, seconds),\n            TimeoutCallback: (callback) => setTimeoutCallback(id, callback),\n        };\n    };\n})();"
        },
        "Timer": {
            "uuid": "beb4a765-6d19-425b-95d3-f984a998eea7",
            "name": "Timer",
            "method": "Plugin",
            "desc": "Provides a timer implementation with automatic stop and interrupt. Useful for running tasks at intervals or for a specific duration.",
            "type": "Plugin",
            "example": "Q.Timer(() => console.log('Tick'), 'timer1', { tick: 5, delay: 1000, interrupt: true });",
            "dependencies": [],
            "script": "Q.Timer = function (callback, id, options = {}) {\n    const defaultOptions = {\n        tick: 1,\n        delay: 1000,\n        interrupt: false\n    };\n    options = { ...defaultOptions, ...options };\n    let tickCount = 0;\n    let intervalId = _n;\n    if (!Q.Timer.activeTimers) {\n        Q.Timer.activeTimers = new Map();\n    }\n    if (options.interrupt && Q.Timer.activeTimers.has(id)) {\n        clearInterval(Q.Timer.activeTimers.get(id));\n    }\n    intervalId = _si(() => {\n        callback();\n        tickCount++;\n        if (options.tick > 0 && tickCount >= options.tick) {\n            clearInterval(intervalId);\n            Q.Timer.activeTimers.delete(id);\n        }\n    }, options.delay);\n    Q.Timer.activeTimers.set(id, intervalId);\n    return intervalId;\n};\nQ.Timer.stop = function (id) {\n    if (Q.Timer.activeTimers && Q.Timer.activeTimers.has(id)) {\n        clearInterval(Q.Timer.activeTimers.get(id));\n        Q.Timer.activeTimers.delete(id);\n    }\n};\nQ.Timer.stopAll = function () {\n    if (Q.Timer.activeTimers) {\n        for (let intervalId of Q.Timer.activeTimers.values()) {\n            clearInterval(intervalId);\n        }\n        Q.Timer.activeTimers.clear();\n    }\n};"
        }
    },
    "statics": {
        "AvgColor": {
            "uuid": "a0b57653-ba8b-40e5-b348-840cb0e411a5",
            "name": "AvgColor",
            "method": "Utility",
            "desc": "Calculates the average color of an image by creating a canvas element, drawing the image on it, and analyzing the pixel data to determine the average color. <br> This technique is useful for generating color palettes, creating visual effects, or enhancing user interface elements based on the predominant colors in an image.",
            "type": "Image Processing",
            "example": "Q.AvgColor('image.jpg or canvas', sampleSize, callback); // Returns the average color of the image or canvas",
            "dependencies": [],
            "script": "Q.AvgColor = function (image, sampleSize, callback) {\n    let img = new Image();\n    img.crossOrigin = 'Anonymous';\n    if (typeof image === 'string') {\n        img.src = image;\n    } else if (image instanceof HTMLCanvasElement) {\n        img.src = image.toDataURL();\n    } else {\n        _c.error(\"Invalid image source provided.\");\n        return;\n    }\n    img.onload = function () {\n        let canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        let ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        let data = ctx.getImageData(0, 0, img.width, img.height).data;\n        let length = data.length / 4;\n        let samplingRate = 1;\n        if (sampleSize === 'auto') {\n            let factor = _ma.ceil(_ma.sqrt(img.width * img.height) / 32);\n            samplingRate = _ma.max(1, factor);\n        } else if (typeof sampleSize === 'number' && sampleSize > 0) {\n            samplingRate = sampleSize;\n        }\n        let color = { r: 0, g: 0, b: 0 };\n        let count = 0;\n        for (let i = 0; i < length; i += samplingRate) {\n            let idx = i * 4; // Convert to RGBA index\n            color.r += data[idx];\n            color.g += data[idx + 1];\n            color.b += data[idx + 2];\n            count++;\n        }\n        color.r = _ma.floor(color.r / count);\n        color.g = _ma.floor(color.g / count);\n        color.b = _ma.floor(color.b / count);\n        if (typeof callback === 'function') {\n            callback(color);\n        }\n    };\n    img.onerror = function () {\n        _c.error(\"Failed to load image.\");\n    };\n};"
        },
        "ColorBrightness": {
            "uuid": "57fc96e3-e54e-43bb-85c5-f7c66a18ea93",
            "name": "ColorBrightness",
            "method": "Utility",
            "desc": "Adjusts the brightness of a given color by a specified percentage, making the color lighter or darker. <br> This function can be used to dynamically change colors for various UI elements, providing visual feedback or creating color schemes with different shades. <br> It supports both hexadecimal and RGB/RGBA color formats, making it flexible for different use cases in web design or graphics.",
            "type": "Color",
            "example": "Q.ColorBrightness('#000000', 50); // #7f7f7f (black +50%) <br> Q.ColorBrightness('rgb(255, 0, 0)', -30); // rgb(178, 0, 0) (red -30%) <br> Q.ColorBrightness('rgba(0, 0, 255, 0.5)', 20); // rgba(51, 51, 255, 0.5) (blue +20%)",
            "dependencies": [],
            "script": "Q.ColorBrightness = function (c, percent) {\n    let r, g, b, a = 1;\n    let hex = false;\n    if (!c.startsWith('#') && !c.startsWith('rgb')) {\n        throw new _er('Unsupported c format');\n    }\n    if (c.startsWith('#')) {\n        c = c.replace(/^#/, '');\n        if (c.length === 3) {\n            r = parseInt(c[0] + c[0], 16);\n            g = parseInt(c[1] + c[1], 16);\n            b = parseInt(c[2] + c[2], 16);\n        }\n        if (c.length === 6) {\n            r = parseInt(c.substring(0, 2), 16);\n            g = parseInt(c.substring(2, 4), 16);\n            b = parseInt(c.substring(4, 6), 16);\n        }\n        hex = true;\n    }\n    if (c.startsWith('rgb')) {\n        const alphaColor = c.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(\\.\\d+)?))?\\)/);\n        if (alphaColor) {\n            r = parseInt(alphaColor[1]);\n            g = parseInt(alphaColor[2]);\n            b = parseInt(alphaColor[3]);\n            if (alphaColor[4]) {\n                a = parseFloat(alphaColor[4]);\n            }\n        }\n    }\n    r = _ma.min(255, _ma.max(0, r + (r * percent / 100)));\n    g = _ma.min(255, _ma.max(0, g + (g * percent / 100)));\n    b = _ma.min(255, _ma.max(0, b + (b * percent / 100)));\n    if (hex) {\n        return '#' +\n            ('0' + _ma.round(r).toString(16)).slice(-2) +\n            ('0' + _ma.round(g).toString(16)).slice(-2) +\n            ('0' + _ma.round(b).toString(16)).slice(-2);\n    } else if (c.startsWith('rgb')) {\n        if (a === 1) {\n            return `rgb(${_ma.round(r)}, ${_ma.round(g)}, ${_ma.round(b)})`;\n        } else {\n            return `rgba(${_ma.round(r)}, ${_ma.round(g)}, ${_ma.round(b)}, ${a})`;\n        }\n    }\n}"
        },
        "Debounce": {
            "uuid": "85d4fa87-3a76-4880-9471-5c66d052eae8",
            "name": "Debounce",
            "method": "Utility",
            "desc": "Debounces a function to ensure it is only called after a specified delay since the last invocation, effectively preventing multiple calls in rapid succession. <br> This technique is particularly useful in scenarios like resizing windows, scrolling, or typing events, where multiple triggers can lead to performance issues or unintended behavior. <br> By controlling the rate at which a function can fire, developers can optimize performance and enhance user experience.",
            "type": "Event Handling",
            "example": "Q.Debounce('myFunction', 500, myFunction); // Calls myFunction after 500ms of inactivity <br> Q.Debounce('resizeEvent', 300, handleResize); // Debounces resize handling function",
            "dependencies": [],
            "script": "Q.Debounce = function (id, b, c) {\n    let d = Q.getGLOBAL('Debounce');\n    if (d && d[id]) {\n        _ct(d[id]);\n    }\n    Q.setGLOBAL({ Debounce: { ...d, [id]: _st(c, b) } });\n};"
        },
        "HSL2RGB": {
            "uuid": "26fc2e1c-7f77-46ce-aacf-c64a4b6213d5",
            "name": "HSL2RGB",
            "method": "Utility",
            "desc": "Converts HSL (Hue, Saturation, Lightness) color values to RGB (Red, Green, Blue) format. <br> This function is essential for applications that require color transformations, allowing developers to switch between different color representations easily. <br> Understanding color models is key in design, and this utility helps bridge the gap between HSL, which is often more intuitive for humans, and RGB, which is commonly used in digital displays.",
            "type": "Color",
            "example": "Q.HSL2RGB(0, 0, 1); // [255, 255, 255] <br> Q.HSL2RGB(0, 1, 0.5); // [255, 0, 0] <br> Q.HSL2RGB(0.33, 1, 0.5); // [0, 255, 0]",
            "dependencies": [],
            "script": "Q.HSL2RGB = function (h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        let a = function (p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        let p = 2 * l - q;\n        r = a(p, q, h + 1 / 3);\n        g = a(p, q, h);\n        b = a(p, q, h - 1 / 3);\n    }\n    return [r * 255, g * 255, b * 255];\n};"
        },
        "ID": {
            "uuid": "5c30589b-b37f-4608-bb5a-0b44a7fad674",
            "name": "ID",
            "method": "Utility",
            "desc": "It's useful for creating unique identifiers for users, sessions, or any items requiring distinct identification. <br> The ID is generated using random hexadecimal digits (0-9 and a-f) and can be customized with a prefix for better context or categorization.",
            "type": "Utility",
            "example": "Q.ID(8, 'user-'); // user-1a2b3c4d <br> Q.ID(); // 1a2b3c4d <br> Q.ID(12, 'session-'); // session-1a2b3c4d5e6f",
            "dependencies": [],
            "script": "Q.ID = function (length = 8, b = '') {\n    return b + [..._ar(length)]\n        .map(() => _ma.floor(_ma.random() * 16).toString(16))\n        .join('');\n};"
        },
        "isDarkColor": {
            "uuid": "8c2e869f-9470-4e16-9499-6b4899ce6e0d",
            "name": "isDarkColor",
            "method": "Utility",
            "desc": "Determines if a color is dark or light based on the HSP (Hue, Saturation, Perceived brightness) model. <br> This utility helps in designing user interfaces by ensuring adequate contrast between text and background colors, enhancing readability and accessibility. <br> Users can adjust the margin and threshold parameters to fine-tune sensitivity according to their design needs.",
            "type": "Color",
            "example": "Q.isDarkColor('#000000'); // true <br> Q.isDarkColor('#ffffff'); // false <br> Q.isDarkColor('#4c4c4c', 30, 90); // true",
            "dependencies": [],
            "script": "Q.isDarkColor = (color, margin = 20, c = 100) => {\n    let r, g, b;\n    const parseHex = (f) => {\n        if (f.length === 3) {\n            return [\n                parseInt(f[0] + f[0], 16),\n                parseInt(f[1] + f[1], 16),\n                parseInt(f[2] + f[2], 16),\n            ];\n        } else if (f.length === 6) {\n            return [\n                parseInt(f.slice(0, 2), 16),\n                parseInt(f.slice(2, 4), 16),\n                parseInt(f.slice(4, 6), 16),\n            ];\n        }\n        throw new _er('Invalid f color format');\n    };\n    if (color[0] === '#') {\n        [r, g, b] = parseHex(color.slice(1));\n    } else if (color.startsWith('rgb')) {\n        const rgba = color.match(/\\d+/g);\n        if (rgba && rgba.length >= 3) {\n            [r, g, b] = rgba.map(_nu);\n        } else {\n            throw new _er('Invalid color format');\n        }\n    } else {\n        throw new _er('Unsupported color format');\n    }\n    const e = _ma.sqrt(\n        0.299 * (r ** 2) +\n        0.587 * (g ** 2) +\n        0.114 * (b ** 2)\n    ) + margin;\n    return e < c;\n};"
        },
        "RGB2HSL": {
            "uuid": "25a080c6-f125-46d5-acf9-12617a52a1ef",
            "name": "RGB2HSL",
            "method": "Utility",
            "desc": "Converts RGB color values to HSL format, providing a different way to represent colors that can be more intuitive for artists and designers. <br> HSL stands for Hue, Saturation, and Lightness, making it easier to manipulate colors based on human perception. <br> This conversion is essential for applications requiring color manipulation, such as image editing or web design, where understanding color relationships is crucial.",
            "type": "Color",
            "example": "Q.RGB2HSL(255, 255, 255); // [0, 0, 1] <br> Q.RGB2HSL(0, 0, 0); // [0, 0, 0] <br> Q.RGB2HSL(255, 0, 0); // [0, 1, 0.5]",
            "dependencies": [],
            "script": "Q.RGB2HSL = function (r, g, b) {\n    r /= 255, g /= 255, b /= 255;\n    let maximum = _ma.max(r, g, b), minimum = _ma.min(r, g, b);\n    let h, s, l = (maximum + minimum) / 2;\n    if (maximum === minimum) {\n        h = s = 0;\n    } else {\n        let d = maximum - minimum;\n        s = l > 0.5 ? d / (2 - maximum - minimum) : d / (maximum + minimum);\n        switch (maximum) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n    }\n    return [h, s, l];\n};"
        }
    }
};
function Highlight(code) {
    // Function to escape HTML characters in code
    const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    code = escapeHTML(code);

    let patterns = [];

    let dictionary = [
        {
            find: ["Q"],
            open: "", 
            close: "", 
            className: "class",
            regex: "single",
            allowNested: false
        },
        {
            find: ["(", ")", "{", "}", "[", "]"],
            open: "", 
            close: "", 
            className: "bracket",
            regex: "single",
            allowNested: false
        },
        {
            find: ["'", '"'],
            open: "", 
            close: "", 
            className: "string",
            regex: "single",
            allowNested: false
        },
        {
            find: ["*"],
            open: "//", 
            close: "<br>", 
            className: "comment",
            regex: "between",
            allowNested: false
        },
        {
            find: ["function", "return", "if", "else", "for", "while"],
            open: "", 
            close: "", 
            className: "keyword",
            regex: "single",
            allowNested: false
        },
        {
            find: ["let", "var", "const"],
            open: "", 
            close: "", 
            className: "variable",
            regex: "single",
            allowNested: false
        }
    ];

    // Generate patterns from the dictionary
    dictionary.forEach(({ find, open, close, className, regex, allowNested }) => {
        let regexString = "";
        if (regex === "single") {
            // Join keywords with | for a single word match, using \b word boundaries
            regexString = `\\b(${find.map(item => item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join("|")})\\b`;
        } else if (regex === "between") {
            // Use non-capturing groups and lookahead/lookbehind for the between match
            regexString = `(${open})((?:(?!${close}).)*?)(${close})`;
        } else {
            regexString = regex; // Assume a custom regex is provided
        }

        patterns.push({
            regex: new RegExp(regexString, "g"),
            replace: `<span class='hl ${className}'>$&</span>`,
            allowNested
        });
    });

    // Apply patterns to the code
    patterns.forEach(({ regex, replace, allowNested }) => {
        code = code.replace(regex, (match, ...groups) => {
            // If allowNested is false, un-nest any nested spans inside
            if (!allowNested) {
                match = match.replace(/<span.*?>(.*?)<\/span>/g, '$1');
            }
            return replace.replace('$&', match);
        });
    });

    // Use a temporary container to parse and process the HTML
    let temp = document.createElement("div");
    temp.innerHTML = code;

    // Remove nested spans if necessary
    temp.querySelectorAll("span span").forEach(nested => {
        const parent = nested.parentElement;
        if (nested.classList.contains("hl")) {
            parent.replaceChild(document.createTextNode(nested.textContent), nested);
        }
    });

    return temp.innerHTML;
}

// function Highlight(code) {
    
//     const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
//     code = code.replace(/\"(.*?)\"/g, (_, p1) => `"${escapeHTML(p1)}"`);

//     let patterns = [];

//     let dictionary = [
//         {
//         find:["Q"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"class", // span class name
//         regex: "single", // single, between, regex (direct regex) 
//         allowNested: false // allow or remove nested (convert to plain text)
//         },
//         {
//         find:["(", ")", "{", "}", "[", "]"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"bracket", // span class name
//         regex: "single", // single, between, regex (direct regex)
//         allowNested: false // allow or remove nested (convert to plain text)
//         }
//     ];


//     dictionary.forEach(({find, open, close, className, regex, allowNested}) => {
//         let regexString = "";
//         if (regex === "single") {
//             regexString = `\\b(${find.join("|")})\\b`;
//         } else if (regex === "between") {
//             regexString = `\\b(${open})((?:(?!${close}).)*)\\b(${close})`;
//         } else {
//             regexString = regex;
//         }

//         patterns.push({
//             regex: new RegExp(regexString, "g"),
//             replace: `<span class='hl ${className}'>$&</span>`
//         });
//     });


//     // const patterns = [
//     //     { regex: /(['"`])(.*?)\1/g, replace: "<span class='hl string'>$1$2$1</span>" },
//     //             { regex: /\b(\d+)\b/g, replace: "<span class='hl number'>$1</span>" },

//     //     { regex: /Q\(/g, replace: "<span class='hl class'>Q</span>(" },
//     //     { regex: /Q\./g, replace: "<span class='hl object'>Q.</span>" },
//     //     // { regex: /\((.*?)\)/g, replace: "(<span class='bracket_inner'>$1</span>)" },
//     //     // { regex: /\{(.*?)\}/g, replace: "{<span class='bracket_inner'>$1</span>}" },
//     //     // { regex: /\[(.*?)\]/g, replace: "[<span class='bracket_inner'>$1</span>]" },
//     //     { regex: /\{|\}|\(|\)|\[|\]/g, replace: "<span class='hl bracket'>$&</span>" },
//     //     { regex: /\b(function|return|if|else|for|while)\b/g, replace: "<span class='hl keyword'>$1</span>" },
//     //     //variables
//     //     { regex: /\b(let|var|const)\b/g, replace: "<span class='hl variable'>$1</span>" },

//     //     {
//     //         regex: /\/\/(?!https?:\/\/|ftp:\/\/|ws:\/\/)(.*?)(?=<br>|$)/g, replace: "<span class='hl comment'>//$1</span>"
//     //     }
//     // ];

//     patterns.forEach(({ regex, replace }) => code = code.replace(regex, replace));

//     let temp = document.createElement("div");
//     temp.innerHTML = code;

//     temp.querySelectorAll("span span").forEach(nested => {
        
//         if (nested.classList.contains("hl")) {
//             const parent = nested.parentElement;
//             parent.replaceChild(document.createTextNode(nested.textContent), nested);
//         }
//     });

//     return temp.innerHTML;
// }

const IDS = {};

function CodeBuilder() {
    const activeBlocks = document.querySelectorAll(".block.active");


    const applyScript = (script) => {
        const sizedata = document.querySelector(".sizedata");
        let BaseScript = JSON.parse(JSON.stringify(DATA.frame));
        BaseScript = BaseScript.replace("return Q;", script + "\nreturn Q;");
        let codeBlock = document.querySelector(".codeData");
        codeBlock.innerHTML = minify(BaseScript);
        sizedata.innerHTML = "Library size: " + CalculateSizeKB(BaseScript);
    }




    if (!activeBlocks.length) {
        applyScript("");
        return;
    }

    const script = Array.from(activeBlocks)
        .map(block => {
            let blockScript = "";
            // Traverse the IDS structure to find the matching script
            for (const name in IDS) {
                const blockData = IDS[name];
                if (blockData.uuid == block.id) {
                    blockScript = blockData.script || "";
                    break;
                }
            }
            return blockScript;
        })
        .join("");

    applyScript(script);

    // console.log(script);
}


function classFormat(text) {
    return text.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");
}

function minify(code) {
    return code.replace(/^\s*/gm, "").replace(/\n/g, "");
}

function CalculateSizeKB(code) {
    return (new Blob([code]).size / 1024).toFixed(2) + " KB";
}

function createTags(tags) {
    const tagsContainer = document.createElement("div");
    tagsContainer.className = "tags";
    tags.forEach(tag => {
        const tagElement = document.createElement("span");
        tagElement.className = "tag";
        tagElement.innerHTML = tag;
        tagsContainer.appendChild(tagElement);
    });
    return tagsContainer;
}

function createCodeCategory(title) {
    const categoryContainer = document.createElement("div");
    categoryContainer.className = "code_category";
    categoryContainer.innerHTML = `<h2 class='code_category_title'>${title}</h2>`;
    const categoryContent = document.createElement("div");
    categoryContent.className = "code_content";
    categoryContent.id = classFormat(title);
    categoryContainer.appendChild(categoryContent);
    return categoryContainer;
}

function createBlock(contentData) {
    const { uuid, name, desc, example, dependencies } = contentData;
    const block = document.createElement("div");
    block.className = "block";
    block.id = uuid;
    block.innerHTML = `<h2>${name}</h2>`;

    const blockContent = document.createElement("div");
    blockContent.className = "block_content";
    block.appendChild(blockContent);

    blockContent.innerHTML = `<p>${desc}</p>`;
    const blockExample = document.createElement("div");
    blockExample.className = "block_example";
    blockExample.innerHTML = Highlight(example.replace(/\n/g, "<br>"));
    blockContent.appendChild(blockExample);

    if (dependencies.length > 0) {
        const blockDependencies = document.createElement("div");
        blockDependencies.className = "block_dependencies";
        blockDependencies.innerHTML = "<b>Dependencies</b>";
        blockDependencies.appendChild(createTags(dependencies));
        blockContent.appendChild(blockDependencies);
    }

    block.addEventListener("click", function (event) {
        if (event.currentTarget.contains(event.target)) {
            block.classList.toggle("active");
            if (block.classList.contains("active")) {
                dependencies.forEach(dep => {
                    const depBlock = document.getElementById(IDS[dep]?.uuid);
                    if (depBlock && !depBlock.classList.contains("active")) {
                        depBlock.click();
                    }
                });
            }
            CodeBuilder();
        }
    });

    return block;
}

function createTab(name, identifier, contentData) {
    const tabHeader = document.querySelector(".tab_header");
    const tabContainer = document.querySelector(".tab_container");

    const tab = document.createElement("div");
    tab.className = "tab";
    tab.innerHTML = name;
    tab.setAttribute("data-identifier", identifier);

    const tabContent = document.createElement("div");
    tabContent.className = "tab_content";
    tabContent.setAttribute("data-identifier", identifier);

    const types = [...new Set(contentData.map(c => c.type))];
    types.forEach(type => tabContent.appendChild(createCodeCategory(type)));
    contentData.forEach(content => {
        tabContent.querySelector(`#${classFormat(content.type)}`).appendChild(createBlock(content));
    });

    tab.addEventListener("click", function () {
        document.querySelectorAll(".tab, .tab_content").forEach(el => el.classList.remove("active"));
        tab.classList.add("active");
        tabContent.classList.add("active");
    });

    tabHeader.appendChild(tab);
    tabContainer.appendChild(tabContent);

    return tab;
}

function createTabs() {
    const methods = new Set();
    Object.values(DATA).forEach(category => {
        if (typeof category === 'object') {
            console.log(category);
            const contentData = [];
            Object.values(category).forEach(({ method, uuid, desc, type, example, dependencies, script }) => {
                if (!methods.has(method)) {
                    methods.add(method);
                    Object.values(category).forEach(block => {
                        contentData.push({ ...block });
                        if (block.dependencies === undefined) {
                            block.dependencies = [];
                        }
                        IDS[block.name] = { uuid: block.uuid, script: block.script, dependencies: block.dependencies };
                    });
                    createTab(method, method, contentData);
                }
            });
        }
    });


    //choose .download button
    const downloadButton = document.querySelector(".download");
    const codeBlock = document.querySelector(".codeData");

    //add event listener to download button
    downloadButton.addEventListener("click", () => {
        const code = codeBlock.innerText;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vulpiniq.js";
        a.click();
        URL.revokeObjectURL(url);
    });


}

document.addEventListener("DOMContentLoaded", createTabs);
</script>
</head>

<body>

    <div class="container">
<div class="left_side">

<div class="header">
    <h1>VulpiniQ</h1>
    <p>Build your own VulpiniQ Library</p>
    </div>

<textarea class="codeData" placeholder="Enter your code here"></textarea>

<div class="footer">
    <div class="sizedata">No code recently</div>
    <button class="btn download">Download</button>
</div>

</div>


<div class="right_side">
    <div class="tab_header">
    </div>

    <div class="tab_container">



    </div>

</div>




    </div>

    <!-- <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>

    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div> -->

</body>

</html>