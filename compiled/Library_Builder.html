<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>
    <link rel="stylesheet" href="builder.css">
<style>*{ margin: 0; padding: 0; box-sizing: border-box; /* outline: 1px solid rgba(255, 255, 255, 0.2); */}body{ font-family: 'Arial', sans-serif; background-color: #0e0e0e; color: #a3a3a3; line-height: 1.6; font-size: 12px;}::-webkit-scrollbar{ width: 8px; height: 8px;}::-webkit-scrollbar-track{ background: #2e2e2e;}::-webkit-scrollbar-thumb{ background: #555; border-radius: 4px;}::-webkit-scrollbar-thumb:hover{ background: #777;}.container{ display: flex;}.left_side{width: 50%;background-color: #0000003d;border-right: 1px solid #ffffff15;}.right_side{ flex-shrink: 0; width: 50%;padding-left:5px}.tab_header{display:flex;}.tab{padding: 5px 15px;cursor: pointer;}.tab.active{background: rgba(255, 255, 255, 0.2);color: #c4c4c4;}.tab_container{overflow-x: hidden;height: calc(100vh - 30px);padding: 0 5px;}.tags{display: flex;flex-wrap: wrap;}.tag{ padding: 0px 9px; margin: 3px; background: #333; border-radius: 5px; cursor: default;}.block{ cursor: default;padding:10px; background: #ffffff09; border-radius: 10px; /* outline: 1px solid #ffffff10; */ width: 100%;}.block.active{ background: #ffffff18;}.block_example{ padding: 8px; background: #00000033; border-radius: 12px; width: 100%; margin-top: 10px;}.code_content{ display: grid; grid-template-columns: repeat(2, 1fr); /* Create 3 equal columns */ gap: 10px; /* Add gap between grid items */}.block_dependencies{ margin-top: 10px;}.block_title{ font-size: 16px; font-weight: bold; margin-bottom: 20px;}.code_category_title{ font-size: 20px; font-weight: bold; margin: 15px 0}.code_category{margin-bottom: 40px;}.codeData{ padding: 10px; background: #00000033; border-radius: 12px; width: calc(100% - 10px); height: 200px; margin-top: 10px; color: #a3a3a3; text-align: justify; border: 1px solid #ffffff10; box-sizing: border-box; margin: 5px; resize: vertical; max-height: 400px;}.codeData:focus{ outline: none;}.footer{display:flex;}.sizedata{ margin: 0 20px; display: flex; align-items: center;}.btn{ padding: 5px 10px; background: #333; color: #a3a3a3; border: none; border-radius: 5px; cursor: pointer;}.tab_content{ display: none;}.tab_content.active{ display: block;}.bracket{ color: #e7e192;}.bracket_inner{ color: #96a8f5;}.class,.object{ color: #bb6485; font-weight: bold;}.keyword{ color: #f78c6c;}.operator{ color: #ff5370;}.method{ color: #82aaff;}.string{ color: #d8a378; font-weight: bold;}.number{ color: #f78c6c;}.comment{ color: #428f59 !important;}</style>
<script>
var DATA = {
    "frame": "const Q = (() => {\n    'use strict';\n    const _ob = Object, _ar = Array, _ma = Math, _da = Date, _re = RegExp, \n          _st = setTimeout, _un = undefined, _n = null, _nl = NodeList,\n          _el = Element, _si = setInterval, _c = console, _ct = clearTimeout,\n          _ci = clearInterval, _pr = Promise, _str = String, _nu = Number,\n          _bo = Boolean, _json = JSON, _map = Map, _set = Set, _sym = Symbol,\n          _win = window, _doc = document, _loc = location, _hist = history,\n          _ls = localStorage, _ss = sessionStorage, _f = fetch, _ev = Event,\n          _ac = AbortController, _as = AbortSignal, _err = Error;\n    let GLOBAL = {};\n    let styleData = {\n        root: '',\n        generic: \"\",\n        responsive: {},\n        element: _n,\n        init: false\n    };\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib-root-styles') || createStyleElement();\n            styleData.init = true;\n        }\n        let finalStyles = styleData.root ? `:root {${styleData.root}}\\n` : '';\n        finalStyles += styleData.generic;\n        const breakpoints = _ob.keys(styleData.responsive);\n        for (let i = 0; i < breakpoints.length; i++) {\n            const size = breakpoints[i];\n            const css = styleData.responsive[size];\n            if (css) {\n                finalStyles += `\\n@media (max-width: ${size}) {\\n${css}\\n}`;\n            }\n        }\n        styleData.element.textContent = finalStyles;\n    }\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib-root-styles';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n    window.addEventListener('load', applyStyles, { once: true });\n    function Q(identifier, attributes, props) {\n        if (!(this instanceof Q)) return new Q(identifier, attributes, props);\n        if (identifier && identifier.nodeType) { \n            this.nodes = [identifier];\n            return;\n        }\n        if (identifier instanceof Q) {\n            this.nodes = identifier.nodes;\n            return;\n        }\n        if (identifier?.constructor === _nl) {\n            this.nodes = _ar.from(identifier);\n            return;\n        }\n        if (typeof identifier === 'string') { \n            const isCreating = attributes || identifier.indexOf('<') > -1;\n            if (isCreating) {\n                const template = document.createElement('template');\n                template.innerHTML = identifier.trim();\n                this.nodes = _ar.from(template.content.childNodes);\n                if (attributes) {\n                    const attrEntries = _ob.entries(attributes);\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = attrEntries.length; j < m; j++) {\n                            const [attr, val] = attrEntries[j];\n                            if (attr === 'class') {\n                                element.classList.add(...(Array.isArray(val) ? val : val.split(/\\s+/)));\n                            } else if (attr === 'style') {\n                                if (typeof val === 'object') {\n                                    const styleEntries = _ob.entries(val);\n                                    for (let k = 0, p = styleEntries.length; k < p; k++) {\n                                        const [prop, propVal] = styleEntries[k];\n                                        element.style[prop] = propVal;\n                                    }\n                                } else {\n                                    element.style.cssText = val;\n                                }\n                            } else if (attr === 'text') {\n                                element.textContent = val;\n                            } else if (attr === 'html') {\n                                element.innerHTML = val;\n                            } else {\n                                element.setAttribute(attr, val);\n                            }\n                        }\n                    }\n                }\n                if (props) {\n                    for (let i = 0, n = this.nodes.length; i < n; i++) {\n                        const element = this.nodes[i];\n                        for (let j = 0, m = props.length; j < m; j++) {\n                            element[props[j]] = true;\n                        }\n                    }\n                }\n            } else {\n                this.nodes = _ar.from(document.querySelectorAll(identifier));\n            }\n        }\n    }\n    Q.Ext = (methodName, functionImplementation) =>\n        (Q.prototype[methodName] = functionImplementation, Q);\n    Q.getGLOBAL = key => GLOBAL[key];\n    Q.setGLOBAL = value => (GLOBAL = { ...GLOBAL, ...value });\n    Q.style = (root = '', style = '', responsive = _n, mapping = _n) => {\n        if (mapping) {\n            const keys = _ob.keys(mapping);\n            keys.forEach((key) => {\n                let newKey = Q.ID ? Q.ID(5, '_') : `_${_ma.random().toString(36).substring(2, 7)}`;\n                if (style && typeof style === 'string') {\n                    style = style.replace(new _re(`\\\\b${key}\\\\b`, 'gm'), newKey);\n                }\n                mapping[key] = mapping[key].replace(key, newKey);\n            });\n        }\n        if (root && typeof root === 'string') {\n            styleData.root += root.trim() + ';';\n        }\n        if (style && typeof style === 'string') {\n            styleData.generic += style;\n        }\n        if (responsive && typeof responsive === 'object') {\n            const breakpoints = _ob.entries(responsive);\n            for (let i = 0; i < breakpoints.length; i++) {\n                const [size, css] = breakpoints[i];\n                if (css && typeof css === 'string') {\n                    if (!styleData.responsive[size]) {\n                        styleData.responsive[size] = '';\n                    }           \n                    styleData.responsive[size] += css + '\\n';\n                }\n            }\n        }\n        if (document.readyState === 'complete') {\n            applyStyles();\n        }  \n        return mapping;\n    };\n    Q._ = {\n        ob: _ob, ar: _ar, ma: _ma, da: _da, re: _re, st: _st, un: _un,\n        n: _n, nl: _nl, el: _el, si: _si, c: _c, ct: _ct, ci: _ci,\n        pr: _pr, str: _str, nu: _nu, bo: _bo, json: _json, map: _map,\n        set: _set, sym: _sym, win: _win, doc: _doc, loc: _loc, hist: _hist,\n        ls: _ls, ss: _ss, f: _f, ev: _ev, ac: _ac, as: _as, err: _err\n    };\n    return Q;\n})();",
    "basics": {
        "Done": {
            "uuid": "30fe7815-fe98-4cec-a0d3-65a695621c64",
            "name": "Done",
            "method": "Static",
            "desc": "Registers one or more callback functions to be executed once the window has completely loaded.",
            "type": "Event Handling",
            "example": "// Basic usage - single callback\nQ.Done(() => {\n    console.log('Window has fully loaded');\n    document.body.style.opacity = '1';\n});\n\n// Multiple callbacks - executed in order\nQ.Done(() => {\n    // Initialize main application\n    initApp();\n});\n\nQ.Done(() => {\n    // Show UI elements\n    document.querySelector('#app').style.display = 'block';\n    document.querySelector('#loader').style.display = 'none';\n});",
            "dependencies": [],
            "script": "Q.Done=((c)=>{\n    window.addEventListener(\"load\",()=>{while(c.length)c.shift()();c=0});\n    return f=>c?c.push(f):f()\n})([])"
        },
        "Leaving": {
            "uuid": "2bd00036-7b2d-44fc-bb56-03ddc0a41e6e",
            "name": "Leaving",
            "method": "Static",
            "desc": "Registers callbacks to be executed when the window is about to be unloaded.",
            "type": "Event Handling",
            "example": "// Warn about unsaved changes\nQ.Leaving((event) => {\n    if (hasUnsavedChanges()) {\n        event.returnValue = 'You have unsaved changes. Are you sure you want to leave?';\n    }\n});\n\n// Save application state\nQ.Leaving((event) => {\n    localStorage.setItem('appState', JSON.stringify(getCurrentState()));\n    sessionStorage.setItem('lastVisited', new Date().toISOString());\n});",
            "dependencies": [],
            "script": "Q.Leaving=((c)=>{\n    let ev;\n    window.addEventListener(\"beforeunload\",e=>{\n      ev=e;while(c.length)c.shift()(e);c=0\n    });\n    return f=>c?c.push(f):f(ev)\n  })([])"
        },
        "Ready": {
            "uuid": "f2471c59-0dec-4264-8fa9-3486a47d2bb6",
            "name": "Ready",
            "method": "Static",
            "desc": "Registers callbacks to be executed once the DOM is fully loaded and parsed.",
            "type": "Event Handling",
            "example": "// Basic initialization\nQ.Ready(() => {\n    const app = document.querySelector('#app');\n    app.classList.remove('loading');\n});\n\n// Set up event listeners\nQ.Ready(() => {\n    document.querySelectorAll('.nav-link').forEach(link => {\n        link.addEventListener('click', handleNavigation);\n    });\n});",
            "dependencies": [],
            "script": "Q.Ready=((c)=>{\n    document.readyState==='loading'?document.addEventListener(\"DOMContentLoaded\",()=>{while(c.length)c.shift()();c=0},{once:1}):c=0;\n    return f=>c?c.push(f):f();\n  })([])"
        },
        "Resize": {
            "uuid": "071d3a3b-2986-4e4d-937c-17f1f7f87c65",
            "name": "Resize",
            "method": "Static",
            "desc": "Registers callbacks to be executed whenever the window is resized, providing the updated width and height.",
            "type": "Event Handling",
            "example": "Q.Resize((width, height) => {\n    const sidebar = document.querySelector('.sidebar');\n    sidebar.style.display = width < 768 ? 'none' : 'block';\n});\n\nQ.Resize((width, height) => {\n    const baseFontSize = Math.max(14, Math.min(18, width / 100));\n    document.documentElement.style.fontSize = `${baseFontSize}px`;\n});",
            "dependencies": [],
            "script": "Q.Resize=((c)=>{\n    addEventListener(\"resize\",()=>{\n      for(let i=0,l=c.length;i<l;) c[i++](innerWidth,innerHeight)\n    });\n    return f=>c.push(f)\n  })([])"
        }
    },
    "methods": {
        "addClass": {
            "uuid": "31ddd8e9-4819-453e-b151-6dcd70829f3f",
            "name": "addClass",
            "method": "Prototype",
            "desc": "Adds one or more classes to each node, ignoring duplicates.",
            "type": "Class Manipulation",
            "example": "Q(selector).addClass(\"class1\"); // Adds a single class\nQ(selector).addClass(\"class1 class2\"); // Adds multiple classes",
            "dependencies": [],
            "script": "Q.Ext('addClass', function (classes) {\n    var b = classes.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].classList.add.apply(nodes[i].classList, b);\n    }\n    return this;\n});"
        },
        "animate": {
            "uuid": "2fdb85cb-b377-46ce-9798-4cb3ac13bf99",
            "name": "animate",
            "method": "Prototype",
            "desc": "Animates each node using specified CSS properties over a given duration, with an optional callback when complete.",
            "type": "Animation",
            "example": "Q(selector).animate(500, { opacity: 0 }, () => { console.log('Fade out complete'); }); // Fades out over 500ms\nQ(selector).animate(1000, { left: \"100px\", top: \"50px\" }); // Moves to new position in 1 second\nQ(selector).animate(700, { opacity: 1, backgroundColor: \"#ff0000\" }, () => { alert('Animation finished!'); }); // Changes opacity and background color",
            "dependencies": [
                "each"
            ],
            "script": "Q.Ext('animate', function (duration, b, e) {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var f = nodes[i],\n        keys = Object.keys(b),\n        c = '';\n    for (var j = 0, klen = keys.length; j < klen; j++) {\n      c += keys[j] + ' ' + duration + 'ms' + (j < klen - 1 ? ', ' : '');\n    }\n    f.style.transition = c;\n    for (var j = 0; j < klen; j++) {\n      var d = keys[j];\n      f.style[d] = b[d];\n    }\n    if (typeof e === 'function') {\n      setTimeout((function(g){\n          return function(){ e.call(g); };\n      })(f), duration);\n    }\n  }\n  return this;\n});"
        },
        "append": {
            "uuid": "f21e625e-7479-4cd5-88ab-dd371d9c0d64",
            "name": "append",
            "method": "Prototype",
            "desc": "Appends child nodes, HTML, or multiple elements to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).append(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML\nQ(selector).append(document.createElement(\"div\")); // Adds a div element\nQ(selector).append(Q(otherSelector)); // Appends a Q object\nQ(selector).append([document.createElement(\"span\"), document.createElement(\"img\")]); // Appends multiple elements\nQ(selector).append(document.querySelectorAll(\".items\")); // Appends a NodeList of elements",
            "dependencies": [],
            "script": "Q.Ext('append', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const parent = nodes[i];\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const child = contents[j];\n      if (typeof child === \"string\") {\n        parent.insertAdjacentHTML('beforeend', child);\n      } else if (child?.nodeType === 1 || child instanceof Q) {\n        parent.appendChild(child.nodes ? child.nodes[0] : child);\n      } else if (Array.isArray(child) || child?.constructor === NodeList) {\n        const subNodes = Array.from(child);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          parent.appendChild(subNodes[k]);\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "attr": {
            "uuid": "1f4d439c-f002-4910-b103-e561244ac50d",
            "name": "attr",
            "method": "Prototype",
            "desc": "Gets or sets attributes on the nodes, supporting multiple attributes at once.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).attr(\"id\", \"newId\"); // Sets the \"id\" attribute to \"newId\" <br> Q(selector).attr({ \"src\": \"image.jpg\", \"alt\": \"An image\" }); // Sets multiple attributes <br> Q(selector).attr(\"href\"); // Gets the \"href\" attribute value",
            "dependencies": [],
            "script": "Q.Ext('attr', function (attribute, value) {\n    var nodes = this.nodes;\n    if (typeof attribute === 'object') {\n        var keys = Object.keys(attribute);\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            var node = nodes[i];\n            for (var j = 0, klen = keys.length; j < klen; j++) {\n                node.setAttribute(keys[j], attribute[keys[j]]);\n            }\n        }\n        return this;\n    } else {\n        if (value === undefined) {\n            return nodes[0] && nodes[0].getAttribute(attribute) || null;\n        }\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            nodes[i].setAttribute(attribute, value);\n        }\n        return this;\n    }\n});"
        },
        "bind": {
            "uuid": "6fa636c0-c2fe-4485-bca5-ed813c07ab9b",
            "name": "bind",
            "method": "Prototype",
            "desc": "Adds an event listener to each node, allowing for event delegation to improve performance.",
            "type": "Event Handling",
            "example": "Q(selector).bind(\"click\", () => console.log(\"Clicked\")); // Logs \"Clicked\" when any matching node is clicked <br> Q('.btn').bind(\"mouseover\", (e) => { console.log(`Hovered over: ${e.target.tagName}`); }); // Logs the tag name of the hovered element",
            "dependencies": [],
            "script": "Q.Ext('bind', function (event, handler) {\n    if (!this._eventDelegation) {\n        this._eventDelegation = {};\n    }\n    if (!this._eventDelegation[event]) {\n        document.addEventListener(event, (e) => {\n            var nodes = this.nodes;\n            for (var i = 0, l = nodes.length; i < l; i++) {\n                if (nodes[i].contains(e.target)) {\n                    handler.call(e.target, e);\n                }\n            }\n        });\n        this._eventDelegation[event] = true;\n    }\n    return this;\n});"
        },
        "blur": {
            "uuid": "0e2d2579-94fa-4bbc-9c9e-57333dc55aa2",
            "name": "blur",
            "method": "Prototype",
            "desc": "Removes focus from the first node in the selection, effectively blurring it.",
            "type": "Form Manipulation",
            "example": "Q(selector).blur(); // Removes focus from the first matched input field <br> Q('.active').blur(); // Blurs the first active element <br> Q('textarea').blur(); // Blurs the first textarea in the selection",
            "dependencies": [],
            "script": "Q.Ext('blur', function () {\n    var nodes = this.nodes; // ...existing code...\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].blur();\n    }\n    return this;\n});"
        },
        "click": {
            "uuid": "0034fff4-a9c6-468e-9dea-7b01f72247f9",
            "name": "click",
            "method": "Prototype",
            "desc": "Simulates a click event on each node in the selection.",
            "type": "Event Handling",
            "example": "Q(selector).click();",
            "dependencies": [],
            "script": "Q.Ext('click', function () {\n    var nodes = this.nodes;\n    for (var i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].click();\n    }\n    return this;\n});"
        },
        "clone": {
            "uuid": "3926656f-e434-4723-9a50-0bb7c7034924",
            "name": "clone",
            "method": "Prototype",
            "desc": "Creates a deep copy of the first node in the selection, including its child nodes.",
            "type": "DOM Manipulation",
            "example": "Q(selector).clone();",
            "dependencies": [],
            "script": "Q.Ext('clone', function () {\n    return new Q(this.nodes[0].cloneNode(true));\n});"
        },
        "closest": {
            "uuid": "a2f6f37c-6e2a-44d0-aaa9-0e8467449de3",
            "name": "closest",
            "method": "Prototype",
            "desc": "Finds the nearest ancestor node of the first node that matches a given selector.",
            "type": "Traversal",
            "example": "Q(selector).closest(\".parent\");",
            "dependencies": [],
            "script": "Q.Ext('closest', function (selector) {\n    let node = this.nodes[0];\n    while (node) {\n        if (node.matches && node.matches(selector)) {\n            return new Q(node);\n        }\n        node = node.parentElement;\n    }\n    return null;\n});"
        },
        "css": {
            "uuid": "849bd43e-97de-425e-baad-f5a775640fee",
            "name": "css",
            "method": "Prototype",
            "desc": "Retrieves or sets CSS styles on the selected nodes. Supports setting multiple styles if provided as an object.",
            "type": "Style Manipulation",
            "example": "Q(selector).css('color', 'red');",
            "dependencies": [],
            "script": "Q.Ext('css', function(property, value) {\n  const nodes = this.nodes;\n  if (typeof property === 'object') {\n      for (let i = 0, len = nodes.length; i < len; i++) {\n          const style = nodes[i].style;\n          for (const key in property) {\n              style[key] = property[key];\n          }\n      }\n      return this;\n  }\n  if (value === Q._.un) return getComputedStyle(nodes[0])[property];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].style[property] = value;\n  }\n  return this;\n});"
        },
        "data": {
            "uuid": "a863ce16-fcb6-4333-be6d-0fb5cba6671a",
            "name": "data",
            "method": "Prototype",
            "desc": "Retrieves or sets data-* attributes on the selected nodes. Provides an easy way to store and access custom data associated with the elements.",
            "type": "Data Manipulation",
            "example": "Q(selector).data('userId', 123);",
            "dependencies": [],
            "script": "Q.Ext('data', function (key, value) {\n    const nodes = this.nodes;\n    if (value === Q._.un) {\n        return nodes[0] && nodes[0].dataset[key] || Q._.n;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].dataset[key] = value;\n    }\n    return this;\n});"
        },
        "each": {
            "uuid": "a6210ab9-479f-46ce-ac71-a41340fd2177",
            "name": "each",
            "method": "Prototype",
            "desc": "Iterates over all nodes in the Q object and executes a callback on each node, providing access to the index and element.",
            "type": "Iteration",
            "example": "Q(selector).each((index, element) => console.log(index, element));",
            "dependencies": [],
            "script": "Q.Ext('each', function (callback) {\n    if (!this.nodes) return this;\n    const nodes = this.nodes;\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        callback.call(nodes[i], i, nodes[i]);\n    }\n    return this;\n});"
        },
        "empty": {
            "uuid": "44418e6e-ceb0-4d19-b27a-c0fe0b51deb5",
            "name": "empty",
            "method": "Prototype",
            "desc": "Empties the innerHTML of each node.",
            "type": "Content Manipulation",
            "example": "Q(selector).empty();",
            "dependencies": [],
            "script": "Q.Ext('empty', function () {\n  var nodes = this.nodes;\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].innerHTML = '';\n  }\n  return this;\n});"
        },
        "eq": {
            "uuid": "feb307cb-767d-416a-a0e7-5cfee56a2f4b",
            "name": "eq",
            "method": "Prototype",
            "desc": "Returns a specific node by index.",
            "type": "Traversal",
            "example": "Q(selector).eq(1);",
            "dependencies": [],
            "script": "Q.Ext('eq', function (index) {\n  var node = this.nodes[index];\n  return node ? new Q(node) : null;\n});"
        },
        "fadeIn": {
            "uuid": "e41e6fac-2bb0-4043-8497-573b0d87b73f",
            "name": "fadeIn",
            "method": "Prototype",
            "desc": "Fades in each node.",
            "type": "Display",
            "example": "Q(selector).fadeIn(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeIn', function(duration, callback) {\n    duration = duration || 400;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.display = '';\n            style.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            style.opacity = 1;\n            setTimeout(function() {\n                style.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeOut": {
            "uuid": "669790e8-2131-4b08-8210-c0d129aa927c",
            "name": "fadeOut",
            "method": "Prototype",
            "desc": "Fades out each node.",
            "type": "Display",
            "example": "Q(selector).fadeOut(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeOut', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.transition = 'opacity ' + duration + 'ms';\n            style.opacity = 0;\n            setTimeout(function() {\n                style.transition = '';\n                style.display = 'none';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeTo": {
            "uuid": "091269ca-7719-4f81-9977-6de05f98a483",
            "name": "fadeTo",
            "method": "Prototype",
            "desc": "Fades each node to a specific opacity.",
            "type": "Display",
            "example": "Q(selector).fadeTo(opacity, duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeTo', function(opacity, duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        (function(el) {\n            var style = el.style;\n            style.transition = 'opacity ' + duration + 'ms';\n            void el.offsetHeight;\n            style.opacity = opacity;\n            setTimeout(function() {\n                style.transition = '';\n                if (callback) callback();\n            }, duration);\n        })(nodes[i]);\n    }\n    return this;\n});"
        },
        "fadeToggle": {
            "uuid": "34931618-fdcb-4937-9861-3cd34e7b7afa",
            "name": "fadeToggle",
            "method": "Prototype",
            "desc": "Toggles the fade state of each node.",
            "type": "Display",
            "example": "Q(selector).fadeToggle(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeToggle', function(duration, callback) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var computed = window.getComputedStyle(nodes[i]);\n        if (computed.opacity === '0') {\n            this.fadeIn(duration, callback);\n        } else {\n            this.fadeOut(duration, callback);\n        }\n    }\n    return this;\n});"
        },
        "find": {
            "uuid": "cc3954b7-839a-415d-9543-f884820ddff7",
            "name": "find",
            "method": "Prototype",
            "desc": "Finds child nodes of the first node that match a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).find(\".child\");",
            "dependencies": [],
            "script": "Q.Ext('find', function(selector) {\n    var parent = this.nodes[0];\n    if (!parent) return null;\n    var found = parent.querySelectorAll(selector);\n    return found.length ? Q(found) : null;\n});"
        },
        "first": {
            "uuid": "9933c9f8-fdfd-4bb0-a6b5-3bdcaa21038e",
            "name": "first",
            "method": "Prototype",
            "desc": "Returns the first node.",
            "type": "Traversal",
            "example": "Q(selector).first();",
            "dependencies": [],
            "script": "Q.Ext('first', function () {\n    return new Q(this.nodes[0]);\n});"
        },
        "focus": {
            "uuid": "1d664f9d-3d18-478d-8170-2468e8b9e07b",
            "name": "focus",
            "method": "Prototype",
            "desc": "Focuses on the first node.",
            "type": "Form Manipulation",
            "example": "Q(selector).focus();",
            "dependencies": [],
            "script": "Q.Ext('focus', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].focus();\n    }\n    return this;\n});"
        },
        "hasClass": {
            "uuid": "c1bdaaee-df4b-4d4b-bfaf-404994de6b36",
            "name": "hasClass",
            "method": "Prototype",
            "desc": "Checks if the first node has a specific class.",
            "type": "Class Manipulation",
            "example": "Q(selector).hasClass(className);",
            "dependencies": [],
            "script": "Q.Ext('hasClass', function(className) {\n    var node = this.nodes[0];\n    return (node && node.classList.contains(className)) || false;\n});"
        },
        "height": {
            "uuid": "fbe85906-1de3-434a-83e2-9f77465b5d04",
            "name": "height",
            "method": "Prototype",
            "desc": "Gets or sets the height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).height(value);",
            "dependencies": [],
            "script": "Q.Ext('height', function (value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0].offsetHeight;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.height = value;\n    }\n    return this;\n});"
        },
        "hide": {
            "uuid": "e4e37710-a981-459f-8cd7-d81887f465b8",
            "name": "hide",
            "method": "Prototype",
            "desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).hide(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('hide', function (duration, callback) {\n    duration = duration || 0;\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        if (duration === 0) {\n            node.style.display = 'none';\n            if (callback) callback();\n        } else {\n            node.style.transition = 'opacity ' + duration + 'ms';\n            node.style.opacity = 1;\n            setTimeout((function(n) {\n                return function() {\n                    n.style.opacity = 0;\n                    n.addEventListener('transitionend', function handler() {\n                        n.style.display = 'none';\n                        n.style.transition = '';\n                        n.removeEventListener('transitionend', handler);\n                        if (callback) callback();\n                    });\n                };\n            })(node), 0);\n        }\n    }\n    return this;\n});"
        },
        "html": {
            "uuid": "b9b995ab-a53e-48ef-99f0-2720555ea084",
            "name": "html",
            "method": "Prototype",
            "desc": "Gets or sets the innerHTML of the nodes. This method allows for easy manipulation of the content inside the selected elements.",
            "type": "Content Manipulation",
            "example": "const currentHtml = Q(selector).html(); // Retrieves the innerHTML of the first selected element <br> Q(selector).html('<div>New Content</div>'); // Sets the innerHTML of each selected element to '<div>New Content</div>' <br> Q(selector).html(['<span>First</span>', '<span>Second</span>']); // Sets the innerHTML with an array of strings <br> const newNode = Q('<p>Paragraph</p>'); Q(selector).html(newNode); // Sets the innerHTML with a Q object containing a new node <br> Q(selector).html(document.createElement('div')); // Sets the innerHTML with a new HTMLElement <br> const nodeList = document.querySelectorAll('.child'); Q(selector).html(nodeList); // Sets the innerHTML with a NodeList of child elements <br> Q(selector).html([]); // Sets the innerHTML to an empty string <br> Q(selector).html(null); // Sets the innerHTML to an empty string",
            "dependencies": [],
            "script": "Q.Ext('html', function (content) {\n    var nodes = this.nodes;\n    if (content === undefined) {\n        return nodes[0] ? nodes[0].innerHTML : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n        node.innerHTML = '';\n        var appendContent = function(child) {\n            if (typeof child === 'string') {\n                node.insertAdjacentHTML('beforeend', child);\n            } else if (child instanceof Q) {\n                for (var j = 0, clen = child.nodes.length; j < clen; j++) {\n                    node.appendChild(child.nodes[j]);\n                }\n            } else if (child?.nodeType === 1 || child?.nodeType != null) {\n                node.appendChild(child);\n            } else if (Array.isArray(child) || child?.constructor === NodeList) {\n                var subs = Array.from(child);\n                for (var k = 0, slen = subs.length; k < slen; k++) {\n                    node.appendChild(subs[k]);\n                }\n            }\n        };\n        if (Array.isArray(content) || content?.constructor === NodeList) {\n            var contArr = Array.from(content);\n            for (var m = 0, mlen = contArr.length; m < mlen; m++) {\n                appendContent(contArr[m]);\n            }\n        } else {\n            appendContent(content);\n        }\n    }\n    return this;\n});"
        },
        "id": {
            "uuid": "e6daf47f-ad51-4c20-9315-7fca2f96bd40",
            "name": "id",
            "method": "Prototype",
            "desc": "Gets or sets the id attribute of the first node.",
            "type": "Attributes",
            "example": "Q(selector).id(); // Retrieves or Q(selector).id('new-id');",
            "dependencies": [],
            "script": "Q.Ext('id', function (ident) {\n    var node = this.nodes[0];\n    if (ident === undefined) return node.id;\n    node.id = ident;\n    return this;\n});"
        },
        "index": {
            "uuid": "0a952eaf-1ed5-493e-8fdb-b1ac36f181ff",
            "name": "index",
            "method": "Prototype",
            "desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
            "type": "Traversal",
            "example": "Q(selector).index(); // Retrieves the index or Q(selector).index(2);",
            "dependencies": [],
            "script": "Q.Ext('index', function (index) {\n    var first = this.nodes[0];\n    if (index === undefined) {\n        return Array.prototype.indexOf.call(first.parentNode.children, first);\n    }\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i],\n            parent = node.parentNode;\n        if (!parent) continue;\n        var children = Array.from(parent.children);\n        parent.removeChild(node);\n        if (index >= children.length) {\n            parent.appendChild(node);\n        } else {\n            parent.insertBefore(node, children[index]);\n        }\n    }\n    return this;\n});"
        },
        "inside": {
            "uuid": "488ac836-3cdd-42d3-b64a-bc0a211e900e",
            "name": "inside",
            "method": "Prototype",
            "desc": "Checks if the first node is inside another node, determined by a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).inside(\".parent\");",
            "dependencies": [],
            "script": "Q.Ext('inside', function (selector) {\n    var node = this.nodes[0];\n    return node ? node.closest(selector) !== null : false;\n});"
        },
        "is": {
            "uuid": "e6dce20a-a924-4519-ae0a-1ca60a42af7e",
            "name": "is",
            "method": "Prototype",
            "desc": "Checks if the first node matches a specific selector or condition, allowing for dynamic queries and element comparisons.",
            "type": "Utilities",
            "example": "Q(selector).is(\":visible\"); // Checks if the element is currently visible",
            "dependencies": [],
            "script": "Q.Ext('is', function (selector) {\n    var node = this.nodes[0];\n    if (!node) return false;\n    if (typeof selector === 'function') {\n        return selector.call(node, 0, node);\n    }\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return node.offsetWidth > 0 && node.offsetHeight > 0;\n            case ':hidden':\n                return node.offsetWidth === 0 || node.offsetHeight === 0;\n            case ':hover':\n                return node === document.querySelector(':hover');\n            case ':focus':\n                return node === document.activeElement;\n            case ':blur':\n                return node !== document.activeElement;\n            case ':checked':\n                return node.checked;\n            case ':selected':\n                return node.selected;\n            case ':disabled':\n                return node.disabled;\n            case ':enabled':\n                return !node.disabled;\n            default:\n                return node.matches(selector);\n        }\n    }\n    if (selector?.nodeType === 1 || selector?.nodeType != null) {\n        return node === selector;\n    }\n    if (selector instanceof Q) {\n        return node === selector.nodes[0];\n    }\n    return false;\n});"
        },
        "isExists": {
            "uuid": "403d2389-9a3f-4781-a3b3-6424802258f4",
            "name": "isExists",
            "method": "Prototype",
            "desc": "Checks if the first node exists in the DOM.",
            "type": "Utilities",
            "example": "Q(selector).isExists(); or Q.isExists('.ok')",
            "dependencies": [],
            "script": "Q.Ext('isExists', function () {\n    var node = this.nodes[0];\n    return node ? document.body.contains(node) : false;\n});\nQ.isExists = function (selector) {\n    return document.querySelector(selector) !== null;\n};"
        },
        "last": {
            "uuid": "a744b6b8-ac33-4ee4-8493-f7275dc3d701",
            "name": "last",
            "method": "Prototype",
            "desc": "Returns the last node.",
            "type": "Traversal",
            "example": "Q(selector).last();",
            "dependencies": [],
            "script": "Q.Ext('last', function () {\n    var nodes = this.nodes;\n    return new Q(nodes[nodes.length - 1]);\n});"
        },
        "map": {
            "uuid": "6308c32e-50cc-472e-ba80-279f421310a4",
            "name": "map",
            "method": "Prototype",
            "desc": "Maps each node to a new array.",
            "type": "Array",
            "example": "Q(selector).map(el => el.innerHTML);",
            "dependencies": [],
            "script": "Q.Ext('map', function (callback) {\n    var result = [],\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        result.push(callback(new Q(nodes[i])));\n    }\n    return result;\n});"
        },
        "off": {
            "uuid": "3716d361-abc7-4e41-a22f-acacfbd86dee",
            "name": "off",
            "method": "Prototype",
            "desc": "Removes an event listener from each node.",
            "type": "Event Handling",
            "example": "Q(selector).off(\"click\", handler);",
            "dependencies": [],
            "script": "Q.Ext('off', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].removeEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
        },
        "offset": {
            "uuid": "d76e3ea0-29d1-414b-a3a5-582f8e434920",
            "name": "offset",
            "method": "Prototype",
            "desc": "Returns the top and left offset of the first node relative to the document.",
            "type": "Dimensions",
            "example": "Q(selector).offset();",
            "dependencies": [],
            "script": "Q.Ext('offset', function () {\n    var node = this.nodes[0],\n        rect = node.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        left: rect.left + window.scrollX\n    };\n});"
        },
        "on": {
            "uuid": "7e3ff4d1-6217-4f20-a2e9-18fbf8a41735",
            "name": "on",
            "method": "Prototype",
            "desc": "Adds an event listener to each node.",
            "type": "Event Handling",
            "example": "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
            "dependencies": [],
            "script": "Q.Ext('on', function (events, handler, options) {\n    var defaultOptions = { capture: false, once: false, passive: false },\n        opts = Object.assign({}, defaultOptions, options),\n        eventList = events.split(' '),\n        nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        for (var j = 0, elen = eventList.length; j < elen; j++) {\n            nodes[i].addEventListener(eventList[j], handler, opts);\n        }\n    }\n    return this;\n});"
        },
        "parent": {
            "uuid": "fd4c0711-890c-4121-b943-8d59554071b5",
            "name": "parent",
            "method": "Prototype",
            "desc": "Returns the parent node of the first node.",
            "type": "Traversal",
            "example": "Q(selector).parent();",
            "dependencies": [],
            "script": "Q.Ext('parent', function () {\n    var node = this.nodes[0];\n    return new Q(node ? node.parentNode : null);\n});"
        },
        "position": {
            "uuid": "6b5d52ff-2ff0-401d-823d-0d97a727d7f4",
            "name": "position",
            "method": "Prototype",
            "desc": "Returns the top and left position of the first node relative to its offset parent.",
            "type": "Dimension/Position",
            "example": "Q(selector).position();",
            "dependencies": [],
            "script": "Q.Ext('position', function () {\n    var node = this.nodes[0];\n    return {\n        top: node.offsetTop,\n        left: node.offsetLeft\n    };\n});"
        },
        "prepend": {
            "uuid": "01d361e7-9a4d-454b-9dc8-9b79a0566f49",
            "name": "prepend",
            "method": "Prototype",
            "desc": "Prepends child nodes or HTML to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).prepend(\"<div>Prepended</div>\");",
            "dependencies": [],
            "script": "Q.Ext('prepend', function () {\n    var nodes = this.nodes,\n        contents = Array.prototype.slice.call(arguments),\n        i, j, k, parent, child, subNodes;\n    for (i = 0; i < nodes.length; i++) {\n        parent = nodes[i];\n        for (j = 0; j < contents.length; j++) {\n            child = contents[j];\n            if (typeof child === 'string') {\n                parent.insertAdjacentHTML('afterbegin', child);\n            } else if (child instanceof Q) {\n                parent.insertBefore(child.nodes[0], parent.firstChild);\n            } else if (child?.nodeType === 1 || child?.nodeType != null) {\n                parent.insertBefore(child, parent.firstChild);\n            } else if (Array.isArray(child) || child?.constructor === NodeList) {\n                subNodes = Array.from(child);\n                for (k = 0; k < subNodes.length; k++) {\n                    parent.insertBefore(subNodes[k], parent.firstChild);\n                }\n            }\n        }\n    }\n    return this;\n});"
        },
        "prop": {
            "uuid": "24d7a15c-97bf-4627-b76c-8856dd42f816",
            "name": "prop",
            "method": "Prototype",
            "desc": "Gets or sets a property on the nodes.",
            "type": "Property Manipulation",
            "example": "Q(selector).prop(property, value);",
            "dependencies": "",
            "script": "Q.Ext('prop', function (property, value) {\n    var nodes = this.nodes;\n    if (value === undefined) {\n        return nodes[0] ? nodes[0][property] : null;\n    }\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i][property] = value;\n    }\n    return this;\n});"
        },
        "remove": {
            "uuid": "08ceb849-f233-4b11-a3bd-961bd7da7e68",
            "name": "remove",
            "method": "Prototype",
            "desc": "Removes each node from the DOM.",
            "type": "DOM Manipulation",
            "example": "Q(selector).remove();",
            "dependencies": "",
            "script": "Q.Ext('remove', function() {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].remove();\n    }\n    return this;\n});"
        },
        "removeAttr": {
            "uuid": "4ddc6ec0-5812-4018-b8dc-3ad7638898fc",
            "name": "removeAttr",
            "method": "Prototype",
            "desc": "Removes an attribute from each node.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).removeAttr(attribute);",
            "dependencies": "",
            "script": "Q.Ext('removeAttr', function (attribute) {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].removeAttribute(attribute);\n    }\n    return this;\n});"
        },
        "removeClass": {
            "uuid": "3dbde363-15c9-4e29-b10e-ed406d708490",
            "name": "removeClass",
            "method": "Prototype",
            "desc": "Removes one or more classes from each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).removeClass(\"class1 class2\");",
            "dependencies": "",
            "script": "Q.Ext('removeClass', function (classes) {\n    var list = classes.split(' ');\n    for (var i = 0, len = this.nodes.length; i < len; i++) {\n        this.nodes[i].classList.remove.apply(this.nodes[i].classList, list);\n    }\n    return this;\n});"
        },
        "removeData": {
            "uuid": "5765fbd8-7ffb-491f-8191-4c522b8f3a0c",
            "name": "removeData",
            "method": "Prototype",
            "desc": "Removes a data-* attribute from each node.",
            "type": "Data Manipulation",
            "example": "Q(selector).removeData(key);",
            "dependencies": "",
            "script": "Q.Ext('removeData', function (key) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i].dataset[key];\n    }\n    return this;\n});"
        },
        "removeProp": {
            "uuid": "fc807c51-6218-41a3-844c-48972a9f0182",
            "name": "removeProp",
            "method": "Prototype",
            "desc": "Removes a property from each node.",
            "type": "Property Manipulation",
            "example": "Q(selector).removeProp(property);",
            "dependencies": "",
            "script": "Q.Ext('removeProp', function (property) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        delete this.nodes[i][property];\n    }\n    return this;\n});"
        },
        "removeTransition": {
            "uuid": "659bf47e-4d87-48cc-9546-90d8911db8dc",
            "name": "removeTransition",
            "method": "Prototype",
            "desc": "Removes the transition from each node.",
            "type": "Display",
            "example": "Q(selector).removeTransition();",
            "dependencies": "",
            "script": "Q.Ext('removeTransition', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.transition = '';\n    }\n    return this;\n});"
        },
        "scrollHeight": {
            "uuid": "5c90f85e-1230-4aa7-b8a2-83bc5576fc97",
            "name": "scrollHeight",
            "method": "Prototype",
            "desc": "Returns the scroll height of the first node.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollHeight();",
            "dependencies": "",
            "script": "Q.Ext('scrollHeight', function () {\n    var node = this.nodes[0];\n    return node.scrollHeight;\n});"
        },
        "scrollLeft": {
            "uuid": "cd288c04-f7fa-4b03-9d99-81779b62e631",
            "name": "scrollLeft",
            "method": "Prototype",
            "desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollLeft(value, increment);",
            "dependencies": "",
            "script": "Q.Ext('scrollLeft', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollLeft;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollLeft = current.scrollWidth - current.clientWidth;\n        current.scrollLeft = increment \n            ? Math.min(current.scrollLeft + value, maxScrollLeft) \n            : Math.min(value, maxScrollLeft);\n    }\n    return this;\n});"
        },
        "scrollTop": {
            "uuid": "8c5f8dcd-fbae-4e5d-9cb0-870c4de1487e",
            "name": "scrollTop",
            "method": "Prototype",
            "desc": "Gets or sets the vertical scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollTop(value, increment);",
            "dependencies": "",
            "script": "Q.Ext('scrollTop', function (value, increment) {\n    const node = this.nodes[0];\n    if (value === undefined) {\n        return node.scrollTop;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const current = this.nodes[i];\n        const maxScrollTop = current.scrollHeight - current.clientHeight;\n        current.scrollTop = increment \n            ? Math.min(current.scrollTop + value, maxScrollTop) \n            : Math.min(value, maxScrollTop);\n    }\n    return this;\n});"
        },
        "scrollWidth": {
            "uuid": "e3e5a7b9-8906-4714-b9e2-bd32fbe03b96",
            "name": "scrollWidth",
            "method": "Prototype",
            "desc": "Returns the scroll width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).scrollWidth();",
            "dependencies": "",
            "script": "Q.Ext('scrollWidth', function () {\n    var node = this.nodes[0];\n    return node.scrollWidth;\n});"
        },
        "show": {
            "uuid": "1bd10311-2e25-49d0-a0d4-079aaa4922cf",
            "name": "show",
            "method": "Prototype",
            "desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).show(duration, callback);",
            "dependencies": "",
            "script": "Q.Ext('show', function (duration = 0, callback) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const element = this.nodes[i];\n        if (duration === 0) {\n            element.style.display = '';\n            if (callback) callback();\n        } else {\n            element.style.transition = `opacity ${duration}ms`;\n            element.style.opacity = 0;\n            element.style.display = '';\n            setTimeout(() => {\n                element.style.opacity = 1;\n                element.addEventListener('transitionend', () => {\n                    element.style.transition = '';\n                    if (callback) callback();\n                }, { once: true });\n            }, 0);\n        }\n    }\n    return this;\n});"
        },
        "size": {
            "uuid": "6c70d86d-3967-401a-9434-3d0aae45237e",
            "name": "size",
            "method": "Prototype",
            "desc": "Returns the width and height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).size();",
            "dependencies": "",
            "script": "Q.Ext('size', function () {\n    const node = this.nodes[0];\n\treturn {\n\t\twidth: node.offsetWidth,\n\t\theight: node.offsetHeight\n\t};\n});"
        },
        "text": {
            "uuid": "774c2427-5b5e-4b95-b20b-0b9ec566a67f",
            "name": "text",
            "method": "Prototype",
            "desc": "Gets or sets the text content of the nodes.",
            "type": "Content Manipulation",
            "example": "Q(selector).text(string);",
            "dependencies": "",
            "script": "Q.Ext('text', function (content) {\n    if (content === undefined) {\n        return this.nodes[0]?.textContent || null;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].textContent = content;\n    }\n    return this;\n});"
        },
        "toggle": {
            "uuid": "1bac48fd-f0ab-40c3-b0c5-d10dd30e8b60",
            "name": "toggle",
            "method": "Prototype",
            "desc": "Toggles the display of each node.",
            "type": "Utilities",
            "example": "Q(selector).toggle();",
            "dependencies": "",
            "script": "Q.Ext('toggle', function () {\n    var nodes = this.nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].style.display = (nodes[i].style.display === 'none' ? '' : 'none');\n    }\n    return this;\n});"
        },
        "toggleClass": {
            "uuid": "9c87248c-d5f5-49b0-8c37-9cd94901f5fb",
            "name": "toggleClass",
            "method": "Prototype",
            "desc": "Toggles a class on each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).toggleClass(className);",
            "dependencies": "",
            "script": "Q.Ext('toggleClass', function (className) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].classList.toggle(className);\n    }\n    return this;\n});"
        },
        "trigger": {
            "uuid": "d84b7012-b8a5-4e06-aa83-1eb096d478a2",
            "name": "trigger",
            "method": "Prototype",
            "desc": "Triggers a specific event on each node.",
            "type": "Event Handling",
            "example": "Q(selector).trigger(\"click\");",
            "dependencies": [],
            "script": "Q.Ext('trigger', function (event) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].dispatchEvent(new Event(event));\n    }\n    return this;\n});"
        },
        "unwrap": {
            "uuid": "1f48dcd8-8365-40e4-a6f6-38a4ef93871f",
            "name": "unwrap",
            "method": "Prototype",
            "desc": "Removes the parent wrapper of each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).unwrap();",
            "dependencies": [],
            "script": "Q.Ext('unwrap', function () {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const el = this.nodes[i];\n        const parent = el.parentNode;\n        if (parent && parent !== document.body) {\n            parent.replaceWith(...parent.childNodes);\n        }\n    }\n    return this;\n});"
        },
        "val": {
            "uuid": "fa3c968a-2097-4719-8039-9b5a432eec52",
            "name": "val",
            "method": "Prototype",
            "desc": "Gets or sets the value of form elements in the nodes.",
            "type": "Form Manipulation",
            "example": "Q(selector).val(value);",
            "dependencies": [],
            "script": "Q.Ext('val', function(input) {\n    if (input === undefined) return this.nodes[0]?.value || null;\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].value = input;\n    }\n    return this;\n});"
        },
        "wait": {
            "uuid": "4b2980c2-d4aa-4297-b6ff-df8bf66b7b89",
            "name": "wait",
            "method": "Prototype",
            "desc": "Returns a promise that resolves after a given time. Useful for delaying actions.",
            "type": "Utility",
            "example": "Q('.text').wait(1000).text('Hello, World!');",
            "dependencies": [],
            "script": "Q.Ext('wait', function(ms) {\n\treturn new Promise(resolve => setTimeout(() => resolve(this), ms));\n});"
        },
        "walk": {
            "uuid": "b61c37ab-1a29-4013-a384-6b8087f96c34",
            "name": "walk",
            "method": "Prototype",
            "desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter.",
            "type": "Iteration",
            "example": "Q(selector).walk((node) => console.log(node), true); // Passes Q object",
            "dependencies": [],
            "script": "Q.Ext('walk', function (callback, useQObject = false) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = useQObject ? Q(this.nodes[i]) : this.nodes[i];\n        callback.call(this.nodes[i], node, i);\n    }\n    return this;\n});"
        },
        "width": {
            "uuid": "2a4f77fe-bcaa-403f-9671-20265fdd32b9",
            "name": "width",
            "method": "Prototype",
            "desc": "Gets or sets the width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).width(value);",
            "dependencies": [],
            "script": "Q.Ext('width', function (value) {\n    if (typeof value === 'undefined') {\n        return this.nodes[0] ? this.nodes[0].offsetWidth : undefined;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.width = value;\n    }\n    return this;\n});"
        },
        "wrap": {
            "uuid": "7719a0c9-bbdd-4a12-a621-fc2f5ef1a952",
            "name": "wrap",
            "method": "Prototype",
            "desc": "Wraps each node with the specified wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrap(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrap', function (wrapper) {\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        const node = this.nodes[i];\n        const parentNode = node.parentNode;\n        let newParentElement;\n        if (typeof wrapper === 'string') {\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = wrapper.trim();\n            newParentElement = tempDiv.firstElementChild.cloneNode(true);\n        } else {\n            newParentElement = wrapper;\n        }\n        parentNode.insertBefore(newParentElement, node);\n        newParentElement.appendChild(node);\n    }\n    return this;\n});"
        },
        "wrapAll": {
            "uuid": "5960398d-a08b-44b9-9010-565b9f8f17d3",
            "name": "wrapAll",
            "method": "Prototype",
            "desc": "Wraps all nodes together in a single wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrapAll(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrapAll', function (wrapper) {\n    if (!this.nodes.length) return this;\n    const parent = this.nodes[0].parentNode;\n    let newParent = typeof wrapper === 'string'\n        ? ((tempDiv => (tempDiv.innerHTML = wrapper.trim(), tempDiv.firstElementChild))\n           (document.createElement('div')))\n        : wrapper;\n    parent.insertBefore(newParent, this.nodes[0]);\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        newParent.appendChild(this.nodes[i]);\n    }\n    return this;\n});"
        },
        "zIndex": {
            "uuid": "929479b2-64cb-4b28-b130-0f60f44cb9a1",
            "name": "zIndex",
            "method": "Prototype",
            "desc": "Gets or sets the z-index of the first node.",
            "type": "Display",
            "example": "Q(selector).zIndex(value);",
            "dependencies": [],
            "script": "Q.Ext('zIndex', function (value) {\n    const node = this.nodes[0];\n    if (!node) return;\n    if (value === undefined) {\n        let Index = node.style.zIndex || window.getComputedStyle(node).zIndex;\n        return Index;\n    }\n    for (let i = 0, n = this.nodes.length; i < n; i++) {\n        this.nodes[i].style.zIndex = value;\n    }\n    return this;\n});"
        }
    },
    "plugins": {
        "Container": {
            "uuid": "b20e5e79-bc6e-4f6e-b633-07ce3735161c",
            "name": "Container",
            "method": "Plugin",
            "desc": "Useful to create containers for your elements, like tabs, accordions, etc.",
            "type": "Plugin",
            "example": "var containers = Q.Container();",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "Icons"
            ],
            "script": "Q.Container = function (options = {}) {\n    const Container = {};\n    Container.Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' container_icon');\n        return iconElement;\n    };\n    Q.Icons();\n    Container.classes = Q.style('', `\n        .container_icon {\n            width: 100%;\n            height: 100%;\n            color: #777; /* Default color */\n            pointer-events: none;\n            z-index: 1;\n        }\n    `, null, {\n        'container_icon': 'container_icon'\n    });\n    return Container;\n};"
        },
        "Container.Tab": {
            "uuid": "4c449132-b989-4a73-92df-666030fc7d7d",
            "name": "Container.Tab",
            "method": "Component",
            "desc": "Tab component for Container plugin",
            "type": "Component",
            "example": "var tabs = Q.Container.Tab([{title: 'Tab 1', value: 'tab1', content: 'Content 1'}, {title: 'Tab 2', value: 'tab2', content: 'Content 2'}]);",
            "dependencies": [
                "Container",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "find",
                "scrollTop",
                "scrollLeft",
                "html",
                "text",
                "data",
                "click"
            ],
            "script": "Q.Container.Tab = function (options = {}) {\n    const Container = Q.Container();\n    const Icon = Container.Icon;\n    const sharedClasses = Container.classes;\n    const classes = Object.assign({}, sharedClasses, Q.style('', `\n        .tab_navigation_buttons {\n            box-sizing: border-box;\n            width: 20px;\n            background-color: #333;\n            display: flex;\n            justify-content: center;\n            padding: 4px;\n        }\n        .tab_navigation_buttons_vertical {\n            width: auto;\n            height: 20px;\n        }\n        .tab_navigation_buttons:hover {\n            background-color: #555;\n        }\n        .tab_container {\n            width: 100%;\n            height: 300px;\n        }\n        .tab_container_vertical {\n            display: flex;\n        }\n        .tab_navigation_header {\n            background-color: #333;\n            display: flex;\n        }\n        .tab_navigation_header_vertical {\n            flex-direction: column;\n            width: auto;\n        }\n        .tab_navigation_tabs {\n            user-select: none;\n            display: flex;\n            flex-direction: row;\n            width: 100%;\n            overflow: hidden;\n        }\n        .tab_navigation_tabs_vertical {\n            flex-direction: column;\n        }\n        .tab_active {\n            background-color: #555;\n            color: #fff;\n        }\n        .tab {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            cursor: default;\n            padding: 5px 25px;\n        }\n        .tab_disabled {\n            background-color: #333;\n            color: #555;\n        }\n    `, null, {\n        'tab_navigation_buttons': 'tab_navigation_buttons',\n        'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n        'tab_container': 'tab_container',\n        'tab_container_vertical': 'tab_container_vertical',\n        'tab_navigation_header': 'tab_navigation_header',\n        'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n        'tab_navigation_tabs': 'tab_navigation_tabs',\n        'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n        'tab_active': 'tab_active',\n        'tab': 'tab',\n        'tab_disabled': 'tab_disabled'\n    }));\n    return function (data, horizontal = true) {\n        let wrapper = Q('<div>', { class: classes.tab_container });\n        let tabs_wrapper = Q('<div>', { class: classes.tab_navigation_header });\n        let tabs_nav_left = Q('<div>', { class: classes.tab_navigation_buttons });\n        let tabs_nav_right = Q('<div>', { class: classes.tab_navigation_buttons });\n        let tabs = Q('<div>', { class: classes.tab_navigation_tabs });\n        tabs_wrapper.append(tabs_nav_left, tabs, tabs_nav_right);\n        let content = Q('<div>');\n        wrapper.append(tabs_wrapper, content);\n        if (!horizontal) {\n            wrapper.addClass(classes.tab_container_vertical);\n            tabs.addClass(classes.tab_navigation_tabs_vertical);\n            tabs_wrapper.addClass(classes.tab_navigation_header_vertical);\n            tabs_nav_left.addClass(classes.tab_navigation_buttons_vertical);\n            tabs_nav_right.addClass(classes.tab_navigation_buttons_vertical);\n            tabs_nav_left.append(Icon('arrow-up'));\n            tabs_nav_right.append(Icon('arrow-down'));\n        }\n        else {\n            tabs_nav_left.append(Icon('arrow-left'));\n            tabs_nav_right.append(Icon('arrow-right'));\n        }\n        let data_tabs = {};\n        let data_contents = {};\n        data.forEach((item) => {\n            const tab = Q('<div>', { class: classes.tab, 'data-value': item.value }).text(item.title);\n            if (item.disabled) {\n                tab.addClass(classes.tab_disabled);\n            }\n            data_tabs[item.value] = tab;\n            data_contents[item.value] = item.content;\n            tab.on('click', function () {\n                if (item.disabled) {\n                    return;\n                }\n                let foundTabs = tabs.find('.' + classes.tab_active);\n                if (foundTabs) {\n                    foundTabs.removeClass(classes.tab_active);\n                }\n                tab.addClass(classes.tab_active);\n                content.html(data_contents[item.value]);\n            });\n            tabs.append(tab);\n        });\n        tabs_nav_left.on('click', function () {\n            if (!horizontal) {\n                tabs.scrollTop(-tabs.height(), true);\n            } else {\n                tabs.scrollLeft(-tabs.width(), true);\n            }\n        });\n        tabs_nav_right.on('click', function () {\n            if (!horizontal) {\n                tabs.scrollTop(tabs.height(), true);\n            } else {\n                tabs.scrollLeft(tabs.width(), true);\n            }\n        });\n        wrapper.select = function (value) {\n            Object.keys(data_tabs).forEach(key => {\n                if (data_tabs[key].data('value') === value) {\n                    data_tabs[key].click();\n                }\n            });\n        };\n        wrapper.disabled = function (value, state) {\n            if (data_tabs[value]) {\n                if (state) {\n                    data_tabs[value].addClass(classes.tab_disabled);\n                } else {\n                    data_tabs[value].removeClass(classes.tab_disabled);\n                }\n            }\n        };\n        return wrapper;\n    };\n};"
        },
        "Cookie": {
            "uuid": "7ddda5dc-d8ac-4c57-aa51-6e38557d841b",
            "name": "Cookie",
            "method": "Plugin",
            "desc": "Provides methods to store and retrieve data from the browser cookies.",
            "type": "Plugin",
            "example": "Q.Cookie('key', 'value to store'); Q.Cookie('key'); // returns 'value to store'",
            "dependencies": [],
            "script": "Q.Cookie = function (a, b, c = {}) {\n    const buildOptions = (options) => {\n      let optionsStr = '';\n      if (options.days) optionsStr += `expires=${new Date(Date.now() + options.days * 86400000).toUTCString()}; `;\n      if (options.path) optionsStr += `path=${options.path}; `;\n      if (options.domain) optionsStr += `domain=${options.domain}; `;\n      if (options.secure) optionsStr += 'secure; ';\n      return optionsStr;\n    };\n    if (arguments.length > 1) {\n      if (b === null || b === '') {\n        b = '';\n        c = { ...c, days: -1 };\n      }\n      return document.cookie = `${a}=${b}; ${buildOptions(c)}`;\n    }\n    const allCookies = document.cookie.split('; ');\n    for (let i = 0, len = allCookies.length; i < len; i++) {\n      const currentCookie = allCookies[i];\n      const indexEqual = currentCookie.indexOf('=');\n      if (indexEqual > -1 && currentCookie.slice(0, indexEqual).trim() === a) {\n        return currentCookie.slice(indexEqual + 1);\n      }\n    }\n    return undefined;\n  };"
        },
        "Fetch": {
            "uuid": "5772dbbc-6900-4d67-988c-374792ede58f",
            "name": "Fetch",
            "method": "Plugin",
            "desc": "Fetches data from a URL and returns it to a callback function. Supports retries, timeouts, and custom response validation.",
            "type": "Plugin",
            "example": "Q.fetch('https://api.example.com/data', (error, data) => console.log(error, data));",
            "dependencies": [],
            "script": "Q.Fetch = function (url, b, c = {}) {\n    const {\n        method = 'GET',\n        headers = {},\n        body,\n        contentType = 'application/json',\n        responseType = 'json',\n        credentials = 'same-origin',\n        retries = 3,\n        retryDelay = 1000,\n        exponentialBackoff = false,\n        timeout = 0,\n        validateResponse = (j) => j,\n        query = null,\n        e: externalSignal = null\n    } = c;\n    if (query && typeof query === 'object') {\n        const urlObject = new URL(url, location.origin);\n        Object.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value));\n        url = urlObject.toString();\n    }\n    let requestBody = body;\n    if (body && typeof body === 'object' && contentType === 'application/json' && !(body instanceof FormData)) {\n        try { requestBody = JSON.stringify(body); } catch (k) { b(new Error('Failed to serialize request body'), null); return; }\n    }\n    headers['Content-Type'] = headers['Content-Type'] || contentType;\n    const d = new AbortController();\n    const { e } = d;\n    if (externalSignal) {\n        externalSignal.addEventListener('abort', () => d.abort(), { once: true });\n    }\n    const doFetch = (f) => {\n        let h = null;\n        if (timeout) { h = setTimeout(() => d.abort(), timeout); }\n        fetch(url, { method, headers, body: requestBody, credentials, e })\n            .then(i => {\n                if (!i.ok) throw new Error(`Network i was not ok: ${i.statusText}`);\n                switch (responseType) {\n                    case 'json': return i.json();\n                    case 'text': return i.text();\n                    case 'blob': return i.blob();\n                    case 'arrayBuffer': return i.arrayBuffer();\n                    default: throw new Error('Unsupported i type');\n                }\n            })\n            .then(result => {\n                if (h) clearTimeout(h);\n                return validateResponse(result);\n            })\n            .then(validatedData => b(null, validatedData))\n            .catch(k => {\n                if (h) clearTimeout(h);\n                if (k.name === 'AbortError') {\n                    b(new Error('Fetch request was aborted'), null);\n                } else if (f < retries) {\n                    const delay = exponentialBackoff ? retryDelay * (2 ** f) : retryDelay;\n                    setTimeout(() => doFetch(f + 1), delay);\n                } else {\n                    b(k, null);\n                }\n            });\n    };\n    doFetch(0);\n    return { abort: () => d.abort() };\n};"
        },
        "Form.Button": {
            "uuid": "2c4faa04-45af-40e6-b6ce-f323b1dc3611",
            "name": "Form.Button",
            "method": "Component",
            "desc": "Button component for Form plugin",
            "type": "Component",
            "example": "var button = Q.Form.Button('Click me'); button.click(function() { alert('Clicked!'); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "text",
                "click"
            ],
            "script": "Form.prototype.Button = function(text = '') {\n    if (!Form.buttonClassesInitialized) {\n        Form.buttonClasses = Q.style('', `\n            .q_form_button {\n                user-select: none;\n                padding: 5px 10px;\n                cursor: pointer;\n            }\n            .q_form_button:hover {\n                background-color: #555;\n            }\n            .q_form_button:active {\n                background-color: #777;\n            }\n        `, null, {\n            'q_form_button': 'q_form_button'\n        });\n        Form.buttonClassesInitialized = true;\n    }\n    const button = Q(`<div class=\"${Form.classes.q_form} ${Form.buttonClasses.q_form_button}\">${text}</div>`);\n    button.click = function(callback) {\n        button.on('click', callback);\n    };\n    button.disabled = function(state) {\n        if (state) {\n            button.addClass(Form.classes.q_form_disabled);\n        } else {\n            button.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    button.setText = function(newText) {\n        button.text(newText);\n        return button;\n    };\n    button.remove = function() {\n        button.remove();\n        return button;\n    };\n    this.elements.push(button);\n    return button;\n};"
        },
        "Form.CheckBox": {
            "uuid": "4ab28c03-b776-445f-9d7c-77f2c94477d9",
            "name": "Form.CheckBox",
            "method": "Component",
            "desc": "CheckBox component for Form plugin",
            "type": "Component",
            "example": "var checkbox = Q.Form.CheckBox(true, 'Check me'); checkbox.change(function(checked) { console.log(checked); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "prop",
                "trigger",
                "text"
            ],
            "script": "Form.prototype.CheckBox = function(checked = false, text = '') {\n    if (!Form.checkBoxClassesInitialized) {\n        Form.checkBoxClasses = Q.style('', `\n            .q_form_checkbox {\n                display: flex;\n                width: fit-content;\n                align-items: center;\n            }\n            .q_form_checkbox .label:empty {\n                display: none;\n            }\n            .q_form_checkbox .label {\n                padding-left: 5px;\n                user-select: none;\n            }\n            .q_form_cb {\n                position: relative;\n                width: 20px;\n                height: 20px;\n                background-color: #555555;\n            }\n            .q_form_cb input[type=\"checkbox\"] {\n                opacity: 0;\n                top: 0;\n                left: 0;\n                padding: 0;\n                margin: 0;\n                width: 100%;\n                height: 100%;\n                position: absolute;\n            }\n            .q_form_cb input[type=\"checkbox\"]:checked+label:before {\n                content: \"\";\n                position: absolute;\n                display: block;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background-color: #1DA1F2;\n            }\n        `, null, {\n            'q_form_checkbox': 'q_form_checkbox',\n            'q_form_cb': 'q_form_cb'\n        });\n        Form.checkBoxClassesInitialized = true;\n    }\n    let ID = '_' + Q.ID();\n    const container = Q('<div class=\"' + Form.classes.q_form + ' ' + Form.checkBoxClasses.q_form_checkbox + '\">');\n    const checkbox_container = Q('<div class=\"' + Form.checkBoxClasses.q_form_cb + '\">');\n    const input = Q(`<input type=\"checkbox\" id=\"${ID}\">`);\n    const label = Q(`<label for=\"${ID}\">${text}</label>`);\n    const labeltext = Q(`<div class=\"label\">${text}</div>`);\n    if (checked) {\n        input.prop('checked', true);\n    }\n    checkbox_container.append(input, label);\n    container.append(checkbox_container, labeltext);\n    container.checked = function(state) {\n        input.prop('checked', state);\n        if (state) {\n            input.trigger('change');\n        }\n    };\n    container.change = function(callback) {\n        input.on('change', function() {\n            callback(this.checked);\n        });\n    };\n    container.disabled = function(state) {\n        input.prop('disabled', state);\n        if (state) {\n            container.addClass(Form.classes.q_form_disabled);\n        } else {\n            container.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    container.text = function(text) {\n        labeltext.text(text);\n    };\n    this.elements.push(container);\n    return container;\n};"
        },
        "Form": {
            "uuid": "b2bb0e03-e85e-4d1e-93d2-40436b6ee677",
            "name": "Form",
            "method": "Plugin",
            "desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
            "type": "Plugin",
            "example": "var containers = Q.Form()",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "hasClass",
                "text",
                "html",
                "val",
                "click",
                "closest",
                "empty",
                "show",
                "hide",
                "css",
                "attr",
                "prop",
                "remove",
                "add"
            ],
            "script": "function Form(options = {}) {\n    if (!(this instanceof Form)) {\n        return new Form(options);\n    }\n    this.elements = [];\n    this.options = options;\n    if (!Form.initialized) {\n        Form.classes = Q.style(`\n            --form-default-background-color: #fff;\n            --form-default-text-color: #000;\n            --form-default-border-color: #000;\n            --form-default-border-radius: 5px;\n        `, `\n            .form_icon {\n                width: 100%;\n                height: 100%;\n                color: #fff;\n                pointer-events: none;\n            }\n            .q_form {\n                box-sizing: border-box;\n                font-family: inherit;\n                font-size: inherit;\n                color: inherit;\n                margin: 1px;\n            }\n            .q_form_disabled {\n                opacity: 0.5;\n            }\n            .form_active {\n                background-color: #1DA1F2;\n                color: #fff;\n            }\n        `, null, {\n            'form_icon': 'form_icon',\n            'q_form': 'q_form',\n            'q_form_disabled': 'q_form_disabled',\n            'form_active': 'form_active'\n        });\n        Form.initialized = true;\n        console.log('Form core initialized');\n    }\n}\nForm.prototype.Icon = function(icon) {\n    let iconElement = Q('<div>');\n    iconElement.addClass('svg_' + icon + ' form_icon');\n    return iconElement;\n};\nQ.Form = Form;"
        },
        "Form.TextArea": {
            "uuid": "e2b8843c-abd1-4b02-8689-44401cc8dd27",
            "name": "Form.TextArea",
            "method": "Component",
            "desc": "TextArea component for Form plugin",
            "type": "Component",
            "example": "var textarea = Q.Form.TextArea('Initial content', 'Enter text...'); textarea.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Form.prototype.TextArea = function(value = '', placeholder = '') {\n    if (!Form.textAreaClassesInitialized) {\n        Form.textAreaClasses = Q.style('', `\n            .q_form_textarea {\n                width: calc(100% - 2px);\n                padding: 5px;\n                outline: none;\n                border: 0;\n            }\n            .q_form_textarea:focus {\n                outline: 1px solid #1DA1F2;\n            }\n        `, null, {\n            'q_form_textarea': 'q_form_textarea'\n        });\n        Form.textAreaClassesInitialized = true;\n    }\n    const textarea = Q(`<textarea class=\"${Form.classes.q_form} ${Form.textAreaClasses.q_form_textarea}\" placeholder=\"${placeholder}\">${value}</textarea>`);\n    textarea.placeholder = function(text) {\n        textarea.attr('placeholder', text);\n    };\n    textarea.disabled = function(state) {\n        textarea.prop('disabled', state);\n        if (state) {\n            textarea.addClass(Form.classes.q_form_disabled);\n        } else {\n            textarea.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    textarea.reset = function() {\n        textarea.val('');\n    };\n    textarea.change = function(callback) {\n        textarea.on('change', function() {\n            callback(this.value);\n        });\n    };\n    this.elements.push(textarea);\n    return textarea;\n};"
        },
        "Form.TextBox": {
            "uuid": "b02cd982-961d-41f1-b7b8-65dc8fe4f931",
            "name": "Form.TextBox",
            "method": "Component",
            "desc": "TextBox component for Form plugin",
            "type": "Component",
            "example": "var textbox = Q.Form.TextBox('text', 'Initial value', 'Enter text...'); textbox.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Form.prototype.TextBox = function(type = 'text', value = '', placeholder = '') {\n    if (!Form.textBoxClassesInitialized) {\n        Form.textBoxClasses = Q.style('', `\n            .q_form_input { \n                width: calc(100% - 2px);\n                padding: 5px;\n                outline: none;\n                border: 0;\n            }\n            .q_form_input:focus {\n                outline: 1px solid #1DA1F2;\n            }\n        `, null, {\n            'q_form_input': 'q_form_input'\n        });\n        Form.textBoxClassesInitialized = true;\n    }\n    const input = Q(`<input class=\"${Form.classes.q_form} ${Form.textBoxClasses.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n    input.placeholder = function(text) {\n        input.attr('placeholder', text);\n    };\n    input.disabled = function(state) {\n        input.prop('disabled', state);\n        if (state) {\n            input.addClass(Form.classes.q_form_disabled);\n        } else {\n            input.removeClass(Form.classes.q_form_disabled);\n        }\n    };\n    input.reset = function() {\n        input.val('');\n    };\n    input.change = function(callback) {\n        input.on('change', function() {\n            callback(this.value);\n        });\n    };\n    this.elements.push(input);\n    return input;\n};"
        },
        "Icons": {
            "uuid": "6fde6f40-b934-48b4-836a-fa26981cf732",
            "name": "Icons",
            "method": "Plugin",
            "desc": "Additional icons for the VulpiniQ library.",
            "type": "Plugin",
            "example": "Q.Icons();",
            "dependencies": [
                "style"
            ],
            "script": "Q.Icons = function () {\n  let glob = Q.getGLOBAL('icons');\n  let classes = {};\n  if (glob && glob.icons) {\n    classes = glob.icons;\n  }\n  else {\n    classes = Q.style(`:root {\n\t--icon_arrow-down: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 100.93685,31.353867 C 82.480099,48.598492 67.319803,62.707709 67.247301,62.707709 c -0.0725,0 -15.232809,-14.109215 -33.689561,-31.353842 L 3.5365448e-8,6.6845858e-7 H 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"M 31.353844,100.93685 C 14.109219,82.480099 1.6018623e-6,67.319803 1.6018623e-6,67.247301 1.6018623e-6,67.174801 14.109217,52.014492 31.353844,33.55774 L 62.70771,0 V 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"m 31.353868,33.55775 c 17.244625,18.456749 31.353842,33.617045 31.353842,33.689547 0,0.0725 -14.109215,15.232809 -31.353842,33.689563 L 1.6018623e-6,134.4946 V 67.247297 0 Z\"/></svg>');\n\t--icon_arrow-up: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 33.55775,31.353843 C 52.014499,14.109218 67.174795,6.6845858e-7 67.247297,6.6845858e-7 67.319797,6.6845858e-7 82.480106,14.109216 100.93686,31.353843 L 134.4946,62.707709 H 67.247297 3.5365448e-8 Z\"/></svg>');\n\t--icon_navigation-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2666.6667 2666.6667\"><path d=\"M 1276.6667,2434.5485 C 950.24325,2418.4963 647.60291,2257.2797 449.65648,1994.0001 360.09366,1874.8766 294.54616,1735.7649 260.06678,1591.6333 c -40.82486,-170.6571 -40.82486,-347.2761 0,-517.9332 71.52438,-298.98806 268.8554,-557.46223 540.12266,-707.48002 258.68606,-143.06006 568.06486,-175.54075 852.57376,-89.50899 276.927,83.73908 511.1437,274.85672 650.2832,530.62227 168.8614,310.40014 177.2264,688.09064 22.2995,1006.84964 -77.0037,158.4335 -189.7203,295.013 -331.3458,401.4939 -205.303,154.3568 -458.4668,231.6017 -717.3334,218.8716 z m 130.2294,-151.2014 c 229.6976,-18.6692 437.2639,-114.273 599.1754,-275.9766 47.6541,-47.593 83.7471,-91.4686 120.133,-146.0371 91.2885,-136.9067 142.8941,-286.0616 157.3086,-454.6667 3.0513,-35.6912 3.0513,-112.3088 0,-148 -9.7543,-114.0948 -35.6813,-216.2096 -79.956,-314.91095 C 2140.8657,803.99837 2044.7703,680.42081 1924.6667,585.10582 1705.8186,411.42656 1421.4281,342.88551 1146,397.43913 961.28159,434.02604 793.07082,524.16769 658.61926,658.61926 508.15954,809.07897 413.50356,1001.5246 386.76219,1211.3334 c -5.50464,43.1886 -7.16468,71.3013 -7.16468,121.3333 0,50.0321 1.66004,78.1448 7.16468,121.3333 31.40785,246.4213 158.34097,471.0271 353.9045,626.2276 118.14734,93.7625 258.15376,158.5796 405.33331,187.6524 50.7995,10.0346 91.5353,14.8142 153.3334,17.9909 18.4799,0.95 83.6306,-0.5787 107.5627,-2.5238 z m 134.7679,-630.3487 -208.3296,-208.3296 -207.9982,207.9951 -207.99834,207.9951 -54.66892,-54.6567 c -30.0679,-30.0612 -54.66892,-55.2602 -54.66892,-55.9978 0,-0.7375 93.30001,-94.6396 207.33338,-208.6711 l 207.3333,-207.3301 -206.6689,-206.6721 -206.66886,-206.67213 55.00599,-54.99402 55.006,-54.99402 206.66127,206.66447 206.6613,206.6646 207.6661,-207.6629 207.666,-207.66288 55.3378,55.32571 55.3378,55.32571 -207.6673,207.67046 -207.6673,207.6705 208.3339,208.3372 208.334,208.3371 -55.0055,54.9935 -55.0054,54.9935 z\"/></svg>');\n\t--icon_navigation-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 282.12556,619.5403 247.03663,609.52248 218.00001,595.4014 129.37889,552.30321 70.013661,466.90205 60.059145,368.19207 51.577814,284.09034 83.346262,198.0417 144.85111,138.52292 212.10881,73.437059 306.81846,45.865772 398.4674,64.691724 519.45153,89.543525 610.11296,190.57708 622.60754,314.47462 c 8.48133,84.10173 -23.28712,170.15036 -84.79196,229.66914 -59.89864,57.96444 -141.4913,86.4009 -224.85943,78.36742 z m 71.04386,-40.49085 c 101.01231,-18.37977 179.6848,-97.26565 198.14953,-198.68699 3.46591,-19.0372 3.48193,-65.25956 0.0291,-84 -18.78642,-101.96514 -96.94357,-180.11939 -198.8453,-198.83796 -18.89894,-3.471598 -65.10105,-3.471598 -84,0 C 197.45585,119.2095 119.27,197.39245 100.48802,299.33334 c -3.452807,18.74044 -3.436783,64.9628 0.0291,84 16.64224,91.4109 82.13775,165.12641 170.46427,191.85833 8.26023,2.49995 21.0186,5.49414 28.35193,6.65376 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 320.66668,412.53122 c -36.66667,-38.4534 -66.66667,-70.49248 -66.66667,-71.19795 0,-0.70547 30.15,-32.79758 67,-71.31579 l 67,-70.03311 v 141.34115 c 0,77.73764 -0.15,141.29162 -0.33333,141.23108 -0.18334,-0.0605 -30.33334,-31.57197 -67,-70.02538 z\"/></svg>');\n\t--icon_navigation-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 103.83077,602.35954 -10.876679,362.01744 104.94177,186.66667 225.81958,3.6559506 499.6699,21.151057 595.4014,218.00001 691.73222,416.0813 532.80292,643.69595 312.95615,622.51118 Z m 71.04386,-40.49085 C 527.6749,555.87785 617.23885,410.16562 575.1842,270.98141 536.24285,142.10102 399.55264,68.634561 270.98141,107.48249 119.67709,153.19925 50.784795,329.22352 130.9177,465.35432 c 35.94209,61.05887 100.57273,105.76313 168.41564,116.49111 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 294.66668,341.34179 V 199.98437 l 67,70.03311 c 36.85,38.51821 67,70.60056 67,71.2941 0,0.69354 -30.15,32.78948 -67,71.32431 l -67,70.06332 z\"/></svg>');\n\t--icon_window-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 2.8176856,98.903421 -4.0360052e-7,96.085741 22.611458,73.473146 45.222917,50.860554 22.611458,28.247962 -4.0360052e-7,5.6353711 2.8176856,2.8176851 5.6353716,-9.1835591e-7 28.247963,22.611458 50.860555,45.222916 73.473147,22.611458 96.085743,-9.1835591e-7 98.903423,2.8176851 101.72111,5.6353711 79.109651,28.247962 56.498193,50.860554 79.109651,73.473146 101.72111,96.085741 98.903423,98.903421 96.085743,101.72111 73.473147,79.109651 50.860555,56.498192 28.247963,79.109651 5.6353716,101.72111 Z\"/></svg>');\n\t--icon_window-full: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 H 50.860555 84.417403 V 50.860554 84.417401 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z\"/></svg>');\n\t--icon_window-minimize: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 0.5252846,83.893071 V 79.698469 H 50.860555 101.19582 v 4.194602 4.19461 H 50.860555 0.5252846 Z\"/></svg>');\n\t--icon_window-windowed: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 h 8.389212 8.389212 V 8.9144961 0.52528408 H 67.638978 101.19582 V 34.082131 67.638977 h -8.389207 -8.38921 v 8.389212 8.389212 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z M 92.806613,34.082131 V 8.9144961 H 67.638978 42.471343 v 4.1946059 4.194606 h 20.973029 20.973031 v 20.973029 20.973029 h 4.1946 4.19461 z\"/></svg>');\n\t--icon_zoom-in: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n\t--icon_zoom-out: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n}\n.svg_icon {-webkit-mask-size: cover;mask-size: cover;-webkit-mask-repeat: no-repeat;mask-repeat: no-repeat;-webkit-mask-position: center;mask-position: center;background-color: currentColor;}\n.svg_iconsize { width:100%;height:100%; }\n.arrow-down { mask-image: var(--icon_arrow-down);}\n.arrow-left { mask-image: var(--icon_arrow-left);}\n.arrow-right { mask-image: var(--icon_arrow-right);}\n.arrow-up { mask-image: var(--icon_arrow-up);}\n.navigation-close { mask-image: var(--icon_navigation-close);}\n.navigation-left { mask-image: var(--icon_navigation-left);}\n.navigation-right { mask-image: var(--icon_navigation-right);}\n.window-close { mask-image: var(--icon_window-close);}\n.window-full { mask-image: var(--icon_window-full);}\n.window-minimize { mask-image: var(--icon_window-minimize);}\n.window-windowed { mask-image: var(--icon_window-windowed);}\n.zoom-in { mask-image: var(--icon_zoom-in);}\n.zoom-out { mask-image: var(--icon_zoom-out);}\n`\n,{\n  \"arrow-down\": \"arrow-down\",\n  \"arrow-left\": \"arrow-left\",\n  \"arrow-right\": \"arrow-right\",\n  \"arrow-up\": \"arrow-up\",\n  \"navigation-close\": \"navigation-close\",\n  \"navigation-left\": \"navigation-left\",\n  \"navigation-right\": \"navigation-right\",\n  \"window-close\": \"window-close\",\n  \"window-full\": \"window-full\",\n  \"window-minimize\": \"window-minimize\",\n  \"window-windowed\": \"window-windowed\",\n  \"zoom-in\": \"zoom-in\",\n  \"zoom-out\": \"zoom-out\",\n  \"svg_icon\": \"svg_icon\",\n  \"svg_iconsize\": \"svg_iconsize\"\n}, true);\n  }\n  return {\n    get: function (name, additional = '') {\n      if (additional === '') {\n        additional = classes['svg_iconsize'];\n      }\n      return Q('<div>', {class: classes['svg_icon'] + ' ' + classes[name] + ' ' + additional});\n    }\n  }\n};"
        },
        "Image.Blur": {
            "uuid": "b749354c-8f2f-472f-a12d-851332fe9d37",
            "name": "Image.Blur",
            "method": "Plugin",
            "desc": "Apply standard blur to images.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Blur({ radius: 5 }); // Applies a blur with a radius of 5 <br> image.Blur({ radius: 8, quality: 2 }); // Higher quality blur with larger radius",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Blur = function(blurOptions = {}) {\n        const defaults = {\n            radius: 5,       // Blur radius\n            quality: 1       // Number of iterations for higher quality\n        };\n        const settings = Object.assign({}, defaults, blurOptions);\n        const canvas_node = this.node;\n        const ctx = canvas_node.getContext('2d');\n        const data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        const pixels = data.data;\n        const width = canvas_node.width;\n        const height = canvas_node.height;\n        const { kernel, size } = gaussianKernel(settings.radius);\n        const half = Math.floor(size / 2);\n        const iterations = Math.round(settings.quality);\n        let currentPixels = new Uint8ClampedArray(pixels);\n        for (let i = 0; i < iterations; i++) {\n            currentPixels = applyBlur(currentPixels, width, height, kernel, size, half);\n        }\n        for (let i = 0; i < pixels.length; i++) {\n            pixels[i] = currentPixels[i];\n        }\n        ctx.putImageData(data, 0, 0);\n        this.SaveHistory();\n        return this;\n    };\n    function gaussianKernel(radius) {\n        const size = 2 * radius + 1;\n        const kernel = new Float32Array(size * size);\n        const sigma = radius / 3;\n        let sum = 0;\n        const center = radius;\n        for (let y = 0; y < size; y++) {\n            for (let x = 0; x < size; x++) {\n                const dx = x - center;\n                const dy = y - center;\n                const weight = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));\n                kernel[y * size + x] = weight;\n                sum += weight;\n            }\n        }\n        for (let i = 0; i < kernel.length; i++) {\n            kernel[i] /= sum;\n        }\n        return { kernel, size };\n    }\n    function applyBlur(pixels, width, height, kernel, size, half) {\n        const output = new Uint8ClampedArray(pixels.length);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0, a = 0;\n                const dstOff = (y * width + x) * 4;\n                let weightSum = 0;\n                for (let ky = 0; ky < size; ky++) {\n                    for (let kx = 0; kx < size; kx++) {\n                        const ny = y + ky - half;\n                        const nx = x + kx - half;\n                        if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                            const srcOff = (ny * width + nx) * 4;\n                            const weight = kernel[ky * size + kx];\n                            r += pixels[srcOff] * weight;\n                            g += pixels[srcOff + 1] * weight;\n                            b += pixels[srcOff + 2] * weight;\n                            a += pixels[srcOff + 3] * weight;\n                            weightSum += weight;\n                        }\n                    }\n                }\n                if (weightSum > 0) {\n                    r /= weightSum;\n                    g /= weightSum;\n                    b /= weightSum;\n                    a /= weightSum;\n                }\n                output[dstOff] = r;\n                output[dstOff + 1] = g;\n                output[dstOff + 2] = b;\n                output[dstOff + 3] = a;\n            }\n        }\n        return output;\n    }"
        },
        "Image.Brightness": {
            "uuid": "04bed40c-b23f-4bd3-bbe3-33aef80d9f32",
            "name": "Image.Brightness",
            "method": "Plugin",
            "desc": "Adjust image brightness.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Brightness(20); // Increases brightness by 20 <br> image.Brightness(-15, { clamp: true }); // Decreases brightness with value clamping",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Brightness = function(value, brightOptions = {}) {\n        const defaultOptions = {\n            preserveAlpha: true,\n            clamp: true   // Whether to clamp values to 0-255 range\n        };\n        const finalOptions = Object.assign({}, defaultOptions, brightOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] += value;     // Red\n            pixels[i + 1] += value; // Green\n            pixels[i + 2] += value; // Blue\n            if (finalOptions.clamp) {\n                pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        return this;\n    };"
        },
        "Image.ComicEffect": {
            "uuid": "e2f02297-a376-4fc3-bdad-72ac1119c2d5",
            "name": "Image.ComicEffect",
            "method": "Plugin",
            "desc": "Apply a comic book style effect to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.ComicEffect(4); // Applies a comic effect with 4 color steps <br> image.ComicEffect(6, { edgeDetection: true, saturation: 1.4 }); // Comic effect with edge detection and enhanced saturation",
            "dependencies": "Image",
            "script": "Q.Image.prototype.ComicEffect = function(colorSteps = 4, effectOptions = {}) {\n        const defaultOptions = {\n            redSteps: colorSteps,      // Number of color steps for red channel\n            greenSteps: colorSteps,    // Number of color steps for green channel\n            blueSteps: colorSteps,     // Number of color steps for blue channel\n            edgeDetection: false,      // Whether to add edge detection\n            edgeThickness: 1,          // Edge thickness (when edge detection is enabled)\n            edgeThreshold: 20,         // Edge detection threshold\n            saturation: 1.2            // Saturation enhancement factor (1.0 = no change)\n        };\n        const finalOptions = Object.assign({}, defaultOptions, effectOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const pixels = imageData.data;\n        const redIntervalSize = 256 / finalOptions.redSteps;\n        const greenIntervalSize = 256 / finalOptions.greenSteps;\n        const blueIntervalSize = 256 / finalOptions.blueSteps;\n        for (let i = 0; i < pixels.length; i += 4) {\n            if (finalOptions.saturation !== 1.0) {\n                let r = pixels[i] / 255;\n                let g = pixels[i + 1] / 255;\n                let b = pixels[i + 2] / 255;\n                const max = Math.max(r, g, b);\n                const min = Math.min(r, g, b);\n                let h, s, l = (max + min) / 2;\n                if (max === min) {\n                    h = s = 0; // achromatic\n                } else {\n                    const d = max - min;\n                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                    switch (max) {\n                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                        case g: h = (b - r) / d + 2; break;\n                        case b: h = (r - g) / d + 4; break;\n                    }\n                    h /= 6;\n                }\n                s = Math.min(1, s * finalOptions.saturation);\n                if (s === 0) {\n                    r = g = b = l; // achromatic\n                } else {\n                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                    const p = 2 * l - q;\n                    r = hue2rgb(p, q, h + 1/3);\n                    g = hue2rgb(p, q, h);\n                    b = hue2rgb(p, q, h - 1/3);\n                }\n                pixels[i] = Math.round(r * 255);\n                pixels[i + 1] = Math.round(g * 255);\n                pixels[i + 2] = Math.round(b * 255);\n            }\n            const redIndex = Math.floor(pixels[i] / redIntervalSize);\n            const greenIndex = Math.floor(pixels[i + 1] / greenIntervalSize);\n            const blueIndex = Math.floor(pixels[i + 2] / blueIntervalSize);\n            pixels[i] = redIndex * redIntervalSize;         // Red channel\n            pixels[i + 1] = greenIndex * greenIntervalSize; // Green channel\n            pixels[i + 2] = blueIndex * blueIntervalSize;   // Blue channel\n        }\n        if (finalOptions.edgeDetection) {\n            const edgeImageData = new ImageData(\n                new Uint8ClampedArray(pixels), \n                temp.width, \n                temp.height\n            );\n            for (let y = finalOptions.edgeThickness; y < temp.height - finalOptions.edgeThickness; y++) {\n                for (let x = finalOptions.edgeThickness; x < temp.width - finalOptions.edgeThickness; x++) {\n                    const pos = (y * temp.width + x) * 4;\n                    let edgeDetected = false;\n                    const leftPos = (y * temp.width + (x - finalOptions.edgeThickness)) * 4;\n                    const rightPos = (y * temp.width + (x + finalOptions.edgeThickness)) * 4;\n                    const topPos = ((y - finalOptions.edgeThickness) * temp.width + x) * 4;\n                    const bottomPos = ((y + finalOptions.edgeThickness) * temp.width + x) * 4;\n                    const diffH = Math.abs(pixels[leftPos] - pixels[rightPos]) +\n                                 Math.abs(pixels[leftPos + 1] - pixels[rightPos + 1]) +\n                                 Math.abs(pixels[leftPos + 2] - pixels[rightPos + 2]);\n                    const diffV = Math.abs(pixels[topPos] - pixels[bottomPos]) +\n                                 Math.abs(pixels[topPos + 1] - pixels[bottomPos + 1]) +\n                                 Math.abs(pixels[topPos + 2] - pixels[bottomPos + 2]);\n                    if (diffH > finalOptions.edgeThreshold || diffV > finalOptions.edgeThreshold) {\n                        edgeImageData.data[pos] = 0;\n                        edgeImageData.data[pos + 1] = 0;\n                        edgeImageData.data[pos + 2] = 0;\n                    }\n                }\n            }\n            ctx.putImageData(edgeImageData, 0, 0);\n        } else {\n            ctx.putImageData(imageData, 0, 0);\n        }\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };\n    function hue2rgb(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1/6) return p + (q - p) * 6 * t;\n        if (t < 1/2) return q;\n        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n        return p;\n    }"
        },
        "Image.Contrast": {
            "uuid": "4bf9127c-aa65-4dca-907c-b92d5adaf655",
            "name": "Image.Contrast",
            "method": "Plugin",
            "desc": "Adjust image contrast.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Contrast(50); // Increases contrast by 50 <br> image.Contrast(-20, { preserveHue: true }); // Decreases contrast while preserving hue",
            "dependencies": "Image",
            "script": "(function() {\n    const originalImage = Q.Image;\n    Q.Image = function(options = {}) {\n        const Image = originalImage(options);\n        return Image;\n    };\n    Q.Image.prototype.Contrast = function(value, contrastOptions = {}) {\n        const defaultOptions = {\n            preserveHue: true,  \n            clamp: true        \n        };\n        const finalOptions = Object.assign({}, defaultOptions, contrastOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let factor = (259 * (value + 255)) / (255 * (259 - value));\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = factor * (pixels[i] - 128) + 128;\n            pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n            pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n            if (finalOptions.clamp) {\n                pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        return this;\n    };\n})();"
        },
        "Image.Crop": {
            "uuid": "236e27e6-a17e-4337-8b0a-c92050254c3d",
            "name": "Image.Crop",
            "method": "Plugin",
            "desc": "Crop image to specified dimensions.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Crop(10, 10, 200, 200); // Crops the image to a 200x200 area starting at (10, 10) <br> image.Crop(50, 50, 400, 300, { preserveContext: true }); // Crops while preserving context properties",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Crop = function(x, y, width, height, cropOptions = {}) {\n        const defaultOptions = {\n            preserveContext: true // Whether to preserve the drawing context properties\n        };\n        const finalOptions = Object.assign({}, defaultOptions, cropOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { width: width, height: height }).nodes[0];\n        let tempCtx = temp.getContext('2d');\n        if (finalOptions.preserveContext) {\n            const ctx = canvas_node.getContext('2d');\n            tempCtx.globalAlpha = ctx.globalAlpha;\n            tempCtx.globalCompositeOperation = ctx.globalCompositeOperation;\n        }\n        tempCtx.drawImage(canvas_node, x, y, width, height, 0, 0, width, height);\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "Image.CRT": {
            "uuid": "06de2362-ff45-4aa6-bbac-3b847d793533",
            "name": "Image.CRT",
            "method": "Plugin",
            "desc": "Apply CRT (old TV) and VHS effects to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.CRT({ noiseStrength: 10 }); // Applies CRT effect with noise strength of 10 <br> image.CRT({ scanlines: true, curvature: true, vignette: true }); // Full retro CRT screen effect",
            "dependencies": "Image",
            "script": "Q.Image.prototype.CRT = function(crtOptions = {}) {\n        const defaultOptions = {\n            noiseStrength: 10,        // Base noise strength\n            strongNoiseStrength: 100, // Stronger noise patches strength\n            strongNoiseCount: 5,      // Number of stronger noise patches\n            noiseMaxLength: 20000,    // Maximum length of noise patch\n            redShift: 3,              // Red channel shift (for chromatic aberration)\n            blueShift: 3,             // Blue channel shift (for chromatic aberration)\n            scanlineHeight: 1,        // Height of scanlines\n            scanlineMargin: 3,        // Space between scanlines\n            scanlineOpacity: 0.1,     // Opacity of scanlines\n            vignette: false,          // Apply vignette effect\n            vignetteStrength: 0.5,    // Vignette effect strength (0-1),\n            scanlineBrightness: 0.5,  // Brightness between scanlines (0-1)\n            rgbOffset: 0,             // RGB subpixel separation\n            curvature: true,          // Apply CRT screen curvature\n            curvatureAmount: 0.1,     // Amount of screen curvature (0-0.3),\n            verticalWobble: 5,        // Amplitude of vertical wobble\n            horizontalWobble: 2,      // Amplitude of horizontal wobble\n            wobbleSpeed: 10,          // Speed of wobble effect (1-50)\n            colorBleed: 0,            // Amount of color bleeding (0-5)\n            jitterChance: 0,          // Chance of frame jitter (0-100)\n        };\n        const finalOptions = Object.assign({}, defaultOptions, crtOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const data = imageData.data;\n        function clamp(value, min, max) {\n            return Math.min(Math.max(value, min), max);\n        }\n        function CRTRandomBetween(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n        const noiseStrength = finalOptions.noiseStrength;\n        for (let i = 0; i < data.length; i += 4) {\n            const noise = (Math.random() - 0.5) * noiseStrength;\n            data[i] = clamp(data[i] + noise, 0, 255);        // Red channel\n            data[i + 1] = clamp(data[i + 1] + noise, 0, 255); // Green channel\n            data[i + 2] = clamp(data[i + 2] + noise, 0, 255); // Blue channel\n        }\n        const strongNoiseStrength = finalOptions.strongNoiseStrength;\n        const strongNoiseCount = finalOptions.strongNoiseCount;\n        const noiseMaxLength = finalOptions.noiseMaxLength;\n        for (let i0 = 0; i0 < strongNoiseCount; i0++) {\n            const startPos = CRTRandomBetween(\n                CRTRandomBetween(0, data.length - noiseMaxLength), \n                data.length - noiseMaxLength\n            );\n            const endPos = startPos + CRTRandomBetween(0, noiseMaxLength);\n            for (let i = startPos; i < endPos; i += 4) {\n                if (i + 2 < data.length) {  // Ensure we're within bounds\n                    const noise = (Math.random() - 0.4) * strongNoiseStrength;\n                    data[i] = clamp(data[i] + noise, 0, 255);        // Red channel\n                    data[i + 1] = clamp(data[i + 1] + noise, 0, 255); // Green channel\n                    data[i + 2] = clamp(data[i + 2] + noise, 0, 255); // Blue channel\n                }\n            }\n        }\n        let wobbleCanvas = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let wobbleCtx = wobbleCanvas.getContext('2d', { willReadFrequently: true });\n        const tempData = new Uint8ClampedArray(data);\n        const redShift = finalOptions.redShift;\n        const blueShift = finalOptions.blueShift;\n        const rgbOffset = finalOptions.rgbOffset;\n        if (finalOptions.colorBleed > 0) {\n            const bleed = Math.floor(finalOptions.colorBleed);\n            for (let y = 0; y < temp.height; y++) {\n                for (let x = 0; x < temp.width; x++) {\n                    const currentIndex = (y * temp.width + x) * 4;\n                    if (x + bleed < temp.width) {\n                        const bleedIndex = (y * temp.width + (x + bleed)) * 4;\n                        data[bleedIndex] = Math.max(data[bleedIndex], data[currentIndex] * 0.7); // Red bleeds\n                    }\n                    if (y > bleed) {\n                        const bleedIndex = ((y - bleed) * temp.width + x) * 4 + 2;\n                        data[bleedIndex] = Math.max(data[bleedIndex], data[currentIndex + 2] * 0.7); // Blue bleeds\n                    }\n                }\n            }\n        }\n        ctx.putImageData(imageData, 0, 0);\n        wobbleCtx.drawImage(temp, 0, 0);\n        const resultCtx = canvas_node.getContext('2d', { willReadFrequently: true });\n        resultCtx.clearRect(0, 0, canvas_node.width, canvas_node.height);\n        let applyScanlines = !finalOptions.subpixelEmulation || !finalOptions.applyScanlineAfterSubpixel;\n        if (finalOptions.jitterChance > 0 && Math.random() * 100 < finalOptions.jitterChance) {\n            const jumpOffset = CRTRandomBetween(5, 20);\n            resultCtx.drawImage(wobbleCanvas, 0, jumpOffset, canvas_node.width, canvas_node.height - jumpOffset);\n            resultCtx.drawImage(wobbleCanvas, 0, 0, canvas_node.width, jumpOffset, 0, canvas_node.height - jumpOffset, canvas_node.width, jumpOffset);\n        } else {\n            const vWobbleAmp = finalOptions.verticalWobble;\n            const hWobbleAmp = finalOptions.horizontalWobble;\n            const wobbleSpeed = finalOptions.wobbleSpeed / 10;\n            const timePhase = Date.now() / 1000 * wobbleSpeed;\n            if (finalOptions.curvature) {\n                const curveAmount = finalOptions.curvatureAmount;\n                for (let y = 0; y < canvas_node.height; y++) {\n                    const ny = y / canvas_node.height * 2 - 1; // -1 to 1\n                    const vWobble = vWobbleAmp * Math.sin(y / 30 + timePhase);\n                    for (let x = 0; x < canvas_node.width; x++) {\n                        const nx = x / canvas_node.width * 2 - 1; // -1 to 1\n                        const hWobble = hWobbleAmp * Math.sin(x / 20 + timePhase * 0.7);\n                        const distSq = nx * nx + ny * ny;\n                        const distortion = 1 + distSq * curveAmount;\n                        const srcX = Math.round((nx / distortion + 1) / 2 * canvas_node.width + hWobble);\n                        const srcY = Math.round((ny / distortion + 1) / 2 * canvas_node.height + vWobble);\n                        if (srcX >= 0 && srcX < canvas_node.width && srcY >= 0 && srcY < canvas_node.height) {\n                            if (rgbOffset > 0) {\n                                const rOffset = Math.min(canvas_node.width - 1, srcX + Math.floor(rgbOffset));\n                                const gOffset = srcX;\n                                const bOffset = Math.max(0, srcX - Math.floor(rgbOffset));\n                                const rData = wobbleCtx.getImageData(rOffset, srcY, 1, 1).data;\n                                const gData = wobbleCtx.getImageData(gOffset, srcY, 1, 1).data;\n                                const bData = wobbleCtx.getImageData(bOffset, srcY, 1, 1).data;\n                                resultCtx.fillStyle = `rgb(${rData[0]}, ${gData[1]}, ${bData[2]})`;\n                                resultCtx.fillRect(x, y, 1, 1);\n                            } else {\n                                const pixelData = wobbleCtx.getImageData(srcX, srcY, 1, 1).data;\n                                resultCtx.fillStyle = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3] / 255})`;\n                                resultCtx.fillRect(x, y, 1, 1);\n                            }\n                        }\n                    }\n                }\n            } else {\n                for (let y = 0; y < canvas_node.height; y++) {\n                    const vWobble = vWobbleAmp * Math.sin(y / 30 + timePhase);\n                    for (let x = 0; x < canvas_node.width; x++) {\n                        const hWobble = hWobbleAmp * Math.sin(x / 20 + timePhase * 0.7);\n                        const srcX = Math.round(x + hWobble);\n                        const srcY = Math.round(y + vWobble);\n                        if (srcX >= 0 && srcX < canvas_node.width && srcY >= 0 && srcY < canvas_node.height) {\n                            if (rgbOffset > 0) {\n                                const rOffset = Math.min(canvas_node.width - 1, srcX + Math.floor(rgbOffset));\n                                const gOffset = srcX;\n                                const bOffset = Math.max(0, srcX - Math.floor(rgbOffset));\n                                const rData = wobbleCtx.getImageData(rOffset, srcY, 1, 1).data;\n                                const gData = wobbleCtx.getImageData(gOffset, srcY, 1, 1).data;\n                                const bData = wobbleCtx.getImageData(bOffset, srcY, 1, 1).data;\n                                resultCtx.fillStyle = `rgb(${rData[0]}, ${gData[1]}, ${bData[2]})`;\n                                resultCtx.fillRect(x, y, 1, 1);\n                            } else {\n                                const pixelData = wobbleCtx.getImageData(srcX, srcY, 1, 1).data;\n                                resultCtx.fillStyle = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3] / 255})`;\n                                resultCtx.fillRect(x, y, 1, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function drawHorizontalLines(ctx, width, height, totalHeight, margin, color, brightnessFactor) {\n            ctx.fillStyle = color;\n            for (let i = 0; i < totalHeight; i += (height + margin)) {\n                ctx.fillRect(0, i, width, height);\n                if (brightnessFactor > 0 && i + height < totalHeight) {\n                    const brightColor = `rgba(255, 255, 255, ${brightnessFactor * 0.1})`;\n                    ctx.fillStyle = brightColor;\n                    ctx.fillRect(0, i + height, width, margin);\n                    ctx.fillStyle = color; // Reset to scanline color\n                }\n            }\n        }\n        if (applyScanlines) {\n            drawHorizontalLines(\n                resultCtx, \n                canvas_node.width, \n                finalOptions.scanlineHeight, \n                canvas_node.height, \n                finalOptions.scanlineMargin, \n                `rgba(0, 0, 0, ${finalOptions.scanlineOpacity})`,\n                finalOptions.scanlineBrightness\n            );\n        }\n        if (finalOptions.subpixelEmulation && finalOptions.applyScanlineAfterSubpixel) {\n            drawHorizontalLines(\n                resultCtx, \n                canvas_node.width, \n                finalOptions.scanlineHeight, \n                canvas_node.height, \n                finalOptions.scanlineMargin, \n                `rgba(0, 0, 0, ${finalOptions.scanlineOpacity})`,\n                finalOptions.scanlineBrightness\n            );\n        }\n        if (finalOptions.vignette) {\n            const centerX = canvas_node.width / 2;\n            const centerY = canvas_node.height / 2;\n            const radius = Math.max(centerX, centerY);\n            const gradient = resultCtx.createRadialGradient(\n                centerX, centerY, radius * 0.5, \n                centerX, centerY, radius * 1.5\n            );\n            gradient.addColorStop(0, 'rgba(0,0,0,0)');\n            gradient.addColorStop(1, `rgba(0,0,0,${finalOptions.vignetteStrength})`);\n            resultCtx.fillStyle = gradient;\n            resultCtx.globalCompositeOperation = 'multiply';\n            resultCtx.fillRect(0, 0, canvas_node.width, canvas_node.height);\n            resultCtx.globalCompositeOperation = 'source-over';\n        }\n        return this;\n    };"
        },
        "Image.Emboss": {
            "uuid": "f1b32e39-6389-4d02-b145-f7e39e30f8b9",
            "name": "Image.Emboss",
            "method": "Plugin",
            "desc": "Apply embossing effect to images.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Emboss({ strength: 2 }); // Embosses the image with strength of 2 <br> image.Emboss({ direction: 'top-right', grayscale: false }); // Colored emboss from top-right",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Emboss = function(embossOptions = {}) {\n        const defaults = {\n            strength: 1,              // Effect strength\n            direction: 'top-left',    // Direction of embossing: 'top-left', 'top-right', 'bottom-left', 'bottom-right'\n            blend: true,              // Blend with original image\n            grayscale: true           // Convert to grayscale\n        };\n        const settings = Object.assign({}, defaults, embossOptions);\n        const canvas_node = this.node;\n        const ctx = canvas_node.getContext('2d');\n        const data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        const pixels = data.data;\n        const width = canvas_node.width;\n        const height = canvas_node.height;\n        const dataCopy = new Uint8ClampedArray(pixels);\n        const kernels = {\n            'top-left': [-2, -1, 0, -1, 1, 1, 0, 1, 2],\n            'top-right': [0, -1, -2, 1, 1, -1, 2, 1, 0],\n            'bottom-left': [0, 1, 2, -1, 1, 1, -2, -1, 0],\n            'bottom-right': [2, 1, 0, 1, 1, -1, 0, -1, -2]\n        };\n        const kernel = kernels[settings.direction] || kernels['top-left'];\n        const kernelSize = Math.sqrt(kernel.length);\n        const half = Math.floor(kernelSize / 2);\n        const strength = settings.strength;\n        const divisor = 1;\n        const offset = 128; // Middle gray for emboss effect\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0;\n                const dstOff = (y * width + x) * 4;\n                for (let cy = 0; cy < kernelSize; cy++) {\n                    for (let cx = 0; cx < kernelSize; cx++) {\n                        const scy = y + cy - half;\n                        const scx = x + cx - half;\n                        if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                            const srcOff = (scy * width + scx) * 4;\n                            const wt = kernel[cy * kernelSize + cx];\n                            r += dataCopy[srcOff] * wt;\n                            g += dataCopy[srcOff + 1] * wt;\n                            b += dataCopy[srcOff + 2] * wt;\n                        }\n                    }\n                }\n                r = (r / divisor) * strength + offset;\n                g = (g / divisor) * strength + offset;\n                b = (b / divisor) * strength + offset;\n                if (settings.grayscale) {\n                    const avg = (r + g + b) / 3;\n                    r = g = b = avg;\n                }\n                r = Math.min(Math.max(r, 0), 255);\n                g = Math.min(Math.max(g, 0), 255);\n                b = Math.min(Math.max(b, 0), 255);\n                if (settings.blend) {\n                    pixels[dstOff] = (pixels[dstOff] + r) / 2;\n                    pixels[dstOff + 1] = (pixels[dstOff + 1] + g) / 2;\n                    pixels[dstOff + 2] = (pixels[dstOff + 2] + b) / 2;\n                } else {\n                    pixels[dstOff] = r;\n                    pixels[dstOff + 1] = g;\n                    pixels[dstOff + 2] = b;\n                }\n            }\n        }\n        ctx.putImageData(data, 0, 0);\n        this.SaveHistory();\n        return this;\n    };"
        },
        "Image.Flip": {
            "uuid": "09f4c261-2a0d-407d-b6d2-07849720c021",
            "name": "Image.Flip",
            "method": "Plugin",
            "desc": "Flip image horizontally or vertically.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Flip('horizontal'); // Flips the image horizontally <br> image.Flip('vertical'); // Flips the image vertically <br> image.Flip('both'); // Flips the image both horizontally and vertically",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Flip = function(direction = 'horizontal', flipOptions = {}) {\n        const defaultOptions = {\n            smoothing: true,    // Whether to use smoothing\n            quality: 'high'     // Smoothing quality: 'low', 'medium', 'high'\n        };\n        const finalOptions = Object.assign({}, defaultOptions, flipOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d');\n        ctx.imageSmoothingEnabled = finalOptions.smoothing;\n        ctx.imageSmoothingQuality = finalOptions.quality;\n        if (direction === 'horizontal') {\n            ctx.translate(canvas_node.width, 0);\n            ctx.scale(-1, 1);\n        } else if (direction === 'vertical') {\n            ctx.translate(0, canvas_node.height);\n            ctx.scale(1, -1);\n        } else if (direction === 'both') {\n            ctx.translate(canvas_node.width, canvas_node.height);\n            ctx.scale(-1, -1);\n        }\n        ctx.drawImage(canvas_node, 0, 0);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "Image.GaussianBlur": {
            "uuid": "423de34b-47bd-4ad7-8217-ecadcac29c27",
            "name": "Image.GaussianBlur",
            "method": "Plugin",
            "desc": "Apply high-quality Gaussian blur to images.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.GaussianBlur(10); // Applies Gaussian blur with a radius of 10 <br> image.GaussianBlur(5, { quality: 2, sigma: 1.5 }); // Higher quality blur with custom sigma",
            "dependencies": "Image",
            "script": "Q.Image.prototype.GaussianBlur = function(radius = 5, blurOptions = {}) {\n        const defaultOptions = {\n            sigma: radius / 2.0,         // Standard deviation of the Gaussian distribution\n            iterations: 1,               // Number of iterations (higher = stronger blur)\n            preserveAlpha: true,         // Whether to preserve alpha channel\n            separableKernel: true        // Use separable kernel for better performance\n        };\n        const finalOptions = Object.assign({}, defaultOptions, blurOptions);\n        const canvas_node = this.node;\n        const ctx = canvas_node.getContext('2d', { willReadFrequently: true });\n        const imageData = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        const pixels = imageData.data;\n        const width = canvas_node.width;\n        const height = canvas_node.height;\n        const kernel = createGaussianKernel(radius, finalOptions.sigma);\n        for (let i = 0; i < finalOptions.iterations; i++) {\n            if (finalOptions.separableKernel) {\n                applySeparableGaussianBlur(pixels, width, height, kernel.kernel1D, kernel.size, finalOptions.preserveAlpha);\n            } else {\n                apply2DGaussianBlur(pixels, width, height, kernel.kernel2D, kernel.size, finalOptions.preserveAlpha);\n            }\n        }\n        ctx.putImageData(imageData, 0, 0);\n        return this;\n    };\n    function createGaussianKernel(radius, sigma) {\n        const size = Math.ceil(radius) * 2 + 1;\n        const center = Math.floor(size / 2);\n        const kernel2D = new Float32Array(size * size);\n        let sum = 0;\n        for (let y = 0; y < size; y++) {\n            for (let x = 0; x < size; x++) {\n                const distance = Math.sqrt(Math.pow(x - center, 2) + Math.pow(y - center, 2));\n                const value = Math.exp(-(distance * distance) / (2 * sigma * sigma));\n                kernel2D[y * size + x] = value;\n                sum += value;\n            }\n        }\n        for (let i = 0; i < kernel2D.length; i++) {\n            kernel2D[i] /= sum;\n        }\n        const kernel1D = new Float32Array(size);\n        sum = 0;\n        for (let i = 0; i < size; i++) {\n            const distance = Math.abs(i - center);\n            const value = Math.exp(-(distance * distance) / (2 * sigma * sigma));\n            kernel1D[i] = value;\n            sum += value;\n        }\n        for (let i = 0; i < size; i++) {\n            kernel1D[i] /= sum;\n        }\n        return { kernel1D, kernel2D, size };\n    }\n    function apply2DGaussianBlur(pixels, width, height, kernel, kernelSize, preserveAlpha) {\n        const tempPixels = new Uint8ClampedArray(pixels.length);\n        const half = Math.floor(kernelSize / 2);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0, a = 0;\n                const index = (y * width + x) * 4;\n                for (let ky = 0; ky < kernelSize; ky++) {\n                    for (let kx = 0; kx < kernelSize; kx++) {\n                        const pixelY = Math.min(height - 1, Math.max(0, y + ky - half));\n                        const pixelX = Math.min(width - 1, Math.max(0, x + kx - half));\n                        const pixelIndex = (pixelY * width + pixelX) * 4;\n                        const kernelValue = kernel[ky * kernelSize + kx];\n                        r += pixels[pixelIndex] * kernelValue;\n                        g += pixels[pixelIndex + 1] * kernelValue;\n                        b += pixels[pixelIndex + 2] * kernelValue;\n                        if (!preserveAlpha) {\n                            a += pixels[pixelIndex + 3] * kernelValue;\n                        }\n                    }\n                }\n                tempPixels[index] = r;\n                tempPixels[index + 1] = g;\n                tempPixels[index + 2] = b;\n                tempPixels[index + 3] = preserveAlpha ? pixels[index + 3] : a;\n            }\n        }\n        for (let i = 0; i < pixels.length; i++) {\n            pixels[i] = tempPixels[i];\n        }\n    }\n    function applySeparableGaussianBlur(pixels, width, height, kernel, kernelSize, preserveAlpha) {\n        const tempPixels = new Uint8ClampedArray(pixels.length);\n        const half = Math.floor(kernelSize / 2);\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0, a = 0;\n                const index = (y * width + x) * 4;\n                for (let k = 0; k < kernelSize; k++) {\n                    const pixelX = Math.min(width - 1, Math.max(0, x + k - half));\n                    const pixelIndex = (y * width + pixelX) * 4;\n                    const kernelValue = kernel[k];\n                    r += pixels[pixelIndex] * kernelValue;\n                    g += pixels[pixelIndex + 1] * kernelValue;\n                    b += pixels[pixelIndex + 2] * kernelValue;\n                    if (!preserveAlpha) {\n                        a += pixels[pixelIndex + 3] * kernelValue;\n                    }\n                }\n                tempPixels[index] = r;\n                tempPixels[index + 1] = g;\n                tempPixels[index + 2] = b;\n                tempPixels[index + 3] = preserveAlpha ? pixels[index + 3] : a;\n            }\n        }\n        for (let i = 0; i < pixels.length; i++) {\n            pixels[i] = tempPixels[i];\n        }\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0, a = 0;\n                const index = (y * width + x) * 4;\n                for (let k = 0; k < kernelSize; k++) {\n                    const pixelY = Math.min(height - 1, Math.max(0, y + k - half));\n                    const pixelIndex = (pixelY * width + x) * 4;\n                    const kernelValue = kernel[k];\n                    r += pixels[pixelIndex] * kernelValue;\n                    g += pixels[pixelIndex + 1] * kernelValue;\n                    b += pixels[pixelIndex + 2] * kernelValue;\n                    if (!preserveAlpha) {\n                        a += pixels[pixelIndex + 3] * kernelValue;\n                    }\n                }\n                tempPixels[index] = r;\n                tempPixels[index + 1] = g;\n                tempPixels[index + 2] = b;\n                tempPixels[index + 3] = preserveAlpha ? pixels[index + 3] : a;\n            }\n        }\n        for (let i = 0; i < pixels.length; i++) {\n            pixels[i] = tempPixels[i];\n        }\n    }"
        },
        "Image.Glow": {
            "uuid": "e2c34199-638e-4a92-939d-10ffe0568c2c",
            "name": "Image.Glow",
            "method": "Plugin",
            "desc": "Apply a glow effect to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Glow({ blurRadius: 15 }); // Adds a glow effect with a blur radius of 15 <br> image.Glow({ illuminanceThreshold: 180, color: '#3388ff', intensity: 1.5 }); // Blue-tinted glow effect",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Glow = function(glowOptions = {}) {\n        const defaultOptions = {\n            illuminanceThreshold: 200,  // Brightness threshold for glow (0-255)\n            blurRadius: 10,             // Radius of the glow blur\n            intensity: 1.0,             // Intensity multiplier for the glow\n            color: null                 // Optional color tint for the glow (null for original colors)\n        };\n        const finalOptions = Object.assign({}, defaultOptions, glowOptions);\n        const canvas_node = this.node;\n        let sourceCanvas = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let glowCanvas = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        sourceCanvas.getContext('2d').drawImage(canvas_node, 0, 0);\n        const glowCtx = glowCanvas.getContext('2d', { willReadFrequently: true });\n        const imageData = sourceCanvas.getContext('2d').getImageData(\n            0, 0, sourceCanvas.width, sourceCanvas.height\n        );\n        const data = imageData.data;\n        for (let i = 0; i < data.length; i += 4) {\n            const red = data[i];\n            const green = data[i + 1];\n            const blue = data[i + 2];\n            const alpha = data[i + 3];\n            const brightness = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n            if (brightness > finalOptions.illuminanceThreshold) {\n                const x = (i / 4) % sourceCanvas.width;\n                const y = Math.floor((i / 4) / sourceCanvas.width);\n                if (finalOptions.color) {\n                    let tintColor;\n                    if (typeof finalOptions.color === 'string') {\n                        const tempCanvas = document.createElement('canvas');\n                        tempCanvas.width = 1;\n                        tempCanvas.height = 1;\n                        const tempCtx = tempCanvas.getContext('2d');\n                        tempCtx.fillStyle = finalOptions.color;\n                        tempCtx.fillRect(0, 0, 1, 1);\n                        const tempData = tempCtx.getImageData(0, 0, 1, 1).data;\n                        tintColor = {\n                            r: tempData[0],\n                            g: tempData[1],\n                            b: tempData[2]\n                        };\n                    } else if (typeof finalOptions.color === 'object') {\n                        tintColor = finalOptions.color;\n                    }\n                    if (tintColor) {\n                        glowCtx.fillStyle = `rgba(${tintColor.r}, ${tintColor.g}, ${tintColor.b}, ${(alpha / 255) * finalOptions.intensity})`;\n                    }\n                } else {\n                    glowCtx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${(alpha / 255) * finalOptions.intensity})`;\n                }\n                glowCtx.fillRect(x, y, 1, 1);\n            }\n        }\n        applyBoxBlur(glowCanvas, finalOptions.blurRadius);\n        const ctx = canvas_node.getContext('2d');\n        ctx.drawImage(sourceCanvas, 0, 0);\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.drawImage(glowCanvas, 0, 0);\n        ctx.globalCompositeOperation = 'source-over';\n        return this;\n        function applyBoxBlur(canvas, radius) {\n            const context = canvas.getContext('2d', { willReadFrequently: true });\n            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n            const pixels = imageData.data;\n            const width = imageData.width;\n            const height = imageData.height;\n            const totalPixels = width * height;\n            const pixelsCopy = new Uint8ClampedArray(pixels);\n            for (let i = 0; i < totalPixels; i++) {\n                let blurValueR = 0;\n                let blurValueG = 0;\n                let blurValueB = 0;\n                let blurValueA = 0;\n                let blurCount = 0;\n                const startY = Math.max(0, Math.floor(i / width) - radius);\n                const endY = Math.min(height - 1, Math.floor(i / width) + radius);\n                const startX = Math.max(0, (i % width) - radius);\n                const endX = Math.min(width - 1, (i % width) + radius);\n                for (let y = startY; y <= endY; y++) {\n                    for (let x = startX; x <= endX; x++) {\n                        const index = (y * width + x) * 4;\n                        blurValueR += pixelsCopy[index];\n                        blurValueG += pixelsCopy[index + 1];\n                        blurValueB += pixelsCopy[index + 2];\n                        blurValueA += pixelsCopy[index + 3];\n                        blurCount++;\n                    }\n                }\n                const currentIndex = i * 4;\n                pixels[currentIndex] = blurValueR / blurCount;\n                pixels[currentIndex + 1] = blurValueG / blurCount;\n                pixels[currentIndex + 2] = blurValueB / blurCount;\n                pixels[currentIndex + 3] = blurValueA / blurCount;\n            }\n            context.putImageData(imageData, 0, 0);\n        }\n    };"
        },
        "Image.Grayscale": {
            "uuid": "e1273768-51cb-438e-9d4b-a90e4cabce23",
            "name": "Image.Grayscale",
            "method": "Plugin",
            "desc": "Convert image to grayscale.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Grayscale({ algorithm: 'luminance' }); // Converts the image to grayscale using luminance <br> image.Grayscale({ intensity: 0.7, algorithm: 'lightness' }); // Partial grayscale conversion",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Grayscale = function(grayOptions = {}) {\n        const defaultGrayOptions = {\n            algorithm: 'average', // 'average', 'luminance', 'lightness'\n            intensity: 1.0       // 0.0 to 1.0 for partial grayscale effect\n        };\n        const finalOptions = Object.assign({}, defaultGrayOptions, grayOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let r = pixels[i];\n            let g = pixels[i + 1];\n            let b = pixels[i + 2];\n            let gray;\n            switch (finalOptions.algorithm) {\n                case 'luminance':\n                    gray = 0.299 * r + 0.587 * g + 0.114 * b;\n                    break;\n                case 'lightness':\n                    gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n                    break;\n                case 'average':\n                default:\n                    gray = (r + g + b) / 3;\n                    break;\n            }\n            if (finalOptions.intensity < 1.0) {\n                pixels[i] = r * (1 - finalOptions.intensity) + gray * finalOptions.intensity;\n                pixels[i + 1] = g * (1 - finalOptions.intensity) + gray * finalOptions.intensity;\n                pixels[i + 2] = b * (1 - finalOptions.intensity) + gray * finalOptions.intensity;\n            } else {\n                pixels[i] = gray;\n                pixels[i + 1] = gray;\n                pixels[i + 2] = gray;\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        return this;\n    };"
        },
        "Image.Halftone": {
            "uuid": "c25bbced-3a83-4f34-8f5f-6d5727a8c048",
            "name": "Image.Halftone",
            "method": "Plugin",
            "desc": "Apply a halftone effect to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Halftone({ dotSize: 8 }); // Applies halftone effect with dot size of 8 <br> image.Halftone({ shape: 'hexagon', colored: false, spacing: 3 }); // Black and white hexagon pattern",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Halftone = function(halftoneOptions = {}) {\n        const defaultOptions = {\n            dotSize: 8,                  // Size of the halftone dots\n            shape: \"dot\",                // Shape of the dots: \"dot\", \"rectangle\", \"hexagon\"\n            colored: true,               // Whether to use color or black and white\n            backgroundColor: \"black\",    // Background color\n            foregroundColor: \"white\",    // Foreground color (for non-colored mode)\n            spacing: 2                   // Spacing multiplier between dots\n        };\n        const finalOptions = Object.assign({}, defaultOptions, halftoneOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let tempCtx = temp.getContext('2d', { willReadFrequently: true });\n        tempCtx.drawImage(canvas_node, 0, 0);\n        const ctx = canvas_node.getContext('2d');\n        ctx.fillStyle = finalOptions.backgroundColor;\n        ctx.fillRect(0, 0, canvas_node.width, canvas_node.height);\n        const imageData = tempCtx.getImageData(0, 0, temp.width, temp.height);\n        const pixels = imageData.data;\n        const width = temp.width;\n        const height = temp.height;\n        function drawShape(x, y, size, color, shapeType) {\n            ctx.beginPath();\n            if (shapeType === \"dot\") {\n                ctx.arc(x, y, size, 0, Math.PI * 2);\n            } else if (shapeType === \"rectangle\") {\n                ctx.rect(x - size / 2, y - size / 2, size, size);\n            } else if (shapeType === \"hexagon\") {\n                const sideLength = size / 2;\n                const angleStep = (Math.PI * 2) / 6;\n                ctx.moveTo(x + sideLength * Math.cos(0), y + sideLength * Math.sin(0));\n                for (let i = 1; i <= 6; i++) {\n                    ctx.lineTo(\n                        x + sideLength * Math.cos(angleStep * i), \n                        y + sideLength * Math.sin(angleStep * i)\n                    );\n                }\n            } else {\n                ctx.arc(x, y, size, 0, Math.PI * 2);\n            }\n            if (finalOptions.colored) {\n                ctx.fillStyle = color;\n            } else {\n                ctx.fillStyle = finalOptions.foregroundColor;\n            }\n            ctx.fill();\n        }\n        const dotSpacing = finalOptions.dotSize * finalOptions.spacing;\n        for (let y = 0; y < height; y += dotSpacing) {\n            for (let x = 0; x < width; x += dotSpacing) {\n                let r = 0, g = 0, b = 0, count = 0;\n                const sampleSize = finalOptions.dotSize;\n                for (let offsetY = 0; offsetY < sampleSize; offsetY++) {\n                    for (let offsetX = 0; offsetX < sampleSize; offsetX++) {\n                        const sampleX = x + offsetX;\n                        const sampleY = y + offsetY;\n                        if (sampleX < width && sampleY < height) {\n                            const index = (sampleY * width + sampleX) * 4;\n                            r += pixels[index];\n                            g += pixels[index + 1];\n                            b += pixels[index + 2];\n                            count++;\n                        }\n                    }\n                }\n                const avgR = Math.floor(r / count);\n                const avgG = Math.floor(g / count);\n                const avgB = Math.floor(b / count);\n                const color = finalOptions.colored ? `rgb(${avgR}, ${avgG}, ${avgB})` : \"\";\n                const brightness = (avgR + avgG + avgB) / 3;\n                const dotSizeBasedOnBrightness = finalOptions.dotSize * (1 - brightness / 255);\n                if (dotSizeBasedOnBrightness > 0) {\n                    if (x >= 0 && x < width && y >= 0 && y < height) {\n                        drawShape(x, y, dotSizeBasedOnBrightness, color, finalOptions.shape);\n                    }\n                }\n            }\n        }\n        return this;\n    };"
        },
        "Image.HDR": {
            "uuid": "5e8d0546-3f46-41fb-adc4-08a3cd321df4",
            "name": "Image.HDR",
            "method": "Plugin",
            "desc": "Apply an HDR-like effect to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.HDR({ shadowAdjust: 20 }); // Applies HDR effect with shadow adjustment <br> image.HDR({ vibrance: 0.3, clarity: 15, tonal: true }); // Enhanced HDR with vibrance and clarity",
            "dependencies": "Image",
            "script": "Q.Image.prototype.HDR = function(hdrOptions = {}) {\n        const defaultOptions = {\n            shadowAdjust: 15,        // Shadow level adjustment\n            brightnessAdjust: 10,    // Brightness adjustment\n            contrastAdjust: 1.2,     // Contrast adjustment\n            vibrance: 0.2,           // Vibrance adjustment (saturation for less saturated colors)\n            highlights: -10,         // Highlight level adjustment\n            clarity: 10,             // Clarity/local contrast enhancement\n            tonal: true              // Apply tonal balancing\n        };\n        const finalOptions = Object.assign({}, defaultOptions, hdrOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const data = imageData.data;\n        let minBrightness = 255;\n        let maxBrightness = 0;\n        let avgBrightness = 0;\n        if (finalOptions.tonal) {\n            for (let i = 0; i < data.length; i += 4) {\n                const r = data[i];\n                const g = data[i + 1];\n                const b = data[i + 2];\n                const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n                minBrightness = Math.min(minBrightness, brightness);\n                maxBrightness = Math.max(maxBrightness, brightness);\n                avgBrightness += brightness;\n            }\n            avgBrightness /= (data.length / 4);\n        }\n        for (let i = 0; i < data.length; i += 4) {\n            let r = data[i];\n            let g = data[i + 1];\n            let b = data[i + 2];\n            const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n            const shadowFactor = Math.max(0, 1 - brightness / 128);\n            r += finalOptions.shadowAdjust * shadowFactor;\n            g += finalOptions.shadowAdjust * shadowFactor;\n            b += finalOptions.shadowAdjust * shadowFactor;\n            const highlightFactor = Math.max(0, brightness / 128 - 1);\n            r += finalOptions.highlights * highlightFactor;\n            g += finalOptions.highlights * highlightFactor;\n            b += finalOptions.highlights * highlightFactor;\n            r += finalOptions.brightnessAdjust;\n            g += finalOptions.brightnessAdjust;\n            b += finalOptions.brightnessAdjust;\n            r = (r - 128) * finalOptions.contrastAdjust + 128;\n            g = (g - 128) * finalOptions.contrastAdjust + 128;\n            b = (b - 128) * finalOptions.contrastAdjust + 128;\n            if (finalOptions.vibrance !== 0) {\n                const max = Math.max(r, g, b);\n                const min = Math.min(r, g, b);\n                const lightness = (max + min) / 510; // Normalize to 0-1\n                if (max - min < 100) {  // Lower values = less saturated\n                    const satAdjust = finalOptions.vibrance * (1 - (max - min) / 100);\n                    if (max === r) {\n                        g = g - satAdjust * (g - min);\n                        b = b - satAdjust * (b - min);\n                    } else if (max === g) {\n                        r = r - satAdjust * (r - min);\n                        b = b - satAdjust * (b - min);\n                    } else {\n                        r = r - satAdjust * (r - min);\n                        g = g - satAdjust * (g - min);\n                    }\n                }\n            }\n            if (finalOptions.tonal && maxBrightness > minBrightness) {\n                const normalizedBrightness = (brightness - minBrightness) / (maxBrightness - minBrightness);\n                const tonalFactor = (normalizedBrightness < 0.5) ? \n                    2 * normalizedBrightness : 2 - 2 * normalizedBrightness;\n                const tonalAdjust = finalOptions.clarity * tonalFactor;\n                r += tonalAdjust;\n                g += tonalAdjust;\n                b += tonalAdjust;\n            }\n            data[i] = Math.min(255, Math.max(0, r));\n            data[i + 1] = Math.min(255, Math.max(0, g));\n            data[i + 2] = Math.min(255, Math.max(0, b));\n        }\n        ctx.putImageData(imageData, 0, 0);\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "Image.Hue": {
            "uuid": "cecbc22a-365b-4d30-bc88-bc34605ebbe8",
            "name": "Image.Hue",
            "method": "Plugin",
            "desc": "Adjust image hue.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Hue(45); // Adjusts the hue by 45 degrees <br> image.Hue(-60, { preserveSaturation: true }); // Shifts hue while preserving saturation",
            "dependencies": "Image, RGB2HSL, HSL2RGB",
            "script": "Q.Image.prototype.Hue = function(value, hueOptions = {}) {\n        const defaultOptions = {\n            preserveSaturation: true,  // Whether to preserve saturation during hue shift\n            preserveLightness: true    // Whether to preserve lightness during hue shift\n        };\n        const finalOptions = Object.assign({}, defaultOptions, hueOptions);\n        if (typeof Q.RGB2HSL !== 'function' || typeof Q.HSL2RGB !== 'function') {\n            console.error('Hue adjustment requires RGB2HSL and HSL2RGB utilities');\n            return this;\n        }\n        const canvas_node = this.node;\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let r = pixels[i];\n            let g = pixels[i + 1];\n            let b = pixels[i + 2];\n            let hsl = Q.RGB2HSL(r, g, b);\n            hsl[0] = (hsl[0] * 360 + value) % 360;\n            if (hsl[0] < 0) hsl[0] += 360; // Handle negative values\n            hsl[0] = hsl[0] / 360; // Convert back to 0-1 range for HSL2RGB\n            let rgb = Q.HSL2RGB(hsl[0], hsl[1], hsl[2]);\n            pixels[i] = rgb[0];\n            pixels[i + 1] = rgb[1];\n            pixels[i + 2] = rgb[2];\n        }\n        ctx.putImageData(data, 0, 0);\n        return this;\n    };"
        },
        "Image": {
            "uuid": "cc6ccd3b-68bd-47d9-8d6c-27b71c5c1e4a",
            "name": "Image",
            "method": "Plugin",
            "desc": "Useful to manipulate images.",
            "type": "Component",
            "example": "var image = Q.Image();",
            "dependencies": "RGB2HSL, HSL2RGB",
            "script": "Q.Image = function (options) {\n    const Image = {};\n    const defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        size: 'auto',\n        quality: 1,\n        historyLimit: 3,         \n        autoSaveHistory: true    \n    };\n    options = Object.assign({}, defaultOptions, options);\n    const Canvas = Q('<canvas>');\n    const canvas_node = Canvas.nodes[0];\n    const history = {\n        states: [],        \n        position: -1,      \n        isUndoRedoing: false \n    };\n    Image.canvas = Canvas;\n    Image.node = canvas_node;\n    Image.options = options;\n    const saveToHistory = function() {\n        if (history.isUndoRedoing || !options.autoSaveHistory) return;\n        const ctx = canvas_node.getContext('2d', { willReadFrequently: true });\n        const imageData = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        if (history.position < history.states.length - 1) {\n            history.states = history.states.slice(0, history.position + 1);\n        }\n        history.states.push(imageData);\n        history.position++;\n        if (history.states.length > options.historyLimit) {\n            history.states.shift();\n            history.position--;\n        }\n        console.log(`History saved: Position=${history.position}, States=${history.states.length}`);\n    };\n    Q.Image.prototype = {\n        saveToHistory: saveToHistory,\n        Load: function (src, callback) {\n            if (src instanceof HTMLCanvasElement) {\n                this.node.width = src.width;\n                this.node.height = src.height;\n                this.node.getContext('2d', { willReadFrequently: true })\n                    .drawImage(src, 0, 0);\n                this.saveToHistory();\n                if (callback) callback();\n                return this;\n            } \n            else if (src instanceof HTMLImageElement) {\n                if (src.complete && src.naturalWidth !== 0) {\n                    this.node.width = src.naturalWidth;\n                    this.node.height = src.naturalHeight;\n                    this.node.getContext('2d', { willReadFrequently: true })\n                        .drawImage(src, 0, 0);\n                    this.saveToHistory();\n                    if (callback) callback();\n                } else {\n                    src.onload = () => {\n                        this.node.width = src.naturalWidth;\n                        this.node.height = src.naturalHeight;\n                        this.node.getContext('2d', { willReadFrequently: true })\n                            .drawImage(src, 0, 0);\n                        this.saveToHistory();\n                        if (callback) callback();\n                    };\n                }\n                return this;\n            } \n            else {\n                let img = new window.Image();\n                img.crossOrigin = 'Anonymous';\n                img.src = src;\n                img.onload = () => {\n                    this.node.width = img.width;\n                    this.node.height = img.height;\n                    this.node.getContext('2d', { willReadFrequently: true })\n                        .drawImage(img, 0, 0);\n                    this.saveToHistory();\n                    if (callback) callback();\n                };\n                return this;\n            }\n        },\n        Get: function (format = this.options.format, quality = this.options.quality) {\n            if (format === 'jpeg' || format === 'webp') {\n                return this.node.toDataURL('image/' + format, quality);\n            } else {\n                return this.node.toDataURL('image/' + format);\n            }\n        },\n        Save: function (filename, saveOptions = {}) {\n            const defaultSaveOptions = {\n                format: this.options.format,\n                quality: this.options.quality,\n                backgroundColor: this.options.fill,\n                preserveTransparency: true    \n            };\n            const finalOptions = Object.assign({}, defaultSaveOptions, saveOptions);\n            let format = finalOptions.format;\n            let quality = finalOptions.quality;\n            let dataUrl;\n            if ((format === 'jpeg' || format === 'jpg') && finalOptions.preserveTransparency) {\n                let tempCanvas = document.createElement('canvas');\n                tempCanvas.width = this.node.width;\n                tempCanvas.height = this.node.height;\n                let tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });\n                tempCtx.fillStyle = finalOptions.backgroundColor;\n                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n                tempCtx.drawImage(this.node, 0, 0);\n                dataUrl = tempCanvas.toDataURL('image/' + format, quality);\n            } else {\n                dataUrl = this.node.toDataURL('image/' + format, format === 'jpeg' || format === 'webp' ? quality : undefined);\n            }\n            const byteString = atob(dataUrl.split(',')[1]);\n            const mimeType = dataUrl.split(',')[0].split(':')[1].split(';')[0];\n            const ab = new ArrayBuffer(byteString.length);\n            const ia = new Uint8Array(ab);\n            for (let i = 0; i < byteString.length; i++) {\n                ia[i] = byteString.charCodeAt(i);\n            }\n            const blob = new Blob([ab], { type: mimeType });\n            if (window.navigator && window.navigator.msSaveOrOpenBlob) {\n                window.navigator.msSaveOrOpenBlob(blob, filename);\n            } else {\n                const link = document.createElement('a');\n                link.href = URL.createObjectURL(blob);\n                link.download = filename;\n                link.style.display = 'none';\n                document.body.appendChild(link);\n                link.click();\n                setTimeout(() => {\n                    document.body.removeChild(link);\n                    URL.revokeObjectURL(link.href);\n                }, 100);\n            }\n            return this;\n        },\n        Clear: function (fill = this.options.fill) {\n            let ctx = this.node.getContext('2d', { willReadFrequently: true });\n            ctx.fillStyle = fill;\n            ctx.fillRect(0, 0, this.node.width, this.node.height);\n            this.saveToHistory();\n            return this;\n        },\n        Render: function(target) {\n            if (!target) {\n                console.error('No target provided for rendering');\n                return this;\n            }\n            let targetElement;\n            if (typeof target === 'string') {\n                targetElement = document.getElementById(target) || document.querySelector(target);\n                if (!targetElement) {\n                    const qElement = Q(target);\n                    if (qElement && qElement.nodes && qElement.nodes.length) {\n                        targetElement = qElement.nodes[0];\n                    }\n                }\n            } else if (target.nodes && target.nodes.length) {\n                targetElement = target.nodes[0];\n            } else if (target.appendChild) {\n                targetElement = target;\n            }\n            if (!targetElement) {\n                console.error('Invalid render target');\n                return this;\n            }\n            let renderCanvas;\n            const targetTag = targetElement.tagName.toLowerCase();\n            if (targetTag === 'canvas') {\n                renderCanvas = targetElement;\n            } else if (targetTag === 'img') {\n                this.node.toBlob((blob) => {\n                    const objectUrl = URL.createObjectURL(blob);\n                    targetElement.src = objectUrl;\n                    targetElement.onload = function() {\n                        URL.revokeObjectURL(objectUrl);\n                    };\n                }, 'image/' + this.options.format, this.options.quality);\n                return this;\n            } else {\n                renderCanvas = targetElement.querySelector('canvas.q-image-render');\n                if (!renderCanvas) {\n                    renderCanvas = document.createElement('canvas');\n                    renderCanvas.className = 'q-image-render';\n                    targetElement.appendChild(renderCanvas);\n                }\n            }\n            renderCanvas.width = this.node.width;\n            renderCanvas.height = this.node.height;\n            const renderCtx = renderCanvas.getContext('2d', { willReadFrequently: true });\n            renderCtx.clearRect(0, 0, renderCanvas.width, renderCanvas.height);\n            renderCtx.drawImage(this.node, 0, 0);\n            return this;\n        },\n        History: function(offset = -1) {\n            if (history.states.length === 0) {\n                console.log(\"No history available\");\n                return this;\n            }\n            if (offset === 0) return this;\n            let targetPosition = history.position + offset;\n            if (targetPosition < 0) targetPosition = 0;\n            if (targetPosition >= history.states.length) targetPosition = history.states.length - 1;\n            if (targetPosition === history.position) {\n                console.log(`Already at position ${targetPosition}`);\n                return this;\n            }\n            console.log(`History navigation: ${history.position} -> ${targetPosition}`);\n            history.isUndoRedoing = true;\n            const ctx = this.node.getContext('2d', { willReadFrequently: true });\n            const state = history.states[targetPosition];\n            if (this.node.width !== state.width || this.node.height !== state.height) {\n                this.node.width = state.width;\n                this.node.height = state.height;\n            }\n            ctx.putImageData(state, 0, 0);\n            history.position = targetPosition;\n            history.isUndoRedoing = false;\n            return this;\n        },\n        Undo: function() {\n            return this.History(-1);\n        },\n        Redo: function() {\n            return this.History(1);\n        },\n        AutoHistory: function(enable = true) {\n            this.options.autoSaveHistory = enable;\n            return this;\n        },\n        SaveHistory: function() {\n            this.saveToHistory();\n            return this;\n        },\n        ClearHistory: function() {\n            history.states = [];\n            history.position = -1;\n            return this;\n        }\n    };\n    Object.setPrototypeOf(Image, Q.Image.prototype);\n    const originalCtxPutImageData = CanvasRenderingContext2D.prototype.putImageData;\n    const originalCtxDrawImage = CanvasRenderingContext2D.prototype.drawImage;\n    CanvasRenderingContext2D.prototype.putImageData = function() {\n        const result = originalCtxPutImageData.apply(this, arguments);\n        if (this.canvas === canvas_node && options.autoSaveHistory && !history.isUndoRedoing) {\n            saveToHistory();\n        }\n        return result;\n    };\n    CanvasRenderingContext2D.prototype.drawImage = function() {\n        const result = originalCtxDrawImage.apply(this, arguments);\n        if (this.canvas === canvas_node && options.autoSaveHistory && !history.isUndoRedoing) {\n            saveToHistory();\n        }\n        return result;\n    };\n    return Image;\n};"
        },
        "Image.LensFlareAnamorphic": {
            "uuid": "c26b5b18-697d-4c58-b715-873da88d3c85",
            "name": "Image.LensFlareAnamorphic",
            "method": "Plugin",
            "desc": "Apply horizontal anamorphic lens flare effect to bright spots in an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.LensFlareAnamorphic({ brightnessThreshold: 200 }); // Adds anamorphic lens flare <br> image.LensFlareAnamorphic({ widthModifier: 1.5, flareColor: [255, 200, 150] }); // Custom colored flare",
            "dependencies": "Image",
            "script": "Q.Image.prototype.LensFlareAnamorphic = function(flareOptions = {}) {\n        const defaultOptions = {\n            brightnessThreshold: 200,  // Minimum brightness to consider as a flare source\n            widthModifier: 1.0,        // Size multiplier for the flare width\n            heightThreshold: 10,       // Height of the flare\n            maxFlares: 20,             // Maximum number of flares to render\n            opacity: 0.2,              // Opacity reduction factor (subtracted from brightness)\n            flareColor: null           // Optional fixed color for flares [r, g, b]\n        };\n        const finalOptions = Object.assign({}, defaultOptions, flareOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const sourceData = ctx.getImageData(0, 0, temp.width, temp.height).data;\n        let flareColor = finalOptions.flareColor;\n        if (!flareColor) {\n            const avgColor = { r: 0, g: 0, b: 0, count: 0 };\n            for (let y = 0; y < temp.height; y++) {\n                for (let x = 0; x < temp.width; x++) {\n                    const index = (y * temp.width + x) * 4;\n                    const brightness = (sourceData[index] + sourceData[index + 1] + sourceData[index + 2]) / 3;\n                    if (brightness >= finalOptions.brightnessThreshold) {\n                        avgColor.r += sourceData[index];\n                        avgColor.g += sourceData[index + 1];\n                        avgColor.b += sourceData[index + 2];\n                        avgColor.count++;\n                    }\n                }\n            }\n            if (avgColor.count > 0) {\n                flareColor = [\n                    Math.round(avgColor.r / avgColor.count),\n                    Math.round(avgColor.g / avgColor.count),\n                    Math.round(avgColor.b / avgColor.count)\n                ];\n            } else {\n                flareColor = [255, 255, 255]; // Default to white if no bright spots\n            }\n        }\n        const flareColorR = flareColor[0];\n        const flareColorG = flareColor[1];\n        const flareColorB = flareColor[2];\n        const flares = [];\n        for (let y = 0; y < temp.height; y++) {\n            for (let x = 0; x < temp.width; x++) {\n                const index = (y * temp.width + x) * 4;\n                const brightness = (sourceData[index] + sourceData[index + 1] + sourceData[index + 2]) / 3;\n                if (brightness >= finalOptions.brightnessThreshold) {\n                    flares.push({ x, y, brightness });\n                }\n            }\n        }\n        flares.sort((a, b) => b.brightness - a.brightness);\n        const targetCtx = canvas_node.getContext('2d');\n        for (let i = 0; i < Math.min(finalOptions.maxFlares, flares.length); i++) {\n            const flare = flares[i];\n            const size = flare.brightness / finalOptions.brightnessThreshold * (100 * finalOptions.widthModifier);\n            const height = finalOptions.heightThreshold;\n            const gradient = targetCtx.createLinearGradient(\n                flare.x - size / 2, flare.y, \n                flare.x + size / 2, flare.y\n            );\n            gradient.addColorStop(0, `rgba(${flareColorR}, ${flareColorG}, ${flareColorB}, 0)`);\n            gradient.addColorStop(0.5, `rgba(${flareColorR}, ${flareColorG}, ${flareColorB}, ${(flare.brightness / 255) - finalOptions.opacity})`);\n            gradient.addColorStop(1, `rgba(${flareColorR}, ${flareColorG}, ${flareColorB}, 0)`);\n            targetCtx.globalCompositeOperation = \"overlay\";\n            targetCtx.beginPath();\n            targetCtx.fillStyle = gradient;\n            targetCtx.fillRect(flare.x - size / 2, flare.y - height / 2, size, height);\n        }\n        targetCtx.globalCompositeOperation = \"source-over\";\n        return this;\n    };"
        },
        "Image.Noise": {
            "uuid": "af2a4eb0-fb0e-498b-9e06-30b33780a975",
            "name": "Image.Noise",
            "method": "Plugin",
            "desc": "Apply random noise to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Noise({ threshold: 30 }); // Adds random noise with a threshold of 30 <br> image.Noise({ threshold: 50, isBlackAndWhite: true, mode: 'mix' }); // Black and white mixed noise",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Noise = function(noiseOptions = {}) {\n        const defaultOptions = {\n            threshold: 30,          // Maximum noise intensity\n            isBlackAndWhite: false, // Whether to apply the same noise to all color channels\n            mode: 'add',            // Mode: 'add', 'subtract', or 'mix'\n            intensity: 1.0,         // Overall noise intensity multiplier (0-1)\n            seed: Math.random()     // Random seed for noise generation\n        };\n        const finalOptions = Object.assign({}, defaultOptions, noiseOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const pixels = imageData.data;\n        function getRandomNoise(threshold) {\n            const adjustedThreshold = threshold * finalOptions.intensity;\n            switch(finalOptions.mode) {\n                case 'subtract':\n                    return -Math.floor(Math.random() * (adjustedThreshold + 1));\n                case 'mix':\n                    return Math.floor(Math.random() * (adjustedThreshold * 2 + 1)) - adjustedThreshold;\n                case 'add':\n                default:\n                    return Math.floor(Math.random() * (adjustedThreshold + 1));\n            }\n        }\n        for (let i = 0; i < pixels.length; i += 4) {\n            let red = pixels[i];\n            let green = pixels[i + 1];\n            let blue = pixels[i + 2];\n            if (finalOptions.isBlackAndWhite) {\n                const noise = getRandomNoise(finalOptions.threshold);\n                red = Math.min(255, Math.max(0, red + noise));\n                green = Math.min(255, Math.max(0, green + noise));\n                blue = Math.min(255, Math.max(0, blue + noise));\n            } else {\n                const noiseRed = getRandomNoise(finalOptions.threshold);\n                const noiseGreen = getRandomNoise(finalOptions.threshold);\n                const noiseBlue = getRandomNoise(finalOptions.threshold);\n                red = Math.min(255, Math.max(0, red + noiseRed));\n                green = Math.min(255, Math.max(0, green + noiseGreen));\n                blue = Math.min(255, Math.max(0, blue + noiseBlue));\n            }\n            pixels[i] = red;\n            pixels[i + 1] = green;\n            pixels[i + 2] = blue;\n        }\n        ctx.putImageData(imageData, 0, 0);\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "Image.NoiseSmooth": {
            "uuid": "42cba6a3-fc4f-470c-943d-63cc2199bb7c",
            "name": "Image.NoiseSmooth",
            "method": "Plugin",
            "desc": "Apply smoothing effect with noise to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.NoiseSmooth({ radius: 2, noiseAmount: 5 }); // Smooths the image with noise <br> image.NoiseSmooth({ radius: 3, strength: 0.7, preserveEdges: true }); // Smooth with edge preservation",
            "dependencies": "Image",
            "script": "Q.Image.prototype.NoiseSmooth = function(smoothOptions = {}) {\n        const defaultOptions = {\n            radius: 1,            // Smoothing radius (pixels)\n            strength: 0.5,        // Blend strength between original and smoothed image (0-1)\n            noiseAmount: 0,       // Amount of noise to add after smoothing (0 = no noise)\n            preserveEdges: false, // Whether to preserve edges while smoothing\n            edgeThreshold: 30     // Threshold for edge detection when preserveEdges is true\n        };\n        const finalOptions = Object.assign({}, defaultOptions, smoothOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const srcImageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const resultImageData = new ImageData(temp.width, temp.height);\n        const srcData = srcImageData.data;\n        const tgtData = resultImageData.data;\n        const diameter = finalOptions.radius * 2 + 1;\n        const area = diameter * diameter;\n        const halfRadius = Math.floor(finalOptions.radius);\n        for (let y = 0; y < temp.height; y++) {\n            for (let x = 0; x < temp.width; x++) {\n                let rSum = 0;\n                let gSum = 0;\n                let bSum = 0;\n                let aSum = 0;\n                let weightSum = 0;\n                let isEdge = false;\n                if (finalOptions.preserveEdges) {\n                    if (x > 0 && y > 0 && x < temp.width - 1 && y < temp.height - 1) {\n                        const centerIdx = (y * temp.width + x) * 4;\n                        const leftIdx = (y * temp.width + (x - 1)) * 4;\n                        const rightIdx = (y * temp.width + (x + 1)) * 4;\n                        const hDiff = Math.abs(srcData[leftIdx] - srcData[rightIdx]) +\n                                      Math.abs(srcData[leftIdx+1] - srcData[rightIdx+1]) +\n                                      Math.abs(srcData[leftIdx+2] - srcData[rightIdx+2]);\n                        const topIdx = ((y - 1) * temp.width + x) * 4;\n                        const bottomIdx = ((y + 1) * temp.width + x) * 4;\n                        const vDiff = Math.abs(srcData[topIdx] - srcData[bottomIdx]) +\n                                      Math.abs(srcData[topIdx+1] - srcData[bottomIdx+1]) +\n                                      Math.abs(srcData[topIdx+2] - srcData[bottomIdx+2]);\n                        if (hDiff > finalOptions.edgeThreshold || \n                            vDiff > finalOptions.edgeThreshold) {\n                            isEdge = true;\n                        }\n                    }\n                }\n                if (isEdge) {\n                    const idx = (y * temp.width + x) * 4;\n                    tgtData[idx] = srcData[idx];\n                    tgtData[idx+1] = srcData[idx+1];\n                    tgtData[idx+2] = srcData[idx+2];\n                    tgtData[idx+3] = srcData[idx+3];\n                    continue;\n                }\n                for (let offsetY = -halfRadius; offsetY <= halfRadius; offsetY++) {\n                    for (let offsetX = -halfRadius; offsetX <= halfRadius; offsetX++) {\n                        const nx = x + offsetX;\n                        const ny = y + offsetY;\n                        if (nx >= 0 && ny >= 0 && nx < temp.width && ny < temp.height) {\n                            const srcIndex = (ny * temp.width + nx) * 4;\n                            const weight = 1;\n                            rSum += srcData[srcIndex] * weight;\n                            gSum += srcData[srcIndex + 1] * weight;\n                            bSum += srcData[srcIndex + 2] * weight;\n                            aSum += srcData[srcIndex + 3] * weight;\n                            weightSum += weight;\n                        }\n                    }\n                }\n                const tgtIndex = (y * temp.width + x) * 4;\n                const smoothedR = rSum / weightSum;\n                const smoothedG = gSum / weightSum;\n                const smoothedB = bSum / weightSum;\n                const smoothedA = aSum / weightSum;\n                const origIdx = (y * temp.width + x) * 4;\n                tgtData[tgtIndex] = smoothedR * finalOptions.strength + srcData[origIdx] * (1 - finalOptions.strength);\n                tgtData[tgtIndex + 1] = smoothedG * finalOptions.strength + srcData[origIdx + 1] * (1 - finalOptions.strength);\n                tgtData[tgtIndex + 2] = smoothedB * finalOptions.strength + srcData[origIdx + 2] * (1 - finalOptions.strength);\n                tgtData[tgtIndex + 3] = smoothedA * finalOptions.strength + srcData[origIdx + 3] * (1 - finalOptions.strength);\n                if (finalOptions.noiseAmount > 0) {\n                    const noise = (Math.random() - 0.5) * finalOptions.noiseAmount * 2;\n                    tgtData[tgtIndex] = Math.min(255, Math.max(0, tgtData[tgtIndex] + noise));\n                    tgtData[tgtIndex + 1] = Math.min(255, Math.max(0, tgtData[tgtIndex + 1] + noise));\n                    tgtData[tgtIndex + 2] = Math.min(255, Math.max(0, tgtData[tgtIndex + 2] + noise));\n                }\n            }\n        }\n        ctx.putImageData(resultImageData, 0, 0);\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "Image.Pixelize": {
            "uuid": "167a492a-3c5c-487f-9f50-6fd254f28f0c",
            "name": "Image.Pixelize",
            "method": "Plugin",
            "desc": "Apply a pixelation effect to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Pixelize({ blockSize: 10 }); // Applies a pixelation effect with block size of 10 <br> image.Pixelize({ blockSize: 8, shape: 'dot', roundedCorners: true }); // Creates rounded pixel dots",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Pixelize = function(pixelizeOptions = {}) {\n        const defaultOptions = {\n            blockSize: 10,        // Size of each pixel block\n            sampleMode: 'corner',  // How to sample pixel color: 'corner', 'center', 'average'\n            effect: 'normal',      // Effect type: 'normal', 'mosaic', 'ordered'\n            roundedCorners: false, // Whether to round the corners of each pixel block\n            cornerRadius: 2,       // Radius for rounded corners\n            spacing: 0             // Spacing between pixel blocks\n        };\n        const finalOptions = Object.assign({}, defaultOptions, pixelizeOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n        const pixels = imageData.data;\n        const resultCtx = canvas_node.getContext('2d');\n        resultCtx.clearRect(0, 0, canvas_node.width, canvas_node.height);\n        const blockSize = Math.max(1, finalOptions.blockSize);\n        const spacing = Math.max(0, finalOptions.spacing);\n        for (let y = 0; y < temp.height; y += blockSize) {\n            for (let x = 0; x < temp.width; x += blockSize) {\n                let r, g, b, a;\n                if (finalOptions.sampleMode === 'center') {\n                    const centerX = Math.min(temp.width - 1, x + Math.floor(blockSize / 2));\n                    const centerY = Math.min(temp.height - 1, y + Math.floor(blockSize / 2));\n                    const centerIndex = (centerY * temp.width + centerX) * 4;\n                    r = pixels[centerIndex];\n                    g = pixels[centerIndex + 1];\n                    b = pixels[centerIndex + 2];\n                    a = pixels[centerIndex + 3];\n                } \n                else if (finalOptions.sampleMode === 'average') {\n                    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;\n                    let count = 0;\n                    for (let by = 0; by < blockSize && y + by < temp.height; by++) {\n                        for (let bx = 0; bx < blockSize && x + bx < temp.width; bx++) {\n                            const idx = ((y + by) * temp.width + (x + bx)) * 4;\n                            rSum += pixels[idx];\n                            gSum += pixels[idx + 1];\n                            bSum += pixels[idx + 2];\n                            aSum += pixels[idx + 3];\n                            count++;\n                        }\n                    }\n                    r = Math.round(rSum / count);\n                    g = Math.round(gSum / count);\n                    b = Math.round(bSum / count);\n                    a = Math.round(aSum / count);\n                } \n                else {\n                    const cornerIndex = (y * temp.width + x) * 4;\n                    r = pixels[cornerIndex];\n                    g = pixels[cornerIndex + 1];\n                    b = pixels[cornerIndex + 2];\n                    a = pixels[cornerIndex + 3];\n                }\n                resultCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a/255})`;\n                if (finalOptions.effect === 'ordered') {\n                    const actualSize = blockSize - spacing;\n                    if (finalOptions.roundedCorners) {\n                        resultCtx.beginPath();\n                        resultCtx.roundRect(\n                            x, y, actualSize, actualSize, \n                            finalOptions.cornerRadius\n                        );\n                        resultCtx.fill();\n                    } else {\n                        resultCtx.fillRect(x, y, actualSize, actualSize);\n                    }\n                } \n                else if (finalOptions.effect === 'mosaic') {\n                    const brightness = (r + g + b) / 3;\n                    const sizeVariation = Math.max(1, blockSize * (brightness / 255));\n                    if (finalOptions.roundedCorners) {\n                        resultCtx.beginPath();\n                        resultCtx.roundRect(\n                            x, y, sizeVariation, sizeVariation, \n                            finalOptions.cornerRadius\n                        );\n                        resultCtx.fill();\n                    } else {\n                        resultCtx.fillRect(x, y, sizeVariation, sizeVariation);\n                    }\n                } \n                else {\n                    const actualWidth = Math.min(blockSize, temp.width - x);\n                    const actualHeight = Math.min(blockSize, temp.height - y);\n                    if (finalOptions.roundedCorners && spacing > 0) {\n                        resultCtx.beginPath();\n                        resultCtx.roundRect(\n                            x, y, \n                            actualWidth - spacing, actualHeight - spacing, \n                            finalOptions.cornerRadius\n                        );\n                        resultCtx.fill();\n                    } else {\n                        resultCtx.fillRect(x, y, \n                            actualWidth - spacing, \n                            actualHeight - spacing);\n                    }\n                }\n            }\n        }\n        return this;\n    };"
        },
        "Image.Resize": {
            "uuid": "6e255229-5da9-4bc2-93a7-7269dce02ade",
            "name": "Image.Resize",
            "method": "Plugin",
            "desc": "Image resizing operations.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Resize(800, 600, { size: 'contain' }); // Resizes the image to fit within 800x600 <br> image.Resize(400, 300, { size: 'cover', quality: 'high' }); // Resizes to cover 400x300 area",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Resize = function(width, height, resizeOptions = {}) {\n        const defaultOptions = {\n            size: 'auto',            // 'auto', 'contain', 'cover'\n            keepDimensions: false,   // Keep original dimensions with padding\n            fill: 'transparent',     // Background fill color\n            smoothing: true,         // Use image smoothing\n            quality: 'high'          // 'low', 'medium', 'high'\n        };\n        const finalOptions = Object.assign({}, defaultOptions, resizeOptions);\n        const canvas_node = this.node;\n        const temp = document.createElement('canvas');\n        temp.width = width;\n        temp.height = height;\n        const ctx = temp.getContext('2d');\n        ctx.imageSmoothingEnabled = finalOptions.smoothing;\n        ctx.imageSmoothingQuality = finalOptions.quality;\n        const canvasWidth = canvas_node.width;\n        const canvasHeight = canvas_node.height;\n        if (finalOptions.size === 'contain') {\n            if (finalOptions.keepDimensions) {\n                const widthRatio = width / canvasWidth;\n                const heightRatio = height / canvasHeight;\n                const ratio = Math.min(widthRatio, heightRatio);\n                const newWidth = canvasWidth * ratio;\n                const newHeight = canvasHeight * ratio;\n                const xOffset = (width - newWidth) / 2;\n                const yOffset = (height - newHeight) / 2;\n                ctx.fillStyle = finalOptions.fill;\n                ctx.fillRect(0, 0, width, height);\n                ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, xOffset, yOffset, newWidth, newHeight);\n            } else {\n                const widthRatio = width / canvasWidth;\n                const heightRatio = height / canvasHeight;\n                const ratio = Math.min(widthRatio, heightRatio);\n                const newWidth = canvasWidth * ratio;\n                const newHeight = canvasHeight * ratio;\n                ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n            }\n        } else if (finalOptions.size === 'cover') {\n            const widthRatio = width / canvasWidth;\n            const heightRatio = height / canvasHeight;\n            const ratio = Math.max(widthRatio, heightRatio);\n            const newWidth = canvasWidth * ratio;\n            const newHeight = canvasHeight * ratio;\n            const sourceX = (canvasWidth - width / ratio) / 2;\n            const sourceY = (canvasHeight - height / ratio) / 2;\n            ctx.drawImage(canvas_node, sourceX, sourceY, width / ratio, height / ratio, 0, 0, width, height);\n        } else if (finalOptions.size === 'auto') {\n            const ratio = Math.min(width / canvasWidth, height / canvasHeight);\n            const newWidth = canvasWidth * ratio;\n            const newHeight = canvasHeight * ratio;\n            ctx.fillStyle = finalOptions.fill;\n            ctx.fillRect(0, 0, width, height);\n            ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n        }\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        this.SaveHistory();\n        return this;\n    };"
        },
        "Image.RGBSubpixel": {
            "uuid": "bac3ca96-7aae-4126-b334-211fe915e554",
            "name": "Image.RGBSubpixel",
            "method": "Plugin",
            "desc": "Apply RGB subpixel emulation effect to an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.RGBSubpixel({ subpixelLayout: 'rgb', subpixelScale: 3.0 }); // Applies RGB subpixel effect <br> image.RGBSubpixel({ scanlines: true, phosphorSize: 0.7 }); // Applies subpixel effect with scanlines",
            "dependencies": "Image",
            "script": "Q.Image.prototype.RGBSubpixel = function(subpixelOptions = {}) {\n        const defaultOptions = {\n            subpixelLayout: 'rgb',         // Subpixel layout: 'rgb', 'bgr', 'vrgb' (vertical)\n            subpixelScale: 3.0,            // Scale factor for subpixel rendering (3 = each pixel becomes 3 subpixels)\n            phosphorSize: 0.8,             // Size of phosphor dots (0-1, where 1 fills the whole subpixel)\n            phosphorBloom: 0.2,            // Bloom effect around phosphors (0-1)\n            maxResolution: 640,            // Maximum \"native resolution\" width to simulate\n            resolutionScale: 1.0,          // Scale factor for the final resolution (1 = use maxResolution)\n            brightness: 1.0,               // Brightness adjustment for subpixels (0.5-2.0)\n            applyNoise: false,             // Apply CRT-like noise\n            noiseAmount: 5,                // Amount of noise to apply\n            fastMode: true,                // Use faster rendering algorithm (less authentic but much faster)\n            scanlines: false,              // Whether to apply scanlines\n            scanlineHeight: 1,             // Height of scanlines\n            scanlineMargin: 3,             // Space between scanlines\n            scanlineOpacity: 0.1,          // Opacity of scanlines\n            scanlineBrightness: 0.5        // Brightness between scanlines (0-1)\n        };\n        const finalOptions = Object.assign({}, defaultOptions, subpixelOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d', { willReadFrequently: true });\n        ctx.drawImage(canvas_node, 0, 0);\n        const resultCanvas = canvas_node;\n        const resultCtx = resultCanvas.getContext('2d', { willReadFrequently: true });\n        if (finalOptions.fastMode) {\n            const patternSize = finalOptions.subpixelLayout === 'vrgb' ? 1 : 3;\n            const patternCanvas = document.createElement('canvas');\n            patternCanvas.width = patternSize;\n            patternCanvas.height = 1;\n            const patternCtx = patternCanvas.getContext('2d');\n            if (finalOptions.subpixelLayout === 'rgb') {\n                patternCtx.fillStyle = `rgba(255,0,0,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(0, 0, 1, 1);\n                patternCtx.fillStyle = `rgba(0,255,0,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(1, 0, 1, 1);\n                patternCtx.fillStyle = `rgba(0,0,255,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(2, 0, 1, 1);\n            } else if (finalOptions.subpixelLayout === 'bgr') {\n                patternCtx.fillStyle = `rgba(0,0,255,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(0, 0, 1, 1);\n                patternCtx.fillStyle = `rgba(0,255,0,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(1, 0, 1, 1);\n                patternCtx.fillStyle = `rgba(255,0,0,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(2, 0, 1, 1);\n            } else if (finalOptions.subpixelLayout === 'vrgb') {\n                patternCanvas.width = 1;\n                patternCanvas.height = 3;\n                patternCtx.fillStyle = `rgba(255,0,0,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(0, 0, 1, 1);\n                patternCtx.fillStyle = `rgba(0,255,0,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(0, 1, 1, 1);\n                patternCtx.fillStyle = `rgba(0,0,255,${finalOptions.phosphorSize})`;\n                patternCtx.fillRect(0, 2, 1, 1);\n            }\n            const targetWidth = Math.min(temp.width, finalOptions.maxResolution);\n            const targetHeight = Math.round(temp.height * (targetWidth / temp.width));\n            const scaledCanvas = document.createElement('canvas');\n            scaledCanvas.width = targetWidth;\n            scaledCanvas.height = targetHeight;\n            const scaledCtx = scaledCanvas.getContext('2d', { willReadFrequently: true });\n            scaledCtx.drawImage(temp, 0, 0, targetWidth, targetHeight);\n            let rgbCanvas;\n            let rgbCtx;\n            if (finalOptions.subpixelLayout === 'vrgb') {\n                rgbCanvas = document.createElement('canvas');\n                rgbCanvas.width = targetWidth;\n                rgbCanvas.height = targetHeight * 3;\n                rgbCtx = rgbCanvas.getContext('2d', { willReadFrequently: true });\n                rgbCtx.drawImage(scaledCanvas, 0, 0);\n                rgbCtx.fillStyle = 'rgba(0, 255, 255, 1.0)'; // Cyan (removes red)\n                rgbCtx.globalCompositeOperation = 'multiply';\n                rgbCtx.fillRect(0, 0, targetWidth, targetHeight);\n                rgbCtx.globalCompositeOperation = 'source-over';\n                rgbCtx.drawImage(scaledCanvas, 0, targetHeight);\n                rgbCtx.fillStyle = 'rgba(255, 0, 255, 1.0)'; // Magenta (removes green)\n                rgbCtx.globalCompositeOperation = 'multiply';\n                rgbCtx.fillRect(0, targetHeight, targetWidth, targetHeight);\n                rgbCtx.globalCompositeOperation = 'source-over';\n                rgbCtx.drawImage(scaledCanvas, 0, targetHeight * 2);\n                rgbCtx.fillStyle = 'rgba(255, 255, 0, 1.0)'; // Yellow (removes blue)\n                rgbCtx.globalCompositeOperation = 'multiply';\n                rgbCtx.fillRect(0, targetHeight * 2, targetWidth, targetHeight);\n            } else {\n                rgbCanvas = document.createElement('canvas');\n                rgbCanvas.width = targetWidth * 3;\n                rgbCanvas.height = targetHeight;\n                rgbCtx = rgbCanvas.getContext('2d', { willReadFrequently: true });\n                rgbCtx.globalCompositeOperation = 'source-over';\n                rgbCtx.drawImage(scaledCanvas, 0, 0);\n                rgbCtx.fillStyle = 'rgba(0, 255, 255, 1.0)'; // Cyan (removes red)\n                rgbCtx.globalCompositeOperation = 'multiply';\n                rgbCtx.fillRect(0, 0, targetWidth, targetHeight);\n                rgbCtx.globalCompositeOperation = 'source-over';\n                rgbCtx.drawImage(scaledCanvas, targetWidth, 0);\n                rgbCtx.fillStyle = 'rgba(255, 0, 255, 1.0)'; // Magenta (removes green)\n                rgbCtx.globalCompositeOperation = 'multiply';\n                rgbCtx.fillRect(targetWidth, 0, targetWidth, targetHeight);\n                rgbCtx.globalCompositeOperation = 'source-over';\n                rgbCtx.drawImage(scaledCanvas, targetWidth * 2, 0);\n                rgbCtx.fillStyle = 'rgba(255, 255, 0, 1.0)'; // Yellow (removes blue)\n                rgbCtx.globalCompositeOperation = 'multiply';\n                rgbCtx.fillRect(targetWidth * 2, 0, targetWidth, targetHeight);\n            }\n            rgbCtx.globalCompositeOperation = 'destination-in';\n            const pattern = patternCtx.createPattern(patternCanvas, 'repeat');\n            rgbCtx.fillStyle = pattern;\n            rgbCtx.fillRect(0, 0, rgbCanvas.width, rgbCanvas.height);\n            if (finalOptions.applyNoise) {\n                const noiseCanvas = document.createElement('canvas');\n                noiseCanvas.width = rgbCanvas.width;\n                noiseCanvas.height = rgbCanvas.height;\n                const noiseCtx = noiseCanvas.getContext('2d', { willReadFrequently: true });\n                const noiseData = noiseCtx.createImageData(noiseCanvas.width, noiseCanvas.height);\n                const noisePixels = noiseData.data;\n                for (let i = 0; i < noisePixels.length; i += 4) {\n                    const noise = (Math.random() - 0.5) * finalOptions.noiseAmount;\n                    noisePixels[i] = noisePixels[i + 1] = noisePixels[i + 2] = 128 + noise;\n                    noisePixels[i + 3] = 30; // Low alpha for subtle noise\n                }\n                noiseCtx.putImageData(noiseData, 0, 0);\n                rgbCtx.globalCompositeOperation = 'overlay';\n                rgbCtx.drawImage(noiseCanvas, 0, 0);\n            }\n            resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);\n            resultCtx.globalAlpha = finalOptions.brightness;\n            resultCtx.drawImage(\n                rgbCanvas, 0, 0, rgbCanvas.width, rgbCanvas.height,\n                0, 0, resultCanvas.width, resultCanvas.height\n            );\n            resultCtx.globalAlpha = 1.0;\n        }\n        else {\n            let subpixelCanvas = Q('<canvas>', { \n                width: Math.ceil(temp.width * finalOptions.subpixelScale), \n                height: Math.ceil(temp.height * finalOptions.subpixelScale) \n            }).nodes[0];\n            let subpixelCtx = subpixelCanvas.getContext('2d', { willReadFrequently: true });\n            const targetWidth = Math.min(temp.width, finalOptions.maxResolution);\n            const targetHeight = Math.round(temp.height * (targetWidth / temp.width));\n            const resolutionScale = targetWidth / temp.width * finalOptions.resolutionScale;\n            subpixelCtx.drawImage(temp, 0, 0, subpixelCanvas.width, subpixelCanvas.height);\n            const imageData = ctx.getImageData(0, 0, temp.width, temp.height);\n            const subpixelData = subpixelCtx.getImageData(0, 0, subpixelCanvas.width, subpixelCanvas.height);\n            let processedCanvas = document.createElement('canvas');\n            processedCanvas.width = subpixelCanvas.width;\n            processedCanvas.height = subpixelCanvas.height;\n            let processedCtx = processedCanvas.getContext('2d', { willReadFrequently: true });\n            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);\n            const subpixelWidth = Math.ceil(finalOptions.subpixelScale / 3);\n            const phosphorWidth = Math.ceil(subpixelWidth * finalOptions.phosphorSize);\n            const phosphorBloom = finalOptions.phosphorBloom * subpixelWidth;\n            const colorRed = `rgba(255,0,0,1)`;\n            const colorGreen = `rgba(0,255,0,1)`;\n            const colorBlue = `rgba(0,0,255,1)`;\n            const colors = [colorRed, colorGreen, colorBlue];\n            const intensityLevels = 10; // Use 10 intensity levels instead of 256\n            const gradients = {\n                'red': [],\n                'green': [],\n                'blue': []\n            };\n            for (let level = 0; level < intensityLevels; level++) {\n                const intensity = level / (intensityLevels - 1);\n                ['red', 'green', 'blue'].forEach((color, colorIndex) => {\n                    const gradientSize = phosphorWidth + (phosphorBloom * 2);\n                    const centerX = subpixelWidth / 2;\n                    const centerY = subpixelWidth / 2;\n                    const gradient = processedCtx.createRadialGradient(\n                        centerX, centerY, 0,\n                        centerX, centerY, gradientSize / 2\n                    );\n                    gradient.addColorStop(0, `rgba(${colors[colorIndex].replace(/[^\\d,]/g, '')},${intensity})`);\n                    gradient.addColorStop(phosphorWidth / gradientSize, \n                        `rgba(${colors[colorIndex].replace(/[^\\d,]/g, '')},${intensity * 0.7})`);\n                    gradient.addColorStop(1, `rgba(${colors[colorIndex].replace(/[^\\d,]/g, '')},0)`);\n                    gradients[color].push(gradient);\n                });\n            }\n            if (finalOptions.subpixelLayout === 'rgb' || finalOptions.subpixelLayout === 'bgr') {\n                const isRGB = finalOptions.subpixelLayout === 'rgb';\n                const colorOrder = isRGB ? [0, 1, 2] : [2, 1, 0]; // RGB or BGR\n                const batchHeight = 20; // Process 20 rows at a time\n                for (let y = 0; y < temp.height; y += batchHeight) {\n                    const maxY = Math.min(temp.height, y + batchHeight);\n                    for (let cy = y; cy < maxY; cy++) {\n                        for (let x = 0; x < temp.width; x++) {\n                            const srcIndex = (cy * temp.width + x) * 4;\n                            const r = imageData.data[srcIndex];\n                            const g = imageData.data[srcIndex + 1];\n                            const b = imageData.data[srcIndex + 2];\n                            const baseX = Math.floor(x * finalOptions.subpixelScale);\n                            const baseY = Math.floor(cy * finalOptions.subpixelScale);\n                            const components = [r, g, b];\n                            for (let i = 0; i < 3; i++) {\n                                const intensity = components[colorOrder[i]] / 255;\n                                const gradientIndex = Math.floor(intensity * (intensityLevels - 1));\n                                const colorName = i === 0 ? 'red' : (i === 1 ? 'green' : 'blue');\n                                const subpixelX = baseX + (i * subpixelWidth);\n                                processedCtx.fillStyle = gradients[colorName][gradientIndex];\n                                processedCtx.fillRect(\n                                    subpixelX, baseY, \n                                    subpixelWidth, finalOptions.subpixelScale\n                                );\n                            }\n                        }\n                    }\n                }\n            } \n            else if (finalOptions.subpixelLayout === 'vrgb') {\n                for (let y = 0; y < temp.height; y++) {\n                    for (let x = 0; x < temp.width; x++) {\n                        const srcIndex = (y * temp.width + x) * 4;\n                        const r = imageData.data[srcIndex];\n                        const g = imageData.data[srcIndex + 1];\n                        const b = imageData.data[srcIndex + 2];\n                        const baseX = Math.floor(x * finalOptions.subpixelScale);\n                        const baseY = Math.floor(y * finalOptions.subpixelScale);\n                        const components = [r, g, b];\n                        for (let i = 0; i < 3; i++) {\n                            const intensity = components[i] / 255;\n                            const gradientIndex = Math.floor(intensity * (intensityLevels - 1));\n                            const colorName = i === 0 ? 'red' : (i === 1 ? 'green' : 'blue');\n                            const subpixelY = baseY + (i * subpixelWidth);\n                            processedCtx.fillStyle = gradients[colorName][gradientIndex];\n                            processedCtx.fillRect(\n                                baseX, subpixelY, \n                                finalOptions.subpixelScale, subpixelWidth\n                            );\n                        }\n                    }\n                }\n            }\n            if (finalOptions.applyNoise) {\n                const noiseData = processedCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);\n                const noisePixels = noiseData.data;\n                for (let i = 0; i < noisePixels.length; i += 4) {\n                    if (noisePixels[i+3] > 0) { // Only apply to visible pixels\n                        const noise = (Math.random() - 0.5) * finalOptions.noiseAmount;\n                        noisePixels[i] = Math.min(255, Math.max(0, noisePixels[i] + noise));\n                        noisePixels[i+1] = Math.min(255, Math.max(0, noisePixels[i+1] + noise));\n                        noisePixels[i+2] = Math.min(255, Math.max(0, noisePixels[i+2] + noise));\n                    }\n                }\n                processedCtx.putImageData(noiseData, 0, 0);\n            }\n            resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);\n            resultCtx.globalAlpha = finalOptions.brightness;\n            resultCtx.drawImage(\n                processedCanvas, 0, 0, \n                processedCanvas.width, processedCanvas.height,\n                0, 0, resultCanvas.width, resultCanvas.height\n            );\n            resultCtx.globalAlpha = 1.0;\n        }\n        if (finalOptions.scanlines) {\n            function drawHorizontalLines(ctx, width, height, totalHeight, margin, color, brightnessFactor) {\n                ctx.fillStyle = color;\n                for (let i = 0; i < totalHeight; i += (height + margin)) {\n                    ctx.fillRect(0, i, width, height);\n                    if (brightnessFactor > 0 && i + height < totalHeight) {\n                        const brightColor = `rgba(255, 255, 255, ${brightnessFactor * 0.1})`;\n                        ctx.fillStyle = brightColor;\n                        ctx.fillRect(0, i + height, width, margin);\n                        ctx.fillStyle = color; // Reset to scanline color\n                    }\n                }\n            }\n            drawHorizontalLines(\n                resultCtx, \n                resultCanvas.width, \n                finalOptions.scanlineHeight, \n                resultCanvas.height, \n                finalOptions.scanlineMargin, \n                `rgba(0, 0, 0, ${finalOptions.scanlineOpacity})`,\n                finalOptions.scanlineBrightness\n            );\n        }\n        return this;\n    };"
        },
        "Image.Rotate": {
            "uuid": "06a1c320-319f-4771-ad05-5e0addca3e2b",
            "name": "Image.Rotate",
            "method": "Plugin",
            "desc": "Rotate image by specified degrees.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Rotate(90); // Rotates the image by 90 degrees <br> image.Rotate(-45, { keepSize: true }); // Rotates by -45 degrees while maintaining canvas size",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Rotate = function(degrees, rotateOptions = {}) {\n        const defaultOptions = {\n            keepSize: false,     // Whether to keep original canvas size\n            smoothing: true,     // Whether to use smoothing\n            quality: 'high',     // Smoothing quality: 'low', 'medium', 'high'\n            centerOrigin: true   // Whether to rotate around the center\n        };\n        const finalOptions = Object.assign({}, defaultOptions, rotateOptions);\n        const canvas_node = this.node;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        if (!finalOptions.keepSize) {\n            const radians = degrees * Math.PI / 180;\n            const newWidth = Math.abs(Math.cos(radians) * width) + Math.abs(Math.sin(radians) * height);\n            const newHeight = Math.abs(Math.sin(radians) * width) + Math.abs(Math.cos(radians) * height);\n            width = newWidth;\n            height = newHeight;\n        }\n        let temp = Q('<canvas>', { width: width, height: height }).nodes[0];\n        let ctx = temp.getContext('2d');\n        ctx.imageSmoothingEnabled = finalOptions.smoothing;\n        ctx.imageSmoothingQuality = finalOptions.quality;\n        ctx.translate(width / 2, height / 2);\n        ctx.rotate(degrees * Math.PI / 180);\n        ctx.drawImage(\n            canvas_node, \n            -canvas_node.width / 2, \n            -canvas_node.height / 2\n        );\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "Image.Sharpen": {
            "uuid": "b17b54dd-b543-426a-b14c-74a9c2de6784",
            "name": "Image.Sharpen",
            "method": "Plugin",
            "desc": "Apply smart sharpening to images.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Sharpen({ amount: 2.0, radius: 1.0 }); // Sharpens the image with specified parameters <br> image.Sharpen({ amount: 1.5, details: 0.7, threshold: 10 }); // Sharpen with detail preservation",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Sharpen = function(sharpenOptions = {}) {\n        const defaults = {\n            amount: 1.0,     // Sharpening amount (0.0 to 4.0)\n            radius: 1.0,     // Sharpening radius\n            threshold: 0,    // Edge threshold\n            details: 0.5     // Detail preservation (0.0 to 1.0)\n        };\n        const settings = Object.assign({}, defaults, sharpenOptions);\n        const canvas_node = this.node;\n        settings.amount = Math.max(0, Math.min(4, settings.amount));\n        const ctx = canvas_node.getContext('2d');\n        const imgData = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        const pixels = imgData.data;\n        const width = canvas_node.width;\n        const height = canvas_node.height;\n        const dataCopy = new Uint8ClampedArray(pixels);\n        applyGaussianBlur(dataCopy, width, height, settings.radius);\n        const sharpAmount = settings.amount * 0.75; // Scale for better visual match\n        const detailFactor = settings.details * 2; // Amplify detail preservation\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const i = (y * width + x) * 4;\n                const diffR = pixels[i] - dataCopy[i];\n                const diffG = pixels[i + 1] - dataCopy[i + 1];\n                const diffB = pixels[i + 2] - dataCopy[i + 2];\n                const edgeIntensity = Math.sqrt(diffR * diffR + diffG * diffG + diffB * diffB);\n                if (edgeIntensity > settings.threshold) {\n                    const factor = sharpAmount + (detailFactor * edgeIntensity / 255);\n                    pixels[i] = clamp(pixels[i] + diffR * factor);\n                    pixels[i + 1] = clamp(pixels[i + 1] + diffG * factor);\n                    pixels[i + 2] = clamp(pixels[i + 2] + diffB * factor);\n                }\n            }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        this.SaveHistory();\n        return this;\n    };\n    function clamp(value) {\n        return Math.min(255, Math.max(0, value));\n    }\n    function applyGaussianBlur(data, width, height, radius) {\n        const iterations = 3; // Multiple passes for better Gaussian approximation\n        const size = Math.ceil(radius) * 2 + 1;\n        const halfSize = Math.floor(size / 2);\n        const temp = new Uint8ClampedArray(data.length);\n        for (let i = 0; i < iterations; i++) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n                    let count = 0;\n                    for (let j = -halfSize; j <= halfSize; j++) {\n                        const cx = Math.min(Math.max(0, x + j), width - 1);\n                        const idx = (y * width + cx) * 4;\n                        r += data[idx];\n                        g += data[idx + 1];\n                        b += data[idx + 2];\n                        count++;\n                    }\n                    const idx = (y * width + x) * 4;\n                    temp[idx] = r / count;\n                    temp[idx + 1] = g / count;\n                    temp[idx + 2] = b / count;\n                    temp[idx + 3] = data[idx + 3];\n                }\n            }\n            for (let x = 0; x < width; x++) {\n                for (let y = 0; y < height; y++) {\n                    let r = 0, g = 0, b = 0;\n                    let count = 0;\n                    for (let j = -halfSize; j <= halfSize; j++) {\n                        const cy = Math.min(Math.max(0, y + j), height - 1);\n                        const idx = (cy * width + x) * 4;\n                        r += temp[idx];\n                        g += temp[idx + 1];\n                        b += temp[idx + 2];\n                        count++;\n                    }\n                    const idx = (y * width + x) * 4;\n                    data[idx] = r / count;\n                    data[idx + 1] = g / count;\n                    data[idx + 2] = b / count;\n                }\n            }\n        }\n    }"
        },
        "Image.Vivid": {
            "uuid": "eea9384c-d769-4e70-bcf9-f13f44a604c4",
            "name": "Image.Vivid",
            "method": "Plugin",
            "desc": "Adjust image vividness/saturation.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Vivid(1.5); // Increases saturation by 1.5x <br> image.Vivid(0.5, { method: 'hsl' }); // Decreases saturation using HSL method",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Vivid = function(value, vividOptions = {}) {\n        const defaultOptions = {\n            method: 'multiply',  // 'multiply', 'hsl'\n            clamp: true          // Whether to clamp values to 0-255 range\n        };\n        const finalOptions = Object.assign({}, defaultOptions, vividOptions);\n        const canvas_node = this.node;\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        if (finalOptions.method === 'hsl' && typeof Q.RGB2HSL === 'function' && typeof Q.HSL2RGB === 'function') {\n            for (let i = 0; i < pixels.length; i += 4) {\n                let r = pixels[i];\n                let g = pixels[i + 1];\n                let b = pixels[i + 2];\n                let hsl = Q.RGB2HSL(r, g, b);\n                hsl[1] *= value; // Adjust saturation\n                if (finalOptions.clamp) {\n                    hsl[1] = Math.min(1, Math.max(0, hsl[1]));\n                }\n                let rgb = Q.HSL2RGB(hsl[0], hsl[1], hsl[2]);\n                pixels[i] = rgb[0];\n                pixels[i + 1] = rgb[1];\n                pixels[i + 2] = rgb[2];\n            }\n        } else {\n            for (let i = 0; i < pixels.length; i += 4) {\n                let luminance = 0.299 * pixels[i] + 0.587 * pixels[i + 1] + 0.114 * pixels[i + 2];\n                pixels[i] = luminance + (pixels[i] - luminance) * value;\n                pixels[i + 1] = luminance + (pixels[i + 1] - luminance) * value;\n                pixels[i + 2] = luminance + (pixels[i + 2] - luminance) * value;\n                if (finalOptions.clamp) {\n                    pixels[i] = Math.min(255, Math.max(0, pixels[i]));\n                    pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1]));\n                    pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2]));\n                }\n            }\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n        return this;\n    };"
        },
        "Image.Zoom": {
            "uuid": "bc272960-ade8-4068-8ff3-7d493ec2b277",
            "name": "Image.Zoom",
            "method": "Plugin",
            "desc": "Zoom in or out of an image.",
            "type": "Component",
            "example": "const image = Q.Image(); <br> image.Zoom(1.5); // Zooms in by a factor of 1.5 <br> image.Zoom(0.5, { centerX: 100, centerY: 100 }); // Zooms out centered at point (100,100)",
            "dependencies": "Image",
            "script": "Q.Image.prototype.Zoom = function(factor = 1.5, zoomOptions = {}) {\n        const defaultOptions = {\n            centerX: this.node.width / 2,   // Default center point X\n            centerY: this.node.height / 2,  // Default center point Y\n            smoothing: true,                // Whether to use smoothing\n            quality: 'high',                // Smoothing quality: 'low', 'medium', 'high'\n            background: 'transparent'       // Background for areas outside the image when zooming out\n        };\n        const finalOptions = Object.assign({}, defaultOptions, zoomOptions);\n        const canvas_node = this.node;\n        let temp = Q('<canvas>', { \n            width: canvas_node.width, \n            height: canvas_node.height \n        }).nodes[0];\n        let ctx = temp.getContext('2d');\n        ctx.imageSmoothingEnabled = finalOptions.smoothing;\n        ctx.imageSmoothingQuality = finalOptions.quality;\n        ctx.fillStyle = finalOptions.background;\n        ctx.fillRect(0, 0, temp.width, temp.height);\n        if (factor >= 1) {\n            const sWidth = canvas_node.width / factor;\n            const sHeight = canvas_node.height / factor;\n            const sx = finalOptions.centerX - (sWidth / 2);\n            const sy = finalOptions.centerY - (sHeight / 2);\n            const boundedSx = Math.max(0, Math.min(canvas_node.width - sWidth, sx));\n            const boundedSy = Math.max(0, Math.min(canvas_node.height - sHeight, sy));\n            ctx.drawImage(\n                canvas_node,\n                boundedSx, boundedSy, sWidth, sHeight,\n                0, 0, canvas_node.width, canvas_node.height\n            );\n        } else {\n            const scaledWidth = canvas_node.width * factor;\n            const scaledHeight = canvas_node.height * factor;\n            const dx = (canvas_node.width - scaledWidth) / 2;\n            const dy = (canvas_node.height - scaledHeight) / 2;\n            ctx.drawImage(\n                canvas_node,\n                0, 0, canvas_node.width, canvas_node.height,\n                dx, dy, scaledWidth, scaledHeight\n            );\n        }\n        canvas_node.getContext('2d').clearRect(0, 0, canvas_node.width, canvas_node.height);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n        return this;\n    };"
        },
        "ImageViewer": {
            "uuid": "98666a27-5a36-484a-abb7-d321cec8ae43",
            "name": "ImageViewer",
            "method": "Plugin",
            "desc": "A simple image viewer plugin",
            "type": "Plugin",
            "example": "Q.ImageViewer().selector('.image').open(['image1.jpg', 'image2.jpg']);",
            "dependencies": [
                "Style",
                "Icons"
            ],
            "script": "Q.ImageViewer = function () {\n    let classes = Q.style(`\n.image_viewer_wrapper {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    background: rgba(0, 0, 0, 0.77);\n    transition: background 10s;\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n    color: #fff;\n}\n.image_panel {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n.image_wrapper {\n    width: 100%;\n    height: 100%;\n    opacity: 0;\n    transition: all 0.15s;\n    margin: 0 1px;\n    display: flex;\n    flex-direction: column;\n    animation: fadeInScale 0.3s forwards;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n}\n.image_canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    transition: width 0.3s, height 0.3s;\n}\n.image_ambient {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    filter: blur(25px);\n    opacity: 0.75;\n    z-index: 0;\n}\n@keyframes fadeInScale {\n    to {\n        opacity: 1;\n    }\n}\n.image_viewer_wrapper .image_panel {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.image_top, .image_bottom {\n    width: 100%;\n    z-index: 1;\n    position: absolute;\n}\n.image_top {\n    top: 0;\n    text-align: left;\n    background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);\n}\n.image_bottom {\n    bottom: 0;\n}\n.side_left, .side_right {\n    height: 100%;\n    width: 80px;\n}\n.image_info {\n    max-width: 500px;\n    padding: 10px;\n    text-shadow: 0 1px 3px #000;\n}\n.image_title {\n    font-size: 18px;\n    font-weight: bold;\n    padding-bottom: 5px;\n}\n.image_desc {\n    font-size: 14px;\n}\n.side_left:hover, .side_right:hover {\n    background: rgba(255,255,255,0.05);\n}\n.viewer_left_button, .viewer_right_button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n.viewer_navicon {\n    width: 40px;\n    height: 40px;\n}\n.viewer_left_button:hover, .viewer_right_button:hover, .viewer_close_button:hover {\n    opacity: 1;\n}\n.viewer_button_container {\n    z-index: 10000;\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    display: flex;\n}\n.viewer_close_button, .viewer_zoom_in_button, .viewer_zoom_out_button {\n    width: 30px;\n    height: 30px;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n    `, {\n        'image_viewer_wrapper': 'image_viewer_wrapper',\n        'image_panel': 'image_panel',\n        'image_wrapper': 'image_wrapper',\n        'image_canvas': 'image_canvas',\n        'image_ambient': 'image_ambient',\n        'image_top': 'image_top',\n        'image_bottom': 'image_bottom',\n        'image_info': 'image_info',\n        'viewer_button_container': 'viewer_button_container',\n        'side_left': 'side_left',\n        'side_right': 'side_right',\n        'viewer_left_button': 'viewer_left_button',\n        'viewer_right_button': 'viewer_right_button',\n        'viewer_close_button': 'viewer_close_button',\n        'viewer_zoom_in_button': 'viewer_zoom_in_button',\n        'viewer_zoom_out_button': 'viewer_zoom_out_button',\n        'image_title': 'image_title',\n        'image_desc': 'image_desc',\n        'viewer_navicon': 'viewer_navicon'\n    }, false);\n    class Viewer {\n        constructor() {\n            this.selector = null;\n            this.images = [];\n            this.currentIndex = 0;\n            this.eventHandler = this.handleClick.bind(this);\n            this.addEventListener();\n            this.icons = Q.Icons();\n            this.eventListenerActive = false;\n            this.loaded = false;\n            this.resizing = false;\n            this.thumbs = false;\n            this.scale = 1;\n            this.panX = 0;\n            this.panY = 0;\n            this.isPanning = false;\n            this.startX = 0;\n            this.startY = 0;\n            this.imageCache = {};\n            this.config = {\n                panAndZoom: true,\n                ambient: true,\n                ambientSize: 1.2,\n                dynamicBackground: true\n            };\n        }\n        construct() {\n            this.image_viewer = Q('<div>', { class: classes.image_viewer_wrapper });\n            this.image_panel = Q('<div>', { class: classes.image_panel });\n            this.image_wrapper = Q('<div>', { class: classes.image_wrapper });\n            this.image_canvas = Q('<canvas>', { class: classes.image_canvas });\n            this.image_ambient = Q('<canvas>', { class: classes.image_ambient });\n            this.image_top = Q('<div>', { class: classes.image_top });\n            this.image_bottom = Q('<div>', { class: classes.image_bottom });\n            this.image_info = Q('<div>', { class: classes.image_info });\n            this.button_container = Q('<div>', { class: classes.viewer_button_container });\n            this.side_left = Q('<div>', { class: classes.side_left });\n            this.side_right = Q('<div>', { class: classes.side_right });\n            this.left_button = Q('<div>', { class: classes.viewer_left_button });\n            this.right_button = Q('<div>', { class: classes.viewer_right_button });\n            this.close_button = Q('<div>', { class: classes.viewer_close_button });\n            this.zoom_in_button = Q('<div>', { class: classes.viewer_zoom_in_button });\n            this.zoom_out_button = Q('<div>', { class: classes.viewer_zoom_out_button });\n            this.left_button.append(this.icons.get('navigation-left', classes.viewer_navicon));\n            this.right_button.append(this.icons.get('navigation-right', classes.viewer_navicon));\n            this.close_button.append(this.icons.get('navigation-close'));\n            this.zoom_in_button.append(this.icons.get('zoom-in'));\n            this.zoom_out_button.append(this.icons.get('zoom-out'));\n            this.side_left.append(this.left_button);\n            this.side_right.append(this.right_button);\n            this.image_top.append(this.image_info);\n            this.button_container.append(this.zoom_in_button, this.zoom_out_button, this.close_button);\n            this.image_wrapper.append(this.image_ambient, this.image_canvas, this.image_top, this.image_bottom);\n            this.image_panel.append(this.side_left, this.image_wrapper, this.side_right);\n            this.image_viewer.append(this.image_panel, this.button_container);\n            this.left_button.on('click', () => this.prev());\n            this.right_button.on('click', () => this.next());\n            this.close_button.on('click', () => this.close());\n            this.image_top.on('mouseenter', () => {\n                this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            });\n            this.image_top.on('mouseleave', () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s', 'transition-delay': '3s' });\n            });\n            this.image_canvas.on('wheel', (e) => this.handleZoom(e));\n            this.image_canvas.on('mousedown', (e) => this.startPan(e));\n            this.image_canvas.on('mousemove', (e) => this.pan(e));\n            this.image_canvas.on('mouseup', () => this.endPan());\n            this.image_canvas.on('mouseleave', () => this.endPan());\n            this.image_canvas.on('touchstart', (e) => this.startTouch(e));\n            this.image_canvas.on('touchmove', (e) => this.touchPanZoom(e));\n            this.image_canvas.on('touchend', () => this.endTouch());\n        }\n        handleClick(e) {\n            if (e.target.closest(this.selector)) {\n                const images = Q(this.selector).find('img');\n                if (!images.nodes.length) {\n                    return;\n                }\n                images.each((index, el) => {\n                    let title, desc, src;\n                    if (el.hasAttribute('data-title')) {\n                        title = el.getAttribute('data-title');\n                    }\n                    if (el.hasAttribute('data-desc')) {\n                        desc = el.getAttribute('data-desc');\n                    }\n                    if (el.hasAttribute('data-source')) {\n                        src = el.getAttribute('data-source');\n                    } else {\n                        src = el.src;\n                    }\n                    this.images[index] = {\n                        src: src,\n                        title: title,\n                        desc: desc\n                    }\n                });\n                this.currentIndex = images.nodes.indexOf(e.target);\n                this.open();\n            }\n        }\n        handleResize() {\n            if (!this.resizing) {\n                this.resizing = true;\n                this.image_canvas.css({ filter: 'blur(10px)', transition: 'all 0.1s ease-in-out' });\n            }\n            Q.Debounce('img_viewer', 500, () => {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.updateImage();\n                this.resizing = false;\n                this.image_canvas.css({ filter: 'none', transition: '' });\n            });\n        }\n        handleZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            const rect = this.image_canvas.nodes[0].getBoundingClientRect();\n            const offsetX = (e.clientX - rect.left - this.panX) / this.scale;\n            const offsetY = (e.clientY - rect.top - this.panY) / this.scale;\n            const scaleAmount = e.deltaY > 0 ? 0.9 : 1.1;\n            const newScale = Math.min(Math.max(this.scale * scaleAmount, 0.5), 2.5);\n            const deltaScale = newScale - this.scale;\n            this.panX -= offsetX * deltaScale;\n            this.panY -= offsetY * deltaScale;\n            this.scale = newScale;\n            this.updateImage();\n        }\n        startPan(e) {\n            if (!this.config.panAndZoom) return;\n            this.isPanning = true;\n            this.startX = e.clientX - this.panX;\n            this.startY = e.clientY - this.panY;\n        }\n        pan(e) {\n            if (!this.config.panAndZoom) return;\n            if (!this.isPanning) return;\n            this.panX = e.clientX - this.startX;\n            this.panY = e.clientY - this.startY;\n            this.updateImage();\n        }\n        endPan() {\n            this.isPanning = false;\n        }\n        startTouch(e) {\n            if (!this.config.panAndZoom) return;\n            if (e.touches.length === 1) {\n                this.isPanning = true;\n                this.startX = e.touches[0].clientX - this.panX;\n                this.startY = e.touches[0].clientY - this.panY;\n            } else if (e.touches.length === 2) {\n                this.isPanning = false;\n                this.initialDistance = Math.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                this.initialScale = this.scale;\n            }\n        }\n        touchPanZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            if (e.touches.length === 1 && this.isPanning) {\n                this.panX = e.touches[0].clientX - this.startX;\n                this.panY = e.touches[0].clientY - this.startY;\n                this.updateImage();\n            } else if (e.touches.length === 2) {\n                const currentDistance = Math.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                const scaleAmount = currentDistance / this.initialDistance;\n                this.scale = Math.min(Math.max(this.initialScale * scaleAmount, 0.5), 2.5);\n                this.updateImage();\n            }\n        }\n        endTouch() {\n            this.isPanning = false;\n        }\n        addEventListener() {\n            if (!this.eventListenerActive) {\n                document.addEventListener('click', this.eventHandler);\n                this.eventListenerActive = true;\n            }\n        }\n        removeEventListener() {\n            if (this.eventListenerActive) {\n                document.removeEventListener('click', this.eventHandler);\n                this.eventListenerActive = false;\n            }\n        }\n        fadeTitle() {\n            this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            Q.Debounce('fade_title', 2000, () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s' });\n            });\n        }\n        open() {\n            this.construct();\n            this.updateImage();\n            this.updateNavigation();\n            Q('body').append(this.image_viewer);\n            window.addEventListener('resize', this.handleResize.bind(this));\n        }\n        close() {\n            this.thumbs = false;\n            window.removeEventListener('resize', this.handleResize.bind(this));\n            this.image_viewer.remove();\n        }\n        prev() {\n            if (this.currentIndex > 0) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex--;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        next() {\n            if (this.currentIndex < this.images.length - 1) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex++;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        updateImage() {\n            this.window_width = window.innerWidth;\n            this.window_height = window.innerHeight;\n            this.image_info.empty();\n            if (this.images[this.currentIndex].title) {\n                this.image_info.append(Q('<div>', { class: classes.image_title, text: this.images[this.currentIndex].title }));\n            }\n            if (this.images[this.currentIndex].desc) {\n                this.image_info.append(Q('<div>', { class: classes.image_desc, text: this.images[this.currentIndex].desc }));\n            }\n            const src = this.images[this.currentIndex];\n            const img = this.imageCache[src.src] || new Image();\n            if (!this.imageCache[src.src]) {\n                img.src = src.src;\n                this.imageCache[src.src] = img;\n            }\n            const isAnimated = /\\.(webm|apng|gif)$/i.test(src.src);\n            img.onload = () => {\n                const canvas = this.image_canvas.nodes[0];\n                const ambientCanvas = this.image_ambient.nodes[0];\n                const ctx = canvas.getContext('2d');\n                const ambientCtx = ambientCanvas.getContext('2d');\n                canvas.width = this.image_wrapper.nodes[0].clientWidth;\n                canvas.height = this.image_wrapper.nodes[0].clientHeight;\n                ambientCanvas.width = canvas.width * 1.2;\n                ambientCanvas.height = canvas.height * 1.2;\n                if (isAnimated) {\n                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n                    if (this.config.ambient) {\n                        ambientCtx.drawImage(img, (ambientCanvas.width - canvas.width) / 2, (ambientCanvas.height - canvas.height) / 2, canvas.width, canvas.height);\n                    }\n                    return;\n                }\n                const aspectRatio = img.width / img.height;\n                let width = this.window_width * this.scale;\n                let height = this.window_height * this.scale;\n                if (width / height > aspectRatio) {\n                    width = height * aspectRatio;\n                } else {\n                    height = width / aspectRatio;\n                }\n                const offsetX = (canvas.width - width) / 2;\n                const offsetY = (canvas.height - height) / 2;\n                ctx.setTransform(this.scale, 0, 0, this.scale, this.panX + offsetX, this.panY + offsetY);\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.drawImage(img, 0, 0, width, height);\n                if (this.config.ambient) {\n                    const ambientOffsetX = (ambientCanvas.width - width * this.config.ambientSize) / 2;\n                    const ambientOffsetY = (ambientCanvas.height - height * this.config.ambientSize) / 2;\n                    ambientCtx.setTransform(this.scale * this.config.ambientSize, 0, 0, this.scale * this.config.ambientSize, this.panX * this.config.ambientSize + ambientOffsetX, this.panY * this.config.ambientSize + ambientOffsetY);\n                    ambientCtx.clearRect(0, 0, ambientCanvas.width, ambientCanvas.height);\n                    ambientCtx.drawImage(img, 0, 0, width, height);\n                }\n                if (this.config.dynamicBackground) {\n                    Q.Debounce('update_ambient', 1000, () => {\n                        Q.AvgColor(canvas, 10, (color) => {\n                            this.image_viewer.css('background', `rgba(${color.r}, ${color.g}, ${color.b}, 0.77)`);\n                        });\n                    });\n                }\n            };\n            if (img.complete) {\n                img.onload();\n            }\n        }\n        updateNavigation() {\n            if (this.images.length > 1) {\n                if (this.currentIndex > 0) {\n                    this.left_button.show();\n                } else {\n                    this.left_button.hide();\n                }\n                if (this.currentIndex < this.images.length - 1) {\n                    this.right_button.show();\n                } else {\n                    this.right_button.hide();\n                }\n            } else {\n                this.left_button.hide();\n                this.right_button.hide();\n            }\n        }\n        setSelector(selector) {\n            this.selector = selector;\n            this.addEventListener();\n        }\n        remove() {\n            this.removeEventListener();\n            this.image_viewer.remove();\n        }\n        source(images) {\n            this.images = images.map((img, index) => ({\n                src: img.source,\n                title: img.title,\n                desc: img.desc\n            }));\n            this.currentIndex = 0;\n        }\n    }\n    let viewer = new Viewer();\n    return {\n        selector: function (selector) {\n            viewer.setSelector(selector);\n            return this;\n        },\n        open: function (images) {\n            viewer.open(images);\n            return this;\n        },\n        close: function () {\n            viewer.close();\n            return this;\n        },\n        remove: function () {\n            viewer.remove();\n            return this;\n        },\n        config: function (options) {\n            Object.assign(viewer.config, options);\n            return this;\n        },\n        source: function (images) {\n            viewer.source(images);\n            return this;\n        }\n    };\n}"
        },
        "JSON": {
            "uuid": "6791f475-5aa8-4f08-8f71-2528d9a9499f",
            "name": "JSON",
            "method": "Plugin",
            "desc": "Provides methods to parse, deflate, inflate, merge, sort, and flatten JSON objects.",
            "type": "Plugin",
            "example": "//   let json = Q.JSON({ key: 'value' });",
            "dependencies": [],
            "script": "Q.JSON = function (jsonData) {\n    if (!(this instanceof Q.JSON)) return new Q.JSON(jsonData);\n    this.json = jsonData;\n};\nQ.JSON.prototype.Parse = function (options = { modify: false, recursive: false }, callback) {\n    const { modify, recursive } = options;\n    const process = (data) => {\n        if (typeof data === 'object' && data && !Array.isArray(data)) {\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    const newValue = callback(key, data[key]);\n                    if (modify) data[key] = newValue;\n                    if (recursive && typeof data[key] === 'object' && data[key]) process(data[key]);\n                }\n            }\n        }\n    };\n    process(this.json);\n    return this.json;\n};\nQ.JSON.prototype.deflate = function (level) {\n    const map = {}, deflateCounter = { count: 1 };\n    const replaceRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                if (typeof obj[key] === 'object' && obj[key]) replaceRecursive(obj[key]);\n                if (key.length >= level) {\n                    if (!map[key]) { map[key] = `[${deflateCounter.count++}]`; }\n                    const newKey = map[key];\n                    obj[newKey] = obj[key]; delete obj[key];\n                }\n                if (typeof obj[key] === 'string' && obj[key].length >= level) {\n                    if (!map[obj[key]]) { map[obj[key]] = `[${deflateCounter.count++}]`; }\n                    obj[key] = map[obj[key]];\n                }\n            }\n        }\n    };\n    const deflatedData = JSON.parse(JSON.stringify(this.json));\n    replaceRecursive(deflatedData);\n    return { data: deflatedData, map: map };\n};\nQ.JSON.prototype.inflate = function (deflatedJson) {\n    const { data, map } = deflatedJson;\n    const reverseMap = Object.fromEntries(Object.entries(map).map(([k, v]) => [v, k]));\n    const restoreRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                const originalKey = reverseMap[key] || key;\n                const value = obj[key]; delete obj[key];\n                obj[originalKey] = value;\n                if (typeof obj[originalKey] === 'object' && obj[originalKey]) {\n                    restoreRecursive(obj[originalKey]);\n                } else if (reverseMap[obj[originalKey]]) {\n                    obj[originalKey] = reverseMap[obj[originalKey]];\n                }\n            }\n        }\n    };\n    const inflatedData = JSON.parse(JSON.stringify(data));\n    restoreRecursive(inflatedData);\n    return inflatedData;\n};\nQ.JSON.prototype.merge = function (otherJson) {\n    const deepMerge = (target, source) => {\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                if (typeof source[key] === 'object' && source[key] && !Array.isArray(source[key])) {\n                    target[key] = deepMerge(target[key] && typeof target[key] === 'object' ? target[key] : {}, source[key]);\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return deepMerge(this.json, otherJson);\n};\nQ.JSON.prototype.sortKeys = function (recursive = false, reverse = false) {\n    const sortObject = (obj) => {\n        const keys = Object.keys(obj).sort();\n        if (reverse) keys.reverse();\n        const sorted = {};\n        keys.forEach(key => {\n            sorted[key] = (recursive && typeof obj[key] === 'object' && obj[key] && !Array.isArray(obj[key])) ? sortObject(obj[key]) : obj[key];\n        });\n        return sorted;\n    };\n    this.json = sortObject(this.json);\n    return this.json;\n};\nQ.JSON.prototype.sortValues = function (reverse = false) {\n    if (typeof this.json !== 'object' || !this.json) return this.json;\n    const entries = Object.entries(this.json).sort((a, b) => {\n        const aValue = String(a[1]), bValue = String(b[1]);\n        return aValue.localeCompare(bValue);\n    });\n    if (reverse) entries.reverse();\n    const sorted = {};\n    for (const [key, value] of entries) sorted[key] = value;\n    this.json = sorted;\n    return this.json;\n};\nQ.JSON.prototype.sortByValues = function (keyProp, valueProp, reverse = false) {\n    if (!Array.isArray(this.json)) return this.json;\n    this.json.sort((a, b) => {\n        const cmpKey = String(a[keyProp]).localeCompare(String(b[keyProp]));\n        const cmpValue = String(a[valueProp]).localeCompare(String(b[valueProp]));\n        const cmp = cmpKey || cmpValue;\n        return reverse ? -cmp : cmp;\n    });\n    return this.json;\n};\nQ.JSON.prototype.flatten = function (prefix = '') {\n    const result = {};\n    const flattenRec = (obj, path) => {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                const newKey = path ? `${path}.${key}` : key;\n                if (typeof obj[key] === 'object' && obj[key] && !Array.isArray(obj[key])) {\n                    flattenRec(obj[key], newKey);\n                } else {\n                    result[newKey] = obj[key];\n                }\n            }\n        }\n    };\n    flattenRec(this.json, prefix);\n    return result;\n};\nQ.JSON.prototype.unflatten = function (flatObject) {\n    const result = {};\n    Object.keys(flatObject).forEach(compoundKey => {\n        compoundKey.split('.').reduce((accumulator, currentKey, index, keysArray) => {\n            if (index === keysArray.length - 1) {\n                accumulator[currentKey] = flatObject[compoundKey];\n            } else {\n                if (!accumulator[currentKey] || typeof accumulator[currentKey] !== 'object') {\n                    accumulator[currentKey] = {};\n                }\n            }\n            return accumulator[currentKey];\n        }, result);\n    });\n    this.json = result;\n    return result;\n};"
        },
        "NodeBlock": {
            "uuid": "c853f386-b4ee-4f60-9517-f402c2d4c8e9",
            "name": "NodeBlock",
            "method": "Plugin",
            "desc": "A plugin for creating UML blocks and connections.",
            "type": "Plugin",
            "example": "var uml = Q.NodeBlock('#canvas', 800, 600); // Create a new UML canvas",
            "dependencies": [
                "ColorBrightness",
                "isDarkColor",
                "Style"
            ],
            "script": "Q.NodeBlock = function (selector, width, height, options) {\n    let classes = Q.style(`\n.node_preferences {\n    position: absolute;\n    background: #181818;\n    overflow: hidden;\n    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);\n}\n.node_preferences_big {\n    width: 350px;\n    max-height: 350px;\n    overflow-y: scroll;\n}\n.node_preferences_small {\nwidth: 200px;\noverflow-y: auto;\n    }\n.pref_content h1, .pref_content h2, .pref_content h3, .pref_content h4, .pref_content h5, .pref_content h6 {\nline-break: anywhere;\nmargin: 0 0 2px 0;\npadding: 0;\n}\n.pref_content h1 { font-size: 150%; }\n.pref_content h2 { font-size: 140%; }\n.pref_content h3 { font-size: 130%; }\n.pref_content h4 { font-size: 120%; }\n.pref_content h5 { font-size: 110%; }\n.pref_content h6 { font-size: 100%; }\n.pref_content p { margin: 0; padding: 0; color: #7a7a7a; }\n.pref_content ul { margin: 5px 5px; padding-left: 15px; color: #7a7a7a; }\n.pref_content li { padding: 0px; margin: 0px; }\n.pref_content table { border-collapse: collapse; width: 100%; }\n.pref_content table, th, td { padding: 0; margin: 0; font-size: 90%; line-break: anywhere; border: 1px solid #222; }\n.pref_content th, td { padding: 1px; text-align: left; }\n.pref_content th { background-color: #222; }\n.pref_content tfoot { background-color: #222; }\n.pref_title {\n    font-size: 12px;\n    margin: 5px;\n    color: #7a7a7a;\n    text-align: center;\n}\n.node_preferences::-webkit-scrollbar {\n    width: 10px;\n}\n.node_preferences::-webkit-scrollbar-track {\n    background: #3a3a3a;\n}\n.node_preferences::-webkit-scrollbar-thumb {\n    background: #242424;\n}\n.node_preferences::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n.pref_content {\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n    padding: 5px 5px;\n}\n.pref_content img {\n    width: 100%;\n    height: auto;\n}\n.connection_content {\n    display: flex;\n    justify-content: space-between;\n}\n.left,\n.right {\n    width: 50%;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin: 5px;\n}\n.connection_wrapper {\n    display: flex;\n    justify-content: space-between;\n    margin: 1px;\n}\n.color_wrapper {\n    position: relative;\n    width: 20px;\n    height: 20px;\n    overflow: hidden;\n    flex-shrink: 0;\n}\n.color {\n    position: absolute;\n    width: 100px;\n    top: -20px;\n    left: -20px;\n    height: 100px;\n}\n.connection {\n    font-size: 12px;\npadding: 0 5px;\n    width: 100%;\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n}\n.button_nodes {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 8px;\n    width: 15px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_nodes_big {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 12px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_add\n{\n    margin:1px;\n    width: 20px;\n    height: 20px;\n}\n        `, {\n        \"node_preferences\": \"node_preferences\",\n        \"node_preferences_small\": \"node_preferences_small\",\n        \"node_preferences_big\": \"node_preferences_big\",\n        \"pref_title\": \"pref_title\",\n        \"pref_content\": \"pref_content\",\n        \"connection_content\": \"connection_content\",\n        \"left\": \"left\",\n        \"right\": \"right\",\n        \"connection_wrapper\": \"connection_wrapper\",\n        \"color_wrapper\": \"color_wrapper\",\n        \"connection\": \"connection\",\n        \"button_nodes\": \"button_nodes\",\n        \"button_nodes_big\": \"button_nodes_big\",\n        \"button_add\": \"button_add\",\n        \"name\": \"_name\",\n        \"content\": \"_content\",\n        \"manipulation\": \"manipulation\",\n        \"color\": \"color\",\n        \"pref_section\": \"pref_section\",\n    }, false);\n    class UMLBlock {\n        constructor(custom_style, appearance, id, name, text, x, y, width, connLeft = [], connRight = [], connections = []) {\n            this.name = name;\n            this.text = text;\n            this.t_text = \"\";\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.connections = connections;\n            this.connLeft = connLeft;\n            this.connRight = connRight;\n            this.height = 0;\n            this.isDragging = false;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            this.img = null;\n            this.content = null;\n            this.contentHeight = 0;\n            this.unescapedBase64Data = null;\n            this.appearance = appearance;\n            this.custom_style = custom_style;\n            this.appearance = Object.assign({}, this.appearance, custom_style);\n            this.darkText = '#ffffff';\n            this.lightText = '#000000';\n            this.update = true;\n            this.compiled_render = document.createElement('canvas');\n            this.block_context = this.compiled_render.getContext('2d');\n            this._processColors();\n        }\n        _restyle(object) {\n            this.custom_style = object;\n            this.appearance = Object.assign({}, this.appearance, object);\n            this._processColors();\n            this.t_text = '';\n        }\n        _processColors() {\n            const {\n                background,\n                factorTitleBackground,\n                factorDarkColorMargin,\n                factorDarkColorThreshold,\n                factorLightColors,\n                factorDarkColors,\n                darkTextColor,\n                lightTextColor\n            } = this.appearance;\n            const titleBg = Q.ColorBrightness(background, factorTitleBackground);\n            const isDark = Q.isDarkColor(background, factorDarkColorMargin, factorDarkColorThreshold);\n            const textColor = isDark ? darkTextColor : lightTextColor;\n            const borderColor = Q.ColorBrightness(background, isDark ? factorLightColors : factorDarkColors);\n            Object.assign(this.appearance, {\n                titleBackground: titleBg,\n                titleColor: textColor,\n                connectionTextColor: textColor,\n                textColor: textColor,\n                node_table_color: borderColor\n            });\n        }\n        _drawContainer(ctx, x, y, width, height) {\n            const { shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, background, radius, connectionPointSize } = this.appearance;\n            ctx.save();\n            Object.assign(ctx, {\n                fillStyle: background,\n                shadowColor,\n                shadowBlur,\n                shadowOffsetX,\n                shadowOffsetY\n            });\n            ctx.beginPath();\n            ctx.moveTo(x + radius, y);\n            ctx.lineTo(x + width - radius, y);\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n            ctx.lineTo(x + width, y + height - radius);\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n            ctx.lineTo(x + radius, y + height);\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n            ctx.lineTo(x, y + radius);\n            ctx.quadraticCurveTo(x, y, x + radius, y);\n            ctx.fill();\n            ctx.restore();\n        }\n        _drawTitle(ctx, x, y, width, height, title) {\n            ctx.fillStyle = this.appearance.titleBackground;\n            ctx.beginPath();\n            ctx.moveTo(x + this.appearance.radius, y);\n            ctx.arcTo(x + width, y, x + width, y + height, this.appearance.radius);\n            ctx.arcTo(x + width, y + height, x, y + height, 0);\n            ctx.arcTo(x, y + height, x, y, 0);\n            ctx.arcTo(x, y, x + width, y, this.appearance.radius);\n            ctx.closePath();\n            ctx.fill();\n            ctx.fillStyle = this.appearance.titleColor;\n            ctx.font = 'bold ' + this.appearance.fontSizeTitle + 'px ' + this.appearance.font;\n            const titleX = x + (width - ctx.measureText(title).width) / 2;\n            const titleY = y + (height + this.appearance.fontSizeTitle) / 2;\n            ctx.fillText(title, titleX, titleY);\n        }\n        parseHTML2Canvas(html, callback) {\n            const renderElements = () => {\n                if (this.t_text == html) {\n                    callback(this.content, this.contentHeight);\n                    return;\n                }\n                this.t_text = html;\n                let tempContainer = document.createElement('div');\n                tempContainer.style.position = 'absolute';\n                tempContainer.style.visibility = 'hidden';\n                tempContainer.style.width = (this.width - this.appearance.fontSize) + 'px';\n                document.body.appendChild(tempContainer);\n                let style = document.createElement('style');\n                let st = `\n        table {border-collapse: collapse; width: 100%;}\n        table, th, td {padding: 0; margin: 0; font-size: ${(this.appearance.fontSize * 0.9)}px; line-break: anywhere;border: 1px solid ${this.appearance.node_table_color};}\n        th, td {padding: 1px; text-align: left;}\n        th {background-color: ${this.appearance.node_table_color};}\n        tfoot {background-color: ${this.appearance.node_table_color};}\n        h1, h2, h3, h4, h5, h6 {line-break: anywhere; margin: 0 0 2px 0; padding: 0;}\n        h1 {font-size: ${(this.appearance.fontSize * 1.5)}px;}\n        h2 {font-size: ${(this.appearance.fontSize * 1.4)}px;}\n        h3 {font-size: ${(this.appearance.fontSize * 1.3)}px;}\n        h4 {font-size: ${(this.appearance.fontSize * 1.2)}px;}\n        h5 {font-size: ${(this.appearance.fontSize * 1.1)}px;}\n        h6 {font-size: ${(this.appearance.fontSize * 1.0)}px;}\n                        p { margin: 0; padding: 0; color: ${this.appearance.textColor}; }\n                        ul { margin: 5px 5px; padding-left: 15px; color: ${this.appearance.textColor}; }\n                        li { padding: 0px; margin: 0px; }\n                        div {font-family: ${this.appearance.font}, sans-serif; font-size: ${this.appearance.fontSize}px; color: ${this.appearance.textColor}; }\n                    `;\n                style.innerHTML = st;\n                document.head.appendChild(style);\n                tempContainer.innerHTML = html;\n                this.contentHeight = tempContainer.offsetHeight + this.appearance.padding;\n                document.body.removeChild(tempContainer);\n                document.head.removeChild(style);\n                this.content = document.createElement('canvas');\n                this.content.width = this.width;\n                this.content.height = this.contentHeight;\n                let ctx = this.content.getContext('2d');\n                let data = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + (this.width - (this.appearance.padding * 2)) + '\" height=\"' + this.contentHeight + '\">' + // Update SVG height\n                    '<foreignObject width=\"100%\" height=\"100%\">' +\n                    '<style>' +\n                    st +\n                    '</style>' +\n                    '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +\n                    html +\n                    '</div>' +\n                    '</foreignObject>' +\n                    '</svg>';\n                let DOMURL = window.URL || window.webkitURL || window;\n                let img = new Image();\n                let svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });\n                let url = DOMURL.createObjectURL(svg);\n                img.onload = () => {\n                    ctx.drawImage(img, 0, 0);\n                    DOMURL.revokeObjectURL(url);\n                    callback(this.content, this.contentHeight);\n                };\n                img.src = url;\n            };\n            html = html.replace(/style=\"[^\"]*\"/g, '');\n            let images = [];\n            html = html.replace(/<br>/g, '');\n            if (html.includes('<img')) {\n                let imgTags = html.match(/<img[^>]+>/g);\n                imgTags.forEach((imgTag, index) => {\n                    let src = imgTag.match(/src=\"([^\"]*)\"/)[1];\n                    let img = new Image();\n                    img.src = src;\n                    img.onload = () => {\n                        images[index] = img;\n                        if (images.length === imgTags.length) {\n                            renderElements();\n                        }\n                    };\n                });\n            }\n            else {\n                renderElements();\n            }\n        }\n        draw(main_context) {\n            const TITLE_HEIGHT = this.appearance.fontSizeTitle + (this.appearance.padding * 2);\n            const CONNECTION_HEIGHT = this.appearance.padding + TITLE_HEIGHT;\n            const CONNECTION_PADDING = (this.appearance.connectionPointSize * 2) + this.appearance.connectionPointPadding;\n            const maxConnectionsHeight = Math.max(this.connLeft.length, this.connRight.length) * CONNECTION_PADDING;\n            if (this.update) {\n                const updateContainerHeight = (contentHeight) => {\n                    this.height = TITLE_HEIGHT + (this.appearance.padding * 2) + maxConnectionsHeight + contentHeight + this.appearance.padding;\n                    this.block_context.canvas.height = this.height;\n                    this.block_context.canvas.width = this.width + (this.appearance.connectionPointSize * 2);\n                };\n                this.parseHTML2Canvas(this.text, (canvas, contentHeight) => {\n                    updateContainerHeight(contentHeight);\n                    this._drawContainer(this.block_context, this.appearance.connectionPointSize, 0, this.width - 5, this.height, this.appearance.radius);\n                    this._drawTitle(this.block_context, this.appearance.connectionPointSize, 0, this.width - this.appearance.connectionPointSize, TITLE_HEIGHT, this.name);\n                    this.block_context.drawImage(canvas, this.appearance.padding, TITLE_HEIGHT + this.appearance.padding + maxConnectionsHeight);\n                    this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                    main_context.drawImage(this.compiled_render, this.x, this.y);\n                });\n                this.update = false;\n            }\n            else {\n                this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                main_context.drawImage(this.compiled_render, this.x, this.y);\n            }\n            return;\n        }\n        drawConnectionPoints(ctx, paddingTop, height) {\n            const connectionY = paddingTop;\n            const font = `bold ${this.appearance.fontSizeConnection}px ${this.appearance.font}`;\n            const pointSize = this.appearance.connectionPointSize;\n            const connectionPaddingX = this.appearance.connectionTextPaddingX;\n            const middleYOffset = ((pointSize / 2) + (this.appearance.fontSizeConnection / 2)) - this.appearance.connectionTextPaddingY;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            ctx.font = font;\n            const drawConnectionPoints = (connList, coordsArray, baseX, getTextX) => {\n                connList.forEach((conn, index) => {\n                    const connY = connectionY + index * height;\n                    coordsArray.push({ x: baseX, y: connY });\n                    ctx.fillStyle = conn.color || this.appearance.connectionColor;\n                    ctx.beginPath();\n                    ctx.arc(baseX, connY, pointSize, 0, 2 * Math.PI);\n                    ctx.fill();\n                    ctx.fillStyle = this.appearance.connectionTextColor;\n                    ctx.fillText(conn.title, getTextX(conn.title, baseX), connY + middleYOffset);\n                });\n            };\n            if (Array.isArray(this.connLeft)) {\n                drawConnectionPoints(this.connLeft, this.leftConnCoords, this.appearance.connectionPointSize, (title, baseX) => baseX + connectionPaddingX * 2);\n            }\n            if (Array.isArray(this.connRight)) {\n                drawConnectionPoints(this.connRight, this.rightConnCoords, this.width, (title, baseX) => baseX - ctx.measureText(title).width - connectionPaddingX * 2);\n            }\n        }\n        addConnection(conn) {\n            this.connections.push(conn);\n        }\n        removeConnection(conn) {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n        }\n        isMouseOver(mouseX, mouseY) {\n            return mouseX >= this.x && mouseX <= this.x + this.width && mouseY >= this.y && mouseY <= this.y + this.height;\n        }\n        getAllConnectionCoords() {\n            return [\n                ...this.leftConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y })),\n                ...this.rightConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y }))\n            ];\n        }\n        getConnectionCoord(point, index) {\n            return point === 'left' ? this.leftConnCoords[index] : this.rightConnCoords[index];\n        }\n    }\n    class UMLCanvas {\n        constructor(selector, width, height, appearance, classes) {\n            this.element_parent = Q(selector);\n            this.canvas = Q('<canvas>', { width: width, height: height });\n            this.width = width;\n            this.height = height;\n            this.element_parent.append(this.canvas);\n            this.canvas_context = this.canvas.nodes[0].getContext('2d');\n            this.blocks = [];\n            this.connections = [];\n            this.draggingBlock = null;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.connection_start = null;\n            this.connection_end = null;\n            this.mouseX = 0;\n            this.mouseY = 0;\n            this.isMenuPreferences = false;\n            this.isDraggingBlock = false;\n            this.isOverConnection = false;\n            this.appearance = appearance;\n            this.classes = classes;\n            this.canvas.on('click', this._event_click.bind(this));\n            this.canvas.on('mousedown', this._event_pointer_down.bind(this));\n            this.canvas.on('mousemove', this._event_pointer_move.bind(this));\n            this.canvas.on('mouseup', this._event_pointer_up.bind(this));\n            this.canvas.on('contextmenu', this._event_click_right.bind(this), false);\n        }\n        import(uml) {\n            const blockCreationPromises = uml.blocks.map(async (block) => {\n                const newBlock = new UMLBlock(\n                    block.custom_style,\n                    this.appearance,\n                    block.id, block.name, block.text, block.x, block.y, block.width,\n                    block.connLeft.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connRight.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connections\n                );\n                this.addBlock(newBlock);\n            });\n            Promise.all(blockCreationPromises).then(() => {\n                uml.connections.forEach(conn => {\n                    const startBlock = this.blocks.find(b => b.id === conn.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.target);\n                    const startCoords = this._point_coords(startBlock, conn.point);\n                    const endCoords = this._point_coords(endBlock, conn.targetPoint);\n                    if (startCoords && endCoords) {\n                        this._connection_create(\n                            { block: startBlock, point: conn.point, x: startCoords.x, y: startCoords.y },\n                            { block: endBlock, point: conn.targetPoint, x: endCoords.x, y: endCoords.y }\n                        );\n                    } else {\n                        console.error('Connection failed to initialize:', startBlock, endBlock);\n                    }\n                });\n            }).catch(err => {\n                console.error('Error during block initialization:', err);\n            });\n        }\n        export() {\n            return {\n                blocks: this.blocks.map(block => ({\n                    custom_style: block.custom_style,\n                    id: block.id,\n                    name: block.name,\n                    text: block.text,\n                    x: block.x,\n                    y: block.y,\n                    width: block.width,\n                    connLeft: block.connLeft,\n                    connRight: block.connRight,\n                    connections: block.connections\n                })),\n                connections: this.connections.map(conn => ({\n                    id: conn.start.block.id,\n                    point: conn.start.point,\n                    target: conn.end.block.id,\n                    targetPoint: conn.end.point\n                }))\n            };\n        }\n        async addBlock(block) {\n            this.blocks.push(block);\n            await this._connections_init(block);\n            this.render();\n        }\n        removeBlock(block) {\n            this.blocks = this.blocks.filter(b => b.id !== block.id);\n            this.connections = this.connections.filter(conn =>\n                conn.start.block.id !== block.id && conn.end.block.id !== block.id\n            );\n            this.render();\n        }\n        getJointContent() {\n            let block = this.blocks[0];\n            let content = block.text;\n            let connections = block.connections;\n            let nextBlock = null;\n            while (connections.length > 0) {\n                let conn = connections[0];\n                nextBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                content += nextBlock.text;\n                connections = nextBlock.connections;\n            }\n            return content;\n        }\n        duplicateBlock(block) {\n            let id = this._id();\n            const newBlock = new UMLBlock(\n                block.custom_style,\n                this.appearance,\n                id, block.name, block.text, block.x + 50, block.y + 50, block.width,\n                block.connLeft, block.connRight, []\n            );\n            this.addBlock(newBlock);\n        }\n        render_grid() {\n            let ctx = this.canvas_context;\n            let w = this.width;\n            let h = this.height;\n            let grid_size = this.appearance.gridSize;\n            let grid_color = this.appearance.gridColor;\n            ctx.strokeStyle = grid_color;\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            for (let x = 0; x <= w; x += grid_size) {\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, h);\n            }\n            for (let y = 0; y <= h; y += grid_size) {\n                ctx.moveTo(0, y);\n                ctx.lineTo(w, y);\n            }\n            ctx.stroke();\n        }\n        render() {\n            this.canvas_context.clearRect(0, 0, this.width, this.height);\n            this.render_grid();\n            this.connections.forEach(conn => {\n                let startBlock = conn.start.block;\n                let endBlock = conn.end.block;\n                let startColor = this._getConnectionColor(startBlock, conn.start.point);\n                let endColor = this._getConnectionColor(endBlock, conn.end.point);\n                this.canvas_context.strokeStyle = 'rgb(150, 150, 150)';\n                this.canvas_context.beginPath();\n                this.canvas_context.lineWidth = 2;\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + conn.start.x, startBlock.y + conn.start.y,\n                    endBlock.x + conn.end.x, endBlock.y + conn.end.y\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, endColor);\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.moveTo(startBlock.x + conn.start.x, startBlock.y + conn.start.y);\n                this.canvas_context.lineTo(endBlock.x + conn.end.x, endBlock.y + conn.end.y);\n                this.canvas_context.stroke();\n                let dx = (endBlock.x + conn.end.x) - (startBlock.x + conn.start.x);\n                let dy = (endBlock.y + conn.end.y) - (startBlock.y + conn.start.y);\n                let length = Math.sqrt(dx * dx + dy * dy);\n                let unitDx = dx / length;\n                let unitDy = dy / length;\n                let arrowLength = 10;\n                let arrowWidth = 5;\n                for (let i = 100; i < length; i += 200) {\n                    let x = (startBlock.x + conn.start.x) + unitDx * i;\n                    let y = (startBlock.y + conn.start.y) + unitDy * i;\n                    this.canvas_context.beginPath();\n                    this.canvas_context.moveTo(x, y);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx + arrowWidth * unitDy, y - arrowLength * unitDy - arrowWidth * unitDx);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx - arrowWidth * unitDy, y - arrowLength * unitDy + arrowWidth * unitDx);\n                    this.canvas_context.closePath();\n                    this.canvas_context.fillStyle = gradient;\n                    this.canvas_context.fill();\n                }\n            });\n            if (this.connection_start && this.connection_end === null) {\n                let startBlock = this.connection_start.block;\n                let startColor = this._getConnectionColor(startBlock, this.connection_start.point);\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y,\n                    this.mouseX, this.mouseY\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, \"rgb(150, 150, 150)\");\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.beginPath();\n                this.canvas_context.moveTo(startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y);\n                this.canvas_context.lineTo(this.mouseX, this.mouseY);\n                this.canvas_context.stroke();\n            }\n            this.blocks.forEach(block => {\n                block.draw(this.canvas_context);\n            });\n            this._connection_update();\n        }\n        _getConnectionColor(block, pointId) {\n            const connection = [...block.connLeft, ...block.connRight]\n                .find(conn => conn.id === pointId);\n            return connection ? connection.color : null;\n        }\n        updateConnections(block) {\n            const preferences = Q('.' + classes.node_preferences);\n            const collectConnections = (sideClass) => {\n                const side = preferences.find('.' + sideClass);\n                const connections = [];\n                side.find('.' + classes.connection_wrapper).walk((element) => {\n                    const id = element.id();\n                    const title = element.find('.' + classes.connection).val() || '';\n                    const color = element.find('.' + classes.color).val();\n                    connections.push({ id, title, color });\n                }, true);\n                return connections;\n            };\n            const newLeftConnections = collectConnections(classes.left);\n            const newRightConnections = collectConnections(classes.right);\n            const newConnections = [...newLeftConnections, ...newRightConnections];\n            const existingConnections = [...block.connLeft, ...block.connRight];\n            newConnections.forEach(newConn => {\n                const existingConn = existingConnections.find(conn => conn.id === newConn.id);\n                if (existingConn) {\n                    existingConn.title = newConn.title;\n                    existingConn.color = newConn.color;\n                } else {\n                    existingConnections.push(newConn);\n                }\n            });\n        }\n        updateBlock(selectedblock = null, callback) {\n            let preferences = Q('.' + classes.node_preferences);\n            let block;\n            if (selectedblock) {\n                block = selectedblock;\n            }\n            else {\n                block = this.blocks.find(b => b.id === preferences.id());\n            }\n            let name = preferences.find('#' + classes.name).text();\n            let content = preferences.find('#' + classes.content).html();\n            block.name = name;\n            block.text = content;\n            block.update = true;\n            if (callback) callback(block);\n        }\n        _event_pointer_down(event) {\n            if (event.button === 2) return;\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                let block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this.isDraggingBlock = true;\n                    this.draggingBlock = block;\n                    this.offsetX = mouseX - block.x;\n                    this.offsetY = mouseY - block.y;\n                    block.isDragging = true;\n                    break;\n                }\n            }\n        }\n        _event_pointer_move(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.draggingBlock) {\n                if (this.appearance.snapToGrid) {\n                    this.draggingBlock.x = Math.round(this.draggingBlock.x / this.appearance.gridSize) * this.appearance.gridSize;\n                    this.draggingBlock.y = Math.round(this.draggingBlock.y / this.appearance.gridSize) * this.appearance.gridSize;\n                    if (!this.lastMouseX || Math.abs(mouseX - this.lastMouseX) >= this.appearance.gridSize || Math.abs(mouseY - this.lastMouseY) >= this.appearance.gridSize) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                } else {\n                    if (!this.lastMouseX || Math.abs(mouseX - this.lastMouseX) >= this.appearance.movementResolution || Math.abs(mouseY - this.lastMouseY) >= this.appearance.movementResolution) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                }\n                return;\n            }\n            if (this.connection_start && this.connection_end === null) {\n                this.mouseX = mouseX;\n                this.mouseY = mouseY;\n                this.render();\n                return;\n            }\n            if (this.isOverConnection) {\n                this.isOverConnection = false;\n                this.render();\n            }\n            this.connections.forEach(conn => {\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    if (!this.isOverConnection) {\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y, this.appearance.connectionPointSize + 2, 0, 2 * Math.PI);\n                        let startColor = this._getConnectionColor(conn.start.block, conn.start.point);\n                        this.canvas_context.strokeStyle = startColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y, this.appearance.connectionPointSize + 2, 0, 2 * Math.PI);\n                        let endColor = this._getConnectionColor(conn.end.block, conn.end.point);\n                        this.canvas_context.strokeStyle = endColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.isOverConnection = true;\n                    }\n                }\n            });\n        }\n        _event_pointer_up(event) {\n            if (this.draggingBlock) {\n                this.isDraggingBlock = false;\n                this.draggingBlock.isDragging = false;\n                this.draggingBlock = null;\n                this.render();\n            }\n            if (this.connection_start && this.connection_end === null) {\n                setTimeout(() => {\n                    this.connection_start = null;\n                    this.mouseX = 0;\n                    this.mouseY = 0;\n                    this.render();\n                }, 100);\n            }\n        }\n        _event_click(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            for (let block of this.blocks) {\n                if (this._connection_over_point(block, mouseX, mouseY)) {\n                    if (this.connection_start === null) {\n                        this.connection_start = this._point_details(block, mouseX, mouseY);\n                    }\n                    else if (this.connection_end === null) {\n                        this.connection_end = this._point_details(block, mouseX, mouseY);\n                        if (this.connection_start.block !== this.connection_end.block &&\n                            !this._connection_exists(this.connection_start, this.connection_end)) {\n                            this._connection_create(this.connection_start, this.connection_end);\n                            block.addConnection({ id: this.connection_start.block.id, point: this.connection_start.point });\n                        } else {\n                            this.connection_start = null;\n                            this.connection_end = null;\n                            this.render();\n                        }\n                        this.connection_start = null;\n                        this.connection_end = null;\n                    }\n                    return;\n                }\n            }\n        }\n        _menu_context(x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_small], style: { position: 'absolute', left: x + 'px', top: y + 'px' } });\n            this.isMenuPreferences = true;\n            let add = Q('<div>', { class: ['button_nodes_big'], text: 'Create Block' });\n            add.on('click', () => {\n                let id = this._id();\n                let nodes = this.blocks.length + 1;\n                let block = new UMLBlock({}, this.appearance, id, 'Node ' + nodes, 'Content', x, y, this.appearance.blockWidth, [{ id: this._id(), title: '', color: this.appearance.connectionColor }], [{ id: this._id(), title: '', color: this.appearance.connectionColor }]);\n                this.addBlock(block);\n                this._menu_remove();\n            });\n            div.append(add);\n            this.element_parent.append(div);\n        }\n        _event_click_right(event) {\n            event.preventDefault();\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                const block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this._menu_remove();\n                    this._menu_preferences(block, mouseX, mouseY);\n                    return;\n                }\n            }\n            for (let i = 0; i < this.connections.length; i++) {\n                const conn = this.connections[i];\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    const startBlock = this.blocks.find(b => b.id === conn.start.block.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                    if (startBlock && endBlock) {\n                        startBlock.removeConnection({ id: endBlock.id, point: conn.start.point });\n                    }\n                    this.connections.splice(i, 1);\n                    this.render();\n                    return;\n                }\n            }\n            this._menu_context(mouseX, mouseY);\n            this.render();\n        }\n        _id() {\n            return '_' + Math.random().toString(36).substr(2, 9);\n        }\n        _menu_remove() {\n            Q('.' + classes.node_preferences).remove();\n            this.isMenuPreferences = false;\n        }\n        _menu_item_section(title, content) {\n            let div = Q('<div>', { class: [classes.pref_section] });\n            let titleDiv = Q('<div>', { class: [classes.pref_title], text: title });\n            div.append(titleDiv, content);\n            return div;\n        }\n        _menu_item_input(id, content, placeholder) {\n            let input = Q('<div>', { class: [classes.pref_content], id: id, contentEditable: true, html: content, placeholder: placeholder });\n            return input;\n        }\n        _menu_item_connections(block) {\n            let div = Q('<div>', { class: [classes.connection_content] });\n            let left = Q('<div>', { class: [classes.left] });\n            let right = Q('<div>', { class: [classes.right] });\n            const connItem = (pos, conn) => {\n                let connection_wrapper = Q('<div>', { class: [classes.connection_wrapper], id: conn.id });\n                let connection = Q('<input>', { class: [classes.connection], type: 'text', value: conn.title, placeholder: 'Point...', maxLength: 10 });\n                let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n                let color = Q('<input>', { class: [classes.color], type: 'color', value: conn.color });\n                color_wrapper.append(color);\n                color.on('change', () => {\n                    conn.color = color.val();\n                    this.render();\n                });\n                connection.on('input', () => {\n                    let contitle = connection.val();\n                    conn.title = (conn.title && contitle !== null) ? contitle : '';\n                    this.updateConnections(block);\n                    this.render();\n                });\n                connection_wrapper.append(color_wrapper, connection);\n                let remove = Q('<div>', { class: [classes.button_nodes], text: 'X' });\n                remove.on('click', () => {\n                    connection_wrapper.remove();\n                    this.connections = this.connections.filter(c => {\n                        if (c.start.block.id === block.id && c.start.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.end.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.end.point });\n                            return false;\n                        }\n                        if (c.end.block.id === block.id && c.end.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.start.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.start.point });\n                            return false;\n                        }\n                        return true;\n                    });\n                    if (pos === 'left') { block.connLeft = block.connLeft.filter(c => c.id !== conn.id); }\n                    if (pos === 'right') { block.connRight = block.connRight.filter(c => c.id !== conn.id); }\n                    this.render();\n                });\n                connection_wrapper.append(remove);\n                return connection_wrapper;\n            };\n            block.connLeft.forEach(conn => {\n                let connection_wrapper = connItem('left', conn);\n                left.append(connection_wrapper);\n            });\n            block.connRight.forEach(conn => {\n                let connection_wrapper = connItem('right', conn);\n                right.append(connection_wrapper);\n            });\n            let add = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            add.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connLeft.push(connection);\n                left.append(connItem('left', connection));\n                left.append(add);\n                this.render();\n            });\n            left.append(add);\n            let addRight = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            addRight.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connRight.push(connection);\n                right.append(connItem('right', connection));\n                right.append(addRight);\n                this.render();\n            });\n            right.append(addRight);\n            div.append(left, right);\n            return div;\n        }\n        _menu_manipulation(block) {\n            let div = Q('<div>', { class: [classes.manipulation] });\n            let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n            let color = Q('<input>', { class: [classes.color], type: 'color', value: block.appearance.background });\n            color_wrapper.append(color);\n            color.on('change', () => {\n                block._restyle({ background: color.val() });\n                this.render();\n            });\n            div.append(color_wrapper);\n            let delete_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Delete Block' });\n            delete_button.on('click', () => {\n                this.removeBlock(block);\n                this._menu_remove();\n            });\n            let duplicate_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Duplicate Block' });\n            duplicate_button.on('click', () => {\n                this.duplicateBlock(block);\n                this._menu_remove();\n            });\n            div.append(color_wrapper, delete_button, duplicate_button);\n            return div;\n        }\n        _menu_preferences(block, x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_big], id: block.id });\n            div.css({ position: 'absolute', left: x + 'px', top: y + 'px' });\n            let title = this._menu_item_section('Class', this._menu_item_input(classes.name, block.name, 'Class name...'));\n            let content = this._menu_item_section('Content', this._menu_item_input(classes.content, block.text, 'Content...'));\n            let connections = this._menu_item_section('Connections', this._menu_item_connections(block));\n            let manipulation = this._menu_item_section('Manipulation', this._menu_manipulation(block));\n            div.append(title, content, connections, manipulation);\n            this.element_parent.append(div);\n            this.isMenuPreferences = true;\n        }\n        _connections_init(block) {\n            block.connections.forEach(conn => {\n                const targetBlock = this.blocks.find(b => b.id === conn.id);\n                if (targetBlock) {\n                    const startCoords = this._point_coords(block, 'right');\n                    const endCoords = this._point_coords(targetBlock, 'left');\n                    this._connection_create(\n                        { block: block, point: 'right', x: startCoords.x, y: startCoords.y },\n                        { block: targetBlock, point: conn.point, x: endCoords.x, y: endCoords.y }\n                    );\n                }\n            });\n        }\n        _blocks_connected(block1, block2) {\n            return this.connections.some(connection =>\n                (connection.start.block === block1 && connection.end.block === block2) ||\n                (connection.start.block === block2 && connection.end.block === block1)\n            );\n        }\n        _connection_exists(startConn, endConn) {\n            return this.connections.some(conn => {\n                const isDirectMatch =\n                    conn.start.block === startConn.block && conn.start.point === startConn.point &&\n                    conn.end.block === endConn.block && conn.end.point === endConn.point;\n                const isReverseMatch =\n                    conn.start.block === endConn.block && conn.start.point === endConn.point &&\n                    conn.end.block === startConn.block && conn.end.point === startConn.point;\n                return isDirectMatch || isReverseMatch;\n            });\n        }\n        _connection_create(startConn, endConn) {\n            this.connections.push({\n                start: { block: startConn.block, point: startConn.point, x: startConn.x, y: startConn.y },\n                end: { block: endConn.block, point: endConn.point, x: endConn.x, y: endConn.y }\n            });\n            startConn.block.addConnection({ id: endConn.block.id, point: startConn.point });\n            endConn.block.addConnection({ id: startConn.block.id, point: endConn.point });\n            this.render();\n        }\n        _connection_update() {\n            this.connections.forEach(conn => {\n                Object.assign(conn.start, this._point_coords(conn.start.block, conn.start.point));\n                Object.assign(conn.end, this._point_coords(conn.end.block, conn.end.point));\n            });\n        }\n        _point_coords(block, pointId) {\n            const connections = [\n                { coords: block.leftConnCoords, conns: block.connLeft },\n                { coords: block.rightConnCoords, conns: block.connRight }\n            ];\n            for (const { coords, conns } of connections) {\n                const index = conns.findIndex(conn => conn.id === pointId);\n                if (index !== -1) {\n                    return { x: coords[index].x, y: coords[index].y };\n                }\n            }\n            return { x: block.x, y: block.y };\n        }\n        _connection_over_point(block, x, y) {\n            const radius = 5;\n            return block.getAllConnectionCoords().some(coord => Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius);\n        }\n        _point_details(block, x, y) {\n            x -= block.x;\n            y -= block.y;\n            const radius = 5;\n            let matchedPoint = null;\n            block.leftConnCoords.forEach((coord, index) => {\n                if (Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius) {\n                    matchedPoint = { block: block, point: block.connLeft[index].id, x: coord.x, y: coord.y, index: index };\n                }\n            });\n            if (!matchedPoint) {\n                block.rightConnCoords.forEach((coord, index) => {\n                    if (Math.abs(x - coord.x) < radius && Math.abs(y - coord.y) < radius) {\n                        matchedPoint = { block: block, point: block.connRight[index].id, x: coord.x, y: coord.y, index: index };\n                    }\n                });\n            }\n            return matchedPoint;\n        }\n        _point_line_segment(px, py, x1, y1, x2, y2) {\n            const d1 = Math.hypot(px - x1, py - y1);\n            const d2 = Math.hypot(px - x2, py - y2);\n            const lineLen = Math.hypot(x2 - x1, y2 - y1);\n            return d1 + d2 >= lineLen - 0.1 && d1 + d2 <= lineLen + 0.1;\n        }\n        _point_line_distance(px, py, x1, y1, x2, y2) {\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            const lenSq = dx * dx + dy * dy;\n            let t = 0;\n            if (lenSq !== 0) {\n                t = ((px - x1) * dx + (py - y1) * dy) / lenSq;\n                t = Math.max(0, Math.min(1, t));\n            }\n            const projX = x1 + t * dx;\n            const projY = y1 + t * dy;\n            return Math.hypot(px - projX, py - projY);\n        }\n    }\n    let appearance = {\n        darkTextColor: '#888',\n        lightTextColor: '#222',\n        background: '#181818',\n        grid: true,\n        gridColor: '#161616',\n        gridSize: 20,\n        snapToGrid: false,\n        movementResolution: 3,\n        factorTitleBackground: -20,\n        factorDarkColors: -30,\n        factorLightColors: 80,\n        factorDarkColorMargin: 20,\n        factorDarkColorThreshold: 127,\n        blockWidth: 200,\n        connectionColor: '#333333',\n        connectionPointSize: 5,\n        connectionPointPadding: 5,\n        connectionTextPaddingX: 5,\n        connectionTextPaddingY: 5,\n        shadowBlur: 10,\n        shadowColor: 'rgba(0, 0, 0, 0.2)',\n        shadowOffsetX: 0,\n        shadowOffsetY: 5,\n        font: 'Arial',\n        fontSize: 12,\n        fontSizeTitle: 12,\n        fontSizeConnection: 10,\n        padding: 5,\n        radius: 10\n    };\n    appearance = Object.assign(appearance, options);\n    let uml = new UMLCanvas(selector, width, height, appearance, classes);\n    return {\n        import: function (data) {\n            uml.import(data);\n        },\n        export: function () {\n            return uml.export();\n        },\n        addBlock: function (block) {\n            uml.addBlock(block);\n        },\n        removeBlock: function (block) {\n            uml.removeBlock(block);\n        }\n    };\n}"
        },
        "Socket": {
            "uuid": "c8141ca3-dcfb-425b-86ee-2bc68c25d186",
            "name": "Socket",
            "method": "Plugin",
            "desc": "Provides a WebSocket implementation with automatic reconnection and status callbacks.",
            "type": "Plugin",
            "example": "var socket = Q.Socket('ws://localhost:8080', console.log, console.log);",
            "dependencies": [],
            "script": "Q.Socket = function (url, onMessage, onStatus, options = {}) {\n    const {\n        retries = 5,                   // Number of reconnection attempts (0 means unlimited)\n        delay = 1000,                  // Initial delay between reconnections in ms\n        protocols = [],                // WebSocket sub-protocols\n        backoff = false,               // Exponential backoff toggle\n        pingInterval = 0,              // Interval for heartbeat pings (ms); 0 disables\n        pingMessage = 'ping',          // Message to send for heartbeat\n        queueMessages = false,         // Queue messages if socket is not open yet\n        autoReconnect = true,          // Automatically reconnect on close\n        onOpen = null,                 // Additional callback on open\n        onClose = null,                // Additional callback on close\n        onError = null                 // Additional callback on error\n    } = options;\n    let socket, attempts = 0, currentDelay = delay, pingId = null;\n    const messageQueue = [];\n    const connect = () => {\n        socket = new WebSocket(url, protocols);\n        socket.onopen = () => {\n            attempts = 0;\n            currentDelay = delay;\n            onStatus?.('connected');\n            onOpen?.();\n            if (queueMessages && messageQueue.length) {\n                while (messageQueue.length) {\n                    socket.send(messageQueue.shift());\n                }\n            }\n            if (pingInterval) {\n                pingId && clearInterval(pingId);\n                pingId = setInterval(() => {\n                    if (socket.readyState === WebSocket.OPEN) {\n                        socket.send(pingMessage);\n                    }\n                }, pingInterval);\n            }\n        };\n        socket.onmessage = event => onMessage?.(event.data);\n        socket.onerror = error => {\n            onStatus?.('error', error);\n            onError?.(error);\n        };\n        socket.onclose = event => {\n            onClose?.(event);\n            pingId && clearInterval(pingId);\n            if (autoReconnect && (retries === 0 || attempts < retries)) {\n                onStatus?.('closed');\n                attempts++;\n                setTimeout(() => {\n                    connect();\n                    if (backoff) {\n                        currentDelay *= 2;\n                    }\n                }, currentDelay);\n            } else {\n                onStatus?.('Max retries exceeded');\n            }\n        };\n    };\n    connect();\n    return {\n        send: message => {\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                socket.send(message);\n            } else if (queueMessages) {\n                messageQueue.push(message);\n            }\n        },\n        reconnect: () => connect(),\n        close: () => {\n            autoReconnect = false;\n            pingId && clearInterval(pingId);\n            socket.close();\n        },\n        getState: () => socket?.readyState\n    };\n};"
        },
        "String": {
            "uuid": "053c6da8-034d-4bb9-aea6-9ba00f608378",
            "name": "String",
            "method": "Plugin",
            "desc": "Provides methods to manipulate strings.",
            "type": "Plugin",
            "example": "Q.String('hello').capitalize(); // returns 'Hello'",
            "dependencies": [],
            "script": "Q.String = function (string) {\n    if (!(this instanceof Q.String)) {\n        return new Q.String(string);\n    }\n    this.string = string;\n};\nQ.String.prototype.capitalize = function () {\n    return this.string.charAt(0).toUpperCase() + this.string.slice(1);\n};\nQ.String.prototype.levenshtein = function (string) {\n    const a = this.string, b = string;\n    const matrix = Array.from({ length: a.length + 1 }, (_, i) => Array.from({ length: b.length + 1 }, (_, j) => i || j));\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\nQ.String.prototype.find = function (stringOrRegex) {\n    return this.string.match(stringOrRegex);\n};\nQ.String.prototype.replaceAll = function (stringOrRegex, replacement) {\n    return this.string.replace(new RegExp(stringOrRegex, 'g'), replacement);\n};"
        },
        "Thread": {
            "uuid": "4a622635-8229-4e34-a6f9-3013bac5f3fd",
            "name": "Thread",
            "method": "Plugin",
            "desc": "Thread is a utility for managing Web Workers in a thread pool. It allows developers to execute functions in parallel, offloading heavy tasks to separate threads and improving performance. <br> Thread provides a simple interface for creating, managing, and controlling worker threads, enabling developers to execute multiple tasks concurrently without blocking the main thread. <br> By distributing workloads across multiple threads, developers can optimize performance and enhance user experience.",
            "type": "Plugin",
            "example": "const thread = Q.Thread(4); // Creates a thread pool with 4 workers <br> thread.Push(() => heavyTask(1, 2, 3)).then(result => console.log(result)); // Executes heavyTask in a worker thread <br> thread.Push(heavyTask, 1, 2, 3).then(result => console.log(result)); // Executes heavyTask in a worker thread <br> thread.Workers(2); // Sets the number of workers to 2 <br> thread.Result(({ id, result, error }) => console.log(id, result, error)); // Logs the result of each task <br> thread.Done(() => console.log('All tasks completed')); // Logs when all tasks are completed <br> thread.Abort(); // Aborts all tasks and terminates worker threads",
            "dependencies": [],
            "script": "(() => {\n    class ThreadPool {\n      constructor(maxWorkers = 1) {\n        this.maxWorkers = maxWorkers;\n        this.workers = [];\n        this.taskQueue = [];\n        this.activeTasks = new Map();\n        this.taskIdCounter = 0;\n        this.resultCallbacks = [];\n        this.doneCallbacks = [];\n        this.aborted = false;\n        this.blobURL = ThreadPool._createWorkerBlob();\n        for (let index = 0; index < maxWorkers; index++) {\n          this._addWorker();\n        }\n      }\n      static _createWorkerBlob() {\n        const code = `\n          self.onmessage = event => {\n            const { taskId, functionCode, parameters } = event.data;\n            let executionFunction;\n            try {\n              executionFunction = eval('(' + functionCode + ')');\n            } catch (error) {\n              self.postMessage({ taskId, error: error.toString() });\n              return;\n            }\n            Promise.resolve().then(() => executionFunction(...parameters)).then(\n              result => self.postMessage({ taskId, result }),\n              error => self.postMessage({ taskId, error: error.toString() })\n            );\n          };\n        `;\n        return URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));\n      }\n      _addWorker() {\n        const workerInstance = new Worker(this.blobURL);\n        workerInstance.busy = false;\n        workerInstance.onmessage = event => {\n          const { taskId, result, error } = event.data;\n          workerInstance.busy = false;\n          const task = this.activeTasks.get(taskId);\n          if (task) {\n            error !== undefined ? task.reject(new Error(error)) : task.resolve(result);\n            this.resultCallbacks.forEach(callbackFunction => callbackFunction({ id: taskId, result, error }));\n            this.activeTasks.delete(taskId);\n          }\n          this._processQueue();\n        };\n        workerInstance.onerror = () => { workerInstance.busy = false; };\n        this.workers.push(workerInstance);\n      }\n      _processQueue() {\n        if (this.aborted) return;\n        while (true) {\n          const idleIndex = this.workers.findIndex(workerInstance => !workerInstance.busy);\n          if (idleIndex === -1 || this.workers.length <= this.maxWorkers) break;\n          this.workers[idleIndex].terminate();\n          this.workers.splice(idleIndex, 1);\n        }\n        for (const workerInstance of this.workers) {\n          if (!workerInstance.busy && this.taskQueue.length) {\n            const task = this.taskQueue.shift();\n            workerInstance.busy = true;\n            this.activeTasks.set(task.id, task);\n            workerInstance.postMessage({ taskId: task.id, functionCode: task.functionCode, parameters: task.parameters });\n          }\n        }\n        if (!this.taskQueue.length && !this.activeTasks.size) {\n          const callbacks = this.doneCallbacks.slice();\n          this.doneCallbacks.length = 0;\n          callbacks.forEach(callbackFunction => callbackFunction());\n        }\n      }\n      Workers(newWorkerCount) {\n        if (this.aborted) return this;\n        this.maxWorkers = newWorkerCount;\n        if (newWorkerCount > this.workers.length) {\n          for (let index = 0, difference = newWorkerCount - this.workers.length; index < difference; index++) {\n            this._addWorker();\n          }\n        } else {\n          this._processQueue();\n        }\n        return this;\n      }\n      Push(taskInput, ...parameters) {\n        if (this.aborted) return Promise.reject(new Error('Thread aborted'));\n        const taskFunction = typeof taskInput === 'function' ? taskInput : (() => taskInput);\n        const taskId = ++this.taskIdCounter;\n        const task = { id: taskId, functionCode: taskFunction.toString(), parameters, resolve: null, reject: null };\n        const promiseResult = new Promise((resolve, reject) => { task.resolve = resolve; task.reject = reject; });\n        this.taskQueue.push(task);\n        this._processQueue();\n        return promiseResult;\n      }\n      Result(callbackFunction) {\n        if (typeof callbackFunction === 'function') this.resultCallbacks.push(callbackFunction);\n        return this;\n      }\n      Done(callbackFunction) {\n        if (typeof callbackFunction !== 'function') return this;\n        if (!this.taskQueue.length && !this.activeTasks.size) callbackFunction();\n        else this.doneCallbacks.push(callbackFunction);\n        return this;\n      }\n      Abort() {\n        this.aborted = true;\n        while (this.taskQueue.length) this.taskQueue.shift().reject(new Error('Task aborted'));\n        this.activeTasks.forEach(task => task.reject(new Error('Task aborted')));\n        this.activeTasks.clear();\n        this.workers.forEach(workerInstance => workerInstance.terminate());\n        this.workers = [];\n        this.doneCallbacks.length = 0;\n        this.resultCallbacks.length = 0;\n        URL.revokeObjectURL(this.blobURL);\n        return this;\n      }\n    }\n    Q.Thread = (maxWorkers = 1) => new ThreadPool(maxWorkers);\n  })();"
        },
        "Timer": {
            "uuid": "108651db-2b81-43af-bd2a-ba9a164057a3",
            "name": "Timer",
            "method": "Plugin",
            "desc": "Provides a timer implementation with automatic stop and interrupt. Useful for running tasks at intervals or for a specific duration.",
            "type": "Plugin",
            "example": "Q.Timer(() => console.log('Tick'), 'timer1', { tick: 5, delay: 1000, interrupt: true });",
            "dependencies": [],
            "script": "Q.Timer = (callback, identifier, options = {}) => {\n    const defaults = { tick: 1, delay: 1000, interrupt: false, autoStart: true, done: null };\n    const config = { ...defaults, ...options };\n    if (!Q.Timer.activeTimers) Q.Timer.activeTimers = new Map();\n    if (config.interrupt && Q.Timer.activeTimers.has(identifier)) Q.Timer.stop(identifier);\n    const timerControl = {\n      id: identifier,\n      tickCount: 0,\n      isPaused: false,\n      remainingDelay: config.delay,\n      startTime: 0,\n      timerHandle: null,\n      pause() {\n        if (!this.isPaused) {\n          this.isPaused = true;\n          clearTimeout(this.timerHandle);\n          const elapsed = Date.now() - this.startTime;\n          this.remainingDelay = config.delay - elapsed;\n        }\n        return this;\n      },\n      resume() {\n        if (this.isPaused) {\n          this.isPaused = false;\n          startTick(this.remainingDelay);\n        }\n        return this;\n      },\n      stop() { Q.Timer.stop(this.id); }\n    };\n    const startTick = (delayTime) => {\n      timerControl.startTime = Date.now();\n      timerControl.timerHandle = setTimeout(function tickHandler() {\n        callback();\n        timerControl.tickCount++;\n        if (config.tick > 0 && timerControl.tickCount >= config.tick) {\n          Q.Timer.stop(identifier);\n          if (typeof config.done === 'function') config.done();\n        } else {\n          timerControl.startTime = Date.now();\n          timerControl.timerHandle = setTimeout(tickHandler, config.delay);\n        }\n      }, delayTime);\n    };\n    if (config.autoStart) startTick(config.delay);\n    Q.Timer.activeTimers.set(identifier, timerControl);\n    return timerControl;\n  };\n  Q.Timer.stop = (identifier) => {\n    if (Q.Timer.activeTimers?.has(identifier)) {\n      const timerControl = Q.Timer.activeTimers.get(identifier);\n      clearTimeout(timerControl.timerHandle);\n      Q.Timer.activeTimers.delete(identifier);\n    }\n  };\n  Q.Timer.stopAll = () => {\n    if (Q.Timer.activeTimers) {\n      Q.Timer.activeTimers.forEach(timerControl => clearTimeout(timerControl.timerHandle));\n      Q.Timer.activeTimers.clear();\n    }\n  };"
        }
    },
    "statics": {
        "AvgColor": {
            "uuid": "90dbc0d4-0b4a-4b3d-bd0a-5558aa54e644",
            "name": "AvgColor",
            "method": "Utility",
            "desc": "Calculates the average color of an image by creating a canvas element, drawing the image on it, and analyzing the pixel data to determine the average color. <br> This technique is useful for generating color palettes, creating visual effects, or enhancing user interface elements based on the predominant colors in an image.",
            "type": "Image Processing",
            "example": "Q.AvgColor('image.jpg or canvas', sampleSize, callback); // Returns the average color of the image or canvas",
            "dependencies": [],
            "script": "Q.AvgColor = (source, sampleSize, callback) => {\n    const image = new Image();\n    image.crossOrigin = 'Anonymous';\n    if (typeof source === 'string') image.src = source;\n    else if (source instanceof HTMLCanvasElement) image.src = source.toDataURL();\n    else return console.error(\"Invalid image source provided.\");\n    image.onload = () => {\n      const canvas = Object.assign(document.createElement('canvas'), { width: image.width, height: image.height });\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const data = context.getImageData(0, 0, image.width, image.height).data;\n      const samplingRate = sampleSize === 'auto'\n        ? Math.max(1, Math.ceil(Math.sqrt(image.width * image.height) / 32))\n        : (typeof sampleSize === 'number' && sampleSize > 0 ? sampleSize : 1);\n      let totalRed = 0, totalGreen = 0, totalBlue = 0, count = 0;\n      for (let index = 0, len = data.length; index < len; index += samplingRate * 4) {\n        totalRed   += data[index];\n        totalGreen += data[index + 1];\n        totalBlue  += data[index + 2];\n        count++;\n      }\n      const avgColor = { r: (totalRed / count) | 0, g: (totalGreen / count) | 0, b: (totalBlue / count) | 0 };\n      typeof callback === 'function' && callback(avgColor);\n    };\n    image.onerror = () => console.error(\"Failed to load image.\");\n  };"
        },
        "ColorBrightness": {
            "uuid": "f83eeec0-9658-4114-943a-cd5e51657ba2",
            "name": "ColorBrightness",
            "method": "Utility",
            "desc": "Adjusts the brightness of a given color by a specified percentage, making the color lighter or darker. <br> This function can be used to dynamically change colors for various UI elements, providing visual feedback or creating color schemes with different shades. <br> It supports both hexadecimal and RGB/RGBA color formats, making it flexible for different use cases in web design or graphics.",
            "type": "Color",
            "example": "Q.ColorBrightness('#000000', 50); // #7f7f7f (black +50%) <br> Q.ColorBrightness('rgb(255, 0, 0)', -30); // rgb(178, 0, 0) (red -30%) <br> Q.ColorBrightness('rgba(0, 0, 255, 0.5)', 20); // rgba(51, 51, 255, 0.5) (blue +20%)",
            "dependencies": [],
            "script": "Q.ColorBrightness = (inputColor, percent) => {\n    if (!/^#|^rgb/.test(inputColor)) throw new Error('Unsupported c format');\n    let red, green, blue, alpha = 1, isHex = false, factor = 1 + percent / 100;\n    if (inputColor[0] === '#') {\n      isHex = true;\n      const hexString = inputColor.slice(1);\n      if (hexString.length === 3) {\n        red = parseInt(hexString[0] + hexString[0], 16);\n        green = parseInt(hexString[1] + hexString[1], 16);\n        blue = parseInt(hexString[2] + hexString[2], 16);\n      } else if (hexString.length === 6) {\n        red = parseInt(hexString.slice(0, 2), 16);\n        green = parseInt(hexString.slice(2, 4), 16);\n        blue = parseInt(hexString.slice(4, 6), 16);\n      }\n    } else {\n      const match = inputColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n      if (match) {\n        red = +match[1];\n        green = +match[2];\n        blue = +match[3];\n        if (match[4] != null) alpha = parseFloat(match[4]);\n      }\n    }\n    const clamp = value => Math.min(255, Math.max(0, Math.round(value * factor)));\n    red = clamp(red);\n    green = clamp(green);\n    blue = clamp(blue);\n    return isHex\n      ? '#' + [red, green, blue].map(component => (`0${component.toString(16)}`).slice(-2)).join('')\n      : (alpha === 1 ? `rgb(${red}, ${green}, ${blue})` : `rgba(${red}, ${green}, ${blue}, ${alpha})`);\n  };"
        },
        "Debounce": {
            "uuid": "6acdf355-2d29-4f98-8819-f24934e4af94",
            "name": "Debounce",
            "method": "Utility",
            "desc": "Debounces a function to ensure it is only called after a specified delay since the last invocation, effectively preventing multiple calls in rapid succession. <br> This technique is particularly useful in scenarios like resizing windows, scrolling, or typing events, where multiple triggers can lead to performance issues or unintended behavior. <br> By controlling the rate at which a function can fire, developers can optimize performance and enhance user experience.",
            "type": "Event Handling",
            "example": "Q.Debounce('myFunction', 500, myFunction); // Calls myFunction after 500ms of inactivity <br> Q.Debounce('resizeEvent', 300, handleResize); // Debounces resize handling function",
            "dependencies": [],
            "script": "Q.Debounce = (id, b, c) => {\n    const debounceStorage = Q.getGLOBAL('Debounce') || {};\n    debounceStorage[id] && clearTimeout(debounceStorage[id]);\n    debounceStorage[id] = setTimeout(c, b);\n    Q.setGLOBAL({ Debounce: debounceStorage });\n  };"
        },
        "HSL2RGB": {
            "uuid": "e309a7bf-9e39-4f10-9ff6-342214a6f192",
            "name": "HSL2RGB",
            "method": "Utility",
            "desc": "Converts HSL (Hue, Saturation, Lightness) color values to RGB (Red, Green, Blue) format. <br> This function is essential for applications that require color transformations, allowing developers to switch between different color representations easily. <br> Understanding color models is key in design, and this utility helps bridge the gap between HSL, which is often more intuitive for humans, and RGB, which is commonly used in digital displays.",
            "type": "Color",
            "example": "Q.HSL2RGB(0, 0, 1); // [255, 255, 255] <br> Q.HSL2RGB(0, 1, 0.5); // [255, 0, 0] <br> Q.HSL2RGB(0.33, 1, 0.5); // [0, 255, 0]",
            "dependencies": [],
            "script": "Q.HSL2RGB = (h, s, l) => {\n    if (s === 0) {\n      const gray = l * 255;\n      return [gray, gray, gray];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s,\n          p = 2 * l - q,\n          hueToRgb = (t) => {\n            t < 0 && (t += 1);\n            t > 1 && (t -= 1);\n            return t < 1 / 6 ? p + (q - p) * 6 * t\n                 : t < 1 / 2 ? q\n                 : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t)\n                 : p;\n          };\n    return [hueToRgb(h + 1 / 3) * 255, hueToRgb(h) * 255, hueToRgb(h - 1 / 3) * 255];\n  };"
        },
        "ID": {
            "uuid": "fa4d3a35-2ce2-4fd4-89e5-3349d80de2f4",
            "name": "ID",
            "method": "Utility",
            "desc": "It's useful for creating unique identifiers for users, sessions, or any items requiring distinct identification. <br> The ID is generated using random hexadecimal digits (0-9 and a-f) and can be customized with a prefix for better context or categorization.",
            "type": "Utility",
            "example": "Q.ID(8, 'user-'); // user-1a2b3c4d <br> Q.ID(); // 1a2b3c4d <br> Q.ID(12, 'session-'); // session-1a2b3c4d5e6f",
            "dependencies": [],
            "script": "Q.ID = (length = 8, b = '') =>\n    b + Array.from({ length }, () => (Math.random() * 16 | 0).toString(16)).join('');"
        },
        "isDarkColor": {
            "uuid": "c36da69d-06c9-45dc-8ecf-c9c4c1378026",
            "name": "isDarkColor",
            "method": "Utility",
            "desc": "Determines if a color is dark or light based on the HSP (Hue, Saturation, Perceived brightness) model. <br> This utility helps in designing user interfaces by ensuring adequate contrast between text and background colors, enhancing readability and accessibility. <br> Users can adjust the margin and threshold parameters to fine-tune sensitivity according to their design needs.",
            "type": "Color",
            "example": "Q.isDarkColor('#000000'); // true <br> Q.isDarkColor('#ffffff'); // false <br> Q.isDarkColor('#4c4c4c', 30, 90); // true",
            "dependencies": [],
            "script": "Q.isDarkColor = (color, b = 20, c = 100) => {\n    let red, green, blue;\n    if (color[0] === '#') {\n      const f = color.slice(1);\n      const parts = f.length === 3\n        ? [f[0] + f[0], f[1] + f[1], f[2] + f[2]]\n        : f.length === 6\n        ? [f.slice(0, 2), f.slice(2, 4), f.slice(4, 6)]\n        : null;\n      if (!parts) throw Error('Invalid f color format');\n      [red, green, blue] = parts.map(v => parseInt(v, 16));\n    } else if (color.startsWith('rgb')) {\n      const arr = color.match(/\\d+/g);\n      if (arr && arr.length >= 3) [red, green, blue] = arr.map(Number);\n      else throw Error('Invalid color format');\n    } else throw Error('Unsupported color format');\n    return Math.sqrt(0.299 * red ** 2 + 0.587 * green ** 2 + 0.114 * blue ** 2) + b < c;\n  };"
        },
        "RGB2HSL": {
            "uuid": "6580f6fe-4710-4f36-884c-5e81cb8efd0d",
            "name": "RGB2HSL",
            "method": "Utility",
            "desc": "Converts RGB color values to HSL format, providing a different way to represent colors that can be more intuitive for artists and designers. <br> HSL stands for Hue, Saturation, and Lightness, making it easier to manipulate colors based on human perception. <br> This conversion is essential for applications requiring color manipulation, such as image editing or web design, where understanding color relationships is crucial.",
            "type": "Color",
            "example": "Q.RGB2HSL(255, 255, 255); // [0, 0, 1] <br> Q.RGB2HSL(0, 0, 0); // [0, 0, 0] <br> Q.RGB2HSL(255, 0, 0); // [0, 1, 0.5]",
            "dependencies": [],
            "script": "Q.RGB2HSL = (r, g, b) => {\n    r /= 255, g /= 255, b /= 255;\n    const max = Math.max(r, g, b), min = Math.min(r, g, b);\n    let h, s, l = (max + min) / 2, d = max - min;\n    if (!d) h = s = 0;\n    else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0)\n        : max === g ? (b - r) / d + 2\n        : (r - g) / d + 4;\n      h /= 6;\n    }\n    return [h, s, l];\n  };"
        }
    }
};
function Highlight(code) {
    // Function to escape HTML characters in code
    const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    code = escapeHTML(code);

    let patterns = [];

    let dictionary = [
        {
            find: ["Q"],
            open: "", 
            close: "", 
            className: "class",
            regex: "single",
            allowNested: false
        },
        {
            find: ["(", ")", "{", "}", "[", "]"],
            open: "", 
            close: "", 
            className: "bracket",
            regex: "single",
            allowNested: false
        },
        {
            find: ["'", '"'],
            open: "", 
            close: "", 
            className: "string",
            regex: "single",
            allowNested: false
        },
        {
            find: ["*"],
            open: "//", 
            close: "<br>", 
            className: "comment",
            regex: "between",
            allowNested: false
        },
        {
            find: ["function", "return", "if", "else", "for", "while"],
            open: "", 
            close: "", 
            className: "keyword",
            regex: "single",
            allowNested: false
        },
        {
            find: ["let", "var", "const"],
            open: "", 
            close: "", 
            className: "variable",
            regex: "single",
            allowNested: false
        }
    ];

    // Generate patterns from the dictionary
    dictionary.forEach(({ find, open, close, className, regex, allowNested }) => {
        let regexString = "";
        if (regex === "single") {
            // Join keywords with | for a single word match, using \b word boundaries
            regexString = `\\b(${find.map(item => item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join("|")})\\b`;
        } else if (regex === "between") {
            // Use non-capturing groups and lookahead/lookbehind for the between match
            regexString = `(${open})((?:(?!${close}).)*?)(${close})`;
        } else {
            regexString = regex; // Assume a custom regex is provided
        }

        patterns.push({
            regex: new RegExp(regexString, "g"),
            replace: `<span class='hl ${className}'>$&</span>`,
            allowNested
        });
    });

    // Apply patterns to the code
    patterns.forEach(({ regex, replace, allowNested }) => {
        code = code.replace(regex, (match, ...groups) => {
            // If allowNested is false, un-nest any nested spans inside
            if (!allowNested) {
                match = match.replace(/<span.*?>(.*?)<\/span>/g, '$1');
            }
            return replace.replace('$&', match);
        });
    });

    // Use a temporary container to parse and process the HTML
    let temp = document.createElement("div");
    temp.innerHTML = code;

    // Remove nested spans if necessary
    temp.querySelectorAll("span span").forEach(nested => {
        const parent = nested.parentElement;
        if (nested.classList.contains("hl")) {
            parent.replaceChild(document.createTextNode(nested.textContent), nested);
        }
    });

    return temp.innerHTML;
}

// function Highlight(code) {
    
//     const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
//     code = code.replace(/\"(.*?)\"/g, (_, p1) => `"${escapeHTML(p1)}"`);

//     let patterns = [];

//     let dictionary = [
//         {
//         find:["Q"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"class", // span class name
//         regex: "single", // single, between, regex (direct regex) 
//         allowNested: false // allow or remove nested (convert to plain text)
//         },
//         {
//         find:["(", ")", "{", "}", "[", "]"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"bracket", // span class name
//         regex: "single", // single, between, regex (direct regex)
//         allowNested: false // allow or remove nested (convert to plain text)
//         }
//     ];


//     dictionary.forEach(({find, open, close, className, regex, allowNested}) => {
//         let regexString = "";
//         if (regex === "single") {
//             regexString = `\\b(${find.join("|")})\\b`;
//         } else if (regex === "between") {
//             regexString = `\\b(${open})((?:(?!${close}).)*)\\b(${close})`;
//         } else {
//             regexString = regex;
//         }

//         patterns.push({
//             regex: new RegExp(regexString, "g"),
//             replace: `<span class='hl ${className}'>$&</span>`
//         });
//     });


//     // const patterns = [
//     //     { regex: /(['"`])(.*?)\1/g, replace: "<span class='hl string'>$1$2$1</span>" },
//     //             { regex: /\b(\d+)\b/g, replace: "<span class='hl number'>$1</span>" },

//     //     { regex: /Q\(/g, replace: "<span class='hl class'>Q</span>(" },
//     //     { regex: /Q\./g, replace: "<span class='hl object'>Q.</span>" },
//     //     // { regex: /\((.*?)\)/g, replace: "(<span class='bracket_inner'>$1</span>)" },
//     //     // { regex: /\{(.*?)\}/g, replace: "{<span class='bracket_inner'>$1</span>}" },
//     //     // { regex: /\[(.*?)\]/g, replace: "[<span class='bracket_inner'>$1</span>]" },
//     //     { regex: /\{|\}|\(|\)|\[|\]/g, replace: "<span class='hl bracket'>$&</span>" },
//     //     { regex: /\b(function|return|if|else|for|while)\b/g, replace: "<span class='hl keyword'>$1</span>" },
//     //     //variables
//     //     { regex: /\b(let|var|const)\b/g, replace: "<span class='hl variable'>$1</span>" },

//     //     {
//     //         regex: /\/\/(?!https?:\/\/|ftp:\/\/|ws:\/\/)(.*?)(?=<br>|$)/g, replace: "<span class='hl comment'>//$1</span>"
//     //     }
//     // ];

//     patterns.forEach(({ regex, replace }) => code = code.replace(regex, replace));

//     let temp = document.createElement("div");
//     temp.innerHTML = code;

//     temp.querySelectorAll("span span").forEach(nested => {
        
//         if (nested.classList.contains("hl")) {
//             const parent = nested.parentElement;
//             parent.replaceChild(document.createTextNode(nested.textContent), nested);
//         }
//     });

//     return temp.innerHTML;
// }

const IDS = {};

function CodeBuilder() {
    const activeBlocks = document.querySelectorAll(".block.active");


    const applyScript = (script) => {
        const sizedata = document.querySelector(".sizedata");
        let BaseScript = JSON.parse(JSON.stringify(DATA.frame));
        BaseScript = BaseScript.replace("return Q;", script + "\nreturn Q;");
        let codeBlock = document.querySelector(".codeData");
        codeBlock.innerHTML = minify(BaseScript);
        sizedata.innerHTML = "Library size: " + CalculateSizeKB(BaseScript);
    }




    if (!activeBlocks.length) {
        applyScript("");
        return;
    }

    const script = Array.from(activeBlocks)
        .map(block => {
            let blockScript = "";
            // Traverse the IDS structure to find the matching script
            for (const name in IDS) {
                const blockData = IDS[name];
                if (blockData.uuid == block.id) {
                    blockScript = blockData.script || "";
                    break;
                }
            }
            return blockScript;
        })
        .join("");

    applyScript(script);

    // console.log(script);
}


function classFormat(text) {
    return text.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");
}

function minify(code) {
    return code.replace(/^\s*/gm, "").replace(/\n/g, "");
}

function CalculateSizeKB(code) {
    return (new Blob([code]).size / 1024).toFixed(2) + " KB";
}

function createTags(tags) {
    const tagsContainer = document.createElement("div");
    tagsContainer.className = "tags";
    tags.forEach(tag => {
        const tagElement = document.createElement("span");
        tagElement.className = "tag";
        tagElement.innerHTML = tag;
        tagsContainer.appendChild(tagElement);
    });
    return tagsContainer;
}

function createCodeCategory(title) {
    const categoryContainer = document.createElement("div");
    categoryContainer.className = "code_category";
    categoryContainer.innerHTML = `<h2 class='code_category_title'>${title}</h2>`;
    const categoryContent = document.createElement("div");
    categoryContent.className = "code_content";
    categoryContent.id = classFormat(title);
    categoryContainer.appendChild(categoryContent);
    return categoryContainer;
}

function createBlock(contentData) {
    const { uuid, name, desc, example, dependencies } = contentData;
    const block = document.createElement("div");
    block.className = "block";
    block.id = uuid;
    block.innerHTML = `<h2>${name}</h2>`;

    const blockContent = document.createElement("div");
    blockContent.className = "block_content";
    block.appendChild(blockContent);

    blockContent.innerHTML = `<p>${desc}</p>`;
    const blockExample = document.createElement("div");
    blockExample.className = "block_example";
    blockExample.innerHTML = Highlight(example.replace(/\n/g, "<br>"));
    blockContent.appendChild(blockExample);

    if (dependencies.length > 0) {
        const blockDependencies = document.createElement("div");
        blockDependencies.className = "block_dependencies";
        blockDependencies.innerHTML = "<b>Dependencies</b>";
        blockDependencies.appendChild(createTags(dependencies));
        blockContent.appendChild(blockDependencies);
    }

    block.addEventListener("click", function (event) {
        if (event.currentTarget.contains(event.target)) {
            block.classList.toggle("active");
            if (block.classList.contains("active")) {
                dependencies.forEach(dep => {
                    const depBlock = document.getElementById(IDS[dep]?.uuid);
                    if (depBlock && !depBlock.classList.contains("active")) {
                        depBlock.click();
                    }
                });
            }
            CodeBuilder();
        }
    });

    return block;
}

function createTab(name, identifier, contentData) {
    const tabHeader = document.querySelector(".tab_header");
    const tabContainer = document.querySelector(".tab_container");

    const tab = document.createElement("div");
    tab.className = "tab";
    tab.innerHTML = name;
    tab.setAttribute("data-identifier", identifier);

    const tabContent = document.createElement("div");
    tabContent.className = "tab_content";
    tabContent.setAttribute("data-identifier", identifier);

    const types = [...new Set(contentData.map(c => c.type))];
    types.forEach(type => tabContent.appendChild(createCodeCategory(type)));
    contentData.forEach(content => {
        tabContent.querySelector(`#${classFormat(content.type)}`).appendChild(createBlock(content));
    });

    tab.addEventListener("click", function () {
        document.querySelectorAll(".tab, .tab_content").forEach(el => el.classList.remove("active"));
        tab.classList.add("active");
        tabContent.classList.add("active");
    });

    tabHeader.appendChild(tab);
    tabContainer.appendChild(tabContent);

    return tab;
}

function createTabs() {
    const methods = new Set();
    Object.values(DATA).forEach(category => {
        if (typeof category === 'object') {
            console.log(category);
            const contentData = [];
            Object.values(category).forEach(({ method, uuid, desc, type, example, dependencies, script }) => {
                if (!methods.has(method)) {
                    methods.add(method);
                    Object.values(category).forEach(block => {
                        contentData.push({ ...block });
                        if (block.dependencies === undefined) {
                            block.dependencies = [];
                        }
                        IDS[block.name] = { uuid: block.uuid, script: block.script, dependencies: block.dependencies };
                    });
                    createTab(method, method, contentData);
                }
            });
        }
    });


    //choose .download button
    const downloadButton = document.querySelector(".download");
    const codeBlock = document.querySelector(".codeData");

    //add event listener to download button
    downloadButton.addEventListener("click", () => {
        const code = codeBlock.innerText;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vulpiniq.js";
        a.click();
        URL.revokeObjectURL(url);
    });


}

document.addEventListener("DOMContentLoaded", createTabs);
</script>
</head>

<body>

    <div class="container">
<div class="left_side">

<div class="header">
    <h1>VulpiniQ</h1>
    <p>Build your own VulpiniQ Library</p>
    </div>

<textarea class="codeData" placeholder="Enter your code here"></textarea>

<div class="footer">
    <div class="sizedata">No code recently</div>
    <button class="btn download">Download</button>
</div>

</div>


<div class="right_side">
    <div class="tab_header">
    </div>

    <div class="tab_container">



    </div>

</div>




    </div>

    <!-- <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>

    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div> -->

</body>

</html>