<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VulpiniQ</title>
    <link rel="stylesheet" href="builder.css">
<style>*{ margin: 0; padding: 0; box-sizing: border-box; /* outline: 1px solid rgba(255, 255, 255, 0.2); */}body{ font-family: 'Arial', sans-serif; background-color: #0e0e0e; color: #a3a3a3; line-height: 1.6; font-size: 12px;}::-webkit-scrollbar{ width: 8px; height: 8px;}::-webkit-scrollbar-track{ background: #2e2e2e;}::-webkit-scrollbar-thumb{ background: #555; border-radius: 4px;}::-webkit-scrollbar-thumb:hover{ background: #777;}.container{ display: flex;}.left_side{width: 50%;background-color: #0000003d;border-right: 1px solid #ffffff15;}.right_side{ flex-shrink: 0; width: 50%;padding-left:5px}.tab_header{display:flex;}.tab{padding: 5px 15px;cursor: pointer;}.tab.active{background: rgba(255, 255, 255, 0.2);color: #c4c4c4;}.tab_container{overflow-x: hidden;height: calc(100vh - 30px);padding: 0 5px;}.tags{display: flex;flex-wrap: wrap;}.tag{ padding: 0px 9px; margin: 3px; background: #333; border-radius: 5px; cursor: default;}.block{ cursor: default;padding:10px; background: #ffffff09; border-radius: 10px; /* outline: 1px solid #ffffff10; */ width: 100%;}.block.active{ background: #ffffff18;}.block_example{ padding: 8px; background: #00000033; border-radius: 12px; width: 100%; margin-top: 10px;}.code_content{ display: grid; grid-template-columns: repeat(2, 1fr); /* Create 3 equal columns */ gap: 10px; /* Add gap between grid items */}.block_dependencies{ margin-top: 10px;}.block_title{ font-size: 16px; font-weight: bold; margin-bottom: 20px;}.code_category_title{ font-size: 20px; font-weight: bold; margin: 15px 0}.code_category{margin-bottom: 40px;}.codeData{ padding: 10px; background: #00000033; border-radius: 12px; width: calc(100% - 10px); height: 200px; margin-top: 10px; color: #a3a3a3; text-align: justify; border: 1px solid #ffffff10; box-sizing: border-box; margin: 5px; resize: vertical; max-height: 400px;}.codeData:focus{ outline: none;}.footer{display:flex;}.sizedata{ margin: 0 20px; display: flex; align-items: center;}.btn{ padding: 5px 10px; background: #333; color: #a3a3a3; border: none; border-radius: 5px; cursor: pointer;}.tab_content{ display: none;}.tab_content.active{ display: block;}.bracket{ color: #e7e192;}.bracket_inner{ color: #96a8f5;}.class,.object{ color: #bb6485; font-weight: bold;}.keyword{ color: #f78c6c;}.operator{ color: #ff5370;}.method{ color: #82aaff;}.string{ color: #d8a378; font-weight: bold;}.number{ color: #f78c6c;}.comment{ color: #428f59 !important;}</style>
<script>
var DATA = {
    "frame": "const Q = (() => {\n    'use strict';\nconst _ob = Object, _ar = Array, _ma = Math, _ac = AbortController, _as = AbortSignal, _bo = Boolean, _da = Date, _er = Error, _ev = Event, _pr = Promise, _nu = Number, _re = RegExp, _st = setTimeout, _un = undefined, _n = null, _nl = NodeList, _el = Element, _si = setInterval, _c = console, _f = fetch, _ct = clearTimeout;\n    let GLOBAL = {};\n    let styleData = {\n        gen: \"\",\n        root: '',\n        element: _n,\n        init: false\n    };\n    function applyStyles() {\n        if (!styleData.init) {\n            styleData.element = document.getElementById('qlib-root-styles') || createStyleElement();\n            styleData.init = true;\n        }\n        let finalStyles = '';\n        if (styleData.root) {\n            finalStyles = `:root {${styleData.root}}\\n`;\n        }\n        finalStyles += styleData.gen;\n        styleData.element.textContent = finalStyles;\n    }\n    function createStyleElement() {\n        const styleElement = document.createElement('style');\n        styleElement.id = 'qlib-root-styles';\n        document.head.insertBefore(styleElement, document.head.firstChild);\n        return styleElement;\n    }\n    window.addEventListener('load', () => {\n        applyStyles();\n    }, { once: true });\n    function Q(a, attributes, c) {\n        if (!(this instanceof Q)) return new Q(a, attributes, c);\n        if (a?.nodeType === 1 || a?.nodeType != _n) {\n            this.nodes = [a];\n            return;\n        }\n        if (a instanceof Q) {\n            this.nodes = a.nodes;\n            return;\n        }\n        if (a?.constructor === _nl) {\n            this.nodes = _ar.from(a);\n            return;\n        }\n        if (typeof a === 'string') { \n            const l = attributes || a.indexOf('<') > -1;\n            if (l) {\n                const template = document.createElement('template');\n                template.innerHTML = a.trim();\n                this.nodes = _ar.from(template.content.childNodes);\n                if (attributes) {\n                    for (const element of this.nodes) {\n                        _ob.entries(attributes).forEach(([g, j]) => {\n                            if (g === 'class') {\n                                element.classList.add(...(_ar.isArray(j) ? j : j.split(/\\s+/)));\n                            } else if (g === 'style') {\n                                if (typeof j === 'object') {\n                                    _ob.entries(j).forEach(([property, propertyValue]) => {\n                                        element.style[property] = propertyValue;\n                                    });\n                                } else {\n                                    element.style.cssText = j;\n                                }\n                            } else if (g === 'text') {\n                                element.textContent = j;\n                            } else if (g === 'html') {\n                                element.innerHTML = j;\n                            } else {\n                                element.setAttribute(g, j);\n                            }\n                        });\n                    }\n                }\n                if (c) {\n                    this.nodes.forEach(element => {\n                        c.forEach(d => element[d] = true);\n                    });\n                }\n            } else {\n                this.nodes = _ar.from(document.querySelectorAll(a));\n            }\n        }\n    }\n    Q.Ext = (methodName, functionImplementation) =>\n        (Q.prototype[methodName] = functionImplementation, Q);\n    Q.getGLOBAL = i => GLOBAL[i];\n    Q.setGLOBAL = h => (GLOBAL = { ...GLOBAL, ...h });\n    Q.style = (root = '', style = '', mapping = _n) => {\n        if (root && typeof root === 'string') {\n            styleData.root += root.trim() + ';';\n        }\n        if (style && typeof style === 'string') {\n            if (mapping) {\n                const keys = _ob.keys(mapping);\n                keys.forEach((i) => {\n                    let newKey = Q.ID ? Q.ID(5, '_') : `_${_ma.random().toString(36).substring(2, 7)}`;\n                    style = style.replace(new _re(`\\\\b${i}\\\\b`, 'gm'), newKey);\n                    mapping[i] = mapping[i].replace(i, newKey);\n                });\n            }\n            styleData.gen += style;\n        }\n        applyStyles();\n        return mapping;\n    };\n    return Q;\n})();",
    "basics": {},
    "methods": {
        "addClass": {
            "uuid": "57234237-7c6d-452f-a513-5e46fe3e78fa",
            "name": "addClass",
            "method": "Prototype",
            "desc": "Adds one or more classes to each node, ignoring duplicates.",
            "type": "Class Manipulation",
            "example": "Q(selector).addClass(\"class1\"); // Adds a single class <br> Q(selector).addClass(\"class1 class2\"); // Adds multiple classes",
            "dependencies": [],
            "script": "Q.Ext('addClass', function (classes) {\n    const b = classes.split(' '),\n          nodes = this.nodes;\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].classList.add(...b);\n    }\n    return this;\n});"
        },
        "animate": {
            "uuid": "4121cf60-c59f-45ba-a8e0-e3befe340555",
            "name": "animate",
            "method": "Prototype",
            "desc": "Animates each node using specified CSS properties over a given duration, with an optional callback when complete.",
            "type": "Animation",
            "example": "Q(selector).animate(500, { opacity: 0 }, () => { console.log('Fade out complete'); }); // Fades out over 500ms <br> Q(selector).animate(1000, { left: \"100px\", top: \"50px\" }); // Moves to new position in 1 second <br> Q(selector).animate(700, { opacity: 1, backgroundColor: \"#ff0000\" }, () => { alert('Animation finished!'); }); // Changes opacity and background color",
            "dependencies": [
                "each"
            ],
            "script": "Q.Ext('animate', function (duration, b, e) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const f = nodes[i],\n          c = _ob.keys(b)\n            .map(d => `${d} ${duration}ms`)\n            .join(', ');\n    f.style.transition = c;\n    for (const d in b) {\n      f.style[d] = b[d];\n    }\n    if (typeof e === 'function') {\n      _st(() => e.call(f), duration);\n    }\n  }\n  return this;\n});"
        },
        "append": {
            "uuid": "f6bdc4c6-d082-4402-9918-86f9394b83f5",
            "name": "append",
            "method": "Prototype",
            "desc": "Appends child nodes, HTML, or multiple elements to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).append(\"<p>New paragraph</p>\"); // Adds a paragraph as HTML <br> Q(selector).append(document.createElement(\"div\")); // Adds a div element <br> Q(selector).append(Q(otherSelector)); // Appends a Q object <br> Q(selector).append([document.createElement(\"span\"), document.createElement(\"img\")]); // Appends multiple elements <br> Q(selector).append(document.querySelectorAll(\".items\")); // Appends a NodeList of elements",
            "dependencies": [],
            "script": "Q.Ext('append', function (...contents) {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    const b = nodes[i];\n    for (let j = 0, clen = contents.length; j < clen; j++) {\n      const c = contents[j];\n      if (typeof c === \"string\") {\n        b.insertAdjacentHTML('beforeend', c);\n      } else if (c?.nodeType === 1 || c instanceof Q) {\n        b.appendChild(c.nodes ? c.nodes[0] : c);\n      } else if (_ar.isArray(c) || c?.constructor === _nl) {\n        const subNodes = _ar.from(c);\n        for (let k = 0, slen = subNodes.length; k < slen; k++) {\n          b.appendChild(subNodes[k]);\n        }\n      }\n    }\n  }\n  return this;\n});"
        },
        "attr": {
            "uuid": "b65f4d4f-4224-4ae4-bb93-8e14e19d341b",
            "name": "attr",
            "method": "Prototype",
            "desc": "Gets or sets attributes on the nodes, supporting multiple attributes at once.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).attr(\"id\", \"newId\"); // Sets the \"id\" attribute to \"newId\" <br> Q(selector).attr({ \"src\": \"image.jpg\", \"alt\": \"An image\" }); // Sets multiple attributes <br> Q(selector).attr(\"href\"); // Gets the \"href\" attribute value",
            "dependencies": [],
            "script": "Q.Ext('attr', function (attribute, b) {\n    const nodes = this.nodes;\n    if (typeof attribute === 'object') {\n        for (const node of nodes) {\n            for (const [c, val] of _ob.entries(attribute)) {\n                node.setAttribute(c, val);\n            }\n        }\n        return this;\n    } else {\n        if (b === _un) {\n            return nodes[0] && nodes[0].getAttribute(attribute) || _n;\n        }\n        for (const node of nodes) {\n            node.setAttribute(attribute, b);\n        }\n        return this;\n    }\n});"
        },
        "bind": {
            "uuid": "9f46b3ec-9bcf-4f21-9274-2e1aed89f9be",
            "name": "bind",
            "method": "Prototype",
            "desc": "Adds an event listener to each node, allowing for event delegation to improve performance.",
            "type": "Event Handling",
            "example": "Q(selector).bind(\"click\", () => console.log(\"Clicked\")); // Logs \"Clicked\" when any matching node is clicked <br> Q(\".btn\").bind(\"mouseover\", (e) => { console.log(`Hovered over: ${e.target.tagName}`); }); // Logs the tag name of the hovered element <br> Q(\"ul\").bind(\"click\", (e) => { console.log(`Item clicked: ${e.target.textContent}`); }); // Logs the text of the clicked list item",
            "dependencies": [],
            "script": "Q.Ext('bind', function (a, b) {\n    if (!this.d) {\n        this.d = {};\n    }\n    if (!this.d[a]) {\n        document.addEventListener(a, (e) => {\n            const nodes = this.nodes;\n            for (const node of nodes) {\n                if (node.contains(e.target)) {\n                    b.call(e.target, e);\n                }\n            }\n        });\n        this.d[a] = true;\n    }\n    return this;\n});"
        },
        "blur": {
            "uuid": "eb2b033b-45f0-42af-9bd4-5347864e9100",
            "name": "blur",
            "method": "Prototype",
            "desc": "Removes focus from the first node in the selection, effectively blurring it.",
            "type": "Form Manipulation",
            "example": "Q(selector).blur(); // Removes focus from the first matched input field <br> Q(\".active\").blur(); // Blurs the first active element <br> Q(\"textarea\").blur(); // Blurs the first textarea in the selection",
            "dependencies": [],
            "script": "Q.Ext('blur', function () {\n    const nodes = this.nodes; // ...existing code...\n    for (const node of nodes) {\n        node.blur();\n    }\n    return this;\n});"
        },
        "children": {
            "uuid": "5253f97d-80cb-46f3-a10d-ca37e559f4bb",
            "name": "children",
            "method": "Prototype",
            "desc": "Retrieves the direct child nodes of the first node in the selection.",
            "type": "Traversal",
            "example": "Q(selector).children(); // Returns all child nodes of the first matched element <br> Q(\"#parent\").children(); // Gets all children of the element with id 'parent' <br> Q(\"ul\").children(); // Retrieves all child nodes of the first unordered list",
            "dependencies": [],
            "script": "Q.Ext('children', function () {\n    return new Q(this.nodes[0].children);\n});"
        },
        "click": {
            "uuid": "2ea8d54f-4712-4f28-ba3a-1225b56f3734",
            "name": "click",
            "method": "Prototype",
            "desc": "Simulates a click event on each node in the selection.",
            "type": "Event Handling",
            "example": "Q(selector).click(); // Triggers a click event on all matched elements <br> Q(\".button\").click(); // Simulates clicks on all elements with the class 'button' <br> Q(\"a\").click(); // Automatically clicks the first anchor element in the selection",
            "dependencies": [],
            "script": "Q.Ext('click', function () {\n    const nodes = this.nodes; // ...existing code...\n    for (const node of nodes) {\n        node.click();\n    }\n    return this;\n});"
        },
        "clone": {
            "uuid": "17f4407a-d83a-4d57-bac9-21cf07d13be1",
            "name": "clone",
            "method": "Prototype",
            "desc": "Creates a deep copy of the first node in the selection, including its child nodes.",
            "type": "DOM Manipulation",
            "example": "Q(selector).clone(); // Clones the first matched element <br> const newElement = Q(\".item\").clone(); // Clones the first element with the class 'item' and stores it in newElement <br> const clonedDiv = Q(\"#myDiv\").clone(); // Clones the element with the ID 'myDiv'",
            "dependencies": [],
            "script": "Q.Ext('clone', function () {\n    const node = this.nodes[0]; // ...existing code...\n    return new Q(node.cloneNode(true));\n});"
        },
        "closest": {
            "uuid": "151ce87f-e892-4d0f-a367-09c2c3d453e3",
            "name": "closest",
            "method": "Prototype",
            "desc": "Finds the nearest ancestor node of the first node that matches a given selector.",
            "type": "Traversal",
            "example": "Q(selector).closest(\".parent\"); // Returns the closest parent with class 'parent' <br> const closestSection = Q(\".child\").closest(\"section\"); // Finds the closest section ancestor of the first element with the class 'child' <br> const closestForm = Q(\"#inputField\").closest(\"form\"); // Gets the nearest form ancestor of the element with ID 'inputField'",
            "dependencies": [],
            "script": "Q.Ext('closest', function (selector) {\n    let node = this.nodes[0]; // ...existing code...\n    while (node) {\n        if (node.matches && node.matches(selector)) {\n            return new Q(node);\n        }\n        node = node.parentElement;\n    }\n    return _n;\n});"
        },
        "css": {
            "uuid": "287e9c1d-95db-479c-a8b9-dcdff8159ef8",
            "name": "css",
            "method": "Prototype",
            "desc": "Retrieves or sets CSS styles on the selected nodes. Supports setting multiple styles if provided as an object.",
            "type": "Style Manipulation",
            "example": "Q(selector).css('color', 'red'); // Sets the text color of the first selected element to red <br> const backgroundColor = Q(selector).css('background-color'); // Gets the background color of the first selected element <br> Q(selector).css({ margin: '10px', padding: '5px' }); // Sets multiple styles on each selected element",
            "dependencies": [],
            "script": "Q.Ext('css', function(property, b) {\n  const nodes = this.nodes;\n  if (typeof property === 'object') {\n      for (let i = 0, len = nodes.length; i < len; i++) {\n          const style = nodes[i].style;\n          for (const c in property) {\n              style[c] = property[c];\n          }\n      }\n      return this;\n  }\n  if (b === _un) return getComputedStyle(nodes[0])[property];\n  for (let i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].style[property] = b;\n  }\n  return this;\n});"
        },
        "data": {
            "uuid": "9aab333c-6d6a-41f5-9ace-469a5d166850",
            "name": "data",
            "method": "Prototype",
            "desc": "Retrieves or sets data-* attributes on the selected nodes. Provides an easy way to store and access custom data associated with the elements.",
            "type": "Data Manipulation",
            "example": "Q(selector).data('userId', 123); // Sets the data-userId attribute to 123 on each selected element <br> const userId = Q(selector).data('userId'); // Retrieves the value of the data-userId attribute from the first selected element <br> const isActive = Q(selector).data('isActive'); // Retrieves the value of the data-isActive attribute, returns null if not set",
            "dependencies": [],
            "script": "Q.Ext('data', function (key, b) {\n    const nodes = this.nodes;\n    if (b === _un) {\n        return nodes[0] && nodes[0].dataset[key] || _n;\n    }\n    for (const node of nodes) {\n        node.dataset[key] = b;\n    }\n    return this;\n});"
        },
        "each": {
            "uuid": "90af4f22-22c8-41c8-82c3-f7cae552bddb",
            "name": "each",
            "method": "Prototype",
            "desc": "Iterates over all nodes in the Q object and executes a callback on each node, providing access to the index and element.",
            "type": "Iteration",
            "example": "Q(selector).each((index, element) => console.log(index, element)); // Logs the index and element for each node in the selection <br> Q(selector).each((index, element) => element.style.color = 'red'); // Changes the text color to red for each selected element",
            "dependencies": [],
            "script": "Q.Ext('each', function (callback) {\n    if (!this.nodes) return this;\n    this.nodes.forEach((b, c) => callback.call(b, c, b));\n    return this;\n});"
        },
        "empty": {
            "uuid": "de28cf06-6009-4aa4-a2a8-31e96b50cd3b",
            "name": "empty",
            "method": "Prototype",
            "desc": "Empties the innerHTML of each node.",
            "type": "Content Manipulation",
            "example": "Q(selector).empty();",
            "dependencies": [],
            "script": "Q.Ext('empty', function () {\n  const nodes = this.nodes;\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].innerHTML = '';\n  }\n  return this;\n});"
        },
        "eq": {
            "uuid": "4a1295d4-da56-4ce3-b1cd-cc29e58dfb63",
            "name": "eq",
            "method": "Prototype",
            "desc": "Returns a specific node by index.",
            "type": "Traversal",
            "example": "Q(selector).eq(1);",
            "dependencies": [],
            "script": "Q.Ext('eq', function (index) {\n  const node = this.nodes[index];\n  return node ? new Q(node) : _n;\n});"
        },
        "fadeIn": {
            "uuid": "e99cfed8-9c45-4882-bfc0-62bd31b6f959",
            "name": "fadeIn",
            "method": "Prototype",
            "desc": "Fades in each node.",
            "type": "Display",
            "example": "Q(selector).fadeIn(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeIn', function(a = 400, b) {\n    const d = this.nodes;\n    this.each(index => {\n      const element = d[index];\n      const c = element.style;\n      c.display = '';\n      c.transition = `opacity ${a}ms`;\n      void element.offsetHeight;\n      c.opacity = 1;\n      _st(() => {\n        c.transition = '';\n        if (b) {\n          b();\n        }\n      }, a);\n    });\n});"
        },
        "fadeOut": {
            "uuid": "264c9eb0-a8de-44dd-a6f4-858ad3bc22b6",
            "name": "fadeOut",
            "method": "Prototype",
            "desc": "Fades out each node.",
            "type": "Display",
            "example": "Q(selector).fadeOut(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeOut', function(a, b) {\n    const d = this.nodes;\n    this.each(index => {\n      const c = d[index].style;\n      c.transition = `opacity ${a}ms`;\n      c.opacity = 0;\n      _st(() => {\n        c.transition = '';\n        c.display = 'none';\n        if (b) b();\n      }, a);\n    });\n});"
        },
        "fadeTo": {
            "uuid": "3c48a23c-bd9d-4922-8ba4-31d4228332a5",
            "name": "fadeTo",
            "method": "Prototype",
            "desc": "Fades each node to a specific opacity.",
            "type": "Display",
            "example": "Q(selector).fadeTo(opacity, duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeTo', function(opacity, b, c) {\n    const e = this.nodes;\n    this.each(function(f) {\n      const element = e[f];\n      const d = element.style;\n      d.transition = `opacity ${b}ms`;\n      void element.offsetHeight;\n      d.opacity = opacity;\n      _st(function() {\n        d.transition = '';\n        if (c) {\n          c();\n        }\n      }, b);\n    });\n  });"
        },
        "fadeToggle": {
            "uuid": "9d594100-a26a-47ae-92e1-b78e9799e3bd",
            "name": "fadeToggle",
            "method": "Prototype",
            "desc": "Toggles the fade state of each node.",
            "type": "Display",
            "example": "Q(selector).fadeToggle(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('fadeToggle', function(a, b) {\n    const c = this.nodes;\n    this.each(function(e) {\n      const d = window.getComputedStyle(c[e]);\n      if (d.opacity === '0') {\n        this.fadeIn(a, b);\n      } else {\n        this.fadeOut(a, b);\n      }\n    });\n  });"
        },
        "find": {
            "uuid": "a2df96b4-8c64-4203-862b-03e34c636f25",
            "name": "find",
            "method": "Prototype",
            "desc": "Finds child nodes of the first node that match a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).find(\".child\");",
            "dependencies": [],
            "script": "Q.Ext('find', function(selector) {\n    const b = this.nodes[0];\n    if (!b) {\n      return _n;\n    }\n    const c = b.querySelectorAll(selector);\n    return c.length ? Q(c) : _n;\n  });"
        },
        "first": {
            "uuid": "813246f6-a758-4fd5-9070-584cf15e6d33",
            "name": "first",
            "method": "Prototype",
            "desc": "Returns the first node.",
            "type": "Traversal",
            "example": "Q(selector).first();",
            "dependencies": [],
            "script": "Q.Ext('first', function () {\n    return new Q(this.nodes[0]);\n});"
        },
        "focus": {
            "uuid": "6d0ec7fc-f1bf-4676-b2bc-00754ce90154",
            "name": "focus",
            "method": "Prototype",
            "desc": "Focuses on the first node.",
            "type": "Form Manipulation",
            "example": "Q(selector).focus();",
            "dependencies": [],
            "script": "Q.Ext('focus', function () {\n    return this.each(a => this.nodes[a].focus());\n});"
        },
        "hasClass": {
            "uuid": "ab538ffa-7d90-4357-aa60-efe00095a43f",
            "name": "hasClass",
            "method": "Prototype",
            "desc": "Checks if the first node has a specific class.",
            "type": "Class Manipulation",
            "example": "Q(selector).hasClass(className);",
            "dependencies": [],
            "script": "Q.Ext('hasClass', function(className) {\n    return this.nodes[0]?.classList.contains(className) || false;\n  });"
        },
        "height": {
            "uuid": "29ef9695-fc4f-44ab-86dd-01d58c75707f",
            "name": "height",
            "method": "Prototype",
            "desc": "Gets or sets the height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).height(value);",
            "dependencies": [],
            "script": "Q.Ext('height', function (a) {\n    const nodes = this.nodes; // ...existing code...\n    if (a === _un) {\n        return nodes[0].offsetHeight;\n    }\n    for (const node of nodes) {\n        node.style.height = a;\n    }\n    return this;\n});"
        },
        "hide": {
            "uuid": "564baca3-d52c-4b76-9950-9e631cabb127",
            "name": "hide",
            "method": "Prototype",
            "desc": "Hides each node, optionally with a fade-out effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).hide(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('hide', function (duration = 0, b) {\n    for (const node of this.nodes) {\n        if (duration === 0) {\n            node.style.display = 'none';\n            if (b) b();\n        } else {\n            node.style.transition = `opacity ${duration}ms`;\n            node.style.opacity = 1;\n            _st(() => {\n                node.style.opacity = 0;\n                node.addEventListener('transitionend', function d() {\n                    node.style.display = 'none';\n                    node.style.transition = '';\n                    node.removeEventListener('transitionend', d);\n                    if (b) b();\n                });\n            }, 0);\n        }\n    }\n    return this;\n});"
        },
        "html": {
            "uuid": "279fc50e-fc58-47d8-bab3-5a31f428a0d2",
            "name": "html",
            "method": "Prototype",
            "desc": "Gets or sets the innerHTML of the nodes. This method allows for easy manipulation of the content inside the selected elements.",
            "type": "Content Manipulation",
            "example": "const currentHtml = Q(selector).html(); // Retrieves the innerHTML of the first selected element <br> Q(selector).html('<div>New Content</div>'); // Sets the innerHTML of each selected element to '<div>New Content</div>' <br> Q(selector).html(['<span>First</span>', '<span>Second</span>']); // Sets the innerHTML with an array of strings <br> const newNode = Q('<p>Paragraph</p>'); Q(selector).html(newNode); // Sets the innerHTML with a Q object containing a new node <br> Q(selector).html(document.createElement('div')); // Sets the innerHTML with a new HTMLElement <br> const nodeList = document.querySelectorAll('.child'); Q(selector).html(nodeList); // Sets the innerHTML with a NodeList of child elements <br> Q(selector).html([]); // Sets the innerHTML to an empty string <br> Q(selector).html(null); // Sets the innerHTML to an empty string",
            "dependencies": [],
            "script": "Q.Ext('html', function (content) {\n    if (content === _un) {\n        return this.nodes[0] ? this.nodes[0].innerHTML : _n;\n    }\n    for (const d of this.nodes) {\n        d.innerHTML = '';\n        const appendContent = (b) => {\n            if (typeof b === 'string') {\n                d.insertAdjacentHTML('beforeend', b);\n            } else if (b instanceof Q) {\n                for (const subnode of b.nodes) {\n                    d.appendChild(subnode);\n                }\n            } else if (b?.nodeType === 1 || b?.nodeType != _n) {\n                d.appendChild(b);\n            } else if (_ar.isArray(b) || b?.constructor === _nl) {\n                for (const e of _ar.from(b)) {\n                    d.appendChild(e);\n                }\n            }\n        };\n        if (_ar.isArray(content) || content?.constructor === _nl) {\n            for (const b of _ar.from(content)) {\n                appendContent(b);\n            }\n        } else {\n            appendContent(content);\n        }\n    }\n    return this;\n});"
        },
        "id": {
            "uuid": "891e845b-df97-4ae4-b8b4-adb7b4128f91",
            "name": "id",
            "method": "Prototype",
            "desc": "Gets or sets the id attribute of the first node. This provides a simple way to retrieve or modify the unique identifier of an element.",
            "type": "Attributes",
            "example": "const currentId = Q(selector).id(); // Retrieves the current id of the first selected element <br> Q(selector).id('new-id'); // Sets the id of the first selected element to 'new-id'",
            "dependencies": [],
            "script": "Q.Ext('id', function (ident) {\n    const node = this.nodes[0];\n    if (ident === _un) return node.id;\n    node.id = ident;\n    return this;\n});"
        },
        "index": {
            "uuid": "cae323bb-6cf1-49b8-94d3-ead6901e32d6",
            "name": "index",
            "method": "Prototype",
            "desc": "Returns the index of the first node, or moves the node to a specific index within its parent.",
            "type": "Traversal",
            "example": "const idx = Q(selector).index(); // Retrieves the index of the first selected node among its siblings <br> Q(selector).index(2); // Moves the first selected node to the index position 2 within its parent",
            "dependencies": [],
            "script": "Q.Ext('index', function (index) {\n    const first = this.nodes[0];\n    if (index === _un) {\n        return _ar.from(first.parentNode.children).indexOf(first);\n    }\n    for (const node of this.nodes) {\n        const b = node.parentNode;\n        if (!b) continue;\n        const children = _ar.from(b.children);\n        b.removeChild(node);\n        if (index >= children.length) {\n            b.appendChild(node);\n        } else {\n            b.insertBefore(node, children[index]);\n        }\n    }\n    return this;\n});"
        },
        "inside": {
            "uuid": "150af2ab-a6bd-4baa-a2bb-4f6c519ded68",
            "name": "inside",
            "method": "Prototype",
            "desc": "Checks if the first node is inside another node, determined by a specific selector.",
            "type": "Traversal",
            "example": "Q(selector).inside(\".parent\"); // Returns true if the first selected element is within a parent matching the selector <br> const isChild = Q(selector).inside(\"#container\"); // Checks if the first node is inside the element with ID \"container\"",
            "dependencies": [],
            "script": "Q.Ext('inside', function (selector) {\n    const node = this.nodes[0];\n    return node ? node.closest(selector) !== _n : false;\n});"
        },
        "is": {
            "uuid": "a92f25e4-3417-4f58-a2a8-a8dbc297abfe",
            "name": "is",
            "method": "Prototype",
            "desc": "Checks if the first node matches a specific selector or condition, allowing for dynamic queries and element comparisons.",
            "type": "Utilities",
            "example": "Q(selector).is(\":visible\"); // Checks if the element is currently visible <br> Q(selector).is(\":checked\"); // Checks if a checkbox or radio button is checked <br> Q(selector).is(anotherElement); // Compares the first node with another DOM element <br> Q(selector).is(\":hover\"); // Checks if the element is currently being hovered over",
            "dependencies": [],
            "script": "Q.Ext('is', function (selector) {\n    const b = this.nodes[0];\n    if (!b) return false;\n    if (typeof selector === 'function') {\n        return selector.call(b, 0, b);\n    }\n    if (typeof selector === 'string') {\n        switch (selector) {\n            case ':visible':\n                return b.offsetWidth > 0 && b.offsetHeight > 0;\n            case ':hidden':\n                return b.offsetWidth === 0 || b.offsetHeight === 0;\n            case ':hover':\n                return b === document.querySelector(':hover');\n            case ':focus':\n                return b === document.activeElement;\n            case ':blur':\n                return b !== document.activeElement;\n            case ':checked':\n                return b.checked;\n            case ':selected':\n                return b.selected;\n            case ':disabled':\n                return b.disabled;\n            case ':enabled':\n                return !b.disabled;\n            default:\n                return b.matches(selector);\n        }\n    }\n    if (selector?.nodeType === 1 || selector?.nodeType != _n) {\n        return b === selector;\n    }\n    if (selector instanceof Q) {\n        return b === selector.nodes[0];\n    }\n    return false;\n});"
        },
        "isExists": {
            "uuid": "a4afc6fb-0ad9-42e3-a778-acda08fb3c95",
            "name": "isExists",
            "method": "Prototype",
            "desc": "Checks if the first node exists in the DOM.",
            "type": "Utilities",
            "example": "Q(selector).isExists(); or Q.isExists('.ok')",
            "dependencies": [],
            "script": "Q.Ext('isExists', function () {\n    const node = this.nodes[0];\n    return node ? document.body.contains(node) : false;\n});\nQ.isExists = function (a) {\n    return document.querySelector(a) !== _n;\n};"
        },
        "last": {
            "uuid": "562515c0-05ff-4e18-8585-efa723bcb48b",
            "name": "last",
            "method": "Prototype",
            "desc": "Returns the last node.",
            "type": "Traversal",
            "example": "Q(selector).last();",
            "dependencies": [],
            "script": "Q.Ext('last', function () {\n    const nodes = this.nodes;\n    return new Q(nodes[nodes.length - 1]);\n});"
        },
        "map": {
            "uuid": "099c8ff1-8737-440f-b443-34069e1e0c91",
            "name": "map",
            "method": "Prototype",
            "desc": "Maps each node to a new array.",
            "type": "Array",
            "example": "Q(selector).map(el => el.innerHTML);",
            "dependencies": [],
            "script": "Q.Ext('map', function (callback) {\n    const b = [];\n    for (const node of this.nodes) {\n        b.push(callback(new Q(node)));\n    }\n    return b;\n});"
        },
        "off": {
            "uuid": "6f5bfb92-54f1-4f14-9515-ee2756a0affb",
            "name": "off",
            "method": "Prototype",
            "desc": "Removes an event listener from each node.",
            "type": "Event Handling",
            "example": "Q(selector).off(\"click\", handler);",
            "dependencies": [],
            "script": "Q.Ext('off', function (a, b, c) {\n    const d = {\n        capture: false,\n        once: false,\n        passive: false\n    };\n    c = { ...d, ...c };\n    const eventList = a.split(' ');\n    for (const node of this.nodes) {\n        for (const e of eventList) {\n            node.removeEventListener(e, b, c);\n        }\n    }\n    return this;\n});"
        },
        "offset": {
            "uuid": "43fd33d0-2ba4-46a4-aeec-3f85cde2e094",
            "name": "offset",
            "method": "Prototype",
            "desc": "Returns the top and left offset of the first node relative to the document.",
            "type": "Dimensions",
            "example": "Q(selector).offset();",
            "dependencies": [],
            "script": "Q.Ext('offset', function () {\n    const node = this.nodes[0];\n    const a = node.getBoundingClientRect();\n    return {\n        top: a.top + window.scrollY,\n        left: a.left + window.scrollX\n    };\n});"
        },
        "on": {
            "uuid": "6b7abf9a-cb29-4b4a-8bce-7246ccb46e84",
            "name": "on",
            "method": "Prototype",
            "desc": "Adds an event listener to each node.",
            "type": "Event Handling",
            "example": "Q(selector).on(\"click\", () => console.log(\"Clicked\"));",
            "dependencies": [],
            "script": "Q.Ext('on', function (a, b, c) {\n  const d = {\n      capture: false,\n      once: false,\n      passive: false\n  };\n  c = { ...d, ...c };\n  const eventList = a.split(' ');\n  return this.each(index => {\n      const node = this.nodes[index];\n      eventList.forEach(f => {\n          node.addEventListener(f, b, c);\n      });\n  });\n});"
        },
        "parent": {
            "uuid": "b3f8b1ff-fade-4cf7-b9e6-01bb2c735549",
            "name": "parent",
            "method": "Prototype",
            "desc": "Returns the parent node of the first node.",
            "type": "Traversal",
            "example": "Q(selector).parent();",
            "dependencies": [],
            "script": "Q.Ext('parent', function () {\n    const node = this.nodes[0];\n    return new Q(node ? node.parentNode : _n);\n});"
        },
        "position": {
            "uuid": "a09196a8-fc4c-4f03-aeb4-fdd4bd23f7c3",
            "name": "position",
            "method": "Prototype",
            "desc": "Returns the top and left position of the first node relative to its offset parent.",
            "type": "Dimension/Position",
            "example": "Q(selector).position();",
            "dependencies": [],
            "script": "Q.Ext('position', function () {\n    const node = this.nodes[0];\n    return {\n        top: node.offsetTop,\n        left: node.offsetLeft\n    };\n});"
        },
        "prepend": {
            "uuid": "de077681-d185-4995-aa30-40c4a369a725",
            "name": "prepend",
            "method": "Prototype",
            "desc": "Prepends child nodes or HTML to each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).prepend(\"<div>Prepended</div>\");",
            "dependencies": [],
            "script": "Q.Ext('prepend', function (...a) {\n    for (const b of this.a) {\n        for (const c of a) {\n            if (typeof c === 'string') {\n                b.insertAdjacentHTML('afterbegin', c);\n            } else if (c instanceof Q) {\n                b.insertBefore(c.a[0], b.firstChild);\n            } else if (c?.nodeType === 1 || c?.nodeType != _n) {\n                b.insertBefore(c, b.firstChild);\n            } else if (_ar.isArray(c) || c?.constructor === _nl) {\n                for (const d of _ar.from(c)) {\n                    b.insertBefore(d, b.firstChild);\n                }\n            }\n        }\n    }\n    return this;\n});"
        },
        "prop": {
            "uuid": "37d4bbd8-768d-482c-ac41-e34303ffb815",
            "name": "prop",
            "method": "Prototype",
            "desc": "Gets or sets a property on the nodes.",
            "type": "Property Manipulation",
            "example": "Q(selector).prop(property, value);",
            "dependencies": [],
            "script": "Q.Ext('prop', function (property, b) {\n    if (b === _un) {\n        return this.nodes[0] ? this.nodes[0][property] : _n;\n    }\n    for (const node of this.nodes) {\n        node[property] = b;\n    }\n    return this;\n});"
        },
        "remove": {
            "uuid": "243b24e7-4f6a-409e-8d79-c14cbc00f6c5",
            "name": "remove",
            "method": "Prototype",
            "desc": "Removes each node from the DOM.",
            "type": "DOM Manipulation",
            "example": "Q(selector).remove();",
            "dependencies": [],
            "script": "Q.Ext('remove', function() {\n    for (const node of this.nodes) {\n        node.remove();\n    }\n    return this;\n});"
        },
        "removeAttr": {
            "uuid": "c53167df-c766-4982-bce3-3c9ada3d47a1",
            "name": "removeAttr",
            "method": "Prototype",
            "desc": "Removes an attribute from each node.",
            "type": "Attribute Manipulation",
            "example": "Q(selector).removeAttr(attribute);",
            "dependencies": [],
            "script": "Q.Ext('removeAttr', function (a) {\n    for (const node of this.nodes) {\n        node.removeAttribute(a);\n    }\n    return this;\n});"
        },
        "removeClass": {
            "uuid": "e66e513b-be73-48bd-95ae-f169cf7f0fff",
            "name": "removeClass",
            "method": "Prototype",
            "desc": "Removes one or more classes from each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).removeClass(\"class1 class2\");",
            "dependencies": [],
            "script": "Q.Ext('removeClass', function (a) {\n    const b = a.split(' ');\n    for (const node of this.nodes) {\n        node.classList.remove(...b);\n    }\n    return this;\n});"
        },
        "removeData": {
            "uuid": "8e63d6d7-8343-4516-9bab-fa5af46cd53b",
            "name": "removeData",
            "method": "Prototype",
            "desc": "Removes a data-* attribute from each node.",
            "type": "Data Manipulation",
            "example": "Q(selector).removeData(key);",
            "dependencies": [],
            "script": "Q.Ext('removeData', function (key) {\n    return this.each(index => {\n        const node = this.nodes[index];\n        delete node.dataset[key];\n    });\n});"
        },
        "removeProp": {
            "uuid": "a216c7ce-4894-4882-b602-86a7488cae40",
            "name": "removeProp",
            "method": "Prototype",
            "desc": "Removes a property from each node.",
            "type": "Property Manipulation",
            "example": "Q(selector).removeProp(property);",
            "dependencies": [],
            "script": "Q.Ext('removeProp', function (property) {\n    return this.each(index => {\n        const node = this.nodes[index];\n        delete node[property];\n    });\n});"
        },
        "removeTransition": {
            "uuid": "8e51b2fa-b911-4559-a15c-0fef509ccdb9",
            "name": "removeTransition",
            "method": "Prototype",
            "desc": "Removes the transition from each node.",
            "type": "Display",
            "example": "Q(selector).removeTransition();",
            "dependencies": [],
            "script": "Q.Ext('removeTransition', function () {\n    return this.each(index => {\n        const node = this.nodes[index];\n        node.style.transition = '';\n    });\n});"
        },
        "scrollHeight": {
            "uuid": "c17e9d81-6376-4084-959e-09a0dbc4e134",
            "name": "scrollHeight",
            "method": "Prototype",
            "desc": "Returns the scroll height of the first node.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollHeight();",
            "dependencies": [],
            "script": "Q.Ext('scrollHeight', function () {\n    return this.nodes[0].scrollHeight;\n});"
        },
        "scrollLeft": {
            "uuid": "32d7f515-6417-4da0-bc7d-8fbce34049d5",
            "name": "scrollLeft",
            "method": "Prototype",
            "desc": "Gets or sets the horizontal scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollLeft(value, increment);",
            "dependencies": [],
            "script": "Q.Ext('scrollLeft', function (a, b) {\n    if (a === _un) {\n        return this.nodes[0].scrollLeft;\n    }\n    return this.each(index => {\n        const node = this.nodes[index];\n        const c = node.scrollWidth - node.clientWidth;\n        if (b) {\n            node.scrollLeft = _ma.min(node.scrollLeft + a, c);\n        } else {\n            node.scrollLeft = _ma.min(a, c);\n        }\n    });\n});"
        },
        "scrollTop": {
            "uuid": "091ba607-1f2b-40e9-8cc3-acef50f939c5",
            "name": "scrollTop",
            "method": "Prototype",
            "desc": "Gets or sets the vertical scroll position of the first node, with an option to increment.",
            "type": "Scroll Manipulation",
            "example": "Q(selector).scrollTop(value, increment);",
            "dependencies": [],
            "script": "Q.Ext('scrollTop', function (a, b) {\n    if (a === _un) {\n        return this.nodes[0].scrollTop;\n    }\n    return this.each(index => {\n        const node = this.nodes[index];\n        const c = node.scrollHeight - node.clientHeight;\n        if (b) {\n            node.scrollTop = _ma.min(node.scrollTop + a, c);\n        } else {\n            node.scrollTop = _ma.min(a, c);\n        }\n    });\n});"
        },
        "scrollWidth": {
            "uuid": "1c5ddaff-57f7-40f8-8ac9-adc51bb5a516",
            "name": "scrollWidth",
            "method": "Prototype",
            "desc": "Returns the scroll width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).scrollWidth();",
            "dependencies": [],
            "script": "Q.Ext('scrollWidth', function () {\n    return this.nodes[0].scrollWidth;\n});"
        },
        "show": {
            "uuid": "edf3874c-056c-4bec-858e-93303e8987d1",
            "name": "show",
            "method": "Prototype",
            "desc": "Shows each node, optionally with a fade-in effect over a specified duration.",
            "type": "Display",
            "example": "Q(selector).show(duration, callback);",
            "dependencies": [],
            "script": "Q.Ext('show', function (duration = 0, b) {\n    return this.each(index => {\n        const c = this.nodes[index];\n        if (duration === 0) {\n            c.style.display = '';\n            if (b) b();\n        } else {\n            c.style.transition = `opacity ${duration}ms`;\n            c.style.opacity = 0;\n            c.style.display = '';\n            _st(() => {\n                c.style.opacity = 1;\n                c.addEventListener('transitionend', () => {\n                    c.style.transition = '';\n                    if (b) b();\n                }, { once: true });\n            }, 0);\n        }\n    });\n});"
        },
        "size": {
            "uuid": "47ced80e-e26f-435a-8d50-c23e7984492d",
            "name": "size",
            "method": "Prototype",
            "desc": "Returns the width and height of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).size();",
            "dependencies": [],
            "script": "Q.Ext('size', function () {\n\treturn {\n\t\twidth: this.nodes[0].offsetWidth,\n\t\theight: this.nodes[0].offsetHeight\n\t};\n});"
        },
        "text": {
            "uuid": "452e4619-53ec-4a21-bd0a-baa7c3f81bad",
            "name": "text",
            "method": "Prototype",
            "desc": "Gets or sets the text content of the nodes.",
            "type": "Content Manipulation",
            "example": "Q(selector).text(string);",
            "dependencies": [],
            "script": "Q.Ext('text', function (a) {\n    if (a === _un) {\n        return this.nodes[0]?.textContent || _n;\n    }\n    return this.each(function(index, b) {\n        b.textContent = a;\n    });\n});"
        },
        "toggle": {
            "uuid": "a2fd71e9-788e-4ea7-bf66-7f860b9e7f2e",
            "name": "toggle",
            "method": "Prototype",
            "desc": "Toggles the display of each node.",
            "type": "Utilities",
            "example": "Q(selector).toggle();",
            "dependencies": [],
            "script": "Q.Ext('toggle', function () {\n    return this.each(function(index, a) {\n        a.style.display = (a.style.display === 'none' ? '' : 'none');\n    });\n});"
        },
        "toggleClass": {
            "uuid": "1bf3a381-77e0-45ae-8149-9b1ea3a900c9",
            "name": "toggleClass",
            "method": "Prototype",
            "desc": "Toggles a class on each node.",
            "type": "Class Manipulation",
            "example": "Q(selector).toggleClass(className);",
            "dependencies": [],
            "script": "Q.Ext('toggleClass', function (className) {\n    return this.each(function(index, b) {\n        b.classList.toggle(className);\n    });\n});"
        },
        "trigger": {
            "uuid": "9071250d-6a8d-4d96-a217-da41a6ad1230",
            "name": "trigger",
            "method": "Prototype",
            "desc": "Triggers a specific event on each node.",
            "type": "Event Handling",
            "example": "Q(selector).trigger(\"click\");",
            "dependencies": [],
            "script": "Q.Ext('trigger', function (event) {\n\treturn this.each(function(c, b) {\n\t\tb.dispatchEvent(new _ev(event));\n\t});\n});"
        },
        "unwrap": {
            "uuid": "190f9810-ba77-4e7e-8bbc-b8b137e5522f",
            "name": "unwrap",
            "method": "Prototype",
            "desc": "Removes the parent wrapper of each node.",
            "type": "DOM Manipulation",
            "example": "Q(selector).unwrap();",
            "dependencies": [],
            "script": "Q.Ext('unwrap', function () {\n    return this.each(function(index, b) {\n        const a = b.parentNode;\n        if (a && a !== document.body) {\n            a.replaceWith(...a.childNodes);\n        }\n    });\n});"
        },
        "val": {
            "uuid": "0dc3d9e2-f9ce-48de-8a46-bd8dd55827c0",
            "name": "val",
            "method": "Prototype",
            "desc": "Gets or sets the value of form elements in the nodes.",
            "type": "Form Manipulation",
            "example": "Q(selector).val(value);",
            "dependencies": [],
            "script": "Q.Ext('val', function(a) {\n    if (a === _un) return this.nodes[0]?.value || _n;\n    for (const node of this.nodes) {\n        node.value = a;\n    }\n    return this;\n  });"
        },
        "wait": {
            "uuid": "e42209f4-5b2b-4b71-a9cf-38fda0bc1cb1",
            "name": "wait",
            "method": "Prototype",
            "desc": "Returns a promise that resolves after a given time. Useful for delaying actions.",
            "type": "Utility",
            "example": "Q('.text').wait(1000).text('Hello, World!');",
            "dependencies": [],
            "script": "Q.Ext('wait', function(ms) {\n\treturn new _pr(resolve => _st(() => resolve(this), ms));\n});"
        },
        "walk": {
            "uuid": "32ee1768-9db9-4fb1-9eed-996a75f062f5",
            "name": "walk",
            "method": "Prototype",
            "desc": "Walks through all nodes in the Q object and executes a callback on each node, passing the current node as a Q object or raw element based on the boolean parameter.",
            "type": "Iteration",
            "example": "Q(selector).walk((node) => console.log(node), true); // Passes Q object",
            "dependencies": [],
            "script": "Q.Ext('walk', function (callback, b = false) {\n\treturn this.each(function(d, el) {\n\t\tconst c = b ? Q(el) : el;\n\t\tcallback.call(el, c, d);\n\t});\n});"
        },
        "width": {
            "uuid": "53c2219f-5e69-42f4-8fcb-ff01c938718d",
            "name": "width",
            "method": "Prototype",
            "desc": "Gets or sets the width of the first node.",
            "type": "Dimensions",
            "example": "Q(selector).width(value);",
            "dependencies": [],
            "script": "Q.Ext('width', function (value) {\n    if (typeof value === '_un') {\n        return this.nodes[0] ? this.nodes[0].offsetWidth : _un;\n    }\n    this.nodes.forEach(node => {\n        node.style.width = value;\n    });\n    return this;\n});"
        },
        "wrap": {
            "uuid": "edb17681-6c4f-4173-9dc7-9d7145fe01d5",
            "name": "wrap",
            "method": "Prototype",
            "desc": "Wraps each node with the specified wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrap(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrap', function (a) {\n    return this.each(f => {\n        const b = f.b;\n        let c = typeof a === 'string'\n            ? // Create and clone the a so each f gets its own instance.\n              ((d => (d.innerHTML = a.trim(), d.firstElementChild.cloneNode(true)))\n              (document.createElement('e')))\n            : a;\n        b.insertBefore(c, f);\n        c.appendChild(f);\n    });\n});"
        },
        "wrapAll": {
            "uuid": "f2f81496-8db6-4ac0-b5da-75cd3a5c366c",
            "name": "wrapAll",
            "method": "Prototype",
            "desc": "Wraps all nodes together in a single wrapper element.",
            "type": "DOM Manipulation",
            "example": "Q(selector).wrapAll(\"<div class='wrapper'></div>\");",
            "dependencies": [],
            "script": "Q.Ext('wrapAll', function (wrapper) {\n    if (!this.nodes.length) return this;\n    const b = this.nodes[0].parentNode;\n    let c = typeof wrapper === 'string'\n        ? ((tempDiv => (tempDiv.innerHTML = wrapper.trim(), tempDiv.firstElementChild))\n           (document.createElement('div')))\n        : wrapper;\n    b.insertBefore(c, this.nodes[0]);\n    this.nodes.forEach(d => c.appendChild(d));\n    return this;\n});"
        },
        "zIndex": {
            "uuid": "bc0a79ef-2092-4d18-8c18-cf4a759d557c",
            "name": "zIndex",
            "method": "Prototype",
            "desc": "Gets or sets the z-index of the first node.",
            "type": "Display",
            "example": "Q(selector).zIndex(value);",
            "dependencies": [],
            "script": "Q.Ext('zIndex', function (value) {\n    const node = this.nodes[0];\n    if (!node) return;\n    if (value === _un) {\n        let b = node.style.zIndex || window.getComputedStyle(node).zIndex;\n        return b;\n    }\n    this.nodes.forEach(node => node.style.zIndex = value);\n    return this;\n});"
        }
    },
    "plugins": {
        "Container": {
            "uuid": "6699df82-1187-4e55-86d3-9a50a1aacf1b",
            "name": "Container",
            "method": "Plugin",
            "desc": "Useful to create containers for your elements, like tabs, accordions, etc.",
            "type": "Plugin",
            "example": "var containers = Q.Container();",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "Icons"
            ],
            "script": "Q.Container = function (options = {}) {\n    const Container = {};\n    Container.Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' container_icon');\n        return iconElement;\n    };\n    Q.Icons();\n    Container.classes = Q.style(`\n        .container_icon {\n            width: 100%;\n            height: 100%;\n            color: #777; /* Default color */\n            pointer-events: none;\n            z-index: 1;\n        }\n    `, {\n        'container_icon': 'container_icon'\n    });\n    return Container;\n};"
        },
        "Container.Tab": {
            "uuid": "6faf3a44-7f11-4609-9842-70ceda849705",
            "name": "Container.Tab",
            "method": "Component",
            "desc": "Tab component for Container plugin",
            "type": "Component",
            "example": "var tabs = Q.Container.Tab([{title: 'Tab 1', value: 'tab1', content: 'Content 1'}, {title: 'Tab 2', value: 'tab2', content: 'Content 2'}]);",
            "dependencies": [
                "Container",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "find",
                "scrollTop",
                "scrollLeft",
                "html",
                "text",
                "data",
                "click"
            ],
            "script": "Q.Container.Tab = function (options = {}) {\n    const Container = Q.Container();\n    const Icon = Container.Icon;\n    const sharedClasses = Container.classes;\n    const classes = _ob.assign({}, sharedClasses, Q.style(`\n        .tab_navigation_buttons {\n            box-sizing: border-box;\n            width: 20px;\n            background-color: #333;\n            display: flex;\n            justify-content: center;\n            padding: 4px;\n        }\n        .tab_navigation_buttons_vertical {\n            width: auto;\n            height: 20px;\n        }\n        .tab_navigation_buttons:hover {\n            background-color: #555;\n        }\n        .tab_container {\n            width: 100%;\n            height: 300px;\n        }\n        .tab_container_vertical {\n            display: flex;\n        }\n        .tab_navigation_header {\n            background-color: #333;\n            display: flex;\n        }\n        .tab_navigation_header_vertical {\n            flex-direction: column;\n            width: auto;\n        }\n        .tab_navigation_tabs {\n            user-select: none;\n            display: flex;\n            flex-direction: row;\n            width: 100%;\n            overflow: hidden;\n        }\n        .tab_navigation_tabs_vertical {\n            flex-direction: column;\n        }\n        .tab_active {\n            background-color: #555;\n            color: #fff;\n        }\n        .tab {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            cursor: default;\n            padding: 5px 25px;\n        }\n        .tab_disabled {\n            background-color: #333;\n            color: #555;\n        }\n    `, {\n        'tab_navigation_buttons': 'tab_navigation_buttons',\n        'tab_navigation_buttons_vertical': 'tab_navigation_buttons_vertical',\n        'tab_container': 'tab_container',\n        'tab_container_vertical': 'tab_container_vertical',\n        'tab_navigation_header': 'tab_navigation_header',\n        'tab_navigation_header_vertical': 'tab_navigation_header_vertical',\n        'tab_navigation_tabs': 'tab_navigation_tabs',\n        'tab_navigation_tabs_vertical': 'tab_navigation_tabs_vertical',\n        'tab_active': 'tab_active',\n        'tab': 'tab',\n        'tab_disabled': 'tab_disabled'\n    }));\n    return function (data, horizontal = true) {\n        let wrapper = Q('<div>', { class: classes.tab_container });\n        let tabs_wrapper = Q('<div>', { class: classes.tab_navigation_header });\n        let tabs_nav_left = Q('<div>', { class: classes.tab_navigation_buttons });\n        let tabs_nav_right = Q('<div>', { class: classes.tab_navigation_buttons });\n        let tabs = Q('<div>', { class: classes.tab_navigation_tabs });\n        tabs_wrapper.append(tabs_nav_left, tabs, tabs_nav_right);\n        let content = Q('<div>');\n        wrapper.append(tabs_wrapper, content);\n        if (!horizontal) {\n            wrapper.addClass(classes.tab_container_vertical);\n            tabs.addClass(classes.tab_navigation_tabs_vertical);\n            tabs_wrapper.addClass(classes.tab_navigation_header_vertical);\n            tabs_nav_left.addClass(classes.tab_navigation_buttons_vertical);\n            tabs_nav_right.addClass(classes.tab_navigation_buttons_vertical);\n            tabs_nav_left.append(Icon('arrow-up'));\n            tabs_nav_right.append(Icon('arrow-down'));\n        }\n        else {\n            tabs_nav_left.append(Icon('arrow-left'));\n            tabs_nav_right.append(Icon('arrow-right'));\n        }\n        let data_tabs = {};\n        let data_contents = {};\n        data.forEach((item) => {\n            const tab = Q('<div>', { class: classes.tab, 'data-value': item.value }).text(item.title);\n            if (item.disabled) {\n                tab.addClass(classes.tab_disabled);\n            }\n            data_tabs[item.value] = tab;\n            data_contents[item.value] = item.content;\n            tab.on('click', function () {\n                if (item.disabled) {\n                    return;\n                }\n                let foundTabs = tabs.find('.' + classes.tab_active);\n                if (foundTabs) {\n                    foundTabs.removeClass(classes.tab_active);\n                }\n                tab.addClass(classes.tab_active);\n                content.html(data_contents[item.value]);\n            });\n            tabs.append(tab);\n        });\n        tabs_nav_left.on('click', function () {\n            if (!horizontal) {\n                tabs.scrollTop(-tabs.height(), true);\n            } else {\n                tabs.scrollLeft(-tabs.width(), true);\n            }\n        });\n        tabs_nav_right.on('click', function () {\n            if (!horizontal) {\n                tabs.scrollTop(tabs.height(), true);\n            } else {\n                tabs.scrollLeft(tabs.width(), true);\n            }\n        });\n        wrapper.select = function (value) {\n            _ob.keys(data_tabs).forEach(key => {\n                if (data_tabs[key].data('value') === value) {\n                    data_tabs[key].click();\n                }\n            });\n        };\n        wrapper.disabled = function (value, state) {\n            if (data_tabs[value]) {\n                if (state) {\n                    data_tabs[value].addClass(classes.tab_disabled);\n                } else {\n                    data_tabs[value].removeClass(classes.tab_disabled);\n                }\n            }\n        };\n        return wrapper;\n    };\n};"
        },
        "Cookie": {
            "uuid": "2079bf89-6478-466c-bf3e-6adf9bca308e",
            "name": "Cookie",
            "method": "Plugin",
            "desc": "Provides methods to store and retrieve data from the browser cookies.",
            "type": "Plugin",
            "example": "Q.Cookie('key', 'value to store'); Q.Cookie('key'); // returns 'value to store'",
            "dependencies": [],
            "script": "Q.Cookie = function (a, b, c = {}) {\n    const buildOptions = (options) => {\n      let optionsStr = '';\n      if (options.days) optionsStr += `expires=${new _da(_da.now() + options.days * 86400000).toUTCString()}; `;\n      if (options.path) optionsStr += `path=${options.path}; `;\n      if (options.domain) optionsStr += `domain=${options.domain}; `;\n      if (options.secure) optionsStr += 'secure; ';\n      return optionsStr;\n    };\n    if (arguments.length > 1) {\n      if (b === _n || b === '') {\n        b = '';\n        c = { ...c, days: -1 };\n      }\n      return document.cookie = `${a}=${b}; ${buildOptions(c)}`;\n    }\n    const allCookies = document.cookie.split('; ');\n    for (let i = 0, len = allCookies.length; i < len; i++) {\n      const currentCookie = allCookies[i];\n      const indexEqual = currentCookie.indexOf('=');\n      if (indexEqual > -1 && currentCookie.slice(0, indexEqual).trim() === a) {\n        return currentCookie.slice(indexEqual + 1);\n      }\n    }\n    return _un;\n  };"
        },
        "Fetch": {
            "uuid": "6f927ae8-f57b-4e33-a829-7e3ffaf65591",
            "name": "Fetch",
            "method": "Plugin",
            "desc": "Fetches data from a URL and returns it to a callback function. Supports retries, timeouts, and custom response validation.",
            "type": "Plugin",
            "example": "Q.fetch('https://api.example.com/data', (error, data) => console.log(error, data));",
            "dependencies": [],
            "script": "Q.Fetch = function (url, b, c = {}) {\n    const {\n        method = 'GET',\n        headers = {},\n        body,\n        contentType = 'application/json',\n        responseType = 'json',\n        credentials = 'same-origin',\n        retries = 3,\n        retryDelay = 1000,\n        exponentialBackoff = false,\n        timeout = 0,\n        validateResponse = (j) => j,\n        query = _n,\n        e: externalSignal = _n\n    } = c;\n    if (query && typeof query === 'object') {\n        const urlObject = new URL(url, location.origin);\n        _ob.entries(query).forEach(([key, value]) => urlObject.searchParams.append(key, value));\n        url = urlObject.toString();\n    }\n    let requestBody = body;\n    if (body && typeof body === 'object' && contentType === 'application/json' && !(body instanceof FormData)) {\n        try { requestBody = JSON.stringify(body); } catch (k) { b(new _er('Failed to serialize request body'), _n); return; }\n    }\n    headers['Content-Type'] = headers['Content-Type'] || contentType;\n    const d = new _ac();\n    const { e } = d;\n    if (externalSignal) {\n        externalSignal.addEventListener('abort', () => d.abort(), { once: true });\n    }\n    const doFetch = (f) => {\n        let h = _n;\n        if (timeout) { h = _st(() => d.abort(), timeout); }\n        _f(url, { method, headers, body: requestBody, credentials, e })\n            .then(i => {\n                if (!i.ok) throw new _er(`Network i was not ok: ${i.statusText}`);\n                switch (responseType) {\n                    case 'json': return i.json();\n                    case 'text': return i.text();\n                    case 'blob': return i.blob();\n                    case 'arrayBuffer': return i.arrayBuffer();\n                    default: throw new _er('Unsupported i type');\n                }\n            })\n            .then(result => {\n                if (h) _ct(h);\n                return validateResponse(result);\n            })\n            .then(validatedData => b(_n, validatedData))\n            .catch(k => {\n                if (h) _ct(h);\n                if (k.name === 'AbortError') {\n                    b(new _er('Fetch request was aborted'), _n);\n                } else if (f < retries) {\n                    const delay = exponentialBackoff ? retryDelay * (2 ** f) : retryDelay;\n                    _st(() => doFetch(f + 1), delay);\n                } else {\n                    b(k, _n);\n                }\n            });\n    };\n    doFetch(0);\n    return { abort: () => d.abort() };\n};"
        },
        "Form.Button": {
            "uuid": "e7571a4a-cbc7-4dc4-a7a5-f07b87e47210",
            "name": "Form.Button",
            "method": "Component",
            "desc": "Button component for Form plugin",
            "type": "Component",
            "example": "var button = Q.Form.Button('Click me'); button.click(function() { alert('Clicked!'); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "text",
                "click"
            ],
            "script": "Q.Form.Button = function (text = '') {\n    const Form = Q.Form();\n    const sharedClasses = Form.classes;\n    const classes = _ob.assign({}, sharedClasses, Q.style(`\n        .q_form_button {\n            user-select: none;\n            padding: 5px 10px;\n            cursor: pointer;\n        }\n        .q_form_button:hover {\n            background-color: #555;\n        }\n        .q_form_button:active {\n            background-color: #777;\n        }\n    `, {\n        'q_form_button': 'q_form_button'\n    }));\n    const button = Q(`<div class=\"${classes.q_form} ${classes.q_form_button}\">${text}</div>`);\n    button.click = function (callback) {\n        button.on('click', callback);\n    };\n    button.disabled = function (state) {\n        if (state) {\n            button.addClass(classes.q_form_disabled);\n        }\n        else {\n            button.removeClass(classes.q_form_disabled);\n        }\n    };\n    button.text = function (text) {\n        button.text(text);\n    };\n    button.remove = function () {\n        button.remove();\n    };\n    return button;\n};"
        },
        "Form.CheckBox": {
            "uuid": "d8827510-471a-4978-8f75-d59ff8c359b6",
            "name": "Form.CheckBox",
            "method": "Component",
            "desc": "CheckBox component for Form plugin",
            "type": "Component",
            "example": "var checkbox = Q.Form.CheckBox(true, 'Check me'); checkbox.change(function(checked) { console.log(checked); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "prop",
                "trigger",
                "text"
            ],
            "script": "Q.Form.CheckBox = function (checked = false, text = '') {\n    const Form = Q.Form();\n    const sharedClasses = Form.classes;\n    const classes = _ob.assign({}, sharedClasses, Q.style(`\n        .q_form_checkbox {\n            display: flex;\n            width: fit-content;\n            align-items: center;\n        }\n        .q_form_checkbox .label:empty {\n            display: none;\n        }\n        .q_form_checkbox .label {\n            padding-left: 5px;\n            user-select: none;\n        }\n        .q_form_cb {\n            position: relative;\n            width: 20px;\n            height: 20px;\n            background-color: #555555;\n        }\n        .q_form_cb input[type=\"checkbox\"] {\n            opacity: 0;\n            top: 0;\n            left: 0;\n            padding: 0;\n            margin: 0;\n            width: 100%;\n            height: 100%;\n            position: absolute;\n        }\n        .q_form_cb input[type=\"checkbox\"]:checked+label:before {\n            content: \"\";\n            position: absolute;\n            display: block;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: #1DA1F2;\n        }\n    `, {\n        'q_form_checkbox': 'q_form_checkbox',\n        'q_form_cb': 'q_form_cb'\n    }));\n    let ID = '_' + Q.ID();\n    const container = Q('<div class=\"' + classes.q_form + ' ' + classes.q_form_checkbox + '\">');\n    const checkbox_container = Q('<div class=\"' + classes.q_form_cb + '\">');\n    const input = Q(`<input type=\"checkbox\" id=\"${ID}\">`);\n    const label = Q(`<label for=\"${ID}\">${text}</label>`);\n    const labeltext = Q(`<div class=\"label\">${text}</div>`);\n    checkbox_container.append(input, label);\n    container.append(checkbox_container, labeltext);\n    container.checked = function (state) {\n        input.prop('checked', state);\n        if (state) {\n            input.trigger('change');\n        }\n    };\n    container.change = function (callback) {\n        input.on('change', function () {\n            callback(this.checked);\n        });\n    };\n    container.disabled = function (state) {\n        input.prop('disabled', state);\n        if (state) {\n            container.addClass(classes.q_form_disabled);\n        } else {\n            container.removeClass(classes.q_form_disabled);\n        }\n    };\n    container.text = function (text) {\n        labeltext.text(text);\n    };\n    return container;\n};"
        },
        "Form": {
            "uuid": "be4fe79e-d7ad-4b9b-87e1-069a11d616fa",
            "name": "Form",
            "method": "Plugin",
            "desc": "Form is a simple library for creating forms and windows in the browser. It provides a set of methods for creating form elements, windows, and other UI components.",
            "type": "Plugin",
            "example": "var containers = Q.Form()",
            "dependencies": [
                "Style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "find",
                "scrollTop",
                "scrollLeft",
                "hasClass",
                "text",
                "html",
                "val",
                "click",
                "closest",
                "empty",
                "show",
                "hide",
                "css",
                "attr",
                "prop",
                "remove",
                "add"
            ],
            "script": "Q.Form = function (options = {}) {\n    const Form = {};\n    Form.Icon = function (icon) {\n        let iconElement = Q('<div>');\n        iconElement.addClass('svg_' + icon + ' form_icon');\n        return iconElement;\n    };\n    Form.classes = Q.style(`\n           .form_icon {\n               width: 100%;\n               height: 100%;\n               color: #fff;\n               pointer-events: none;\n           }\n           .q_form {\n               box-sizing: border-box;\n               font-family: inherit;\n               font-size: inherit;\n               color: inherit;\n               margin: 1px;\n           }\n           .q_form_disabled {\n               opacity: 0.5;\n           }\n    `, {\n        'form_icon': 'form_icon',\n        'q_form': 'q_form',\n        'q_form_disabled': 'q_form_disabled'\n    });\n    return Form;\n};"
        },
        "Form.Tag": {
            "uuid": "7cfd4dbc-e8e2-427b-87cf-771139d128cb",
            "name": "Form.Tag",
            "method": "Component",
            "desc": "Tag component for Form plugin",
            "type": "Component",
            "example": "var tags = Q.Form.Tag(); tags.add(['JavaScript', 'HTML', 'CSS']);",
            "dependencies": [
                "Form",
                "Icon",
                "style",
                "addClass",
                "removeClass",
                "on",
                "append",
                "each",
                "text",
                "html",
                "val",
                "click",
                "closest",
                "empty",
                "attr"
            ],
            "script": "Q.Form.Tag = function (options = {}) {\n    const Form = Q.Form();\n    const sharedClasses = Form.classes;\n    const Icon = Form.Icon;\n    const classes = _ob.assign({}, sharedClasses, Q.style(`\n        .tag_container {\n            display: flex;\n            flex-wrap: wrap;\n        }\n        .tag_tag {\n            display: flex;\n            align-items: center;\n            border: 1px solid #333;\n            color: #fff;\n            overflow: hidden;\n            margin: 2px;\n            border-radius: 5px;\n        }\n        .tag_rating {\n            display: flex;\n            background-color: #333;\n            padding: 2px 5px;\n            align-items: center;\n        }\n        .tag_icon {\n            width: 10px;\n            height: 10px;\n        }\n        .tag_icon_small {\n            width: 5px;\n            height: 5px;\n        }\n        .tag_name {\n            padding: 2px 8px;\n        }\n        .tag_value {\n            padding: 0 5px;\n            user-select: none;   \n        }\n        .tag_close {\n            cursor: pointer;\n            background-color: #333;\n            height: auto;\n            width: 20px;\n        }\n        .tag_input {\n            width: content;\n            border: 0;\n            margin: 0;\n            background-color: transparent;\n            color: #fff;\n        }\n        .tag_name[contenteditable=\"true\"] {\n            cursor: text;\n        }\n        .tag_name[contenteditable=\"true\"]:focus {\n            outline: 0;\n        }\n    `, {\n        'tag_container': 'tag_container',\n        'tag_tag': 'tag_tag',\n        'tag_rating': 'tag_rating',\n        'tag_icon': 'tag_icon',\n        'tag_icon_small': 'tag_icon_small',\n        'tag_name': 'tag_name',\n        'tag_value': 'tag_value',\n        'tag_close': 'tag_close',\n        'tag_input': 'tag_input',\n        'tag_up': 'tag_up',\n        'tag_down': 'tag_down'\n    }));\n    const defaultOptions = {\n        min: 0,\n        max: 10,\n        step: 1,\n        value: 0,\n        digit: 3,\n        flood: 500,\n        disabled: false,\n        removable: true,\n        votes: true,\n        readonly: false,\n        placeholder: ''\n    };\n    let { min, max, step, digit, votes, removable, flood } = { ...defaultOptions, ...options };\n    if (step.toString().includes('.')) {\n        digit = step.toString().split('.')[1].length;\n    }\n    let data = [];\n    let changeCallback = _n;\n    const tagContainer = Q('<div>', { class: classes.tag_container });\n    const input = Q('<input>', { class: classes.tag_input });\n    const malformFix = Q('<input>', { class: classes.tag_input });\n    let ID = Q.ID(5, '_');\n    const changeTagValue = (tag, delta, currentValue) => {\n        let newValue = tag.value + delta;\n        newValue = _ma.min(_ma.max(newValue, min), max);\n        tag.value = parseFloat(newValue.toFixed(digit));\n        currentValue.text(tag.value);\n        data = data.map(t => (t.tag === tag.tag ? { ...t, value: tag.value } : t));\n        if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n    };\n    const appendTags = tags => {\n        tags.forEach(tag => {\n            const tagElement = Q('<div>', { class: classes.tag_tag });\n            let tagValue = Q('<div>', { class: classes.tag_name }).text(tag.tag);\n            if (votes) {\n                const tagRate = Q('<div>', { class: classes.tag_rating });\n                const upvote = Q('<div>', { class: [classes.tag_icon, classes.tag_up] }).html(Icon('arrow-up'));\n                const currentValue = Q('<div>', { class: classes.tag_value }).text(tag.value);\n                const downvote = Q('<div>', { class: [classes.tag_icon, classes.tag_down] }).html(Icon('arrow-down'));\n                tagRate.append(downvote, currentValue, upvote);\n                tagElement.append(tagRate);\n                upvote.on('click', () => changeTagValue(tag, step, currentValue));\n                downvote.on('click', () => changeTagValue(tag, -step, currentValue));\n            }\n            if (!defaultOptions.readonly) {\n                tagValue.attr('contenteditable', true);\n                tagValue.on('input', function () {\n                    malformFix.val(tagValue.text());\n                    tagValue.text(malformFix.val());\n                    tag.tag = malformFix.val();\n                    if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n                });\n            }\n            tagElement.append(tagValue);\n            if (removable) {\n                const close = Q('<div>', { class: [classes.tag_icon_small, classes.tag_close] }).html(Icon('window-close'));\n                close.on('click', () => {\n                    data = data.filter(t => t.tag !== tag.tag);\n                    tagElement.remove();\n                    if (changeCallback) Q.Debounce(ID, flood, changeCallback);\n                });\n                tagElement.append(close);\n            }\n            tagContainer.append(tagElement);\n        });\n    };\n    tagContainer.add = function (taglist) {\n        tagContainer.empty();\n        if (!_ar.isArray(taglist)) {\n            taglist = [taglist];\n        }\n        taglist = taglist.map(tag => (typeof tag === 'string' ? { tag, value: 0 } : tag));\n        data = [...data, ...taglist];\n        appendTags(data);\n    };\n    tagContainer.get = function () {\n        return data;\n    };\n    tagContainer.change = function (callback) {\n        changeCallback = callback;\n    };\n    return tagContainer;\n};"
        },
        "Form.TextArea": {
            "uuid": "5b4e6896-72d4-47dd-8eaa-8e5f8047e365",
            "name": "Form.TextArea",
            "method": "Component",
            "desc": "TextArea component for Form plugin",
            "type": "Component",
            "example": "var textarea = Q.Form.TextArea('Initial content', 'Enter text...'); textarea.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Q.Form.TextArea = function (value = '', placeholder = '') {\n    const Form = Q.Form();\n    const sharedClasses = Form.classes;\n    const classes = _ob.assign({}, sharedClasses, Q.style(`\n        .q_form_textarea {\n            width: calc(100% - 2px);\n            padding: 5px;\n            outline: none;\n            border: 0;\n        }\n        .q_form_textarea:focus {\n            outline: 1px solid #1DA1F2;\n        }\n    `, {\n        'q_form_textarea': 'q_form_textarea'\n    }));\n    const textarea = Q(`<textarea class=\"${classes.q_form} ${classes.q_form_textarea}\" placeholder=\"${placeholder}\">${value}</textarea>`);\n    textarea.placeholder = function (text) {\n        textarea.attr('placeholder', text);\n    };\n    textarea.disabled = function (state) {\n        textarea.prop('disabled', state);\n        if (state) {\n            textarea.addClass(classes.q_form_disabled);\n        } else {\n            textarea.removeClass(classes.q_form_disabled);\n        }\n    };\n    textarea.reset = function () {\n        textarea.val('');\n    };\n    textarea.change = function (callback) {\n        textarea.on('change', function () {\n            callback(this.value);\n        });\n    };\n    return textarea;\n};"
        },
        "Form.TextBox": {
            "uuid": "1bcd2777-19eb-436f-8926-ab249b7a3000",
            "name": "Form.TextBox",
            "method": "Component",
            "desc": "TextBox component for Form plugin",
            "type": "Component",
            "example": "var textbox = Q.Form.TextBox('text', 'Initial value', 'Enter text...'); textbox.change(function(value) { console.log(value); });",
            "dependencies": [
                "Form",
                "style",
                "addClass",
                "removeClass",
                "on",
                "attr",
                "val",
                "prop"
            ],
            "script": "Q.Form.TextBox = function (type = 'text', value = '', placeholder = '') {\n    const Form = Q.Form();\n    const sharedClasses = Form.classes;\n    const classes = _ob.assign({}, sharedClasses, Q.style(`\n        .q_form_input { \n            width: calc(100% - 2px);\n            padding: 5px;\n            outline: none;\n            border: 0;\n        }\n        .q_form_input:focus {\n            outline: 1px solid #1DA1F2;\n        }\n    `, {\n        'q_form_input': 'q_form_input'\n    }));\n    const input = Q(`<input class=\"${classes.q_form} ${classes.q_form_input}\" type=\"${type}\" placeholder=\"${placeholder}\" value=\"${value}\">`);\n    input.placeholder = function (text) {\n        input.attr('placeholder', text);\n    };\n    input.disabled = function (state) {\n        input.prop('disabled', state);\n        if (state) {\n            input.addClass(classes.q_form_disabled);\n        } else {\n            input.removeClass(classes.q_form_disabled);\n        }\n    };\n    input.reset = function () {\n        input.val('');\n    };\n    input.change = function (callback) {\n        input.on('change', function () {\n            callback(this.value);\n        });\n    };\n    return input;\n};"
        },
        "Icons": {
            "uuid": "67c9118b-dea4-4c46-9887-2b48f0450cb3",
            "name": "Icons",
            "method": "Plugin",
            "desc": "Additional icons for the VulpiniQ library.",
            "type": "Plugin",
            "example": "Q.Icons();",
            "dependencies": [
                "style"
            ],
            "script": "Q.Icons = function () {\n  let glob = Q.getGLOBAL('icons');\n  let classes = {};\n  if (glob && glob.icons) {\n    classes = glob.icons;\n  }\n  else {\n    classes = Q.style(`:root {\n\t--icon_arrow-down: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 100.93685,31.353867 C 82.480099,48.598492 67.319803,62.707709 67.247301,62.707709 c -0.0725,0 -15.232809,-14.109215 -33.689561,-31.353842 L 3.5365448e-8,6.6845858e-7 H 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"M 31.353844,100.93685 C 14.109219,82.480099 1.6018623e-6,67.319803 1.6018623e-6,67.247301 1.6018623e-6,67.174801 14.109217,52.014492 31.353844,33.55774 L 62.70771,0 V 67.247301 134.4946 Z\"/></svg>');\n\t--icon_arrow-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62.707704 134.4946\"><path d=\"m 31.353868,33.55775 c 17.244625,18.456749 31.353842,33.617045 31.353842,33.689547 0,0.0725 -14.109215,15.232809 -31.353842,33.689563 L 1.6018623e-6,134.4946 V 67.247297 0 Z\"/></svg>');\n\t--icon_arrow-up: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 134.49459 62.707709\"><path d=\"M 33.55775,31.353843 C 52.014499,14.109218 67.174795,6.6845858e-7 67.247297,6.6845858e-7 67.319797,6.6845858e-7 82.480106,14.109216 100.93686,31.353843 L 134.4946,62.707709 H 67.247297 3.5365448e-8 Z\"/></svg>');\n\t--icon_navigation-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2666.6667 2666.6667\"><path d=\"M 1276.6667,2434.5485 C 950.24325,2418.4963 647.60291,2257.2797 449.65648,1994.0001 360.09366,1874.8766 294.54616,1735.7649 260.06678,1591.6333 c -40.82486,-170.6571 -40.82486,-347.2761 0,-517.9332 71.52438,-298.98806 268.8554,-557.46223 540.12266,-707.48002 258.68606,-143.06006 568.06486,-175.54075 852.57376,-89.50899 276.927,83.73908 511.1437,274.85672 650.2832,530.62227 168.8614,310.40014 177.2264,688.09064 22.2995,1006.84964 -77.0037,158.4335 -189.7203,295.013 -331.3458,401.4939 -205.303,154.3568 -458.4668,231.6017 -717.3334,218.8716 z m 130.2294,-151.2014 c 229.6976,-18.6692 437.2639,-114.273 599.1754,-275.9766 47.6541,-47.593 83.7471,-91.4686 120.133,-146.0371 91.2885,-136.9067 142.8941,-286.0616 157.3086,-454.6667 3.0513,-35.6912 3.0513,-112.3088 0,-148 -9.7543,-114.0948 -35.6813,-216.2096 -79.956,-314.91095 C 2140.8657,803.99837 2044.7703,680.42081 1924.6667,585.10582 1705.8186,411.42656 1421.4281,342.88551 1146,397.43913 961.28159,434.02604 793.07082,524.16769 658.61926,658.61926 508.15954,809.07897 413.50356,1001.5246 386.76219,1211.3334 c -5.50464,43.1886 -7.16468,71.3013 -7.16468,121.3333 0,50.0321 1.66004,78.1448 7.16468,121.3333 31.40785,246.4213 158.34097,471.0271 353.9045,626.2276 118.14734,93.7625 258.15376,158.5796 405.33331,187.6524 50.7995,10.0346 91.5353,14.8142 153.3334,17.9909 18.4799,0.95 83.6306,-0.5787 107.5627,-2.5238 z m 134.7679,-630.3487 -208.3296,-208.3296 -207.9982,207.9951 -207.99834,207.9951 -54.66892,-54.6567 c -30.0679,-30.0612 -54.66892,-55.2602 -54.66892,-55.9978 0,-0.7375 93.30001,-94.6396 207.33338,-208.6711 l 207.3333,-207.3301 -206.6689,-206.6721 -206.66886,-206.67213 55.00599,-54.99402 55.006,-54.99402 206.66127,206.66447 206.6613,206.6646 207.6661,-207.6629 207.666,-207.66288 55.3378,55.32571 55.3378,55.32571 -207.6673,207.67046 -207.6673,207.6705 208.3339,208.3372 208.334,208.3371 -55.0055,54.9935 -55.0054,54.9935 z\"/></svg>');\n\t--icon_navigation-left: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 282.12556,619.5403 247.03663,609.52248 218.00001,595.4014 129.37889,552.30321 70.013661,466.90205 60.059145,368.19207 51.577814,284.09034 83.346262,198.0417 144.85111,138.52292 212.10881,73.437059 306.81846,45.865772 398.4674,64.691724 519.45153,89.543525 610.11296,190.57708 622.60754,314.47462 c 8.48133,84.10173 -23.28712,170.15036 -84.79196,229.66914 -59.89864,57.96444 -141.4913,86.4009 -224.85943,78.36742 z m 71.04386,-40.49085 c 101.01231,-18.37977 179.6848,-97.26565 198.14953,-198.68699 3.46591,-19.0372 3.48193,-65.25956 0.0291,-84 -18.78642,-101.96514 -96.94357,-180.11939 -198.8453,-198.83796 -18.89894,-3.471598 -65.10105,-3.471598 -84,0 C 197.45585,119.2095 119.27,197.39245 100.48802,299.33334 c -3.452807,18.74044 -3.436783,64.9628 0.0291,84 16.64224,91.4109 82.13775,165.12641 170.46427,191.85833 8.26023,2.49995 21.0186,5.49414 28.35193,6.65376 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 320.66668,412.53122 c -36.66667,-38.4534 -66.66667,-70.49248 -66.66667,-71.19795 0,-0.70547 30.15,-32.79758 67,-71.31579 l 67,-70.03311 v 141.34115 c 0,77.73764 -0.15,141.29162 -0.33333,141.23108 -0.18334,-0.0605 -30.33334,-31.57197 -67,-70.02538 z\"/></svg>');\n\t--icon_navigation-right: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 682.66669 682.66669\"><path d=\"M 312.95615,622.51118 C 103.83077,602.35954 -10.876679,362.01744 104.94177,186.66667 225.81958,3.6559506 499.6699,21.151057 595.4014,218.00001 691.73222,416.0813 532.80292,643.69595 312.95615,622.51118 Z m 71.04386,-40.49085 C 527.6749,555.87785 617.23885,410.16562 575.1842,270.98141 536.24285,142.10102 399.55264,68.634561 270.98141,107.48249 119.67709,153.19925 50.784795,329.22352 130.9177,465.35432 c 35.94209,61.05887 100.57273,105.76313 168.41564,116.49111 7.33334,1.15962 14.83334,2.3709 16.66667,2.69173 8.26494,1.44635 55.91079,-0.31712 68,-2.51683 z M 294.66668,341.34179 V 199.98437 l 67,70.03311 c 36.85,38.51821 67,70.60056 67,71.2941 0,0.69354 -30.15,32.78948 -67,71.32431 l -67,70.06332 z\"/></svg>');\n\t--icon_window-close: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 2.8176856,98.903421 -4.0360052e-7,96.085741 22.611458,73.473146 45.222917,50.860554 22.611458,28.247962 -4.0360052e-7,5.6353711 2.8176856,2.8176851 5.6353716,-9.1835591e-7 28.247963,22.611458 50.860555,45.222916 73.473147,22.611458 96.085743,-9.1835591e-7 98.903423,2.8176851 101.72111,5.6353711 79.109651,28.247962 56.498193,50.860554 79.109651,73.473146 101.72111,96.085741 98.903423,98.903421 96.085743,101.72111 73.473147,79.109651 50.860555,56.498192 28.247963,79.109651 5.6353716,101.72111 Z\"/></svg>');\n\t--icon_window-full: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 H 50.860555 84.417403 V 50.860554 84.417401 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z\"/></svg>');\n\t--icon_window-minimize: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 0.5252846,83.893071 V 79.698469 H 50.860555 101.19582 v 4.194602 4.19461 H 50.860555 0.5252846 Z\"/></svg>');\n\t--icon_window-windowed: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 101.7211 101.72111\"><path d=\"M 17.303708,50.860554 V 17.303708 h 8.389212 8.389212 V 8.9144961 0.52528408 H 67.638978 101.19582 V 34.082131 67.638977 h -8.389207 -8.38921 v 8.389212 8.389212 H 50.860555 17.303708 Z m 58.724482,0 V 25.692919 H 50.860555 25.69292 V 50.860554 76.028189 H 50.860555 76.02819 Z M 92.806613,34.082131 V 8.9144961 H 67.638978 42.471343 v 4.1946059 4.194606 h 20.973029 20.973031 v 20.973029 20.973029 h 4.1946 4.19461 z\"/></svg>');\n\t--icon_zoom-in: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n\t--icon_zoom-out: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0V0z\"/></svg>');\n}\n.svg_icon {-webkit-mask-size: cover;mask-size: cover;-webkit-mask-repeat: no-repeat;mask-repeat: no-repeat;-webkit-mask-position: center;mask-position: center;background-color: currentColor;}\n.svg_iconsize { width:100%;height:100%; }\n.arrow-down { mask-image: var(--icon_arrow-down);}\n.arrow-left { mask-image: var(--icon_arrow-left);}\n.arrow-right { mask-image: var(--icon_arrow-right);}\n.arrow-up { mask-image: var(--icon_arrow-up);}\n.navigation-close { mask-image: var(--icon_navigation-close);}\n.navigation-left { mask-image: var(--icon_navigation-left);}\n.navigation-right { mask-image: var(--icon_navigation-right);}\n.window-close { mask-image: var(--icon_window-close);}\n.window-full { mask-image: var(--icon_window-full);}\n.window-minimize { mask-image: var(--icon_window-minimize);}\n.window-windowed { mask-image: var(--icon_window-windowed);}\n.zoom-in { mask-image: var(--icon_zoom-in);}\n.zoom-out { mask-image: var(--icon_zoom-out);}\n`\n,{\n  \"arrow-down\": \"arrow-down\",\n  \"arrow-left\": \"arrow-left\",\n  \"arrow-right\": \"arrow-right\",\n  \"arrow-up\": \"arrow-up\",\n  \"navigation-close\": \"navigation-close\",\n  \"navigation-left\": \"navigation-left\",\n  \"navigation-right\": \"navigation-right\",\n  \"window-close\": \"window-close\",\n  \"window-full\": \"window-full\",\n  \"window-minimize\": \"window-minimize\",\n  \"window-windowed\": \"window-windowed\",\n  \"zoom-in\": \"zoom-in\",\n  \"zoom-out\": \"zoom-out\",\n  \"svg_icon\": \"svg_icon\",\n  \"svg_iconsize\": \"svg_iconsize\"\n}, true);\n  }\n  return {\n    get: function (name, additional = '') {\n      if (additional === '') {\n        additional = classes['svg_iconsize'];\n      }\n      return Q('<div>', {class: classes['svg_icon'] + ' ' + classes[name] + ' ' + additional});\n    }\n  }\n};"
        },
        "Image": {
            "uuid": "1cf6aaac-f70f-40a5-9984-63eb525ac5c5",
            "name": "Image",
            "method": "Plugin",
            "desc": "Useful to manipulate images.",
            "type": "Plugin",
            "example": "var image = Q.Image();",
            "dependencies": [
                "RGB2HSL",
                "HSL2RGB"
            ],
            "script": "Q.Image = function (options) {\n    let Canvas = Q('<canvas>');\n    let canvas_node = Canvas.nodes[0];\n    let defaultOptions = {\n        width: 0,\n        height: 0,\n        format: 'png',\n        fill: 'transparent',\n        size: 'auto',\n        quality: 1\n    }\n    options = _ob.assign(defaultOptions, options);\n    Canvas.Load = function (src, callback) {\n        let img = new Image();\n        img.src = src;\n        img.onload = function () {\n            canvas_node.width = img.width;\n            canvas_node.height = img.height;\n            canvas_node.getContext('2d').drawImage(img, 0, 0);\n            if (callback) callback();\n        };\n    }\n    Canvas.Get = function (format = options.format, quality = options.quality) {\n        if (format === 'jpeg' || format === 'webp') {\n            return canvas_node.toDataURL('image/' + format, quality);\n        } else {\n            return canvas_node.toDataURL('image/' + format);\n        }\n    }\n    Canvas.Save = function (filename, format = options.format, quality = options.quality) {\n        let href = Canvas.Get(format, quality);\n        let a = Q('<a>', { download: filename, href: href });\n        a.click();\n    }\n    Canvas.Clear = function (fill = options.fill) {\n        let ctx = canvas_node.getContext('2d');\n        ctx.fillStyle = fill;\n        ctx.fillRect(0, 0, canvas_node.width, canvas_node.height);\n    }\n    Canvas.Resize = function (width, height, size = options.size, keepDimensions = false) {\n        options.width = width;\n        options.height = height;\n        options.size = size;\n        _c.log(keepDimensions);\n        let temp = Q('<canvas>', { width: width, height: height }).nodes[0];\n        let ctx = temp.getContext('2d');\n        let ratio = 1;\n        let canvasWidth = canvas_node.width;\n        let canvasHeight = canvas_node.height;\n        if (size === 'contain') {\n            if (keepDimensions) {\n                let widthRatio = width / canvasWidth;\n                let heightRatio = height / canvasHeight;\n                ratio = _ma.min(widthRatio, heightRatio);\n                let newWidth = canvasWidth * ratio;\n                let newHeight = canvasHeight * ratio;\n                let xOffset = (width - newWidth) / 2;\n                let yOffset = (height - newHeight) / 2;\n                ctx.fillStyle = options.fill;\n                ctx.fillRect(0, 0, width, height);\n                ctx.drawImage(canvas_node, xOffset, yOffset, newWidth, newHeight);\n            } else {\n                let widthRatio = width / canvasWidth;\n                let heightRatio = height / canvasHeight;\n                ratio = _ma.min(widthRatio, heightRatio);\n                let newWidth = canvasWidth * ratio;\n                let newHeight = canvasHeight * ratio;\n                ctx.imageSmoothingEnabled = true;\n                ctx.imageSmoothingQuality = 'high';\n                ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n            }\n        } else if (size === 'cover') {\n            let widthRatio = width / canvasWidth;\n            let heightRatio = height / canvasHeight;\n            ratio = _ma.max(widthRatio, heightRatio);\n            let newWidth = canvasWidth * ratio;\n            let newHeight = canvasHeight * ratio;\n            let xOffset = (newWidth - width) / 2;\n            let yOffset = (newHeight - height) / 2;\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = 'high';\n            ctx.drawImage(canvas_node, -xOffset, -yOffset, newWidth, newHeight);\n        } else if (size === 'auto') {\n            ratio = _ma.min(width / canvasWidth, height / canvasHeight);\n            let newWidth = canvasWidth * ratio;\n            let newHeight = canvasHeight * ratio;\n            ctx.fillStyle = options.fill;\n            ctx.fillRect(0, 0, width, height);\n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = 'high';\n            ctx.drawImage(canvas_node, 0, 0, canvasWidth, canvasHeight, 0, 0, newWidth, newHeight);\n        }\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Crop = function (x, y, width, height) {\n        let temp = Q('<canvas>', { width: width, height: height });\n        temp.getContext('2d').drawImage(canvas_node, x, y, width, height, 0, 0, width, height);\n        canvas_node.width = width;\n        canvas_node.height = height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Rotate = function (degrees) {\n        let temp = Q('<canvas>', { width: canvas_node.height, height: canvas_node.width });\n        let ctx = temp.getContext('2d');\n        ctx.translate(canvas_node.height / 2, canvas_node.width / 2);\n        ctx.rotate(degrees * _ma.PI / 180);\n        ctx.drawImage(canvas_node, -canvas_node.width / 2, -canvas_node.height / 2);\n        canvas_node.width = temp.width;\n        canvas_node.height = temp.height;\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Flip = function (direction = 'horizontal')\n    {\n        let temp = Q('<canvas>', { width: canvas_node.width, height: canvas_node.height });\n        let ctx = temp.getContext('2d');\n        ctx.translate(canvas_node.width, 0);\n        ctx.scale(direction == 'horizontal' ? -1 : 1, direction == 'vertical' ? -1 : 1);\n        ctx.drawImage(canvas_node, 0, 0);\n        canvas_node.getContext('2d').drawImage(temp, 0, 0);\n    }\n    Canvas.Grayscale = function () {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;\n            pixels[i] = avg;\n            pixels[i + 1] = avg;\n            pixels[i + 2] = avg;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Brightness = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] += value;\n            pixels[i + 1] += value;\n            pixels[i + 2] += value;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Contrast = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let factor = (259 * (value + 255)) / (255 * (259 - value));\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = factor * (pixels[i] - 128) + 128;\n            pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;\n            pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Vivid = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            pixels[i] = _ma.min(255, pixels[i] * value);\n            pixels[i + 1] = _ma.min(255, pixels[i + 1] * value);\n            pixels[i + 2] = _ma.min(255, pixels[i + 2] * value);\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Hue = function (value) {\n        let data = canvas_node.getContext('2d').getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        for (let i = 0; i < pixels.length; i += 4) {\n            let r = pixels[i];\n            let g = pixels[i + 1];\n            let b = pixels[i + 2];\n            let hsl = Q.RGB2HSL(r, g, b);\n            hsl[0] += value;\n            let rgb = Q.HSL2RGB(hsl[0], hsl[1], hsl[2]);\n            pixels[i] = rgb[0];\n            pixels[i + 1] = rgb[1];\n            pixels[i + 2] = rgb[2];\n        }\n        canvas_node.getContext('2d').putImageData(data, 0, 0);\n    }\n    Canvas.Sharpen = function (options) {\n        let defaults = {\n            amount: 1,\n            threshold: 0,\n            radius: 1,\n            quality: 1\n        };\n        options = _ob.assign(defaults, options);\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let weights = [-1, -1, -1, -1, 9, -1, -1, -1, -1];\n        let katet = _ma.round(_ma.sqrt(weights.length));\n        let half = _ma.floor(katet / 2);\n        let divisor = weights.reduce((sum, weight) => sum + weight, 0) || 1;\n        let offset = 0;\n        let dataCopy = new Uint8ClampedArray(pixels);\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        let iterations = _ma.round(options.quality);\n        let iteration = 0;\n        while (iteration < iterations) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n                    let dstOff = (y * width + x) * 4;\n                    for (let cy = 0; cy < katet; cy++) {\n                        for (let cx = 0; cx < katet; cx++) {\n                            let scy = y + cy - half;\n                            let scx = x + cx - half;\n                            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                                let srcOff = (scy * width + scx) * 4;\n                                let wt = weights[cy * katet + cx];\n                                r += dataCopy[srcOff] * wt;\n                                g += dataCopy[srcOff + 1] * wt;\n                                b += dataCopy[srcOff + 2] * wt;\n                            }\n                        }\n                    }\n                    r = _ma.min(_ma.max((r / divisor) + offset, 0), 255);\n                    g = _ma.min(_ma.max((g / divisor) + offset, 0), 255);\n                    b = _ma.min(_ma.max((b / divisor) + offset, 0), 255);\n                    if (_ma.abs(dataCopy[dstOff] - r) > options.threshold) {\n                        pixels[dstOff] = r;\n                        pixels[dstOff + 1] = g;\n                        pixels[dstOff + 2] = b;\n                    }\n                }\n            }\n            iteration++;\n        }\n        ctx.putImageData(data, 0, 0);\n    }\n    Canvas.Emboss = function (options) {\n        let defaults = {\n            strength: 1,\n            direction: 'top-left',\n            blend: true,    \n            grayscale: true  \n        };\n        options = _ob.assign(defaults, options);\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        let dataCopy = new Uint8ClampedArray(pixels);\n        let kernels = {\n            'top-left': [-2, -1, 0, -1, 1, 1, 0, 1, 2],\n            'top-right': [0, -1, -2, 1, 1, -1, 2, 1, 0],\n            'bottom-left': [0, 1, 2, -1, 1, 1, -2, -1, 0],\n            'bottom-right': [2, 1, 0, 1, 1, -1, 0, -1, -2]\n        };\n        let kernel = kernels[options.direction] || kernels['top-left'];\n        let katet = _ma.sqrt(kernel.length); \n        let half = _ma.floor(katet / 2);\n        let strength = options.strength;\n        let divisor = 1; \n        let offset = 128; \n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let r = 0, g = 0, b = 0;\n                let dstOff = (y * width + x) * 4;\n                for (let cy = 0; cy < katet; cy++) {\n                    for (let cx = 0; cx < katet; cx++) {\n                        let scy = y + cy - half;\n                        let scx = x + cx - half;\n                        if (scy >= 0 && scy < height && scx >= 0 && scx < width) {\n                            let srcOff = (scy * width + scx) * 4; \n                            let wt = kernel[cy * katet + cx];\n                            r += dataCopy[srcOff] * wt;\n                            g += dataCopy[srcOff + 1] * wt;\n                            b += dataCopy[srcOff + 2] * wt;\n                        }\n                    }\n                }\n                r = (r / divisor) * strength + offset;\n                g = (g / divisor) * strength + offset;\n                b = (b / divisor) * strength + offset;\n                if (options.grayscale) {\n                    let avg = (r + g + b) / 3;\n                    r = g = b = avg;\n                }\n                r = _ma.min(_ma.max(r, 0), 255);\n                g = _ma.min(_ma.max(g, 0), 255);\n                b = _ma.min(_ma.max(b, 0), 255);\n                if (options.blend) {\n                    pixels[dstOff] = (pixels[dstOff] + r) / 2;\n                    pixels[dstOff + 1] = (pixels[dstOff + 1] + g) / 2;\n                    pixels[dstOff + 2] = (pixels[dstOff + 2] + b) / 2;\n                } else {\n                    pixels[dstOff] = r;\n                    pixels[dstOff + 1] = g;\n                    pixels[dstOff + 2] = b;\n                }\n            }\n        }\n        ctx.putImageData(data, 0, 0);\n    }\n    Canvas.Blur = function (options) {\n        let defaults = {\n            radius: 5, \n            quality: 1 \n        };\n        options = _ob.assign(defaults, options);\n        let ctx = canvas_node.getContext('2d');\n        let data = ctx.getImageData(0, 0, canvas_node.width, canvas_node.height);\n        let pixels = data.data;\n        let width = canvas_node.width;\n        let height = canvas_node.height;\n        function gaussianKernel(radius) {\n            let size = 2 * radius + 1;\n            let kernel = new Float32Array(size * size);\n            let sigma = radius / 3;\n            let sum = 0;\n            let center = radius;\n            for (let y = 0; y < size; y++) {\n                for (let x = 0; x < size; x++) {\n                    let dx = x - center;\n                    let dy = y - center;\n                    let weight = _ma.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));\n                    kernel[y * size + x] = weight;\n                    sum += weight;\n                }\n            }\n            for (let i = 0; i < kernel.length; i++) {\n                kernel[i] /= sum;\n            }\n            return {\n                kernel: kernel,\n                size: size\n            };\n        }\n        let { kernel, size } = gaussianKernel(options.radius);\n        let half = _ma.floor(size / 2);\n        let iterations = _ma.round(options.quality);\n        function applyBlur() {\n            let output = new Uint8ClampedArray(pixels);\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = 0, g = 0, b = 0;\n                    let dstOff = (y * width + x) * 4;\n                    for (let ky = 0; ky < size; ky++) {\n                        for (let kx = 0; kx < size; kx++) {\n                            let ny = y + ky - half;\n                            let nx = x + kx - half;\n                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                                let srcOff = (ny * width + nx) * 4;\n                                let weight = kernel[ky * size + kx];\n                                r += pixels[srcOff] * weight;\n                                g += pixels[srcOff + 1] * weight;\n                                b += pixels[srcOff + 2] * weight;\n                            }\n                        }\n                    }\n                    output[dstOff] = r;\n                    output[dstOff + 1] = g;\n                    output[dstOff + 2] = b;\n                }\n            }\n            return output;\n        }\n        for (let i = 0; i < iterations; i++) {\n            pixels = applyBlur();\n        }\n        ctx.putImageData(new ImageData(pixels, width, height), 0, 0);\n    }\n    return Canvas;\n}"
        },
        "ImageViewer": {
            "uuid": "8c42226f-cc22-4f8c-9b65-748394bf7b4b",
            "name": "ImageViewer",
            "method": "Plugin",
            "desc": "A simple image viewer plugin",
            "type": "Plugin",
            "example": "Q.ImageViewer().selector('.image').open(['image1.jpg', 'image2.jpg']);",
            "dependencies": [
                "Style",
                "Icons"
            ],
            "script": "Q.ImageViewer = function () {\n    let classes = Q.style(`\n.image_viewer_wrapper {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    background: rgba(0, 0, 0, 0.77);\n    transition: background 10s;\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n    color: #fff;\n}\n.image_panel {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n.image_wrapper {\n    width: 100%;\n    height: 100%;\n    opacity: 0;\n    transition: all 0.15s;\n    margin: 0 1px;\n    display: flex;\n    flex-direction: column;\n    animation: fadeInScale 0.3s forwards;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n}\n.image_canvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    transition: width 0.3s, height 0.3s;\n}\n.image_ambient {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: auto;\n    filter: blur(25px);\n    opacity: 0.75;\n    z-index: 0;\n}\n@keyframes fadeInScale {\n    to {\n        opacity: 1;\n    }\n}\n.image_viewer_wrapper .image_panel {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.image_top, .image_bottom {\n    width: 100%;\n    z-index: 1;\n    position: absolute;\n}\n.image_top {\n    top: 0;\n    text-align: left;\n    background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);\n}\n.image_bottom {\n    bottom: 0;\n}\n.side_left, .side_right {\n    height: 100%;\n    width: 80px;\n}\n.image_info {\n    max-width: 500px;\n    padding: 10px;\n    text-shadow: 0 1px 3px #000;\n}\n.image_title {\n    font-size: 18px;\n    font-weight: bold;\n    padding-bottom: 5px;\n}\n.image_desc {\n    font-size: 14px;\n}\n.side_left:hover, .side_right:hover {\n    background: rgba(255,255,255,0.05);\n}\n.viewer_left_button, .viewer_right_button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n.viewer_navicon {\n    width: 40px;\n    height: 40px;\n}\n.viewer_left_button:hover, .viewer_right_button:hover, .viewer_close_button:hover {\n    opacity: 1;\n}\n.viewer_button_container {\n    z-index: 10000;\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    display: flex;\n}\n.viewer_close_button, .viewer_zoom_in_button, .viewer_zoom_out_button {\n    width: 30px;\n    height: 30px;\n    cursor: pointer;\n    color: white;\n    opacity: 0.5;\n}\n    `, {\n        'image_viewer_wrapper': 'image_viewer_wrapper',\n        'image_panel': 'image_panel',\n        'image_wrapper': 'image_wrapper',\n        'image_canvas': 'image_canvas',\n        'image_ambient': 'image_ambient',\n        'image_top': 'image_top',\n        'image_bottom': 'image_bottom',\n        'image_info': 'image_info',\n        'viewer_button_container': 'viewer_button_container',\n        'side_left': 'side_left',\n        'side_right': 'side_right',\n        'viewer_left_button': 'viewer_left_button',\n        'viewer_right_button': 'viewer_right_button',\n        'viewer_close_button': 'viewer_close_button',\n        'viewer_zoom_in_button': 'viewer_zoom_in_button',\n        'viewer_zoom_out_button': 'viewer_zoom_out_button',\n        'image_title': 'image_title',\n        'image_desc': 'image_desc',\n        'viewer_navicon': 'viewer_navicon'\n    }, false);\n    class Viewer {\n        constructor() {\n            this.selector = _n;\n            this.images = [];\n            this.currentIndex = 0;\n            this.eventHandler = this.handleClick.bind(this);\n            this.addEventListener();\n            this.icons = Q.Icons();\n            this.eventListenerActive = false;\n            this.loaded = false;\n            this.resizing = false;\n            this.thumbs = false;\n            this.scale = 1;\n            this.panX = 0;\n            this.panY = 0;\n            this.isPanning = false;\n            this.startX = 0;\n            this.startY = 0;\n            this.imageCache = {};\n            this.config = {\n                panAndZoom: true,\n                ambient: true,\n                ambientSize: 1.2,\n                dynamicBackground: true\n            };\n        }\n        construct() {\n            this.image_viewer = Q('<div>', { class: classes.image_viewer_wrapper });\n            this.image_panel = Q('<div>', { class: classes.image_panel });\n            this.image_wrapper = Q('<div>', { class: classes.image_wrapper });\n            this.image_canvas = Q('<canvas>', { class: classes.image_canvas });\n            this.image_ambient = Q('<canvas>', { class: classes.image_ambient });\n            this.image_top = Q('<div>', { class: classes.image_top });\n            this.image_bottom = Q('<div>', { class: classes.image_bottom });\n            this.image_info = Q('<div>', { class: classes.image_info });\n            this.button_container = Q('<div>', { class: classes.viewer_button_container });\n            this.side_left = Q('<div>', { class: classes.side_left });\n            this.side_right = Q('<div>', { class: classes.side_right });\n            this.left_button = Q('<div>', { class: classes.viewer_left_button });\n            this.right_button = Q('<div>', { class: classes.viewer_right_button });\n            this.close_button = Q('<div>', { class: classes.viewer_close_button });\n            this.zoom_in_button = Q('<div>', { class: classes.viewer_zoom_in_button });\n            this.zoom_out_button = Q('<div>', { class: classes.viewer_zoom_out_button });\n            this.left_button.append(this.icons.get('navigation-left', classes.viewer_navicon));\n            this.right_button.append(this.icons.get('navigation-right', classes.viewer_navicon));\n            this.close_button.append(this.icons.get('navigation-close'));\n            this.zoom_in_button.append(this.icons.get('zoom-in'));\n            this.zoom_out_button.append(this.icons.get('zoom-out'));\n            this.side_left.append(this.left_button);\n            this.side_right.append(this.right_button);\n            this.image_top.append(this.image_info);\n            this.button_container.append(this.zoom_in_button, this.zoom_out_button, this.close_button);\n            this.image_wrapper.append(this.image_ambient, this.image_canvas, this.image_top, this.image_bottom);\n            this.image_panel.append(this.side_left, this.image_wrapper, this.side_right);\n            this.image_viewer.append(this.image_panel, this.button_container);\n            this.left_button.on('click', () => this.prev());\n            this.right_button.on('click', () => this.next());\n            this.close_button.on('click', () => this.close());\n            this.image_top.on('mouseenter', () => {\n                this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            });\n            this.image_top.on('mouseleave', () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s', 'transition-delay': '3s' });\n            });\n            this.image_canvas.on('wheel', (e) => this.handleZoom(e));\n            this.image_canvas.on('mousedown', (e) => this.startPan(e));\n            this.image_canvas.on('mousemove', (e) => this.pan(e));\n            this.image_canvas.on('mouseup', () => this.endPan());\n            this.image_canvas.on('mouseleave', () => this.endPan());\n            this.image_canvas.on('touchstart', (e) => this.startTouch(e));\n            this.image_canvas.on('touchmove', (e) => this.touchPanZoom(e));\n            this.image_canvas.on('touchend', () => this.endTouch());\n        }\n        handleClick(e) {\n            if (e.target.closest(this.selector)) {\n                const images = Q(this.selector).find('img');\n                if (!images.nodes.length) {\n                    return;\n                }\n                images.each((index, el) => {\n                    let title, desc, src;\n                    if (el.hasAttribute('data-title')) {\n                        title = el.getAttribute('data-title');\n                    }\n                    if (el.hasAttribute('data-desc')) {\n                        desc = el.getAttribute('data-desc');\n                    }\n                    if (el.hasAttribute('data-source')) {\n                        src = el.getAttribute('data-source');\n                    } else {\n                        src = el.src;\n                    }\n                    this.images[index] = {\n                        src: src,\n                        title: title,\n                        desc: desc\n                    }\n                });\n                this.currentIndex = images.nodes.indexOf(e.target);\n                this.open();\n            }\n        }\n        handleResize() {\n            if (!this.resizing) {\n                this.resizing = true;\n                this.image_canvas.css({ filter: 'blur(10px)', transition: 'all 0.1s ease-in-out' });\n            }\n            Q.Debounce('img_viewer', 500, () => {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.updateImage();\n                this.resizing = false;\n                this.image_canvas.css({ filter: 'none', transition: '' });\n            });\n        }\n        handleZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            const rect = this.image_canvas.nodes[0].getBoundingClientRect();\n            const offsetX = (e.clientX - rect.left - this.panX) / this.scale;\n            const offsetY = (e.clientY - rect.top - this.panY) / this.scale;\n            const scaleAmount = e.deltaY > 0 ? 0.9 : 1.1;\n            const newScale = _ma.min(_ma.max(this.scale * scaleAmount, 0.5), 2.5);\n            const deltaScale = newScale - this.scale;\n            this.panX -= offsetX * deltaScale;\n            this.panY -= offsetY * deltaScale;\n            this.scale = newScale;\n            this.updateImage();\n        }\n        startPan(e) {\n            if (!this.config.panAndZoom) return;\n            this.isPanning = true;\n            this.startX = e.clientX - this.panX;\n            this.startY = e.clientY - this.panY;\n        }\n        pan(e) {\n            if (!this.config.panAndZoom) return;\n            if (!this.isPanning) return;\n            this.panX = e.clientX - this.startX;\n            this.panY = e.clientY - this.startY;\n            this.updateImage();\n        }\n        endPan() {\n            this.isPanning = false;\n        }\n        startTouch(e) {\n            if (!this.config.panAndZoom) return;\n            if (e.touches.length === 1) {\n                this.isPanning = true;\n                this.startX = e.touches[0].clientX - this.panX;\n                this.startY = e.touches[0].clientY - this.panY;\n            } else if (e.touches.length === 2) {\n                this.isPanning = false;\n                this.initialDistance = _ma.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                this.initialScale = this.scale;\n            }\n        }\n        touchPanZoom(e) {\n            if (!this.config.panAndZoom) return;\n            e.preventDefault();\n            if (e.touches.length === 1 && this.isPanning) {\n                this.panX = e.touches[0].clientX - this.startX;\n                this.panY = e.touches[0].clientY - this.startY;\n                this.updateImage();\n            } else if (e.touches.length === 2) {\n                const currentDistance = _ma.hypot(\n                    e.touches[0].clientX - e.touches[1].clientX,\n                    e.touches[0].clientY - e.touches[1].clientY\n                );\n                const scaleAmount = currentDistance / this.initialDistance;\n                this.scale = _ma.min(_ma.max(this.initialScale * scaleAmount, 0.5), 2.5);\n                this.updateImage();\n            }\n        }\n        endTouch() {\n            this.isPanning = false;\n        }\n        addEventListener() {\n            if (!this.eventListenerActive) {\n                document.addEventListener('click', this.eventHandler);\n                this.eventListenerActive = true;\n            }\n        }\n        removeEventListener() {\n            if (this.eventListenerActive) {\n                document.removeEventListener('click', this.eventHandler);\n                this.eventListenerActive = false;\n            }\n        }\n        fadeTitle() {\n            this.image_top.css({ opacity: 1, transition: 'all 0.3s' });\n            Q.Debounce('fade_title', 2000, () => {\n                this.image_top.css({ opacity: 0, transition: 'all 0.3s' });\n            });\n        }\n        open() {\n            this.construct();\n            this.updateImage();\n            this.updateNavigation();\n            Q('body').append(this.image_viewer);\n            window.addEventListener('resize', this.handleResize.bind(this));\n        }\n        close() {\n            this.thumbs = false;\n            window.removeEventListener('resize', this.handleResize.bind(this));\n            this.image_viewer.remove();\n        }\n        prev() {\n            if (this.currentIndex > 0) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex--;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        next() {\n            if (this.currentIndex < this.images.length - 1) {\n                this.scale = 1;\n                this.startX = 0;\n                this.startY = 0;\n                this.panX = 0;\n                this.panY = 0;\n                this.currentIndex++;\n                this.fadeTitle();\n                this.updateImage();\n                this.updateNavigation();\n            }\n        }\n        updateImage() {\n            this.window_width = window.innerWidth;\n            this.window_height = window.innerHeight;\n            this.image_info.empty();\n            if (this.images[this.currentIndex].title) {\n                this.image_info.append(Q('<div>', { class: classes.image_title, text: this.images[this.currentIndex].title }));\n            }\n            if (this.images[this.currentIndex].desc) {\n                this.image_info.append(Q('<div>', { class: classes.image_desc, text: this.images[this.currentIndex].desc }));\n            }\n            const src = this.images[this.currentIndex];\n            const img = this.imageCache[src.src] || new Image();\n            if (!this.imageCache[src.src]) {\n                img.src = src.src;\n                this.imageCache[src.src] = img;\n            }\n            const isAnimated = /\\.(webm|apng|gif)$/i.test(src.src);\n            img.onload = () => {\n                const canvas = this.image_canvas.nodes[0];\n                const ambientCanvas = this.image_ambient.nodes[0];\n                const ctx = canvas.getContext('2d');\n                const ambientCtx = ambientCanvas.getContext('2d');\n                canvas.width = this.image_wrapper.nodes[0].clientWidth;\n                canvas.height = this.image_wrapper.nodes[0].clientHeight;\n                ambientCanvas.width = canvas.width * 1.2;\n                ambientCanvas.height = canvas.height * 1.2;\n                if (isAnimated) {\n                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n                    if (this.config.ambient) {\n                        ambientCtx.drawImage(img, (ambientCanvas.width - canvas.width) / 2, (ambientCanvas.height - canvas.height) / 2, canvas.width, canvas.height);\n                    }\n                    return;\n                }\n                const aspectRatio = img.width / img.height;\n                let width = this.window_width * this.scale;\n                let height = this.window_height * this.scale;\n                if (width / height > aspectRatio) {\n                    width = height * aspectRatio;\n                } else {\n                    height = width / aspectRatio;\n                }\n                const offsetX = (canvas.width - width) / 2;\n                const offsetY = (canvas.height - height) / 2;\n                ctx.setTransform(this.scale, 0, 0, this.scale, this.panX + offsetX, this.panY + offsetY);\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.drawImage(img, 0, 0, width, height);\n                if (this.config.ambient) {\n                    const ambientOffsetX = (ambientCanvas.width - width * this.config.ambientSize) / 2;\n                    const ambientOffsetY = (ambientCanvas.height - height * this.config.ambientSize) / 2;\n                    ambientCtx.setTransform(this.scale * this.config.ambientSize, 0, 0, this.scale * this.config.ambientSize, this.panX * this.config.ambientSize + ambientOffsetX, this.panY * this.config.ambientSize + ambientOffsetY);\n                    ambientCtx.clearRect(0, 0, ambientCanvas.width, ambientCanvas.height);\n                    ambientCtx.drawImage(img, 0, 0, width, height);\n                }\n                if (this.config.dynamicBackground) {\n                    Q.Debounce('update_ambient', 1000, () => {\n                        Q.AvgColor(canvas, 10, (color) => {\n                            this.image_viewer.css('background', `rgba(${color.r}, ${color.g}, ${color.b}, 0.77)`);\n                        });\n                    });\n                }\n            };\n            if (img.complete) {\n                img.onload();\n            }\n        }\n        updateNavigation() {\n            if (this.images.length > 1) {\n                if (this.currentIndex > 0) {\n                    this.left_button.show();\n                } else {\n                    this.left_button.hide();\n                }\n                if (this.currentIndex < this.images.length - 1) {\n                    this.right_button.show();\n                } else {\n                    this.right_button.hide();\n                }\n            } else {\n                this.left_button.hide();\n                this.right_button.hide();\n            }\n        }\n        setSelector(selector) {\n            this.selector = selector;\n            this.addEventListener();\n        }\n        remove() {\n            this.removeEventListener();\n            this.image_viewer.remove();\n        }\n        source(images) {\n            this.images = images.map((img, index) => ({\n                src: img.source,\n                title: img.title,\n                desc: img.desc\n            }));\n            this.currentIndex = 0;\n        }\n    }\n    let viewer = new Viewer();\n    return {\n        selector: function (selector) {\n            viewer.setSelector(selector);\n            return this;\n        },\n        open: function (images) {\n            viewer.open(images);\n            return this;\n        },\n        close: function () {\n            viewer.close();\n            return this;\n        },\n        remove: function () {\n            viewer.remove();\n            return this;\n        },\n        config: function (options) {\n            _ob.assign(viewer.config, options);\n            return this;\n        },\n        source: function (images) {\n            viewer.source(images);\n            return this;\n        }\n    };\n}"
        },
        "JSON": {
            "uuid": "b8589239-6f6e-458a-9a96-c492d59aa464",
            "name": "JSON",
            "method": "Plugin",
            "desc": "Provides methods to parse, deflate, inflate, merge, sort, and flatten JSON objects.",
            "type": "Plugin",
            "example": "//   let json = Q.JSON({ key: 'value' });",
            "dependencies": [],
            "script": "Q.JSON = function (jsonData) {\n    if (!(this instanceof Q.JSON)) return new Q.JSON(jsonData);\n    this.json = jsonData;\n};\nQ.JSON.prototype.Parse = function (options = { modify: false, recursive: false }, callback) {\n    const { modify, recursive } = options;\n    const process = (data) => {\n        if (typeof data === 'object' && data && !_ar.isArray(data)) {\n            for (const key in data) {\n                if (_ob.prototype.hasOwnProperty.call(data, key)) {\n                    const newValue = callback(key, data[key]);\n                    if (modify) data[key] = newValue;\n                    if (recursive && typeof data[key] === 'object' && data[key]) process(data[key]);\n                }\n            }\n        }\n    };\n    process(this.json);\n    return this.json;\n};\nQ.JSON.prototype.deflate = function (level) {\n    const map = {}, deflateCounter = { count: 1 };\n    const replaceRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                if (typeof obj[key] === 'object' && obj[key]) replaceRecursive(obj[key]);\n                if (key.length >= level) {\n                    if (!map[key]) { map[key] = `[${deflateCounter.count++}]`; }\n                    const newKey = map[key];\n                    obj[newKey] = obj[key]; delete obj[key];\n                }\n                if (typeof obj[key] === 'string' && obj[key].length >= level) {\n                    if (!map[obj[key]]) { map[obj[key]] = `[${deflateCounter.count++}]`; }\n                    obj[key] = map[obj[key]];\n                }\n            }\n        }\n    };\n    const deflatedData = JSON.parse(JSON.stringify(this.json));\n    replaceRecursive(deflatedData);\n    return { data: deflatedData, map: map };\n};\nQ.JSON.prototype.inflate = function (deflatedJson) {\n    const { data, map } = deflatedJson;\n    const reverseMap = _ob.fromEntries(_ob.entries(map).map(([k, v]) => [v, k]));\n    const restoreRecursive = (obj) => {\n        if (typeof obj === 'object' && obj) {\n            for (let key in obj) {\n                const originalKey = reverseMap[key] || key;\n                const value = obj[key]; delete obj[key];\n                obj[originalKey] = value;\n                if (typeof obj[originalKey] === 'object' && obj[originalKey]) {\n                    restoreRecursive(obj[originalKey]);\n                } else if (reverseMap[obj[originalKey]]) {\n                    obj[originalKey] = reverseMap[obj[originalKey]];\n                }\n            }\n        }\n    };\n    const inflatedData = JSON.parse(JSON.stringify(data));\n    restoreRecursive(inflatedData);\n    return inflatedData;\n};\nQ.JSON.prototype.merge = function (otherJson) {\n    const deepMerge = (target, source) => {\n        for (const key in source) {\n            if (_ob.prototype.hasOwnProperty.call(source, key)) {\n                if (typeof source[key] === 'object' && source[key] && !_ar.isArray(source[key])) {\n                    target[key] = deepMerge(target[key] && typeof target[key] === 'object' ? target[key] : {}, source[key]);\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return deepMerge(this.json, otherJson);\n};\nQ.JSON.prototype.sortKeys = function (recursive = false, reverse = false) {\n    const sortObject = (obj) => {\n        const keys = _ob.keys(obj).sort();\n        if (reverse) keys.reverse();\n        const sorted = {};\n        keys.forEach(key => {\n            sorted[key] = (recursive && typeof obj[key] === 'object' && obj[key] && !_ar.isArray(obj[key])) ? sortObject(obj[key]) : obj[key];\n        });\n        return sorted;\n    };\n    this.json = sortObject(this.json);\n    return this.json;\n};\nQ.JSON.prototype.sortValues = function (reverse = false) {\n    if (typeof this.json !== 'object' || !this.json) return this.json;\n    const entries = _ob.entries(this.json).sort((a, b) => {\n        const aValue = String(a[1]), bValue = String(b[1]);\n        return aValue.localeCompare(bValue);\n    });\n    if (reverse) entries.reverse();\n    const sorted = {};\n    for (const [key, value] of entries) sorted[key] = value;\n    this.json = sorted;\n    return this.json;\n};\nQ.JSON.prototype.sortByValues = function (keyProp, valueProp, reverse = false) {\n    if (!_ar.isArray(this.json)) return this.json;\n    this.json.sort((a, b) => {\n        const cmpKey = String(a[keyProp]).localeCompare(String(b[keyProp]));\n        const cmpValue = String(a[valueProp]).localeCompare(String(b[valueProp]));\n        const cmp = cmpKey || cmpValue;\n        return reverse ? -cmp : cmp;\n    });\n    return this.json;\n};\nQ.JSON.prototype.flatten = function (prefix = '') {\n    const result = {};\n    const flattenRec = (obj, path) => {\n        for (const key in obj) {\n            if (_ob.prototype.hasOwnProperty.call(obj, key)) {\n                const newKey = path ? `${path}.${key}` : key;\n                if (typeof obj[key] === 'object' && obj[key] && !_ar.isArray(obj[key])) {\n                    flattenRec(obj[key], newKey);\n                } else {\n                    result[newKey] = obj[key];\n                }\n            }\n        }\n    };\n    flattenRec(this.json, prefix);\n    return result;\n};\nQ.JSON.prototype.unflatten = function (flatObject) {\n    const result = {};\n    _ob.keys(flatObject).forEach(compoundKey => {\n        compoundKey.split('.').reduce((accumulator, currentKey, index, keysArray) => {\n            if (index === keysArray.length - 1) {\n                accumulator[currentKey] = flatObject[compoundKey];\n            } else {\n                if (!accumulator[currentKey] || typeof accumulator[currentKey] !== 'object') {\n                    accumulator[currentKey] = {};\n                }\n            }\n            return accumulator[currentKey];\n        }, result);\n    });\n    this.json = result;\n    return result;\n};"
        },
        "NodeBlock": {
            "uuid": "bc2eeb44-7b14-47d5-a094-a561b9c116be",
            "name": "NodeBlock",
            "method": "Plugin",
            "desc": "A plugin for creating UML blocks and connections.",
            "type": "Plugin",
            "example": "var uml = Q.NodeBlock('#canvas', 800, 600); // Create a new UML canvas",
            "dependencies": [
                "ColorBrightness",
                "isDarkColor",
                "Style"
            ],
            "script": "Q.NodeBlock = function (selector, width, height, options) {\n    let classes = Q.style(`\n.node_preferences {\n    position: absolute;\n    background: #181818;\n    overflow: hidden;\n    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);\n}\n.node_preferences_big {\n    width: 350px;\n    max-height: 350px;\n    overflow-y: scroll;\n}\n.node_preferences_small {\nwidth: 200px;\noverflow-y: auto;\n    }\n.pref_content h1, .pref_content h2, .pref_content h3, .pref_content h4, .pref_content h5, .pref_content h6 {\nline-break: anywhere;\nmargin: 0 0 2px 0;\npadding: 0;\n}\n.pref_content h1 { font-size: 150%; }\n.pref_content h2 { font-size: 140%; }\n.pref_content h3 { font-size: 130%; }\n.pref_content h4 { font-size: 120%; }\n.pref_content h5 { font-size: 110%; }\n.pref_content h6 { font-size: 100%; }\n.pref_content p { margin: 0; padding: 0; color: #7a7a7a; }\n.pref_content ul { margin: 5px 5px; padding-left: 15px; color: #7a7a7a; }\n.pref_content li { padding: 0px; margin: 0px; }\n.pref_content table { border-collapse: collapse; width: 100%; }\n.pref_content table, th, td { padding: 0; margin: 0; font-size: 90%; line-break: anywhere; border: 1px solid #222; }\n.pref_content th, td { padding: 1px; text-align: left; }\n.pref_content th { background-color: #222; }\n.pref_content tfoot { background-color: #222; }\n.pref_title {\n    font-size: 12px;\n    margin: 5px;\n    color: #7a7a7a;\n    text-align: center;\n}\n.node_preferences::-webkit-scrollbar {\n    width: 10px;\n}\n.node_preferences::-webkit-scrollbar-track {\n    background: #3a3a3a;\n}\n.node_preferences::-webkit-scrollbar-thumb {\n    background: #242424;\n}\n.node_preferences::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n.pref_content {\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n    padding: 5px 5px;\n}\n.pref_content img {\n    width: 100%;\n    height: auto;\n}\n.connection_content {\n    display: flex;\n    justify-content: space-between;\n}\n.left,\n.right {\n    width: 50%;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin: 5px;\n}\n.connection_wrapper {\n    display: flex;\n    justify-content: space-between;\n    margin: 1px;\n}\n.color_wrapper {\n    position: relative;\n    width: 20px;\n    height: 20px;\n    overflow: hidden;\n    flex-shrink: 0;\n}\n.color {\n    position: absolute;\n    width: 100px;\n    top: -20px;\n    left: -20px;\n    height: 100px;\n}\n.connection {\n    font-size: 12px;\npadding: 0 5px;\n    width: 100%;\n    background-color: #1d1d1d;\n    border: 0;\n    outline: 0;\n    color: #7a7a7a;\n    font-size: 12px !important;\n}\n.button_nodes {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 8px;\n    width: 15px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_nodes_big {\n    background: #2e2e2e;\n    color: #6e6e6e;\n    border: 0;\n    cursor: pointer;\n    font-size: 12px;\n    flex-shrink: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.button_add\n{\n    margin:1px;\n    width: 20px;\n    height: 20px;\n}\n        `, {\n        \"node_preferences\": \"node_preferences\",\n        \"node_preferences_small\": \"node_preferences_small\",\n        \"node_preferences_big\": \"node_preferences_big\",\n        \"pref_title\": \"pref_title\",\n        \"pref_content\": \"pref_content\",\n        \"connection_content\": \"connection_content\",\n        \"left\": \"left\",\n        \"right\": \"right\",\n        \"connection_wrapper\": \"connection_wrapper\",\n        \"color_wrapper\": \"color_wrapper\",\n        \"connection\": \"connection\",\n        \"button_nodes\": \"button_nodes\",\n        \"button_nodes_big\": \"button_nodes_big\",\n        \"button_add\": \"button_add\",\n        \"name\": \"_name\",\n        \"content\": \"_content\",\n        \"manipulation\": \"manipulation\",\n        \"color\": \"color\",\n        \"pref_section\": \"pref_section\",\n    }, false);\n    class UMLBlock {\n        constructor(custom_style, appearance, id, name, text, x, y, width, connLeft = [], connRight = [], connections = []) {\n            this.name = name;\n            this.text = text;\n            this.t_text = \"\";\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.connections = connections;\n            this.connLeft = connLeft;\n            this.connRight = connRight;\n            this.height = 0;\n            this.isDragging = false;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            this.img = _n;\n            this.content = _n;\n            this.contentHeight = 0;\n            this.unescapedBase64Data = _n;\n            this.appearance = appearance;\n            this.custom_style = custom_style;\n            this.appearance = _ob.assign({}, this.appearance, custom_style);\n            this.darkText = '#ffffff';\n            this.lightText = '#000000';\n            this.update = true;\n            this.compiled_render = document.createElement('canvas');\n            this.block_context = this.compiled_render.getContext('2d');\n            this._processColors();\n        }\n        _restyle(object) {\n            this.custom_style = object;\n            this.appearance = _ob.assign({}, this.appearance, object);\n            this._processColors();\n            this.t_text = '';\n        }\n        _processColors() {\n            const {\n                background,\n                factorTitleBackground,\n                factorDarkColorMargin,\n                factorDarkColorThreshold,\n                factorLightColors,\n                factorDarkColors,\n                darkTextColor,\n                lightTextColor\n            } = this.appearance;\n            const titleBg = Q.ColorBrightness(background, factorTitleBackground);\n            const isDark = Q.isDarkColor(background, factorDarkColorMargin, factorDarkColorThreshold);\n            const textColor = isDark ? darkTextColor : lightTextColor;\n            const borderColor = Q.ColorBrightness(background, isDark ? factorLightColors : factorDarkColors);\n            _ob.assign(this.appearance, {\n                titleBackground: titleBg,\n                titleColor: textColor,\n                connectionTextColor: textColor,\n                textColor: textColor,\n                node_table_color: borderColor\n            });\n        }\n        _drawContainer(ctx, x, y, width, height) {\n            const { shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, background, radius, connectionPointSize } = this.appearance;\n            ctx.save();\n            _ob.assign(ctx, {\n                fillStyle: background,\n                shadowColor,\n                shadowBlur,\n                shadowOffsetX,\n                shadowOffsetY\n            });\n            ctx.beginPath();\n            ctx.moveTo(x + radius, y);\n            ctx.lineTo(x + width - radius, y);\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n            ctx.lineTo(x + width, y + height - radius);\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n            ctx.lineTo(x + radius, y + height);\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n            ctx.lineTo(x, y + radius);\n            ctx.quadraticCurveTo(x, y, x + radius, y);\n            ctx.fill();\n            ctx.restore();\n        }\n        _drawTitle(ctx, x, y, width, height, title) {\n            ctx.fillStyle = this.appearance.titleBackground;\n            ctx.beginPath();\n            ctx.moveTo(x + this.appearance.radius, y);\n            ctx.arcTo(x + width, y, x + width, y + height, this.appearance.radius);\n            ctx.arcTo(x + width, y + height, x, y + height, 0);\n            ctx.arcTo(x, y + height, x, y, 0);\n            ctx.arcTo(x, y, x + width, y, this.appearance.radius);\n            ctx.closePath();\n            ctx.fill();\n            ctx.fillStyle = this.appearance.titleColor;\n            ctx.font = 'bold ' + this.appearance.fontSizeTitle + 'px ' + this.appearance.font;\n            const titleX = x + (width - ctx.measureText(title).width) / 2;\n            const titleY = y + (height + this.appearance.fontSizeTitle) / 2;\n            ctx.fillText(title, titleX, titleY);\n        }\n        parseHTML2Canvas(html, callback) {\n            const renderElements = () => {\n                if (this.t_text == html) {\n                    callback(this.content, this.contentHeight);\n                    return;\n                }\n                this.t_text = html;\n                let tempContainer = document.createElement('div');\n                tempContainer.style.position = 'absolute';\n                tempContainer.style.visibility = 'hidden';\n                tempContainer.style.width = (this.width - this.appearance.fontSize) + 'px';\n                document.body.appendChild(tempContainer);\n                let style = document.createElement('style');\n                let st = `\n        table {border-collapse: collapse; width: 100%;}\n        table, th, td {padding: 0; margin: 0; font-size: ${(this.appearance.fontSize * 0.9)}px; line-break: anywhere;border: 1px solid ${this.appearance.node_table_color};}\n        th, td {padding: 1px; text-align: left;}\n        th {background-color: ${this.appearance.node_table_color};}\n        tfoot {background-color: ${this.appearance.node_table_color};}\n        h1, h2, h3, h4, h5, h6 {line-break: anywhere; margin: 0 0 2px 0; padding: 0;}\n        h1 {font-size: ${(this.appearance.fontSize * 1.5)}px;}\n        h2 {font-size: ${(this.appearance.fontSize * 1.4)}px;}\n        h3 {font-size: ${(this.appearance.fontSize * 1.3)}px;}\n        h4 {font-size: ${(this.appearance.fontSize * 1.2)}px;}\n        h5 {font-size: ${(this.appearance.fontSize * 1.1)}px;}\n        h6 {font-size: ${(this.appearance.fontSize * 1.0)}px;}\n                        p { margin: 0; padding: 0; color: ${this.appearance.textColor}; }\n                        ul { margin: 5px 5px; padding-left: 15px; color: ${this.appearance.textColor}; }\n                        li { padding: 0px; margin: 0px; }\n                        div {font-family: ${this.appearance.font}, sans-serif; font-size: ${this.appearance.fontSize}px; color: ${this.appearance.textColor}; }\n                    `;\n                style.innerHTML = st;\n                document.head.appendChild(style);\n                tempContainer.innerHTML = html;\n                this.contentHeight = tempContainer.offsetHeight + this.appearance.padding;\n                document.body.removeChild(tempContainer);\n                document.head.removeChild(style);\n                this.content = document.createElement('canvas');\n                this.content.width = this.width;\n                this.content.height = this.contentHeight;\n                let ctx = this.content.getContext('2d');\n                let data = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + (this.width - (this.appearance.padding * 2)) + '\" height=\"' + this.contentHeight + '\">' + // Update SVG height\n                    '<foreignObject width=\"100%\" height=\"100%\">' +\n                    '<style>' +\n                    st +\n                    '</style>' +\n                    '<div xmlns=\"http://www.w3.org/1999/xhtml\">' +\n                    html +\n                    '</div>' +\n                    '</foreignObject>' +\n                    '</svg>';\n                let DOMURL = window.URL || window.webkitURL || window;\n                let img = new Image();\n                let svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });\n                let url = DOMURL.createObjectURL(svg);\n                img.onload = () => {\n                    ctx.drawImage(img, 0, 0);\n                    DOMURL.revokeObjectURL(url);\n                    callback(this.content, this.contentHeight);\n                };\n                img.src = url;\n            };\n            html = html.replace(/style=\"[^\"]*\"/g, '');\n            let images = [];\n            html = html.replace(/<br>/g, '');\n            if (html.includes('<img')) {\n                let imgTags = html.match(/<img[^>]+>/g);\n                imgTags.forEach((imgTag, index) => {\n                    let src = imgTag.match(/src=\"([^\"]*)\"/)[1];\n                    let img = new Image();\n                    img.src = src;\n                    img.onload = () => {\n                        images[index] = img;\n                        if (images.length === imgTags.length) {\n                            renderElements();\n                        }\n                    };\n                });\n            }\n            else {\n                renderElements();\n            }\n        }\n        draw(main_context) {\n            const TITLE_HEIGHT = this.appearance.fontSizeTitle + (this.appearance.padding * 2);\n            const CONNECTION_HEIGHT = this.appearance.padding + TITLE_HEIGHT;\n            const CONNECTION_PADDING = (this.appearance.connectionPointSize * 2) + this.appearance.connectionPointPadding;\n            const maxConnectionsHeight = _ma.max(this.connLeft.length, this.connRight.length) * CONNECTION_PADDING;\n            if (this.update) {\n                const updateContainerHeight = (contentHeight) => {\n                    this.height = TITLE_HEIGHT + (this.appearance.padding * 2) + maxConnectionsHeight + contentHeight + this.appearance.padding;\n                    this.block_context.canvas.height = this.height;\n                    this.block_context.canvas.width = this.width + (this.appearance.connectionPointSize * 2);\n                };\n                this.parseHTML2Canvas(this.text, (canvas, contentHeight) => {\n                    updateContainerHeight(contentHeight);\n                    this._drawContainer(this.block_context, this.appearance.connectionPointSize, 0, this.width - 5, this.height, this.appearance.radius);\n                    this._drawTitle(this.block_context, this.appearance.connectionPointSize, 0, this.width - this.appearance.connectionPointSize, TITLE_HEIGHT, this.name);\n                    this.block_context.drawImage(canvas, this.appearance.padding, TITLE_HEIGHT + this.appearance.padding + maxConnectionsHeight);\n                    this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                    main_context.drawImage(this.compiled_render, this.x, this.y);\n                });\n                this.update = false;\n            }\n            else {\n                this.drawConnectionPoints(this.block_context, CONNECTION_HEIGHT, CONNECTION_PADDING);\n                main_context.drawImage(this.compiled_render, this.x, this.y);\n            }\n            return;\n        }\n        drawConnectionPoints(ctx, paddingTop, height) {\n            const connectionY = paddingTop;\n            const font = `bold ${this.appearance.fontSizeConnection}px ${this.appearance.font}`;\n            const pointSize = this.appearance.connectionPointSize;\n            const connectionPaddingX = this.appearance.connectionTextPaddingX;\n            const middleYOffset = ((pointSize / 2) + (this.appearance.fontSizeConnection / 2)) - this.appearance.connectionTextPaddingY;\n            this.leftConnCoords = [];\n            this.rightConnCoords = [];\n            ctx.font = font;\n            const drawConnectionPoints = (connList, coordsArray, baseX, getTextX) => {\n                connList.forEach((conn, index) => {\n                    const connY = connectionY + index * height;\n                    coordsArray.push({ x: baseX, y: connY });\n                    ctx.fillStyle = conn.color || this.appearance.connectionColor;\n                    ctx.beginPath();\n                    ctx.arc(baseX, connY, pointSize, 0, 2 * _ma.PI);\n                    ctx.fill();\n                    ctx.fillStyle = this.appearance.connectionTextColor;\n                    ctx.fillText(conn.title, getTextX(conn.title, baseX), connY + middleYOffset);\n                });\n            };\n            if (_ar.isArray(this.connLeft)) {\n                drawConnectionPoints(this.connLeft, this.leftConnCoords, this.appearance.connectionPointSize, (title, baseX) => baseX + connectionPaddingX * 2);\n            }\n            if (_ar.isArray(this.connRight)) {\n                drawConnectionPoints(this.connRight, this.rightConnCoords, this.width, (title, baseX) => baseX - ctx.measureText(title).width - connectionPaddingX * 2);\n            }\n        }\n        addConnection(conn) {\n            this.connections.push(conn);\n        }\n        removeConnection(conn) {\n            this.connections = this.connections.filter(c => c.id !== conn.id);\n        }\n        isMouseOver(mouseX, mouseY) {\n            return mouseX >= this.x && mouseX <= this.x + this.width && mouseY >= this.y && mouseY <= this.y + this.height;\n        }\n        getAllConnectionCoords() {\n            return [\n                ...this.leftConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y })),\n                ...this.rightConnCoords.map(coord => ({ x: coord.x + this.x, y: coord.y + this.y }))\n            ];\n        }\n        getConnectionCoord(point, index) {\n            return point === 'left' ? this.leftConnCoords[index] : this.rightConnCoords[index];\n        }\n    }\n    class UMLCanvas {\n        constructor(selector, width, height, appearance, classes) {\n            this.element_parent = Q(selector);\n            this.canvas = Q('<canvas>', { width: width, height: height });\n            this.width = width;\n            this.height = height;\n            this.element_parent.append(this.canvas);\n            this.canvas_context = this.canvas.nodes[0].getContext('2d');\n            this.blocks = [];\n            this.connections = [];\n            this.draggingBlock = _n;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.connection_start = _n;\n            this.connection_end = _n;\n            this.mouseX = 0;\n            this.mouseY = 0;\n            this.isMenuPreferences = false;\n            this.isDraggingBlock = false;\n            this.isOverConnection = false;\n            this.appearance = appearance;\n            this.classes = classes;\n            this.canvas.on('click', this._event_click.bind(this));\n            this.canvas.on('mousedown', this._event_pointer_down.bind(this));\n            this.canvas.on('mousemove', this._event_pointer_move.bind(this));\n            this.canvas.on('mouseup', this._event_pointer_up.bind(this));\n            this.canvas.on('contextmenu', this._event_click_right.bind(this), false);\n        }\n        import(uml) {\n            const blockCreationPromises = uml.blocks.map(async (block) => {\n                const newBlock = new UMLBlock(\n                    block.custom_style,\n                    this.appearance,\n                    block.id, block.name, block.text, block.x, block.y, block.width,\n                    block.connLeft.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connRight.map(conn => ({ id: conn.id, title: conn.title, color: conn.color })),\n                    block.connections\n                );\n                this.addBlock(newBlock);\n            });\n            _pr.all(blockCreationPromises).then(() => {\n                uml.connections.forEach(conn => {\n                    const startBlock = this.blocks.find(b => b.id === conn.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.target);\n                    const startCoords = this._point_coords(startBlock, conn.point);\n                    const endCoords = this._point_coords(endBlock, conn.targetPoint);\n                    if (startCoords && endCoords) {\n                        this._connection_create(\n                            { block: startBlock, point: conn.point, x: startCoords.x, y: startCoords.y },\n                            { block: endBlock, point: conn.targetPoint, x: endCoords.x, y: endCoords.y }\n                        );\n                    } else {\n                        _c.error('Connection failed to initialize:', startBlock, endBlock);\n                    }\n                });\n            }).catch(err => {\n                _c.error('_er during block initialization:', err);\n            });\n        }\n        export() {\n            return {\n                blocks: this.blocks.map(block => ({\n                    custom_style: block.custom_style,\n                    id: block.id,\n                    name: block.name,\n                    text: block.text,\n                    x: block.x,\n                    y: block.y,\n                    width: block.width,\n                    connLeft: block.connLeft,\n                    connRight: block.connRight,\n                    connections: block.connections\n                })),\n                connections: this.connections.map(conn => ({\n                    id: conn.start.block.id,\n                    point: conn.start.point,\n                    target: conn.end.block.id,\n                    targetPoint: conn.end.point\n                }))\n            };\n        }\n        async addBlock(block) {\n            this.blocks.push(block);\n            await this._connections_init(block);\n            this.render();\n        }\n        removeBlock(block) {\n            this.blocks = this.blocks.filter(b => b.id !== block.id);\n            this.connections = this.connections.filter(conn =>\n                conn.start.block.id !== block.id && conn.end.block.id !== block.id\n            );\n            this.render();\n        }\n        getJointContent() {\n            let block = this.blocks[0];\n            let content = block.text;\n            let connections = block.connections;\n            let nextBlock = _n;\n            while (connections.length > 0) {\n                let conn = connections[0];\n                nextBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                content += nextBlock.text;\n                connections = nextBlock.connections;\n            }\n            return content;\n        }\n        duplicateBlock(block) {\n            let id = this._id();\n            const newBlock = new UMLBlock(\n                block.custom_style,\n                this.appearance,\n                id, block.name, block.text, block.x + 50, block.y + 50, block.width,\n                block.connLeft, block.connRight, []\n            );\n            this.addBlock(newBlock);\n        }\n        render_grid() {\n            let ctx = this.canvas_context;\n            let w = this.width;\n            let h = this.height;\n            let grid_size = this.appearance.gridSize;\n            let grid_color = this.appearance.gridColor;\n            ctx.strokeStyle = grid_color;\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            for (let x = 0; x <= w; x += grid_size) {\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, h);\n            }\n            for (let y = 0; y <= h; y += grid_size) {\n                ctx.moveTo(0, y);\n                ctx.lineTo(w, y);\n            }\n            ctx.stroke();\n        }\n        render() {\n            this.canvas_context.clearRect(0, 0, this.width, this.height);\n            this.render_grid();\n            this.connections.forEach(conn => {\n                let startBlock = conn.start.block;\n                let endBlock = conn.end.block;\n                let startColor = this._getConnectionColor(startBlock, conn.start.point);\n                let endColor = this._getConnectionColor(endBlock, conn.end.point);\n                this.canvas_context.strokeStyle = 'rgb(150, 150, 150)';\n                this.canvas_context.beginPath();\n                this.canvas_context.lineWidth = 2;\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + conn.start.x, startBlock.y + conn.start.y,\n                    endBlock.x + conn.end.x, endBlock.y + conn.end.y\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, endColor);\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.moveTo(startBlock.x + conn.start.x, startBlock.y + conn.start.y);\n                this.canvas_context.lineTo(endBlock.x + conn.end.x, endBlock.y + conn.end.y);\n                this.canvas_context.stroke();\n                let dx = (endBlock.x + conn.end.x) - (startBlock.x + conn.start.x);\n                let dy = (endBlock.y + conn.end.y) - (startBlock.y + conn.start.y);\n                let length = _ma.sqrt(dx * dx + dy * dy);\n                let unitDx = dx / length;\n                let unitDy = dy / length;\n                let arrowLength = 10;\n                let arrowWidth = 5;\n                for (let i = 100; i < length; i += 200) {\n                    let x = (startBlock.x + conn.start.x) + unitDx * i;\n                    let y = (startBlock.y + conn.start.y) + unitDy * i;\n                    this.canvas_context.beginPath();\n                    this.canvas_context.moveTo(x, y);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx + arrowWidth * unitDy, y - arrowLength * unitDy - arrowWidth * unitDx);\n                    this.canvas_context.lineTo(x - arrowLength * unitDx - arrowWidth * unitDy, y - arrowLength * unitDy + arrowWidth * unitDx);\n                    this.canvas_context.closePath();\n                    this.canvas_context.fillStyle = gradient;\n                    this.canvas_context.fill();\n                }\n            });\n            if (this.connection_start && this.connection_end === _n) {\n                let startBlock = this.connection_start.block;\n                let startColor = this._getConnectionColor(startBlock, this.connection_start.point);\n                let gradient = this.canvas_context.createLinearGradient(\n                    startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y,\n                    this.mouseX, this.mouseY\n                );\n                gradient.addColorStop(0, startColor);\n                gradient.addColorStop(1, \"rgb(150, 150, 150)\");\n                this.canvas_context.strokeStyle = gradient;\n                this.canvas_context.beginPath();\n                this.canvas_context.moveTo(startBlock.x + this.connection_start.x, startBlock.y + this.connection_start.y);\n                this.canvas_context.lineTo(this.mouseX, this.mouseY);\n                this.canvas_context.stroke();\n            }\n            this.blocks.forEach(block => {\n                block.draw(this.canvas_context);\n            });\n            this._connection_update();\n        }\n        _getConnectionColor(block, pointId) {\n            const connection = [...block.connLeft, ...block.connRight]\n                .find(conn => conn.id === pointId);\n            return connection ? connection.color : _n;\n        }\n        updateConnections(block) {\n            const preferences = Q('.' + classes.node_preferences);\n            const collectConnections = (sideClass) => {\n                const side = preferences.find('.' + sideClass);\n                const connections = [];\n                side.find('.' + classes.connection_wrapper).walk((element) => {\n                    const id = element.id();\n                    const title = element.find('.' + classes.connection).val() || '';\n                    const color = element.find('.' + classes.color).val();\n                    connections.push({ id, title, color });\n                }, true);\n                return connections;\n            };\n            const newLeftConnections = collectConnections(classes.left);\n            const newRightConnections = collectConnections(classes.right);\n            const newConnections = [...newLeftConnections, ...newRightConnections];\n            const existingConnections = [...block.connLeft, ...block.connRight];\n            newConnections.forEach(newConn => {\n                const existingConn = existingConnections.find(conn => conn.id === newConn.id);\n                if (existingConn) {\n                    existingConn.title = newConn.title;\n                    existingConn.color = newConn.color;\n                } else {\n                    existingConnections.push(newConn);\n                }\n            });\n        }\n        updateBlock(selectedblock = _n, callback) {\n            let preferences = Q('.' + classes.node_preferences);\n            let block;\n            if (selectedblock) {\n                block = selectedblock;\n            }\n            else {\n                block = this.blocks.find(b => b.id === preferences.id());\n            }\n            let name = preferences.find('#' + classes.name).text();\n            let content = preferences.find('#' + classes.content).html();\n            block.name = name;\n            block.text = content;\n            block.update = true;\n            if (callback) callback(block);\n        }\n        _event_pointer_down(event) {\n            if (event.button === 2) return;\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                let block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this.isDraggingBlock = true;\n                    this.draggingBlock = block;\n                    this.offsetX = mouseX - block.x;\n                    this.offsetY = mouseY - block.y;\n                    block.isDragging = true;\n                    break;\n                }\n            }\n        }\n        _event_pointer_move(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.draggingBlock) {\n                if (this.appearance.snapToGrid) {\n                    this.draggingBlock.x = _ma.round(this.draggingBlock.x / this.appearance.gridSize) * this.appearance.gridSize;\n                    this.draggingBlock.y = _ma.round(this.draggingBlock.y / this.appearance.gridSize) * this.appearance.gridSize;\n                    if (!this.lastMouseX || _ma.abs(mouseX - this.lastMouseX) >= this.appearance.gridSize || _ma.abs(mouseY - this.lastMouseY) >= this.appearance.gridSize) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                } else {\n                    if (!this.lastMouseX || _ma.abs(mouseX - this.lastMouseX) >= this.appearance.movementResolution || _ma.abs(mouseY - this.lastMouseY) >= this.appearance.movementResolution) {\n                        this.draggingBlock.x = mouseX - this.offsetX;\n                        this.draggingBlock.y = mouseY - this.offsetY;\n                        this.render();\n                        this.lastMouseX = mouseX;\n                        this.lastMouseY = mouseY;\n                    }\n                }\n                return;\n            }\n            if (this.connection_start && this.connection_end === _n) {\n                this.mouseX = mouseX;\n                this.mouseY = mouseY;\n                this.render();\n                return;\n            }\n            if (this.isOverConnection) {\n                this.isOverConnection = false;\n                this.render();\n            }\n            this.connections.forEach(conn => {\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    if (!this.isOverConnection) {\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y, this.appearance.connectionPointSize + 2, 0, 2 * _ma.PI);\n                        let startColor = this._getConnectionColor(conn.start.block, conn.start.point);\n                        this.canvas_context.strokeStyle = startColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.canvas_context.beginPath();\n                        this.canvas_context.arc(conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y, this.appearance.connectionPointSize + 2, 0, 2 * _ma.PI);\n                        let endColor = this._getConnectionColor(conn.end.block, conn.end.point);\n                        this.canvas_context.strokeStyle = endColor;\n                        this.canvas_context.lineWidth = 2;\n                        this.canvas_context.stroke();\n                        this.isOverConnection = true;\n                    }\n                }\n            });\n        }\n        _event_pointer_up(event) {\n            if (this.draggingBlock) {\n                this.isDraggingBlock = false;\n                this.draggingBlock.isDragging = false;\n                this.draggingBlock = _n;\n                this.render();\n            }\n            if (this.connection_start && this.connection_end === _n) {\n                _st(() => {\n                    this.connection_start = _n;\n                    this.mouseX = 0;\n                    this.mouseY = 0;\n                    this.render();\n                }, 100);\n            }\n        }\n        _event_click(event) {\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            for (let block of this.blocks) {\n                if (this._connection_over_point(block, mouseX, mouseY)) {\n                    if (this.connection_start === _n) {\n                        this.connection_start = this._point_details(block, mouseX, mouseY);\n                    }\n                    else if (this.connection_end === _n) {\n                        this.connection_end = this._point_details(block, mouseX, mouseY);\n                        if (this.connection_start.block !== this.connection_end.block &&\n                            !this._connection_exists(this.connection_start, this.connection_end)) {\n                            this._connection_create(this.connection_start, this.connection_end);\n                            block.addConnection({ id: this.connection_start.block.id, point: this.connection_start.point });\n                        } else {\n                            this.connection_start = _n;\n                            this.connection_end = _n;\n                            this.render();\n                        }\n                        this.connection_start = _n;\n                        this.connection_end = _n;\n                    }\n                    return;\n                }\n            }\n        }\n        _menu_context(x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_small], style: { position: 'absolute', left: x + 'px', top: y + 'px' } });\n            this.isMenuPreferences = true;\n            let add = Q('<div>', { class: ['button_nodes_big'], text: 'Create Block' });\n            add.on('click', () => {\n                let id = this._id();\n                let nodes = this.blocks.length + 1;\n                let block = new UMLBlock({}, this.appearance, id, 'Node ' + nodes, 'Content', x, y, this.appearance.blockWidth, [{ id: this._id(), title: '', color: this.appearance.connectionColor }], [{ id: this._id(), title: '', color: this.appearance.connectionColor }]);\n                this.addBlock(block);\n                this._menu_remove();\n            });\n            div.append(add);\n            this.element_parent.append(div);\n        }\n        _event_click_right(event) {\n            event.preventDefault();\n            const mouseX = event.offsetX;\n            const mouseY = event.offsetY;\n            if (this.isMenuPreferences) {\n                this.isMenuPreferences = false;\n                if (!Q.isExists('.' + classes.node_preferences + ' #' + classes.name)) {\n                    this._menu_remove();\n                    return;\n                }\n                let block = this.blocks.find(b => b.id === Q('.' + classes.node_preferences).id());\n                this.updateBlock(block);\n                this.updateConnections(block);\n                this._menu_remove();\n                this.render();\n            }\n            for (let i = this.blocks.length - 1; i >= 0; i--) {\n                const block = this.blocks[i];\n                if (block.isMouseOver(mouseX, mouseY)) {\n                    this._menu_remove();\n                    this._menu_preferences(block, mouseX, mouseY);\n                    return;\n                }\n            }\n            for (let i = 0; i < this.connections.length; i++) {\n                const conn = this.connections[i];\n                if (this._point_line_segment(\n                    mouseX, mouseY,\n                    conn.start.block.x + conn.start.x, conn.start.block.y + conn.start.y,\n                    conn.end.block.x + conn.end.x, conn.end.block.y + conn.end.y\n                )) {\n                    const startBlock = this.blocks.find(b => b.id === conn.start.block.id);\n                    const endBlock = this.blocks.find(b => b.id === conn.end.block.id);\n                    if (startBlock && endBlock) {\n                        startBlock.removeConnection({ id: endBlock.id, point: conn.start.point });\n                    }\n                    this.connections.splice(i, 1);\n                    this.render();\n                    return;\n                }\n            }\n            this._menu_context(mouseX, mouseY);\n            this.render();\n        }\n        _id() {\n            return '_' + _ma.random().toString(36).substr(2, 9);\n        }\n        _menu_remove() {\n            Q('.' + classes.node_preferences).remove();\n            this.isMenuPreferences = false;\n        }\n        _menu_item_section(title, content) {\n            let div = Q('<div>', { class: [classes.pref_section] });\n            let titleDiv = Q('<div>', { class: [classes.pref_title], text: title });\n            div.append(titleDiv, content);\n            return div;\n        }\n        _menu_item_input(id, content, placeholder) {\n            let input = Q('<div>', { class: [classes.pref_content], id: id, contentEditable: true, html: content, placeholder: placeholder });\n            return input;\n        }\n        _menu_item_connections(block) {\n            let div = Q('<div>', { class: [classes.connection_content] });\n            let left = Q('<div>', { class: [classes.left] });\n            let right = Q('<div>', { class: [classes.right] });\n            const connItem = (pos, conn) => {\n                let connection_wrapper = Q('<div>', { class: [classes.connection_wrapper], id: conn.id });\n                let connection = Q('<input>', { class: [classes.connection], type: 'text', value: conn.title, placeholder: 'Point...', maxLength: 10 });\n                let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n                let color = Q('<input>', { class: [classes.color], type: 'color', value: conn.color });\n                color_wrapper.append(color);\n                color.on('change', () => {\n                    conn.color = color.val();\n                    this.render();\n                });\n                connection.on('input', () => {\n                    let contitle = connection.val();\n                    conn.title = (conn.title && contitle !== _n) ? contitle : '';\n                    this.updateConnections(block);\n                    this.render();\n                });\n                connection_wrapper.append(color_wrapper, connection);\n                let remove = Q('<div>', { class: [classes.button_nodes], text: 'X' });\n                remove.on('click', () => {\n                    connection_wrapper.remove();\n                    this.connections = this.connections.filter(c => {\n                        if (c.start.block.id === block.id && c.start.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.end.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.end.point });\n                            return false;\n                        }\n                        if (c.end.block.id === block.id && c.end.point === conn.id) {\n                            let targetBlock = this.blocks.find(b => b.id === c.start.block.id);\n                            targetBlock.removeConnection({ id: block.id, point: c.start.point });\n                            return false;\n                        }\n                        return true;\n                    });\n                    if (pos === 'left') { block.connLeft = block.connLeft.filter(c => c.id !== conn.id); }\n                    if (pos === 'right') { block.connRight = block.connRight.filter(c => c.id !== conn.id); }\n                    this.render();\n                });\n                connection_wrapper.append(remove);\n                return connection_wrapper;\n            };\n            block.connLeft.forEach(conn => {\n                let connection_wrapper = connItem('left', conn);\n                left.append(connection_wrapper);\n            });\n            block.connRight.forEach(conn => {\n                let connection_wrapper = connItem('right', conn);\n                right.append(connection_wrapper);\n            });\n            let add = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            add.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connLeft.push(connection);\n                left.append(connItem('left', connection));\n                left.append(add);\n                this.render();\n            });\n            left.append(add);\n            let addRight = Q('<button>', { class: [classes.button_nodes, classes.button_add], text: '+' });\n            addRight.on('click', () => {\n                let id = this._id();\n                let connection = { id: id, title: '', color: '#333333' };\n                block.connRight.push(connection);\n                right.append(connItem('right', connection));\n                right.append(addRight);\n                this.render();\n            });\n            right.append(addRight);\n            div.append(left, right);\n            return div;\n        }\n        _menu_manipulation(block) {\n            let div = Q('<div>', { class: [classes.manipulation] });\n            let color_wrapper = Q('<div>', { class: [classes.color_wrapper] });\n            let color = Q('<input>', { class: [classes.color], type: 'color', value: block.appearance.background });\n            color_wrapper.append(color);\n            color.on('change', () => {\n                block._restyle({ background: color.val() });\n                this.render();\n            });\n            div.append(color_wrapper);\n            let delete_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Delete Block' });\n            delete_button.on('click', () => {\n                this.removeBlock(block);\n                this._menu_remove();\n            });\n            let duplicate_button = Q('<div>', { class: [classes.button_nodes_big], text: 'Duplicate Block' });\n            duplicate_button.on('click', () => {\n                this.duplicateBlock(block);\n                this._menu_remove();\n            });\n            div.append(color_wrapper, delete_button, duplicate_button);\n            return div;\n        }\n        _menu_preferences(block, x, y) {\n            let div = Q('<div>', { class: [classes.node_preferences, classes.node_preferences_big], id: block.id });\n            div.css({ position: 'absolute', left: x + 'px', top: y + 'px' });\n            let title = this._menu_item_section('Class', this._menu_item_input(classes.name, block.name, 'Class name...'));\n            let content = this._menu_item_section('Content', this._menu_item_input(classes.content, block.text, 'Content...'));\n            let connections = this._menu_item_section('Connections', this._menu_item_connections(block));\n            let manipulation = this._menu_item_section('Manipulation', this._menu_manipulation(block));\n            div.append(title, content, connections, manipulation);\n            this.element_parent.append(div);\n            this.isMenuPreferences = true;\n        }\n        _connections_init(block) {\n            block.connections.forEach(conn => {\n                const targetBlock = this.blocks.find(b => b.id === conn.id);\n                if (targetBlock) {\n                    const startCoords = this._point_coords(block, 'right');\n                    const endCoords = this._point_coords(targetBlock, 'left');\n                    this._connection_create(\n                        { block: block, point: 'right', x: startCoords.x, y: startCoords.y },\n                        { block: targetBlock, point: conn.point, x: endCoords.x, y: endCoords.y }\n                    );\n                }\n            });\n        }\n        _blocks_connected(block1, block2) {\n            return this.connections.some(connection =>\n                (connection.start.block === block1 && connection.end.block === block2) ||\n                (connection.start.block === block2 && connection.end.block === block1)\n            );\n        }\n        _connection_exists(startConn, endConn) {\n            return this.connections.some(conn => {\n                const isDirectMatch =\n                    conn.start.block === startConn.block && conn.start.point === startConn.point &&\n                    conn.end.block === endConn.block && conn.end.point === endConn.point;\n                const isReverseMatch =\n                    conn.start.block === endConn.block && conn.start.point === endConn.point &&\n                    conn.end.block === startConn.block && conn.end.point === startConn.point;\n                return isDirectMatch || isReverseMatch;\n            });\n        }\n        _connection_create(startConn, endConn) {\n            this.connections.push({\n                start: { block: startConn.block, point: startConn.point, x: startConn.x, y: startConn.y },\n                end: { block: endConn.block, point: endConn.point, x: endConn.x, y: endConn.y }\n            });\n            startConn.block.addConnection({ id: endConn.block.id, point: startConn.point });\n            endConn.block.addConnection({ id: startConn.block.id, point: endConn.point });\n            this.render();\n        }\n        _connection_update() {\n            this.connections.forEach(conn => {\n                _ob.assign(conn.start, this._point_coords(conn.start.block, conn.start.point));\n                _ob.assign(conn.end, this._point_coords(conn.end.block, conn.end.point));\n            });\n        }\n        _point_coords(block, pointId) {\n            const connections = [\n                { coords: block.leftConnCoords, conns: block.connLeft },\n                { coords: block.rightConnCoords, conns: block.connRight }\n            ];\n            for (const { coords, conns } of connections) {\n                const index = conns.findIndex(conn => conn.id === pointId);\n                if (index !== -1) {\n                    return { x: coords[index].x, y: coords[index].y };\n                }\n            }\n            return { x: block.x, y: block.y };\n        }\n        _connection_over_point(block, x, y) {\n            const radius = 5;\n            return block.getAllConnectionCoords().some(coord => _ma.abs(x - coord.x) < radius && _ma.abs(y - coord.y) < radius);\n        }\n        _point_details(block, x, y) {\n            x -= block.x;\n            y -= block.y;\n            const radius = 5;\n            let matchedPoint = _n;\n            block.leftConnCoords.forEach((coord, index) => {\n                if (_ma.abs(x - coord.x) < radius && _ma.abs(y - coord.y) < radius) {\n                    matchedPoint = { block: block, point: block.connLeft[index].id, x: coord.x, y: coord.y, index: index };\n                }\n            });\n            if (!matchedPoint) {\n                block.rightConnCoords.forEach((coord, index) => {\n                    if (_ma.abs(x - coord.x) < radius && _ma.abs(y - coord.y) < radius) {\n                        matchedPoint = { block: block, point: block.connRight[index].id, x: coord.x, y: coord.y, index: index };\n                    }\n                });\n            }\n            return matchedPoint;\n        }\n        _point_line_segment(px, py, x1, y1, x2, y2) {\n            const d1 = _ma.hypot(px - x1, py - y1);\n            const d2 = _ma.hypot(px - x2, py - y2);\n            const lineLen = _ma.hypot(x2 - x1, y2 - y1);\n            return d1 + d2 >= lineLen - 0.1 && d1 + d2 <= lineLen + 0.1;\n        }\n        _point_line_distance(px, py, x1, y1, x2, y2) {\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            const lenSq = dx * dx + dy * dy;\n            let t = 0;\n            if (lenSq !== 0) {\n                t = ((px - x1) * dx + (py - y1) * dy) / lenSq;\n                t = _ma.max(0, _ma.min(1, t));\n            }\n            const projX = x1 + t * dx;\n            const projY = y1 + t * dy;\n            return _ma.hypot(px - projX, py - projY);\n        }\n    }\n    let appearance = {\n        darkTextColor: '#888',\n        lightTextColor: '#222',\n        background: '#181818',\n        grid: true,\n        gridColor: '#161616',\n        gridSize: 20,\n        snapToGrid: false,\n        movementResolution: 3,\n        factorTitleBackground: -20,\n        factorDarkColors: -30,\n        factorLightColors: 80,\n        factorDarkColorMargin: 20,\n        factorDarkColorThreshold: 127,\n        blockWidth: 200,\n        connectionColor: '#333333',\n        connectionPointSize: 5,\n        connectionPointPadding: 5,\n        connectionTextPaddingX: 5,\n        connectionTextPaddingY: 5,\n        shadowBlur: 10,\n        shadowColor: 'rgba(0, 0, 0, 0.2)',\n        shadowOffsetX: 0,\n        shadowOffsetY: 5,\n        font: 'Arial',\n        fontSize: 12,\n        fontSizeTitle: 12,\n        fontSizeConnection: 10,\n        padding: 5,\n        radius: 10\n    };\n    appearance = _ob.assign(appearance, options);\n    let uml = new UMLCanvas(selector, width, height, appearance, classes);\n    return {\n        import: function (data) {\n            uml.import(data);\n        },\n        export: function () {\n            return uml.export();\n        },\n        addBlock: function (block) {\n            uml.addBlock(block);\n        },\n        removeBlock: function (block) {\n            uml.removeBlock(block);\n        }\n    };\n}"
        },
        "Socket": {
            "uuid": "7b5c549b-e5d9-4993-9fab-8779db5bb53a",
            "name": "Socket",
            "method": "Plugin",
            "desc": "Provides a WebSocket implementation with automatic reconnection and status callbacks.",
            "type": "Plugin",
            "example": "var socket = Q.Socket('ws://localhost:8080', console.log, console.log);",
            "dependencies": [],
            "script": "Q.Socket = function (url, onMessage, onStatus, options = {}) {\n    const {\n        retries = 5,                   // _nu of reconnection attempts (0 means unlimited)\n        delay = 1000,                  // Initial delay between reconnections in ms\n        protocols = [],                // WebSocket sub-protocols\n        backoff = false,               // Exponential backoff toggle\n        pingInterval = 0,              // Interval for heartbeat pings (ms); 0 disables\n        pingMessage = 'ping',          // Message to send for heartbeat\n        queueMessages = false,         // Queue messages if socket is not open yet\n        autoReconnect = true,          // Automatically reconnect on close\n        onOpen = _n,                 // Additional callback on open\n        onClose = _n,                // Additional callback on close\n        onError = _n                 // Additional callback on error\n    } = options;\n    let socket, attempts = 0, currentDelay = delay, pingId = _n;\n    const messageQueue = [];\n    const connect = () => {\n        socket = new WebSocket(url, protocols);\n        socket.onopen = () => {\n            attempts = 0;\n            currentDelay = delay;\n            onStatus?.('connected');\n            onOpen?.();\n            if (queueMessages && messageQueue.length) {\n                while (messageQueue.length) {\n                    socket.send(messageQueue.shift());\n                }\n            }\n            if (pingInterval) {\n                pingId && clearInterval(pingId);\n                pingId = _si(() => {\n                    if (socket.readyState === WebSocket.OPEN) {\n                        socket.send(pingMessage);\n                    }\n                }, pingInterval);\n            }\n        };\n        socket.onmessage = event => onMessage?.(event.data);\n        socket.onerror = error => {\n            onStatus?.('error', error);\n            onError?.(error);\n        };\n        socket.onclose = event => {\n            onClose?.(event);\n            pingId && clearInterval(pingId);\n            if (autoReconnect && (retries === 0 || attempts < retries)) {\n                onStatus?.('closed');\n                attempts++;\n                _st(() => {\n                    connect();\n                    if (backoff) {\n                        currentDelay *= 2;\n                    }\n                }, currentDelay);\n            } else {\n                onStatus?.('Max retries exceeded');\n            }\n        };\n    };\n    connect();\n    return {\n        send: message => {\n            if (socket && socket.readyState === WebSocket.OPEN) {\n                socket.send(message);\n            } else if (queueMessages) {\n                messageQueue.push(message);\n            }\n        },\n        reconnect: () => connect(),\n        close: () => {\n            autoReconnect = false;\n            pingId && clearInterval(pingId);\n            socket.close();\n        },\n        getState: () => socket?.readyState\n    };\n};"
        },
        "String": {
            "uuid": "1532e464-31ae-4fc9-b19b-22f7c413a039",
            "name": "String",
            "method": "Plugin",
            "desc": "Provides methods to manipulate strings.",
            "type": "Plugin",
            "example": "Q.String('hello').capitalize(); // returns 'Hello'",
            "dependencies": [],
            "script": "Q.String = function (string) {\n    if (!(this instanceof Q.String)) {\n        return new Q.String(string);\n    }\n    this.string = string;\n};\nQ.String.prototype.capitalize = function () {\n    return this.string.charAt(0).toUpperCase() + this.string.slice(1);\n};\nQ.String.prototype.levenshtein = function (string) {\n    const a = this.string, b = string;\n    const matrix = _ar.from({ length: a.length + 1 }, (_, i) => _ar.from({ length: b.length + 1 }, (_, j) => i || j));\n    for (let i = 1; i <= a.length; i++) {\n        for (let j = 1; j <= b.length; j++) {\n            matrix[i][j] = _ma.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)\n            );\n        }\n    }\n    return matrix[a.length][b.length];\n};\nQ.String.prototype.find = function (stringOrRegex) {\n    return this.string.match(stringOrRegex);\n};\nQ.String.prototype.replaceAll = function (stringOrRegex, replacement) {\n    return this.string.replace(new _re(stringOrRegex, 'g'), replacement);\n};"
        },
        "Thread": {
            "uuid": "e4df80f7-f782-496c-ad73-65e882f51882",
            "name": "Thread",
            "method": "Plugin",
            "desc": "Thread is a utility for managing Web Workers in a thread pool. It allows developers to execute functions in parallel, offloading heavy tasks to separate threads and improving performance. <br> Thread provides a simple interface for creating, managing, and controlling worker threads, enabling developers to execute multiple tasks concurrently without blocking the main thread. <br> By distributing workloads across multiple threads, developers can optimize performance and enhance user experience.",
            "type": "Plugin",
            "example": "const thread = Q.Thread(4); // Creates a thread pool with 4 workers <br> thread.Push(() => heavyTask(1, 2, 3)).then(result => console.log(result)); // Executes heavyTask in a worker thread <br> thread.Push(heavyTask, 1, 2, 3).then(result => console.log(result)); // Executes heavyTask in a worker thread <br> thread.Workers(2); // Sets the number of workers to 2 <br> thread.Result(({ id, result, error }) => console.log(id, result, error)); // Logs the result of each task <br> thread.Done(() => console.log('All tasks completed')); // Logs when all tasks are completed <br> thread.Abort(); // Aborts all tasks and terminates worker threads",
            "dependencies": [],
            "script": "(() => {\n    class ThreadPool {\n      constructor(maxWorkers = 1) {\n        this.maxWorkers = maxWorkers;\n        this.workers = [];\n        this.taskQueue = [];\n        this.activeTasks = new Map();\n        this.taskIdCounter = 0;\n        this.resultCallbacks = [];\n        this.doneCallbacks = [];\n        this.aborted = false;\n        this.blobURL = ThreadPool._createWorkerBlob();\n        for (let index = 0; index < maxWorkers; index++) {\n          this._addWorker();\n        }\n      }\n      static _createWorkerBlob() {\n        const code = `\n          self.onmessage = event => {\n            const { taskId, functionCode, parameters } = event.data;\n            let executionFunction;\n            try {\n              executionFunction = eval('(' + functionCode + ')');\n            } catch (error) {\n              self.postMessage({ taskId, error: error.toString() });\n              return;\n            }\n            _pr.resolve().then(() => executionFunction(...parameters)).then(\n              result => self.postMessage({ taskId, result }),\n              error => self.postMessage({ taskId, error: error.toString() })\n            );\n          };\n        `;\n        return URL.createObjectURL(new Blob([code], { type: 'application/javascript' }));\n      }\n      _addWorker() {\n        const workerInstance = new Worker(this.blobURL);\n        workerInstance.busy = false;\n        workerInstance.onmessage = event => {\n          const { taskId, result, error } = event.data;\n          workerInstance.busy = false;\n          const task = this.activeTasks.get(taskId);\n          if (task) {\n            error !== _un ? task.reject(new _er(error)) : task.resolve(result);\n            this.resultCallbacks.forEach(callbackFunction => callbackFunction({ id: taskId, result, error }));\n            this.activeTasks.delete(taskId);\n          }\n          this._processQueue();\n        };\n        workerInstance.onerror = () => { workerInstance.busy = false; };\n        this.workers.push(workerInstance);\n      }\n      _processQueue() {\n        if (this.aborted) return;\n        while (true) {\n          const idleIndex = this.workers.findIndex(workerInstance => !workerInstance.busy);\n          if (idleIndex === -1 || this.workers.length <= this.maxWorkers) break;\n          this.workers[idleIndex].terminate();\n          this.workers.splice(idleIndex, 1);\n        }\n        for (const workerInstance of this.workers) {\n          if (!workerInstance.busy && this.taskQueue.length) {\n            const task = this.taskQueue.shift();\n            workerInstance.busy = true;\n            this.activeTasks.set(task.id, task);\n            workerInstance.postMessage({ taskId: task.id, functionCode: task.functionCode, parameters: task.parameters });\n          }\n        }\n        if (!this.taskQueue.length && !this.activeTasks.size) {\n          const callbacks = this.doneCallbacks.slice();\n          this.doneCallbacks.length = 0;\n          callbacks.forEach(callbackFunction => callbackFunction());\n        }\n      }\n      Workers(newWorkerCount) {\n        if (this.aborted) return this;\n        this.maxWorkers = newWorkerCount;\n        if (newWorkerCount > this.workers.length) {\n          for (let index = 0, difference = newWorkerCount - this.workers.length; index < difference; index++) {\n            this._addWorker();\n          }\n        } else {\n          this._processQueue();\n        }\n        return this;\n      }\n      Push(taskInput, ...parameters) {\n        if (this.aborted) return _pr.reject(new _er('Thread aborted'));\n        const taskFunction = typeof taskInput === 'function' ? taskInput : (() => taskInput);\n        const taskId = ++this.taskIdCounter;\n        const task = { id: taskId, functionCode: taskFunction.toString(), parameters, resolve: _n, reject: _n };\n        const promiseResult = new _pr((resolve, reject) => { task.resolve = resolve; task.reject = reject; });\n        this.taskQueue.push(task);\n        this._processQueue();\n        return promiseResult;\n      }\n      Result(callbackFunction) {\n        if (typeof callbackFunction === 'function') this.resultCallbacks.push(callbackFunction);\n        return this;\n      }\n      Done(callbackFunction) {\n        if (typeof callbackFunction !== 'function') return this;\n        if (!this.taskQueue.length && !this.activeTasks.size) callbackFunction();\n        else this.doneCallbacks.push(callbackFunction);\n        return this;\n      }\n      Abort() {\n        this.aborted = true;\n        while (this.taskQueue.length) this.taskQueue.shift().reject(new _er('Task aborted'));\n        this.activeTasks.forEach(task => task.reject(new _er('Task aborted')));\n        this.activeTasks.clear();\n        this.workers.forEach(workerInstance => workerInstance.terminate());\n        this.workers = [];\n        this.doneCallbacks.length = 0;\n        this.resultCallbacks.length = 0;\n        URL.revokeObjectURL(this.blobURL);\n        return this;\n      }\n    }\n    Q.Thread = (maxWorkers = 1) => new ThreadPool(maxWorkers);\n  })();"
        },
        "Timer": {
            "uuid": "f11a3141-b5d8-4221-a92d-e43c64e77060",
            "name": "Timer",
            "method": "Plugin",
            "desc": "Provides a timer implementation with automatic stop and interrupt. Useful for running tasks at intervals or for a specific duration.",
            "type": "Plugin",
            "example": "Q.Timer(() => console.log('Tick'), 'timer1', { tick: 5, delay: 1000, interrupt: true });",
            "dependencies": [],
            "script": "Q.Timer = (callback, identifier, options = {}) => {\n    const defaults = { tick: 1, delay: 1000, interrupt: false, autoStart: true, done: _n };\n    const config = { ...defaults, ...options };\n    if (!Q.Timer.activeTimers) Q.Timer.activeTimers = new Map();\n    if (config.interrupt && Q.Timer.activeTimers.has(identifier)) Q.Timer.stop(identifier);\n    const timerControl = {\n      id: identifier,\n      tickCount: 0,\n      isPaused: false,\n      remainingDelay: config.delay,\n      startTime: 0,\n      timerHandle: _n,\n      pause() {\n        if (!this.isPaused) {\n          this.isPaused = true;\n          _ct(this.timerHandle);\n          const elapsed = _da.now() - this.startTime;\n          this.remainingDelay = config.delay - elapsed;\n        }\n        return this;\n      },\n      resume() {\n        if (this.isPaused) {\n          this.isPaused = false;\n          startTick(this.remainingDelay);\n        }\n        return this;\n      },\n      stop() { Q.Timer.stop(this.id); }\n    };\n    const startTick = (delayTime) => {\n      timerControl.startTime = _da.now();\n      timerControl.timerHandle = _st(function tickHandler() {\n        callback();\n        timerControl.tickCount++;\n        if (config.tick > 0 && timerControl.tickCount >= config.tick) {\n          Q.Timer.stop(identifier);\n          if (typeof config.done === 'function') config.done();\n        } else {\n          timerControl.startTime = _da.now();\n          timerControl.timerHandle = _st(tickHandler, config.delay);\n        }\n      }, delayTime);\n    };\n    if (config.autoStart) startTick(config.delay);\n    Q.Timer.activeTimers.set(identifier, timerControl);\n    return timerControl;\n  };\n  Q.Timer.stop = (identifier) => {\n    if (Q.Timer.activeTimers?.has(identifier)) {\n      const timerControl = Q.Timer.activeTimers.get(identifier);\n      _ct(timerControl.timerHandle);\n      Q.Timer.activeTimers.delete(identifier);\n    }\n  };\n  Q.Timer.stopAll = () => {\n    if (Q.Timer.activeTimers) {\n      Q.Timer.activeTimers.forEach(timerControl => _ct(timerControl.timerHandle));\n      Q.Timer.activeTimers.clear();\n    }\n  };"
        }
    },
    "statics": {
        "AvgColor": {
            "uuid": "4f90ac34-ee95-4c54-8348-5f15396057f2",
            "name": "AvgColor",
            "method": "Utility",
            "desc": "Calculates the average color of an image by creating a canvas element, drawing the image on it, and analyzing the pixel data to determine the average color. <br> This technique is useful for generating color palettes, creating visual effects, or enhancing user interface elements based on the predominant colors in an image.",
            "type": "Image Processing",
            "example": "Q.AvgColor('image.jpg or canvas', sampleSize, callback); // Returns the average color of the image or canvas",
            "dependencies": [],
            "script": "Q.AvgColor = (source, sampleSize, callback) => {\n    const image = new Image();\n    image.crossOrigin = 'Anonymous';\n    if (typeof source === 'string') image.src = source;\n    else if (source instanceof HTMLCanvasElement) image.src = source.toDataURL();\n    else return _c.error(\"Invalid image source provided.\");\n    image.onload = () => {\n      const canvas = _ob.assign(document.createElement('canvas'), { width: image.width, height: image.height });\n      const context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0);\n      const data = context.getImageData(0, 0, image.width, image.height).data;\n      const samplingRate = sampleSize === 'auto'\n        ? _ma.max(1, _ma.ceil(_ma.sqrt(image.width * image.height) / 32))\n        : (typeof sampleSize === 'number' && sampleSize > 0 ? sampleSize : 1);\n      let totalRed = 0, totalGreen = 0, totalBlue = 0, count = 0;\n      for (let index = 0, len = data.length; index < len; index += samplingRate * 4) {\n        totalRed   += data[index];\n        totalGreen += data[index + 1];\n        totalBlue  += data[index + 2];\n        count++;\n      }\n      const avgColor = { r: (totalRed / count) | 0, g: (totalGreen / count) | 0, b: (totalBlue / count) | 0 };\n      typeof callback === 'function' && callback(avgColor);\n    };\n    image.onerror = () => _c.error(\"Failed to load image.\");\n  };"
        },
        "ColorBrightness": {
            "uuid": "f5347291-fa2f-4a6b-87af-e3756c087c36",
            "name": "ColorBrightness",
            "method": "Utility",
            "desc": "Adjusts the brightness of a given color by a specified percentage, making the color lighter or darker. <br> This function can be used to dynamically change colors for various UI elements, providing visual feedback or creating color schemes with different shades. <br> It supports both hexadecimal and RGB/RGBA color formats, making it flexible for different use cases in web design or graphics.",
            "type": "Color",
            "example": "Q.ColorBrightness('#000000', 50); // #7f7f7f (black +50%) <br> Q.ColorBrightness('rgb(255, 0, 0)', -30); // rgb(178, 0, 0) (red -30%) <br> Q.ColorBrightness('rgba(0, 0, 255, 0.5)', 20); // rgba(51, 51, 255, 0.5) (blue +20%)",
            "dependencies": [],
            "script": "Q.ColorBrightness = (inputColor, percent) => {\n    if (!/^#|^rgb/.test(inputColor)) throw new _er('Unsupported c format');\n    let red, green, blue, alpha = 1, isHex = false, factor = 1 + percent / 100;\n    if (inputColor[0] === '#') {\n      isHex = true;\n      const hexString = inputColor.slice(1);\n      if (hexString.length === 3) {\n        red = parseInt(hexString[0] + hexString[0], 16);\n        green = parseInt(hexString[1] + hexString[1], 16);\n        blue = parseInt(hexString[2] + hexString[2], 16);\n      } else if (hexString.length === 6) {\n        red = parseInt(hexString.slice(0, 2), 16);\n        green = parseInt(hexString.slice(2, 4), 16);\n        blue = parseInt(hexString.slice(4, 6), 16);\n      }\n    } else {\n      const match = inputColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n      if (match) {\n        red = +match[1];\n        green = +match[2];\n        blue = +match[3];\n        if (match[4] != _n) alpha = parseFloat(match[4]);\n      }\n    }\n    const clamp = value => _ma.min(255, _ma.max(0, _ma.round(value * factor)));\n    red = clamp(red);\n    green = clamp(green);\n    blue = clamp(blue);\n    return isHex\n      ? '#' + [red, green, blue].map(component => (`0${component.toString(16)}`).slice(-2)).join('')\n      : (alpha === 1 ? `rgb(${red}, ${green}, ${blue})` : `rgba(${red}, ${green}, ${blue}, ${alpha})`);\n  };"
        },
        "Debounce": {
            "uuid": "b54e2a6d-1b39-4cfd-8f28-3888bbb63432",
            "name": "Debounce",
            "method": "Utility",
            "desc": "Debounces a function to ensure it is only called after a specified delay since the last invocation, effectively preventing multiple calls in rapid succession. <br> This technique is particularly useful in scenarios like resizing windows, scrolling, or typing events, where multiple triggers can lead to performance issues or unintended behavior. <br> By controlling the rate at which a function can fire, developers can optimize performance and enhance user experience.",
            "type": "Event Handling",
            "example": "Q.Debounce('myFunction', 500, myFunction); // Calls myFunction after 500ms of inactivity <br> Q.Debounce('resizeEvent', 300, handleResize); // Debounces resize handling function",
            "dependencies": [],
            "script": "Q.Debounce = (id, b, c) => {\n    const debounceStorage = Q.getGLOBAL('Debounce') || {};\n    debounceStorage[id] && _ct(debounceStorage[id]);\n    debounceStorage[id] = _st(c, b);\n    Q.setGLOBAL({ Debounce: debounceStorage });\n  };"
        },
        "HSL2RGB": {
            "uuid": "6a2662c9-c830-442e-a883-8729b27f9902",
            "name": "HSL2RGB",
            "method": "Utility",
            "desc": "Converts HSL (Hue, Saturation, Lightness) color values to RGB (Red, Green, Blue) format. <br> This function is essential for applications that require color transformations, allowing developers to switch between different color representations easily. <br> Understanding color models is key in design, and this utility helps bridge the gap between HSL, which is often more intuitive for humans, and RGB, which is commonly used in digital displays.",
            "type": "Color",
            "example": "Q.HSL2RGB(0, 0, 1); // [255, 255, 255] <br> Q.HSL2RGB(0, 1, 0.5); // [255, 0, 0] <br> Q.HSL2RGB(0.33, 1, 0.5); // [0, 255, 0]",
            "dependencies": [],
            "script": "Q.HSL2RGB = (h, s, l) => {\n    if (s === 0) {\n      const gray = l * 255;\n      return [gray, gray, gray];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s,\n          p = 2 * l - q,\n          hueToRgb = (t) => {\n            t < 0 && (t += 1);\n            t > 1 && (t -= 1);\n            return t < 1 / 6 ? p + (q - p) * 6 * t\n                 : t < 1 / 2 ? q\n                 : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t)\n                 : p;\n          };\n    return [hueToRgb(h + 1 / 3) * 255, hueToRgb(h) * 255, hueToRgb(h - 1 / 3) * 255];\n  };"
        },
        "ID": {
            "uuid": "a85e6d6d-75ad-4f85-ba0b-209965ff4f2a",
            "name": "ID",
            "method": "Utility",
            "desc": "It's useful for creating unique identifiers for users, sessions, or any items requiring distinct identification. <br> The ID is generated using random hexadecimal digits (0-9 and a-f) and can be customized with a prefix for better context or categorization.",
            "type": "Utility",
            "example": "Q.ID(8, 'user-'); // user-1a2b3c4d <br> Q.ID(); // 1a2b3c4d <br> Q.ID(12, 'session-'); // session-1a2b3c4d5e6f",
            "dependencies": [],
            "script": "Q.ID = (length = 8, b = '') =>\n    b + _ar.from({ length }, () => (_ma.random() * 16 | 0).toString(16)).join('');"
        },
        "isDarkColor": {
            "uuid": "ce16337c-0072-4b83-8a51-7f348cc8b741",
            "name": "isDarkColor",
            "method": "Utility",
            "desc": "Determines if a color is dark or light based on the HSP (Hue, Saturation, Perceived brightness) model. <br> This utility helps in designing user interfaces by ensuring adequate contrast between text and background colors, enhancing readability and accessibility. <br> Users can adjust the margin and threshold parameters to fine-tune sensitivity according to their design needs.",
            "type": "Color",
            "example": "Q.isDarkColor('#000000'); // true <br> Q.isDarkColor('#ffffff'); // false <br> Q.isDarkColor('#4c4c4c', 30, 90); // true",
            "dependencies": [],
            "script": "Q.isDarkColor = (color, b = 20, c = 100) => {\n    let red, green, blue;\n    if (color[0] === '#') {\n      const f = color.slice(1);\n      const parts = f.length === 3\n        ? [f[0] + f[0], f[1] + f[1], f[2] + f[2]]\n        : f.length === 6\n        ? [f.slice(0, 2), f.slice(2, 4), f.slice(4, 6)]\n        : _n;\n      if (!parts) throw _er('Invalid f color format');\n      [red, green, blue] = parts.map(v => parseInt(v, 16));\n    } else if (color.startsWith('rgb')) {\n      const arr = color.match(/\\d+/g);\n      if (arr && arr.length >= 3) [red, green, blue] = arr.map(_nu);\n      else throw _er('Invalid color format');\n    } else throw _er('Unsupported color format');\n    return _ma.sqrt(0.299 * red ** 2 + 0.587 * green ** 2 + 0.114 * blue ** 2) + b < c;\n  };"
        },
        "RGB2HSL": {
            "uuid": "56b72d74-3cf4-47d7-b974-4acbe19fc0dc",
            "name": "RGB2HSL",
            "method": "Utility",
            "desc": "Converts RGB color values to HSL format, providing a different way to represent colors that can be more intuitive for artists and designers. <br> HSL stands for Hue, Saturation, and Lightness, making it easier to manipulate colors based on human perception. <br> This conversion is essential for applications requiring color manipulation, such as image editing or web design, where understanding color relationships is crucial.",
            "type": "Color",
            "example": "Q.RGB2HSL(255, 255, 255); // [0, 0, 1] <br> Q.RGB2HSL(0, 0, 0); // [0, 0, 0] <br> Q.RGB2HSL(255, 0, 0); // [0, 1, 0.5]",
            "dependencies": [],
            "script": "Q.RGB2HSL = (r, g, b) => {\n    r /= 255, g /= 255, b /= 255;\n    const max = _ma.max(r, g, b), min = _ma.min(r, g, b);\n    let h, s, l = (max + min) / 2, d = max - min;\n    if (!d) h = s = 0;\n    else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0)\n        : max === g ? (b - r) / d + 2\n        : (r - g) / d + 4;\n      h /= 6;\n    }\n    return [h, s, l];\n  };"
        }
    }
};
function Highlight(code) {
    // Function to escape HTML characters in code
    const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    code = escapeHTML(code);

    let patterns = [];

    let dictionary = [
        {
            find: ["Q"],
            open: "", 
            close: "", 
            className: "class",
            regex: "single",
            allowNested: false
        },
        {
            find: ["(", ")", "{", "}", "[", "]"],
            open: "", 
            close: "", 
            className: "bracket",
            regex: "single",
            allowNested: false
        },
        {
            find: ["'", '"'],
            open: "", 
            close: "", 
            className: "string",
            regex: "single",
            allowNested: false
        },
        {
            find: ["*"],
            open: "//", 
            close: "<br>", 
            className: "comment",
            regex: "between",
            allowNested: false
        },
        {
            find: ["function", "return", "if", "else", "for", "while"],
            open: "", 
            close: "", 
            className: "keyword",
            regex: "single",
            allowNested: false
        },
        {
            find: ["let", "var", "const"],
            open: "", 
            close: "", 
            className: "variable",
            regex: "single",
            allowNested: false
        }
    ];

    // Generate patterns from the dictionary
    dictionary.forEach(({ find, open, close, className, regex, allowNested }) => {
        let regexString = "";
        if (regex === "single") {
            // Join keywords with | for a single word match, using \b word boundaries
            regexString = `\\b(${find.map(item => item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join("|")})\\b`;
        } else if (regex === "between") {
            // Use non-capturing groups and lookahead/lookbehind for the between match
            regexString = `(${open})((?:(?!${close}).)*?)(${close})`;
        } else {
            regexString = regex; // Assume a custom regex is provided
        }

        patterns.push({
            regex: new RegExp(regexString, "g"),
            replace: `<span class='hl ${className}'>$&</span>`,
            allowNested
        });
    });

    // Apply patterns to the code
    patterns.forEach(({ regex, replace, allowNested }) => {
        code = code.replace(regex, (match, ...groups) => {
            // If allowNested is false, un-nest any nested spans inside
            if (!allowNested) {
                match = match.replace(/<span.*?>(.*?)<\/span>/g, '$1');
            }
            return replace.replace('$&', match);
        });
    });

    // Use a temporary container to parse and process the HTML
    let temp = document.createElement("div");
    temp.innerHTML = code;

    // Remove nested spans if necessary
    temp.querySelectorAll("span span").forEach(nested => {
        const parent = nested.parentElement;
        if (nested.classList.contains("hl")) {
            parent.replaceChild(document.createTextNode(nested.textContent), nested);
        }
    });

    return temp.innerHTML;
}

// function Highlight(code) {
    
//     const escapeHTML = str => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
//     code = code.replace(/\"(.*?)\"/g, (_, p1) => `"${escapeHTML(p1)}"`);

//     let patterns = [];

//     let dictionary = [
//         {
//         find:["Q"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"class", // span class name
//         regex: "single", // single, between, regex (direct regex) 
//         allowNested: false // allow or remove nested (convert to plain text)
//         },
//         {
//         find:["(", ")", "{", "}", "[", "]"],
//         open: "", //works only with "between"
//         close: "", //works only with "between"
//         className:"bracket", // span class name
//         regex: "single", // single, between, regex (direct regex)
//         allowNested: false // allow or remove nested (convert to plain text)
//         }
//     ];


//     dictionary.forEach(({find, open, close, className, regex, allowNested}) => {
//         let regexString = "";
//         if (regex === "single") {
//             regexString = `\\b(${find.join("|")})\\b`;
//         } else if (regex === "between") {
//             regexString = `\\b(${open})((?:(?!${close}).)*)\\b(${close})`;
//         } else {
//             regexString = regex;
//         }

//         patterns.push({
//             regex: new RegExp(regexString, "g"),
//             replace: `<span class='hl ${className}'>$&</span>`
//         });
//     });


//     // const patterns = [
//     //     { regex: /(['"`])(.*?)\1/g, replace: "<span class='hl string'>$1$2$1</span>" },
//     //             { regex: /\b(\d+)\b/g, replace: "<span class='hl number'>$1</span>" },

//     //     { regex: /Q\(/g, replace: "<span class='hl class'>Q</span>(" },
//     //     { regex: /Q\./g, replace: "<span class='hl object'>Q.</span>" },
//     //     // { regex: /\((.*?)\)/g, replace: "(<span class='bracket_inner'>$1</span>)" },
//     //     // { regex: /\{(.*?)\}/g, replace: "{<span class='bracket_inner'>$1</span>}" },
//     //     // { regex: /\[(.*?)\]/g, replace: "[<span class='bracket_inner'>$1</span>]" },
//     //     { regex: /\{|\}|\(|\)|\[|\]/g, replace: "<span class='hl bracket'>$&</span>" },
//     //     { regex: /\b(function|return|if|else|for|while)\b/g, replace: "<span class='hl keyword'>$1</span>" },
//     //     //variables
//     //     { regex: /\b(let|var|const)\b/g, replace: "<span class='hl variable'>$1</span>" },

//     //     {
//     //         regex: /\/\/(?!https?:\/\/|ftp:\/\/|ws:\/\/)(.*?)(?=<br>|$)/g, replace: "<span class='hl comment'>//$1</span>"
//     //     }
//     // ];

//     patterns.forEach(({ regex, replace }) => code = code.replace(regex, replace));

//     let temp = document.createElement("div");
//     temp.innerHTML = code;

//     temp.querySelectorAll("span span").forEach(nested => {
        
//         if (nested.classList.contains("hl")) {
//             const parent = nested.parentElement;
//             parent.replaceChild(document.createTextNode(nested.textContent), nested);
//         }
//     });

//     return temp.innerHTML;
// }

const IDS = {};

function CodeBuilder() {
    const activeBlocks = document.querySelectorAll(".block.active");


    const applyScript = (script) => {
        const sizedata = document.querySelector(".sizedata");
        let BaseScript = JSON.parse(JSON.stringify(DATA.frame));
        BaseScript = BaseScript.replace("return Q;", script + "\nreturn Q;");
        let codeBlock = document.querySelector(".codeData");
        codeBlock.innerHTML = minify(BaseScript);
        sizedata.innerHTML = "Library size: " + CalculateSizeKB(BaseScript);
    }




    if (!activeBlocks.length) {
        applyScript("");
        return;
    }

    const script = Array.from(activeBlocks)
        .map(block => {
            let blockScript = "";
            // Traverse the IDS structure to find the matching script
            for (const name in IDS) {
                const blockData = IDS[name];
                if (blockData.uuid == block.id) {
                    blockScript = blockData.script || "";
                    break;
                }
            }
            return blockScript;
        })
        .join("");

    applyScript(script);

    // console.log(script);
}


function classFormat(text) {
    return text.toLowerCase().replace(/ /g, "_").replace(/[^a-z0-9_]/g, "");
}

function minify(code) {
    return code.replace(/^\s*/gm, "").replace(/\n/g, "");
}

function CalculateSizeKB(code) {
    return (new Blob([code]).size / 1024).toFixed(2) + " KB";
}

function createTags(tags) {
    const tagsContainer = document.createElement("div");
    tagsContainer.className = "tags";
    tags.forEach(tag => {
        const tagElement = document.createElement("span");
        tagElement.className = "tag";
        tagElement.innerHTML = tag;
        tagsContainer.appendChild(tagElement);
    });
    return tagsContainer;
}

function createCodeCategory(title) {
    const categoryContainer = document.createElement("div");
    categoryContainer.className = "code_category";
    categoryContainer.innerHTML = `<h2 class='code_category_title'>${title}</h2>`;
    const categoryContent = document.createElement("div");
    categoryContent.className = "code_content";
    categoryContent.id = classFormat(title);
    categoryContainer.appendChild(categoryContent);
    return categoryContainer;
}

function createBlock(contentData) {
    const { uuid, name, desc, example, dependencies } = contentData;
    const block = document.createElement("div");
    block.className = "block";
    block.id = uuid;
    block.innerHTML = `<h2>${name}</h2>`;

    const blockContent = document.createElement("div");
    blockContent.className = "block_content";
    block.appendChild(blockContent);

    blockContent.innerHTML = `<p>${desc}</p>`;
    const blockExample = document.createElement("div");
    blockExample.className = "block_example";
    blockExample.innerHTML = Highlight(example.replace(/\n/g, "<br>"));
    blockContent.appendChild(blockExample);

    if (dependencies.length > 0) {
        const blockDependencies = document.createElement("div");
        blockDependencies.className = "block_dependencies";
        blockDependencies.innerHTML = "<b>Dependencies</b>";
        blockDependencies.appendChild(createTags(dependencies));
        blockContent.appendChild(blockDependencies);
    }

    block.addEventListener("click", function (event) {
        if (event.currentTarget.contains(event.target)) {
            block.classList.toggle("active");
            if (block.classList.contains("active")) {
                dependencies.forEach(dep => {
                    const depBlock = document.getElementById(IDS[dep]?.uuid);
                    if (depBlock && !depBlock.classList.contains("active")) {
                        depBlock.click();
                    }
                });
            }
            CodeBuilder();
        }
    });

    return block;
}

function createTab(name, identifier, contentData) {
    const tabHeader = document.querySelector(".tab_header");
    const tabContainer = document.querySelector(".tab_container");

    const tab = document.createElement("div");
    tab.className = "tab";
    tab.innerHTML = name;
    tab.setAttribute("data-identifier", identifier);

    const tabContent = document.createElement("div");
    tabContent.className = "tab_content";
    tabContent.setAttribute("data-identifier", identifier);

    const types = [...new Set(contentData.map(c => c.type))];
    types.forEach(type => tabContent.appendChild(createCodeCategory(type)));
    contentData.forEach(content => {
        tabContent.querySelector(`#${classFormat(content.type)}`).appendChild(createBlock(content));
    });

    tab.addEventListener("click", function () {
        document.querySelectorAll(".tab, .tab_content").forEach(el => el.classList.remove("active"));
        tab.classList.add("active");
        tabContent.classList.add("active");
    });

    tabHeader.appendChild(tab);
    tabContainer.appendChild(tabContent);

    return tab;
}

function createTabs() {
    const methods = new Set();
    Object.values(DATA).forEach(category => {
        if (typeof category === 'object') {
            console.log(category);
            const contentData = [];
            Object.values(category).forEach(({ method, uuid, desc, type, example, dependencies, script }) => {
                if (!methods.has(method)) {
                    methods.add(method);
                    Object.values(category).forEach(block => {
                        contentData.push({ ...block });
                        if (block.dependencies === undefined) {
                            block.dependencies = [];
                        }
                        IDS[block.name] = { uuid: block.uuid, script: block.script, dependencies: block.dependencies };
                    });
                    createTab(method, method, contentData);
                }
            });
        }
    });


    //choose .download button
    const downloadButton = document.querySelector(".download");
    const codeBlock = document.querySelector(".codeData");

    //add event listener to download button
    downloadButton.addEventListener("click", () => {
        const code = codeBlock.innerText;
        const blob = new Blob([code], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "vulpiniq.js";
        a.click();
        URL.revokeObjectURL(url);
    });


}

document.addEventListener("DOMContentLoaded", createTabs);
</script>
</head>

<body>

    <div class="container">
<div class="left_side">

<div class="header">
    <h1>VulpiniQ</h1>
    <p>Build your own VulpiniQ Library</p>
    </div>

<textarea class="codeData" placeholder="Enter your code here"></textarea>

<div class="footer">
    <div class="sizedata">No code recently</div>
    <button class="btn download">Download</button>
</div>

</div>


<div class="right_side">
    <div class="tab_header">
    </div>

    <div class="tab_container">



    </div>

</div>




    </div>

    <!-- <div class="generated">
        <h2>Your personalised VulpiniQ</h2>
        <div class="gen_code_size" readonly></div>
        <textarea class="gen_code" readonly></textarea>
    </div>

    <div class="generated">
        <h2>Minified version</h2>
        <div class="minified_size" readonly></div>
        <textarea class="gen_code minified" readonly></textarea>
    </div> -->

</body>

</html>